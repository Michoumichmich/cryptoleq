0
1
tmp_e3
0
6
art
0
2
cudd
7
main.cpp
850
#include <iostream>
#include "cuddObj.hh"

int main()
{
    Cudd mgr(0, 0);
    BDD x0 = mgr.bddVar();
    BDD x1 = mgr.bddVar();
    BDD x2 = mgr.bddVar();
    BDD x3 = mgr.bddVar();
    BDD f = x0 ^ x1 ;//+ x2; //*x3;
    //BDD f2 = x0 + x1 * x2; //*x3;

    mgr.ReduceHeap();

    //std::cout <<"\no Blif:\n";	
    //mgr.DumpBlif(std::vector<BDD>{ f });

    std::cout <<"\no DDcal:\n";	
    mgr.DumpDDcal(std::vector<BDD>{ f });

    //std::cout <<"\no Dot:\n";	
    //mgr.DumpDot(std::vector<BDD>{ f });

    //std::cout <<"\no DaVinci:\n";	
    //mgr.DumpDaVinci(std::vector<BDD>{ f });

    //std::cout <<"\no Form:\n";	
    //mgr.DumpFactoredForm(std::vector<BDD>{ f });

    std::cout <<"\no cout:\n" << f << '\n';

    //mgr.DumpFactoredForm(std::vector<BDD>{ f2 });
    //std::cout <<'\n' << f2 << '\n';
}
makefile
1872
# PLAT: w u

include mk_all.mak

CUD=c30
CULIB=cuddlib

O=$(TRG)

#src = ut.c

#obj := $($(CUD)/src:%.c=$O/%$(OEXT))


src = \
cpu_stats.c      cuddAndAbs.c   cuddCof.c      cuddInteract.c  cuddSign.c      cuddZddGroup.c  mtrBasic.c	\
cpu_time.c       cuddAnneal.c   cuddCompose.c  cuddLCache.c    cuddSolve.c     cuddZddIsop.c   mtrGroup.c	\
cstringstream.c  cuddApa.c      cuddDecomp.c   cuddLevelQ.c    cuddSplit.c     cuddZddLin.c    pathsearch.c	\
cuddAPI.c        cuddApprox.c   cuddEssent.c   cuddLinear.c    cuddSubsetHB.c  cuddZddMisc.c   pipefork.c	\
cuddAddAbs.c     cuddBddAbs.c   cuddExact.c    cuddLiteral.c   cuddSubsetSP.c  cuddZddPort.c   prtime.c		\
cuddAddApply.c   cuddBddCorr.c  cuddExport.c   cuddMatMult.c   cuddSymmetry.c  cuddZddReord.c  safe_mem.c	\
cuddAddFind.c    cuddBddIte.c   cuddGenCof.c   cuddPriority.c  cuddTable.c     cuddZddSetop.c  st.c		\
cuddAddInv.c     cuddBridge.c   cuddGenetic.c  cuddRead.c      cuddUtil.c      cuddZddSymm.c   strsav.c		\
cuddAddIte.c     cuddCache.c    cuddGroup.c    cuddRef.c       cuddWindow.c    cuddZddUtil.c   texpand.c	\
cuddAddNeg.c     cuddCheck.c    cuddHarwell.c  cuddReorder.c   cuddZddCount.c  datalimit.c     ucbqsort.c	\
cuddAddWalsh.c   cuddClip.c     cuddInit.c     cuddSat.c       cuddZddFuncs.c  epd.c

obj := $(src:%.c=$O/%$(OEXT))


srctrg = main.cpp
trg := $(srctrg:%.cpp=%$(EEXT))


all: $O $(trg) $O/$(CULIB)$(LEXT)

$O:
	mkdir -p $O

$(trg): %$(EEXT):%.cpp $O/$(CULIB)$(LEXT) $O/cuddObj$(OEXT)
	$(COMPILER) $(OPT) $(INC) $< $O/$(CULIB)$(LEXT) \
	$O/cuddObj$(OEXT) $(LDF) $(EOUT)$@

$O/$(CULIB)$(LEXT): $(obj)
	$(ARCR)$O/$(CULIB)$(LEXT) $(obj)

$(obj): $O/%$(OEXT):$(CUD)/%.c $(CUD)/*.h
	$(COMPILER) -c $(OPT) $(OPTCD) $(INC) $(FLAGS) $< $(OOUT)$@

$O/cuddObj$(OEXT): $(CUD)/cuddObj.cc
	$(COMPILER) -c $(OPT) $(OPTCD) $(INC) $(FLAGS) $< $(OOUT)$@


clean:
	rm -rf $(TRG) *.obj *.exe

mk_all.mak
151
# Hasq Technology Pty Ltd (C) 2013-2016

ifeq ($(OS),Windows_NT)
PLAT=w
else
PLAT=u
endif

BINR=$(PLAT)
TRG=_bin$(BINR)

include $(SRC)mk_$(PLAT).mak


mk_u.mak
325

COMPILER=g++
COMPILERC=gcc
ARCR=ar crs #
AR=arXXX
LD=ld
RANLIB=ranlibXXX
STRIP=strip

OPT=-Wall -O2 -std=c++11 -fno-strict-aliasing
OPTC=-Wall -O2

INC=-Ic30
EEXT=
OEXT=.o
LEXT=.a
DEFEXT=
LDF=-lpthread -ldl
OOUT=-o 
EOUT=-o 

ifdef GCOV
OPT= -Wall -g -std=c++11 -fprofile-arcs -ftest-coverage -fno-elide-constructors
endif


mk_w.mak
772

COMPILER=cl
COMPILERC=cl
AR=arXXX
ARCR=lib /OUT:
LD=ld
RANLIB=ranlibXXX
STRIP=strip

OPT=-WX -W4 -nologo -EHsc -Ox -D_CRT_SECURE_NO_DEPRECATE=1 /wd4355 /wd4127 /wd4702 /wd4100 /wd4290 /wd4589 -D_USING_V110_SDK71_=1
#4355 'this' used in base member initializer list
#4127 conditional expression is constant
#4244 possible loss of data
#4100 unreferenced formal parameter
#4309 trucation of constant value
#4702 unreachable code
#4290 C++ exception specification ignored except to indicate a function is not __declspec(nothrow)
#4589 Constructor of abstract class

OPTC=$(OPT)

OPTCD=$(OPT) /wd4244 /wd4204 /wd4245 /wd4018
# Ze initialization with non constants
# /wd4267 

INC=-Ic30
EEXT=.exe
OEXT=.obj
LEXT=.lib
DEFEXT=.exe
LDF=WS2_32.Lib advapi32.lib
OOUT=-Fo
EOUT=-Fe


sizes.cpp
106
#include <iostream>

int main()
{
	std::cout<<sizeof(int)<<sizeof(unsigned)<<sizeof(void*)<<'\n';
}

z
170

o DDcal:
 *  * v0 * v1
n0x4fd = 1
n0x502 = v1 * n0x4fd + v1' * n0x4fd'
n0x505 = v0 * n0x502 + v0' * n0x502'
f0 = n0x505'
[f0]

o cout:
!(x0 & x1 | !x0 & !x1)

1
c30
88
config.h
5437
/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define if building universal (internal helper macro) */
/* #undef AC_APPLE_UNIVERSAL_BUILD */

/* Define to 1 if you have the <assert.h> header file. */
#define HAVE_ASSERT_H 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you have the <float.h> header file. */
#define HAVE_FLOAT_H 1

/* Define to 1 if you have the `gethostname' function. */
#define HAVE_GETHOSTNAME 1

/* Define to 1 if you have the `getrlimit' function. */
#define HAVE_GETRLIMIT 1

/* Define to 1 if you have the `getrusage' function. */
#define HAVE_GETRUSAGE 0

/* Define to 1 if you have working floating-point infinities */
#define HAVE_IEEE_754 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the <math.h> header file. */
#define HAVE_MATH_H 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if your compiler supports enough C++11 */
#define HAVE_MODERN_CXX 1

/* Define to 1 if you have the `pow' function. */
#define HAVE_POW 1

/* Define to 1 if you have the `powl' function. */
#define HAVE_POWL 1
/* #undef HAVE_POWL */

/* Define to 1 if the system has the type `ptrdiff_t'. */
#define HAVE_PTRDIFF_T 1

/* Define to 1 if you have the `sqrt' function. */
#define HAVE_SQRT 1

/* Define to 1 if you have the <stddef.h> header file. */
#define HAVE_STDDEF_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strstr' function. */
#define HAVE_STRSTR 1

/* Define to 1 if you have the `sysconf' function. */
#define HAVE_SYSCONF 0

/* Define to 1 if you have the <sys/resource.h> header file. */
#define HAVE_SYS_RESOURCE_H 0

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/times.h> header file. */
#define HAVE_SYS_TIMES_H 0

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 0

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/wait.h> header file. */
#define HAVE_SYS_WAIT_H 0

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 0

/* Define to 1 if C++ thread header is usable */
#define HAVE_WORKING_THREAD 1

/* Define to 1 if the system has the type `_Bool'. */
#define HAVE__BOOL 1

/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#define LT_OBJDIR ".libs/"

/* Name of package */
#define PACKAGE "cudd"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "Fabio@Colorado.EDU"

/* Define to the full name of this package. */
#define PACKAGE_NAME "cudd"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "cudd 3.0.0"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "cudd"

/* Define to the home page for this package. */
#define PACKAGE_URL ""

/* Define to the version of this package. */
#define PACKAGE_VERSION "3.0.0"

/* The size of `int', as computed by sizeof. */
#define SIZEOF_INT 4

/* The size of `long', as computed by sizeof. */
#define SIZEOF_LONG 4

/* The size of `long double', as computed by sizeof. */
#define SIZEOF_LONG_DOUBLE 12

/* The size of `void *', as computed by sizeof. */
#define SIZEOF_VOID_P 4

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Define to 1 to use system qsort */
/* #undef USE_SYSTEM_QSORT */

/* Version number of package */
#define VERSION "3.0.0"

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
#if defined AC_APPLE_UNIVERSAL_BUILD
# if defined __BIG_ENDIAN__
#  define WORDS_BIGENDIAN 1
# endif
#else
# ifndef WORDS_BIGENDIAN
/* #  undef WORDS_BIGENDIAN */
# endif
#endif

/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
   #define below would cause a syntax error. */
/* #undef _UINT32_T */

/* Define to 1 to enable C99-compliant printf on MinGW-w64 */
/* #undef __USE_MINGW_ANSI_STDIO */

/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
#ifndef __cplusplus
/* #undef inline */
#endif

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to the type of an unsigned integer type of width exactly 16 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint16_t */

/* Define to the type of an unsigned integer type of width exactly 32 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint32_t */

cpu_stats.c
8594
/**
  @file

  @ingroup util

  @brief CPU statistics.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#define _BSD_SOURCE
#include "util.h"

#if HAVE_SYS_TIME_H == 1
#include <sys/time.h>
#endif
#if HAVE_SYS_RESOURCE_H == 1
#include <sys/resource.h>
#endif

#ifdef BSD
#if defined(_IBMR2)
#define etext _etext
#define edata _edata
#define end _end
#endif

extern int end, etext, edata;

#endif

#ifdef _WIN32
#include <winsock2.h>
#include <psapi.h>
#endif

/**
   @brief Prints CPU statistics.

   The amount of detail printed depends on the host operating system.

*/
void
util_print_cpu_stats(FILE *fp)
{
#if HAVE_GETRUSAGE == 1 && HAVE_GETRLIMIT == 1
    struct rusage rusage;
    double user, system, scale;
    long text, data;
    struct rlimit rlp;
    long vm_limit, vm_soft_limit;
    char hostname[257];
#ifdef BSD
    long vm_text, vm_init_data, vm_uninit_data, vm_sbrk_data;
#endif

    /* Get the hostname */
    (void) gethostname(hostname, sizeof(hostname));
    hostname[sizeof(hostname)-1] = '\0';	/* just in case */

#ifdef BSD
    /* Get the virtual memory sizes */
    vm_text = (long) (((long) (&etext)) / 1024.0 + 0.5);
    vm_init_data = (long) (((long) (&edata) - (long) (&etext)) / 1024.0 + 0.5);
    vm_uninit_data = (long) (((long) (&end) - (long) (&edata)) / 1024.0 + 0.5);
    vm_sbrk_data = (long) (((long) sbrk(0) - (long) (&end)) / 1024.0 + 0.5);
#endif

    /* Get virtual memory limits */
    (void) getrlimit(RLIMIT_DATA, &rlp);
    vm_limit = (long) (rlp.rlim_max / 1024.0 + 0.5);
    vm_soft_limit = (long) (rlp.rlim_cur / 1024.0 + 0.5);

    /* Get usage stats */
    (void) getrusage(RUSAGE_SELF, &rusage);
    user = rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec * 1e-6;
    system = rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec * 1e-6;
    scale = (user + system)*100.0;
    if (scale == 0.0) scale = 0.001;
    text = (int) (rusage.ru_ixrss / scale + 0.5);
    data = (int) ((rusage.ru_idrss + rusage.ru_isrss) / scale + 0.5);

#elif defined(_WIN32)
    char hostname[257];
    WSADATA wsaData;
    FILETIME creationTime, exitTime, kernelTime, userTime;
    double user, system;
    MEMORYSTATUSEX statex;
    size_t vm_limit;
    PROCESS_MEMORY_COUNTERS pmc;
    size_t peak_working_set;
    long page_faults;

    /* Get the hostname */
    WSAStartup(MAKEWORD(2, 2), &wsaData);
    (void) gethostname(hostname, sizeof(hostname));
    hostname[sizeof(hostname)-1] = '\0';	/* just in case */
    WSACleanup();

    /* Get usage stats */
    if (GetProcessTimes(GetCurrentProcess(), &creationTime, &exitTime,
			&kernelTime, &userTime)) {
	ULARGE_INTEGER integerSystemTime, integerUserTime;
	integerUserTime.u.LowPart = userTime.dwLowDateTime;
	integerUserTime.u.HighPart = userTime.dwHighDateTime;
	user = (double) integerUserTime.QuadPart * 1e-7;
	integerSystemTime.u.LowPart = kernelTime.dwLowDateTime;
	integerSystemTime.u.HighPart = kernelTime.dwHighDateTime;
	system = (double) integerSystemTime.QuadPart * 1e-7;
    } else {
	user = system = 0.0;
    }
    statex.dwLength = sizeof(statex);
    if (GlobalMemoryStatusEx(&statex)) {
	vm_limit = (size_t) (statex.ullTotalVirtual / 1024.0 + 0.5);
    } else {
	vm_limit = 0;
    }
    if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
	peak_working_set = (size_t) (pmc.PeakWorkingSetSize / 1024.0 + 0.5);
	page_faults = (long) pmc.PageFaultCount;
    } else {
	peak_working_set = 0;
	page_faults = 0;
    }
#endif

#if (HAVE_GETRUSAGE == 1 && HAVE_GETRLIMIT == 1) || defined(_WIN32)
    (void) fprintf(fp, "Runtime Statistics\n");
    (void) fprintf(fp, "------------------\n");
    (void) fprintf(fp, "Machine name: %s\n", hostname);
    (void) fprintf(fp, "User time   %6.1f seconds\n", user);
    (void) fprintf(fp, "System time %6.1f seconds\n\n", system);

#if HAVE_GETRUSAGE == 1 && HAVE_GETRLIMIT == 1
    (void) fprintf(fp, "Average resident text size       = %5ldK\n", text);
    (void) fprintf(fp, "Average resident data+stack size = %5ldK\n", data);
    (void) fprintf(fp, "Maximum resident size            = %5ldK\n\n",
	rusage.ru_maxrss);
#if defined(BSD)
    (void) fprintf(fp, "Virtual text size                = %5ldK\n",
	vm_text);
    (void) fprintf(fp, "Virtual data size                = %5ldK\n",
	vm_init_data + vm_uninit_data + vm_sbrk_data);
    (void) fprintf(fp, "    data size initialized        = %5ldK\n",
	vm_init_data);
    (void) fprintf(fp, "    data size uninitialized      = %5ldK\n",
	vm_uninit_data);
    (void) fprintf(fp, "    data size sbrk               = %5ldK\n",
	vm_sbrk_data);
#endif
    (void) fprintf(fp, "Virtual memory limit             = ");
    if (rlp.rlim_cur == RLIM_INFINITY)
        (void) fprintf(fp, "unlimited");
    else
        (void) fprintf(fp, "%5ldK", vm_soft_limit);
    if (rlp.rlim_max == RLIM_INFINITY)
        (void) fprintf(fp, " (unlimited)\n");
    else
        (void) fprintf(fp, " (%ldK)\n\n", vm_limit);

    (void) fprintf(fp, "Major page faults = %ld\n", rusage.ru_majflt);
    (void) fprintf(fp, "Minor page faults = %ld\n", rusage.ru_minflt);
    (void) fprintf(fp, "Swaps = %ld\n", rusage.ru_nswap);
    (void) fprintf(fp, "Input blocks = %ld\n", rusage.ru_inblock);
    (void) fprintf(fp, "Output blocks = %ld\n", rusage.ru_oublock);
    (void) fprintf(fp, "Context switch (voluntary) = %ld\n", rusage.ru_nvcsw);
    (void) fprintf(fp, "Context switch (involuntary) = %ld\n", rusage.ru_nivcsw);
#else
    (void) fprintf(fp, "Maximum resident size            = ");
    if (peak_working_set == 0)
	(void) fprintf(fp, "unavailable\n");
    else
	(void) fprintf(fp, "%" PRIszt "K\n", peak_working_set);
    (void) fprintf(fp, "Virtual memory limit             = ");
    if (vm_limit == 0)
	(void) fprintf(fp, "unavailable\n");
    else
	(void) fprintf(fp, "%5" PRIszt "K\n", vm_limit);
    (void) fprintf(fp, "Page faults       = %ld\n", page_faults);
#endif
#else
    (void) fprintf(fp, "Usage statistics not available\n");
#endif
}

cpu_time.c
4338
/**
  @file

  @ingroup util

  @brief System time calls

  @details Provide a uniform interface across different operating systems.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"

#if HAVE_SYS_TIMES_H == 1
#include <sys/times.h>
#endif

#ifdef _WIN32
#include <windows.h>
#endif

/**
 * @brief returns a long which represents the elapsed processor
 * time in milliseconds since some constant reference.
 */
long
util_cpu_time(void)
{
#if HAVE_SYSCONF == 1

    /* Code for POSIX systems */

    struct tms buffer;
    long nticks;                /* number of clock ticks per second */

    nticks = sysconf(_SC_CLK_TCK);
    times(&buffer);
    return (long) ((buffer.tms_utime + buffer.tms_stime) * (1000.0/nticks));

#elif defined(_WIN32)
    FILETIME creationTime, exitTime, kernelTime, userTime;
    if (GetProcessTimes(GetCurrentProcess(), &creationTime, &exitTime,
			&kernelTime, &userTime)) {
	ULARGE_INTEGER integerTime;
	integerTime.u.LowPart = userTime.dwLowDateTime;
	integerTime.u.HighPart = userTime.dwHighDateTime;
	return (long) (integerTime.QuadPart / 10000);
    } else {
	return 0;
    }
#else
    return 0L;
#endif

}

/**
 * @brief returns a long which represents the elapsed processor
 * time in milliseconds since some constant reference.  It includes
 * waited-for terminated children.
 */
long
util_cpu_ctime(void)
{
#if HAVE_SYSCONF == 1

    /* Code for POSIX systems */

    struct tms buffer;
    long nticks;                /* number of clock ticks per second */

    nticks = sysconf(_SC_CLK_TCK);
    times(&buffer);
    return (long) ((buffer.tms_utime + buffer.tms_cutime) * (1000.0/nticks));

#else
    return 0L;
#endif

}


cstringstream.c
5483
/**
  @file 

  @ingroup cstringstream

  @brief Simple string streams in C.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 2014-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cstringstream.h"

/**
 * @brief Type of a simple extensible string buffer.
 */
struct _cstringstream {
  size_t capacity; /**< elements allocated */
  size_t inUse;    /**< elements currently in use */
  char * data;     /**< actual data */
};

cstringstream newStringStream(void) {
  cstringstream ss;
  ss = (cstringstream) malloc(sizeof(struct _cstringstream));
  if (!ss) return NULL;
  ss->capacity = 1; /* parsimonious */
  ss->inUse = 0;
  ss->data = (char *) malloc(sizeof(char) * ss->capacity);
  if (!ss->data) {
    free(ss);
    return NULL;
  }
  return ss;
}

void deleteStringStream(cstringstream ss) {
  if (ss) {
    free(ss->data);
    free(ss);
  }
}

int clearStringStream(cstringstream ss) {
  if (!ss) return -1;
  ss->inUse = 0;
  return 0;
}

cstringstream copyStringStream(const_cstringstream src) {
  cstringstream dest;
  if (!src) return 0;
  dest = newStringStream();
  if (!dest) return 0;
  if (resizeStringStream(dest, src->inUse)) {
    deleteStringStream(dest);
    return 0;
  }
  strncpy(dest->data, src->data, src->inUse);
  return dest;
}

int resizeStringStream(cstringstream ss, size_t newSize) {
  if (newSize > ss->capacity) {
    /* To avoid too many calls to realloc, we choose the larger of
     * twice the current size and the new requested size. */
    size_t newCapacity = 2 * ss->capacity;
    if (newCapacity < newSize)
      newCapacity = newSize;
    char * tmp = (char *) realloc(ss->data, newCapacity * sizeof(char));
    /* If the allocation fails, leave the array alone. */
    if (!tmp) return -1;
    ss->data = tmp;
    ss->capacity = newCapacity;
  }
  /* Here we are guaranteed that newSize <= ss->capacity. */
  ss->inUse = newSize;
  return 0;
}

int sizeStringStream(const_cstringstream ss, size_t * num) {
  if (!ss || !num) return -1;
  *num = ss->inUse;
  return 0;
}

int getStringStream(const_cstringstream ss, size_t index, char * c) {
  if (!ss || !c || index >= ss->inUse) return -1;
  *c = ss->data[index];
  return 0;
}

int appendCharStringStream(cstringstream ss, char c) {
  if (!ss) return -1;
  if (resizeStringStream(ss, ss->inUse + 1)) return -1;
  /* Now we have space. */
  ss->data[ss->inUse-1] = c;
  return 0;
}

int appendStringStringStream(cstringstream ss, char const * s) {
  if (!ss) return -1;
  size_t len = strlen(s);
  if (resizeStringStream(ss, ss->inUse + len)) return -1;
  /* Now we have space. */
  strncpy(ss->data + ss->inUse - len, s, len); 
  return 0;
}

int appendIntStringStream(cstringstream ss, int d) {
  char str[256];
  if (!ss) return -1;
  sprintf(str, "%d", d);
  return appendStringStringStream(ss, str);
}

int appendUnsignedStringStream(cstringstream ss, unsigned u) {
  char str[256];
  if (!ss) return -1;
  sprintf(str, "%u", u);
  return appendStringStringStream(ss, str);
}

int appendLongStringStream(cstringstream ss, long ld) {
  char str[256];
  if (!ss) return -1;
  sprintf(str, "%ld", ld);
  return appendStringStringStream(ss, str);
}

int appendUnsignedLongStringStream(cstringstream ss, unsigned long lu) {
  char str[256];
  if (!ss) return -1;
  sprintf(str, "%lu", lu);
  return appendStringStringStream(ss, str);
}

int appendDoubleStringStream(cstringstream ss, double g) {
  char str[256];
  if (!ss) return -1;
  sprintf(str, "%g", g);
  return appendStringStringStream(ss, str);
}

int putStringStream(cstringstream ss, size_t index, char c) {
  if (!ss || index >= ss->inUse) return -1;
  ss->data[index] = c;
  return 0;
}

char * stringFromStringStream(const_cstringstream ss) {
  if (!ss) return 0;
  char * str = (char *) malloc(sizeof(char) * (ss->inUse + 1));
  if (!str) return 0;
  strncpy(str, ss->data, ss->inUse);
  str[ss->inUse] = '\0';
  return str;
}

cstringstream.h
5430
/**
  @file 

  @ingroup cstringstream

  @brief Package for simple stringstreams in C.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 2014-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

  $Id: cstringstream.h,v 1.1 2015/07/01 20:36:47 fabio Exp fabio $

*/
#ifndef CSTRINGSTREAM_H_
#define CSTRINGSTREAM_H_

#ifdef __cplusplus
extern "C" {
#endif

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
 * @brief Type of a string stream.
 */
typedef struct _cstringstream * cstringstream;

/**
 * @brief Const-qualified version of cstringstream.
 */
typedef struct _cstringstream const * const_cstringstream;

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

/**
 * @brief Returns a new cstringstream with an empty string.
 * @return NULL if creation fails.
 */
cstringstream newStringStream(void);
/**
 * @brief Frees cstringstream ss.
 */
void deleteStringStream(cstringstream ss);
/**
 * @brief Clears the contents of cstringstream ss.
 * @return 0 if succesful and -1 if ss is an invalid pointer.
 */
int clearStringStream(cstringstream ss);
/**
 * @brief Copies cstringstream src to a new cstringstream.
 * @return 0 if succesful or -1 if src is an invalid pointer
 * or memory allocation fails.
 */
cstringstream copyStringStream(const_cstringstream src);
/**
 * @brief Changes the size of cstringstream ss.
 * @return 0 if successful or -1 if resizing fails.
 */
int resizeStringStream(cstringstream ss, size_t newSize);
/**
 * @brief Writes the size of cstringstream ss to the location pointed by num.
 * @return 0 if succesful or -1 if ss is an invalid pointer.
 */
int sizeStringStream(const_cstringstream ss, size_t * num);
/**
 * @brief Writes the i-th element of cstringstream ss to the location
 * pointed by c.
 * @return 0 if successful or -1 otherwise.
 */
int getStringStream(const_cstringstream ss, size_t i, char * c);
/**
 * @brief Adds char c at the end of cstringstream ss.
 * @return 0 if successful or -1 otherwise.
 */
int appendCharStringStream(cstringstream ss, char c);
/**
 * @brief Adds string s at the end of cstringstream ss.
 * @return 0 if successful or -1 otherwise.
 */
int appendStringStringStream(cstringstream ss, char const * s);
/**
 * @brief Adds int d at the end of cstringstream ss.
 * @return 0 if successful or -1 otherwise.
 */
int appendIntStringStream(cstringstream ss, int d);
/**
 * @brief Adds unsigned u at the end of cstringstream ss.
 * @return 0 if successful or -1 otherwise.
 */
int appendUnsignedStringStream(cstringstream ss, unsigned u);
/**
 * @brief Adds long ld at the end of cstringstream ss.
 * @return 0 if successful or -1 otherwise.
 */
int appendLongStringStream(cstringstream ss, long ld);
/**
 * @brief Adds unsigned long lu at the end of cstringstream ss.
 * @return 0 if successful or -1 otherwise.
 */
int appendUnsignedLongStringStream(cstringstream ss, unsigned long lu);
/**
 * @brief Adds double g at the end of cstringstream ss.
 * @return 0 if successful or -1 otherwise.
 */
int appendDoubleStringStream(cstringstream ss, double g);
/**
 * @brief Sets the i-th element of cstringstream ss to c.
 * @return 0 if successful or -1 otherwise.
 *
 * The i-th element of ss must already exist.
 */
int putStringStream(cstringstream ss, size_t index, char c);
/**
 * @brief Returns a NULL-terminated string from the contents of
 * cstringstream ss.
 * @details In case of failure, it returns NULL.
 * The returned string must be freed by the caller.
 */
char * stringFromStringStream(const_cstringstream ss);

#ifdef __cplusplus
}
#endif

#endif

cudd.h
47917
/**
  @file 

  @ingroup cudd

  @brief The University of Colorado decision diagram package.

  @details External functions and data strucures of the CUDD package.
  <ul>
  <li> To turn on the gathering of statistics, define DD_STATS.
  <li> To turn on additional debugging code, define DD_DEBUG.
  </ul>

  @author Fabio Somenzi
  @author Modified by Abelardo Pardo to interface it to VIS

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef CUDD_H_
#define CUDD_H_

/*---------------------------------------------------------------------------*/
/* Nested includes                                                           */
/*---------------------------------------------------------------------------*/

#include <inttypes.h>

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define CUDD_TRUE 1 /**< readable true */
#define CUDD_FALSE 0 /**< readable false */

/**
 * @brief Value returned my many functions when memory is exhausted.
 */
#define CUDD_OUT_OF_MEM		-1
/* The sizes of the subtables and the cache must be powers of two. */
#define CUDD_UNIQUE_SLOTS	256	/**< Initial size of subtables */
#define CUDD_CACHE_SLOTS	262144	/**< Default size of the cache */

/* Constants for residue functions. */
#define CUDD_RESIDUE_DEFAULT	0
#define CUDD_RESIDUE_MSB	1
#define CUDD_RESIDUE_TC		2

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
  @brief Type of reordering algorithm.
*/
typedef enum {
    CUDD_REORDER_SAME,
    CUDD_REORDER_NONE,
    CUDD_REORDER_RANDOM,
    CUDD_REORDER_RANDOM_PIVOT,
    CUDD_REORDER_SIFT,
    CUDD_REORDER_SIFT_CONVERGE,
    CUDD_REORDER_SYMM_SIFT,
    CUDD_REORDER_SYMM_SIFT_CONV,
    CUDD_REORDER_WINDOW2,
    CUDD_REORDER_WINDOW3,
    CUDD_REORDER_WINDOW4,
    CUDD_REORDER_WINDOW2_CONV,
    CUDD_REORDER_WINDOW3_CONV,
    CUDD_REORDER_WINDOW4_CONV,
    CUDD_REORDER_GROUP_SIFT,
    CUDD_REORDER_GROUP_SIFT_CONV,
    CUDD_REORDER_ANNEALING,
    CUDD_REORDER_GENETIC,
    CUDD_REORDER_LINEAR,
    CUDD_REORDER_LINEAR_CONVERGE,
    CUDD_REORDER_LAZY_SIFT,
    CUDD_REORDER_EXACT
} Cudd_ReorderingType;


/**
  @brief Type of aggregation methods.
*/
typedef enum {
    CUDD_NO_CHECK,
    CUDD_GROUP_CHECK,
    CUDD_GROUP_CHECK2,
    CUDD_GROUP_CHECK3,
    CUDD_GROUP_CHECK4,
    CUDD_GROUP_CHECK5,
    CUDD_GROUP_CHECK6,
    CUDD_GROUP_CHECK7,
    CUDD_GROUP_CHECK8,
    CUDD_GROUP_CHECK9
} Cudd_AggregationType;


/**
  @brief Type of hooks.
*/
typedef enum {
    CUDD_PRE_GC_HOOK,
    CUDD_POST_GC_HOOK,
    CUDD_PRE_REORDERING_HOOK,
    CUDD_POST_REORDERING_HOOK
} Cudd_HookType;


/**
  @brief Type of error codes.
*/
typedef enum {
    CUDD_NO_ERROR,
    CUDD_MEMORY_OUT,
    CUDD_TOO_MANY_NODES,
    CUDD_MAX_MEM_EXCEEDED,
    CUDD_TIMEOUT_EXPIRED,
    CUDD_TERMINATION,
    CUDD_INVALID_ARG,
    CUDD_INTERNAL_ERROR
} Cudd_ErrorType;


/**
  @brief Group type for lazy sifting.
*/
typedef enum {
    CUDD_LAZY_NONE,
    CUDD_LAZY_SOFT_GROUP,
    CUDD_LAZY_HARD_GROUP,
    CUDD_LAZY_UNGROUP
} Cudd_LazyGroupType;


/**
  @brief Variable type.

  @details Used only in lazy sifting.

*/
typedef enum {
    CUDD_VAR_PRIMARY_INPUT,
    CUDD_VAR_PRESENT_STATE,
    CUDD_VAR_NEXT_STATE
} Cudd_VariableType;

/**
   @brief Type of the value of a terminal node.
*/
typedef double CUDD_VALUE_TYPE;

/**
   @brief Type of the decision diagram node.
*/
typedef struct DdNode DdNode;

/**
   @brief Type of a pointer to a decision diagram node.
*/
typedef DdNode *DdNodePtr;

/**
   @brief CUDD manager.
*/
typedef struct DdManager DdManager;

/**
   @brief CUDD generator.
*/
typedef struct DdGen DdGen;

/**
   @brief Type of an arbitrary precision integer "digit."
*/
typedef uint32_t DdApaDigit;

/**
   @brief Type of an arbitrary precision intger, which is an array of digits.
*/
typedef DdApaDigit * DdApaNumber;

/**
   @brief Type of a const-qualified arbitrary precision integer.
*/
typedef DdApaDigit const * DdConstApaNumber;

/**
   @brief Return type for function computing two-literal clauses.
*/
typedef struct DdTlcInfo DdTlcInfo;

/**
   @brief Type of hook function.
*/
typedef int (*DD_HFP)(DdManager *, const char *, void *);
/**
   @brief Type of priority function
*/
typedef DdNode * (*DD_PRFP)(DdManager * , int, DdNode **, DdNode **, DdNode **);
/**
   @brief Type of apply operator.
*/
typedef DdNode * (*DD_AOP)(DdManager *, DdNode **, DdNode **);
/**
   @brief Type of monadic apply operator.
*/
typedef DdNode * (*DD_MAOP)(DdManager *, DdNode *);
/**
   @brief Type of two-operand cache tag functions.
*/
typedef DdNode * (*DD_CTFP)(DdManager *, DdNode *, DdNode *);
/**
   @brief Type of one-operand cache tag functions.
*/
typedef DdNode * (*DD_CTFP1)(DdManager *, DdNode *);
/**
   @brief Type of memory-out function.
*/
typedef void (*DD_OOMFP)(size_t);
/**
   @brief Type of comparison function for qsort.
*/
typedef int (*DD_QSFP)(const void *, const void *);
/**
   @brief Type of termination handler.
*/
typedef int (*DD_THFP)(const void *);
/**
   @brief Type of timeout handler.
*/
typedef void (*DD_TOHFP)(DdManager *, void *);

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/


/**
  @brief Complements a %DD.

  @details Complements a %DD by flipping the complement attribute of
  the pointer (the least significant bit).

  @sideeffect none

  @see Cudd_NotCond

*/
#define Cudd_Not(node) ((DdNode *)((uintptr_t)(node) ^ (uintptr_t) 01))


/**
  @brief Complements a %DD if a condition is true.

  @details Complements a %DD if condition c is true; c should be
  either 0 or 1, because it is used directly (for efficiency). If in
  doubt on the values c may take, use "(c) ? Cudd_Not(node) : node".

  @sideeffect none

  @see Cudd_Not

*/
#define Cudd_NotCond(node,c) ((DdNode *)((uintptr_t)(node) ^ (uintptr_t) (c)))


/**
  @brief Returns the regular version of a pointer.

  @details 

  @sideeffect none

  @see Cudd_Complement Cudd_IsComplement

*/
#define Cudd_Regular(node) ((DdNode *)((uintptr_t)(node) & ~(uintptr_t) 01))


/**
  @brief Returns the complemented version of a pointer.

  @details 

  @sideeffect none

  @see Cudd_Regular Cudd_IsComplement

*/
#define Cudd_Complement(node) ((DdNode *)((uintptr_t)(node) | (uintptr_t) 01))


/**
  @brief Returns 1 if a pointer is complemented.

  @details 

  @sideeffect none

  @see Cudd_Regular Cudd_Complement

*/
#define Cudd_IsComplement(node) ((int) ((uintptr_t) (node) & (uintptr_t) 01))


/**
  @brief Returns the current position in the order of variable
  index.

  @details Returns the current position in the order of variable
  index. This macro is obsolete and is kept for compatibility. New
  applications should use Cudd_ReadPerm instead.

  @sideeffect none

  @see Cudd_ReadPerm

*/
#define Cudd_ReadIndex(dd,index) (Cudd_ReadPerm(dd,index))


/**
  @brief Iterates over the cubes of a decision diagram.

  @details Iterates over the cubes of a decision diagram f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> int *cube;
  <li> CUDD_VALUE_TYPE value;
  </ul>
  Cudd_ForeachCube allocates and frees the generator. Therefore the
  application should not try to do that. Also, the cube is freed at the
  end of Cudd_ForeachCube and hence is not available outside of the loop.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators. It is the user's responsibility to make sure
  that dynamic reordering does not occur. As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur. Alternatively, it is sufficient to
  disable dynamic reordering. It is a mistake to dispose of a diagram
  on which generation is ongoing.

  @sideeffect none

  @see Cudd_ForeachNode Cudd_FirstCube Cudd_NextCube Cudd_GenFree
  Cudd_IsGenEmpty Cudd_AutodynDisable

*/
#define Cudd_ForeachCube(manager, f, gen, cube, value)\
    for((gen) = Cudd_FirstCube(manager, f, &cube, &value);\
	Cudd_IsGenEmpty(gen) ? Cudd_GenFree(gen) : CUDD_TRUE;\
	(void) Cudd_NextCube(gen, &cube, &value))


/**
  @brief Iterates over the primes of a Boolean function.

  @details Iterates over the primes of a Boolean function producing
  a prime, but not necessarily irredundant, cover.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *l;
  <li> DdNode *u;
  <li> DdGen *gen;
  <li> int *cube;
  </ul>
  The Boolean function is described by an upper bound and a lower bound.  If
  the function is completely specified, the two bounds coincide.
  Cudd_ForeachPrime allocates and frees the generator.  Therefore the
  application should not try to do that.  Also, the cube is freed at the
  end of Cudd_ForeachPrime and hence is not available outside of the loop.<p>
  CAUTION: It is a mistake to change a diagram on which generation is ongoing.

  @sideeffect none

  @see Cudd_ForeachCube Cudd_FirstPrime Cudd_NextPrime Cudd_GenFree
  Cudd_IsGenEmpty

*/
#define Cudd_ForeachPrime(manager, l, u, gen, cube)\
    for((gen) = Cudd_FirstPrime(manager, l, u, &cube);\
	Cudd_IsGenEmpty(gen) ? Cudd_GenFree(gen) : CUDD_TRUE;\
	(void) Cudd_NextPrime(gen, &cube))


/**
  @brief Iterates over the nodes of a decision diagram.

  @details Iterates over the nodes of a decision diagram f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> DdNode *node;
  </ul>
  The nodes are returned in a seemingly random order.
  Cudd_ForeachNode allocates and frees the generator. Therefore the
  application should not try to do that.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators. It is the user's responsibility to make sure
  that dynamic reordering does not occur. As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur. Alternatively, it is sufficient to
  disable dynamic reordering. It is a mistake to dispose of a diagram
  on which generation is ongoing.

  @sideeffect none

  @see Cudd_ForeachCube Cudd_FirstNode Cudd_NextNode Cudd_GenFree
  Cudd_IsGenEmpty Cudd_AutodynDisable

*/
#define Cudd_ForeachNode(manager, f, gen, node)\
    for((gen) = Cudd_FirstNode(manager, f, &node);\
	Cudd_IsGenEmpty(gen) ? Cudd_GenFree(gen) : CUDD_TRUE;\
	(void) Cudd_NextNode(gen, &node))


/**
  @brief Iterates over the paths of a %ZDD.

  @details Iterates over the paths of a %ZDD f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> int *path;
  </ul>
  Cudd_zddForeachPath allocates and frees the generator. Therefore the
  application should not try to do that. Also, the path is freed at the
  end of Cudd_zddForeachPath and hence is not available outside of the loop.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators.  It is the user's responsibility to make sure
  that dynamic reordering does not occur.  As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur.  Alternatively, it is sufficient to
  disable dynamic reordering.  It is a mistake to dispose of a diagram
  on which generation is ongoing.

  @sideeffect none

  @see Cudd_zddFirstPath Cudd_zddNextPath Cudd_GenFree
  Cudd_IsGenEmpty Cudd_AutodynDisable

*/
#define Cudd_zddForeachPath(manager, f, gen, path)\
    for((gen) = Cudd_zddFirstPath(manager, f, &path);\
	Cudd_IsGenEmpty(gen) ? Cudd_GenFree(gen) : CUDD_TRUE;\
	(void) Cudd_zddNextPath(gen, &path))



/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

extern DdNode * Cudd_addNewVar(DdManager *dd);
extern DdNode * Cudd_addNewVarAtLevel(DdManager *dd, int level);
extern DdNode * Cudd_bddNewVar(DdManager *dd);
extern DdNode * Cudd_bddNewVarAtLevel(DdManager *dd, int level);
extern int Cudd_bddIsVar(DdManager * dd, DdNode * f);
extern DdNode * Cudd_addIthVar(DdManager *dd, int i);
extern DdNode * Cudd_bddIthVar(DdManager *dd, int i);
extern DdNode * Cudd_zddIthVar(DdManager *dd, int i);
extern int Cudd_zddVarsFromBddVars(DdManager *dd, int multiplicity);
extern unsigned int Cudd_ReadMaxIndex(void);
extern DdNode * Cudd_addConst(DdManager *dd, CUDD_VALUE_TYPE c);
extern int Cudd_IsConstant(DdNode *node);
extern int Cudd_IsNonConstant(DdNode *f);
extern DdNode * Cudd_T(DdNode *node);
extern DdNode * Cudd_E(DdNode *node);
extern CUDD_VALUE_TYPE Cudd_V(DdNode *node);
extern unsigned long Cudd_ReadStartTime(DdManager *unique);
extern unsigned long Cudd_ReadElapsedTime(DdManager *unique);
extern void Cudd_SetStartTime(DdManager *unique, unsigned long st);
extern void Cudd_ResetStartTime(DdManager *unique);
extern unsigned long Cudd_ReadTimeLimit(DdManager *unique);
extern unsigned long Cudd_SetTimeLimit(DdManager *unique, unsigned long tl);
extern void Cudd_UpdateTimeLimit(DdManager * unique);
extern void Cudd_IncreaseTimeLimit(DdManager * unique, unsigned long increase);
extern void Cudd_UnsetTimeLimit(DdManager *unique);
extern int Cudd_TimeLimited(DdManager *unique);
extern void Cudd_RegisterTerminationCallback(DdManager *unique, DD_THFP callback, void * callback_arg);
extern void Cudd_UnregisterTerminationCallback(DdManager *unique);
extern DD_OOMFP Cudd_RegisterOutOfMemoryCallback(DdManager *unique, DD_OOMFP callback);
extern void Cudd_UnregisterOutOfMemoryCallback(DdManager *unique);
extern void Cudd_RegisterTimeoutHandler(DdManager *unique, DD_TOHFP handler, void *arg);
extern DD_TOHFP Cudd_ReadTimeoutHandler(DdManager *unique, void **argp);
extern void Cudd_AutodynEnable(DdManager *unique, Cudd_ReorderingType method);
extern void Cudd_AutodynDisable(DdManager *unique);
extern int Cudd_ReorderingStatus(DdManager *unique, Cudd_ReorderingType *method);
extern void Cudd_AutodynEnableZdd(DdManager *unique, Cudd_ReorderingType method);
extern void Cudd_AutodynDisableZdd(DdManager *unique);
extern int Cudd_ReorderingStatusZdd(DdManager *unique, Cudd_ReorderingType *method);
extern int Cudd_zddRealignmentEnabled(DdManager *unique);
extern void Cudd_zddRealignEnable(DdManager *unique);
extern void Cudd_zddRealignDisable(DdManager *unique);
extern int Cudd_bddRealignmentEnabled(DdManager *unique);
extern void Cudd_bddRealignEnable(DdManager *unique);
extern void Cudd_bddRealignDisable(DdManager *unique);
extern DdNode * Cudd_ReadOne(DdManager *dd);
extern DdNode * Cudd_ReadZddOne(DdManager *dd, int i);
extern DdNode * Cudd_ReadZero(DdManager *dd);
extern DdNode * Cudd_ReadLogicZero(DdManager *dd);
extern DdNode * Cudd_ReadPlusInfinity(DdManager *dd);
extern DdNode * Cudd_ReadMinusInfinity(DdManager *dd);
extern DdNode * Cudd_ReadBackground(DdManager *dd);
extern void Cudd_SetBackground(DdManager *dd, DdNode *bck);
extern unsigned int Cudd_ReadCacheSlots(DdManager *dd);
extern double Cudd_ReadCacheUsedSlots(DdManager * dd);
extern double Cudd_ReadCacheLookUps(DdManager *dd);
extern double Cudd_ReadCacheHits(DdManager *dd);
extern double Cudd_ReadRecursiveCalls(DdManager * dd);
extern unsigned int Cudd_ReadMinHit(DdManager *dd);
extern void Cudd_SetMinHit(DdManager *dd, unsigned int hr);
extern unsigned int Cudd_ReadLooseUpTo(DdManager *dd);
extern void Cudd_SetLooseUpTo(DdManager *dd, unsigned int lut);
extern unsigned int Cudd_ReadMaxCache(DdManager *dd);
extern unsigned int Cudd_ReadMaxCacheHard(DdManager *dd);
extern void Cudd_SetMaxCacheHard(DdManager *dd, unsigned int mc);
extern int Cudd_ReadSize(DdManager *dd);
extern int Cudd_ReadZddSize(DdManager *dd);
extern unsigned int Cudd_ReadSlots(DdManager *dd);
extern double Cudd_ReadUsedSlots(DdManager * dd);
extern double Cudd_ExpectedUsedSlots(DdManager * dd);
extern unsigned int Cudd_ReadKeys(DdManager *dd);
extern unsigned int Cudd_ReadDead(DdManager *dd);
extern unsigned int Cudd_ReadMinDead(DdManager *dd);
extern unsigned int Cudd_ReadReorderings(DdManager *dd);
extern unsigned int Cudd_ReadMaxReorderings(DdManager *dd);
extern void Cudd_SetMaxReorderings(DdManager *dd, unsigned int mr);
extern long Cudd_ReadReorderingTime(DdManager * dd);
extern int Cudd_ReadGarbageCollections(DdManager * dd);
extern long Cudd_ReadGarbageCollectionTime(DdManager * dd);
extern double Cudd_ReadNodesFreed(DdManager * dd);
extern double Cudd_ReadNodesDropped(DdManager * dd);
extern double Cudd_ReadUniqueLookUps(DdManager * dd);
extern double Cudd_ReadUniqueLinks(DdManager * dd);
extern int Cudd_ReadSiftMaxVar(DdManager *dd);
extern void Cudd_SetSiftMaxVar(DdManager *dd, int smv);
extern int Cudd_ReadSiftMaxSwap(DdManager *dd);
extern void Cudd_SetSiftMaxSwap(DdManager *dd, int sms);
extern double Cudd_ReadMaxGrowth(DdManager *dd);
extern void Cudd_SetMaxGrowth(DdManager *dd, double mg);
extern double Cudd_ReadMaxGrowthAlternate(DdManager * dd);
extern void Cudd_SetMaxGrowthAlternate(DdManager * dd, double mg);
extern int Cudd_ReadReorderingCycle(DdManager * dd);
extern void Cudd_SetReorderingCycle(DdManager * dd, int cycle);
extern unsigned int Cudd_NodeReadIndex(DdNode *node);
extern int Cudd_ReadPerm(DdManager *dd, int i);
extern int Cudd_ReadPermZdd(DdManager *dd, int i);
extern int Cudd_ReadInvPerm(DdManager *dd, int i);
extern int Cudd_ReadInvPermZdd(DdManager *dd, int i);
extern DdNode * Cudd_ReadVars(DdManager *dd, int i);
extern CUDD_VALUE_TYPE Cudd_ReadEpsilon(DdManager *dd);
extern void Cudd_SetEpsilon(DdManager *dd, CUDD_VALUE_TYPE ep);
extern Cudd_AggregationType Cudd_ReadGroupcheck(DdManager *dd);
extern void Cudd_SetGroupcheck(DdManager *dd, Cudd_AggregationType gc);
extern int Cudd_GarbageCollectionEnabled(DdManager *dd);
extern void Cudd_EnableGarbageCollection(DdManager *dd);
extern void Cudd_DisableGarbageCollection(DdManager *dd);
extern int Cudd_DeadAreCounted(DdManager *dd);
extern void Cudd_TurnOnCountDead(DdManager *dd);
extern void Cudd_TurnOffCountDead(DdManager *dd);
extern int Cudd_ReadRecomb(DdManager *dd);
extern void Cudd_SetRecomb(DdManager *dd, int recomb);
extern int Cudd_ReadSymmviolation(DdManager *dd);
extern void Cudd_SetSymmviolation(DdManager *dd, int symmviolation);
extern int Cudd_ReadArcviolation(DdManager *dd);
extern void Cudd_SetArcviolation(DdManager *dd, int arcviolation);
extern int Cudd_ReadPopulationSize(DdManager *dd);
extern void Cudd_SetPopulationSize(DdManager *dd, int populationSize);
extern int Cudd_ReadNumberXovers(DdManager *dd);
extern void Cudd_SetNumberXovers(DdManager *dd, int numberXovers);
extern unsigned int Cudd_ReadOrderRandomization(DdManager * dd);
extern void Cudd_SetOrderRandomization(DdManager * dd, unsigned int factor);
extern size_t Cudd_ReadMemoryInUse(DdManager *dd);
extern int Cudd_PrintInfo(DdManager *dd, FILE *fp);
extern long Cudd_ReadPeakNodeCount(DdManager *dd);
extern int Cudd_ReadPeakLiveNodeCount(DdManager * dd);
extern long Cudd_ReadNodeCount(DdManager *dd);
extern long Cudd_zddReadNodeCount(DdManager *dd);
extern int Cudd_AddHook(DdManager *dd, DD_HFP f, Cudd_HookType where);
extern int Cudd_RemoveHook(DdManager *dd, DD_HFP f, Cudd_HookType where);
extern int Cudd_IsInHook(DdManager * dd, DD_HFP f, Cudd_HookType where);
extern int Cudd_StdPreReordHook(DdManager *dd, const char *str, void *data);
extern int Cudd_StdPostReordHook(DdManager *dd, const char *str, void *data);
extern int Cudd_EnableReorderingReporting(DdManager *dd);
extern int Cudd_DisableReorderingReporting(DdManager *dd);
extern int Cudd_ReorderingReporting(DdManager *dd);
extern int Cudd_PrintGroupedOrder(DdManager * dd, const char *str, void *data);
extern int Cudd_EnableOrderingMonitoring(DdManager *dd);
extern int Cudd_DisableOrderingMonitoring(DdManager *dd);
extern int Cudd_OrderingMonitoring(DdManager *dd);
extern void Cudd_SetApplicationHook(DdManager *dd, void * value);
extern void * Cudd_ReadApplicationHook(DdManager *dd);
extern Cudd_ErrorType Cudd_ReadErrorCode(DdManager *dd);
extern void Cudd_ClearErrorCode(DdManager *dd);
extern DD_OOMFP Cudd_InstallOutOfMemoryHandler(DD_OOMFP newHandler);
extern FILE * Cudd_ReadStdout(DdManager *dd);
extern void Cudd_SetStdout(DdManager *dd, FILE *fp);
extern FILE * Cudd_ReadStderr(DdManager *dd);
extern void Cudd_SetStderr(DdManager *dd, FILE *fp);
extern unsigned int Cudd_ReadNextReordering(DdManager *dd);
extern void Cudd_SetNextReordering(DdManager *dd, unsigned int next);
extern double Cudd_ReadSwapSteps(DdManager *dd);
extern unsigned int Cudd_ReadMaxLive(DdManager *dd);
extern void Cudd_SetMaxLive(DdManager *dd, unsigned int maxLive);
extern size_t Cudd_ReadMaxMemory(DdManager *dd);
extern size_t Cudd_SetMaxMemory(DdManager *dd, size_t maxMemory);
extern int Cudd_bddBindVar(DdManager *dd, int index);
extern int Cudd_bddUnbindVar(DdManager *dd, int index);
extern int Cudd_bddVarIsBound(DdManager *dd, int index);
extern DdNode * Cudd_addExistAbstract(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * Cudd_addUnivAbstract(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * Cudd_addOrAbstract(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * Cudd_addApply(DdManager *dd, DD_AOP op, DdNode *f, DdNode *g);
extern DdNode * Cudd_addPlus(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addTimes(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addThreshold(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addSetNZ(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addDivide(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addMinus(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addMinimum(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addMaximum(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addOneZeroMaximum(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addDiff(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addAgreement(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addOr(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addNand(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addNor(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addXor(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addXnor(DdManager *dd, DdNode **f, DdNode **g);
extern DdNode * Cudd_addMonadicApply(DdManager * dd, DD_MAOP op, DdNode * f);
extern DdNode * Cudd_addLog(DdManager * dd, DdNode * f);
extern DdNode * Cudd_addFindMax(DdManager *dd, DdNode *f);
extern DdNode * Cudd_addFindMin(DdManager *dd, DdNode *f);
extern DdNode * Cudd_addIthBit(DdManager *dd, DdNode *f, int bit);
extern DdNode * Cudd_addScalarInverse(DdManager *dd, DdNode *f, DdNode *epsilon);
extern DdNode * Cudd_addIte(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * Cudd_addIteConstant(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * Cudd_addEvalConst(DdManager *dd, DdNode *f, DdNode *g);
extern int Cudd_addLeq(DdManager * dd, DdNode * f, DdNode * g);
extern DdNode * Cudd_addCmpl(DdManager *dd, DdNode *f);
extern DdNode * Cudd_addNegate(DdManager *dd, DdNode *f);
extern DdNode * Cudd_addRoundOff(DdManager *dd, DdNode *f, int N);
extern DdNode * Cudd_addWalsh(DdManager *dd, DdNode **x, DdNode **y, int n);
extern DdNode * Cudd_addResidue(DdManager *dd, int n, int m, int options, int top);
extern DdNode * Cudd_bddAndAbstract(DdManager *manager, DdNode *f, DdNode *g, DdNode *cube);
extern DdNode * Cudd_bddAndAbstractLimit(DdManager *manager, DdNode *f, DdNode *g, DdNode *cube, unsigned int limit);
extern int Cudd_ApaNumberOfDigits(int binaryDigits);
extern DdApaNumber Cudd_NewApaNumber(int digits);
extern void Cudd_FreeApaNumber(DdApaNumber number);
extern void Cudd_ApaCopy(int digits, DdConstApaNumber source, DdApaNumber dest);
extern DdApaDigit Cudd_ApaAdd(int digits, DdConstApaNumber a, DdConstApaNumber b, DdApaNumber sum);
extern DdApaDigit Cudd_ApaSubtract(int digits, DdConstApaNumber a, DdConstApaNumber b, DdApaNumber diff);
extern DdApaDigit Cudd_ApaShortDivision(int digits, DdConstApaNumber dividend, DdApaDigit divisor, DdApaNumber quotient);
extern unsigned int Cudd_ApaIntDivision(int  digits, DdConstApaNumber dividend, unsigned int  divisor, DdApaNumber  quotient);
extern void Cudd_ApaShiftRight(int digits, DdApaDigit in, DdConstApaNumber a, DdApaNumber b);
extern void Cudd_ApaSetToLiteral(int digits, DdApaNumber number, DdApaDigit literal);
extern void Cudd_ApaPowerOfTwo(int digits, DdApaNumber number, int power);
extern int Cudd_ApaCompare(int digitsFirst, DdConstApaNumber first, int digitsSecond, DdConstApaNumber second);
extern int Cudd_ApaCompareRatios(int digitsFirst, DdConstApaNumber firstNum, unsigned int firstDen, int digitsSecond, DdConstApaNumber secondNum, unsigned int secondDen);
extern int Cudd_ApaPrintHex(FILE *fp, int digits, DdConstApaNumber number);
extern int Cudd_ApaPrintDecimal(FILE *fp, int digits, DdConstApaNumber number);
extern char * Cudd_ApaStringDecimal(int digits, DdConstApaNumber number);
extern int Cudd_ApaPrintExponential(FILE * fp, int  digits, DdConstApaNumber number, int precision);
extern DdApaNumber Cudd_ApaCountMinterm(DdManager const *manager, DdNode *node, int nvars, int *digits);
extern int Cudd_ApaPrintMinterm(FILE *fp, DdManager const *dd, DdNode *node, int nvars);
extern int Cudd_ApaPrintMintermExp(FILE * fp, DdManager const * dd, DdNode *node, int  nvars, int precision);
extern int Cudd_ApaPrintDensity(FILE * fp, DdManager * dd, DdNode * node, int  nvars);
extern DdNode * Cudd_UnderApprox(DdManager *dd, DdNode *f, int numVars, int threshold, int safe, double quality);
extern DdNode * Cudd_OverApprox(DdManager *dd, DdNode *f, int numVars, int threshold, int safe, double quality);
extern DdNode * Cudd_RemapUnderApprox(DdManager *dd, DdNode *f, int numVars, int threshold, double quality);
extern DdNode * Cudd_RemapOverApprox(DdManager *dd, DdNode *f, int numVars, int threshold, double quality);
extern DdNode * Cudd_BiasedUnderApprox(DdManager *dd, DdNode *f, DdNode *b, int numVars, int threshold, double quality1, double quality0);
extern DdNode * Cudd_BiasedOverApprox(DdManager *dd, DdNode *f, DdNode *b, int numVars, int threshold, double quality1, double quality0);
extern DdNode * Cudd_bddExistAbstract(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * Cudd_bddExistAbstractLimit(DdManager * manager, DdNode * f, DdNode * cube, unsigned int limit);
extern DdNode * Cudd_bddXorExistAbstract(DdManager *manager, DdNode *f, DdNode *g, DdNode *cube);
extern DdNode * Cudd_bddUnivAbstract(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * Cudd_bddBooleanDiff(DdManager *manager, DdNode *f, int x);
extern int Cudd_bddVarIsDependent(DdManager *dd, DdNode *f, DdNode *var);
extern double Cudd_bddCorrelation(DdManager *manager, DdNode *f, DdNode *g);
extern double Cudd_bddCorrelationWeights(DdManager *manager, DdNode *f, DdNode *g, double *prob);
extern DdNode * Cudd_bddIte(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * Cudd_bddIteLimit(DdManager *dd, DdNode *f, DdNode *g, DdNode *h, unsigned int limit);
extern DdNode * Cudd_bddIteConstant(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * Cudd_bddIntersect(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_bddAnd(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_bddAndLimit(DdManager *dd, DdNode *f, DdNode *g, unsigned int limit);
extern DdNode * Cudd_bddOr(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_bddOrLimit(DdManager *dd, DdNode *f, DdNode *g, unsigned int limit);
extern DdNode * Cudd_bddNand(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_bddNor(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_bddXor(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_bddXnor(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_bddXnorLimit(DdManager *dd, DdNode *f, DdNode *g, unsigned int limit);
extern int Cudd_bddLeq(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_addBddThreshold(DdManager *dd, DdNode *f, CUDD_VALUE_TYPE value);
extern DdNode * Cudd_addBddStrictThreshold(DdManager *dd, DdNode *f, CUDD_VALUE_TYPE value);
extern DdNode * Cudd_addBddInterval(DdManager *dd, DdNode *f, CUDD_VALUE_TYPE lower, CUDD_VALUE_TYPE upper);
extern DdNode * Cudd_addBddIthBit(DdManager *dd, DdNode *f, int bit);
extern DdNode * Cudd_BddToAdd(DdManager *dd, DdNode *B);
extern DdNode * Cudd_addBddPattern(DdManager *dd, DdNode *f);
extern DdNode * Cudd_bddTransfer(DdManager *ddSource, DdManager *ddDestination, DdNode *f);
extern int Cudd_DebugCheck(DdManager *table);
extern int Cudd_CheckKeys(DdManager *table);
extern DdNode * Cudd_bddClippingAnd(DdManager *dd, DdNode *f, DdNode *g, int maxDepth, int direction);
extern DdNode * Cudd_bddClippingAndAbstract(DdManager *dd, DdNode *f, DdNode *g, DdNode *cube, int maxDepth, int direction);
extern DdNode * Cudd_Cofactor(DdManager *dd, DdNode *f, DdNode *g);
extern int Cudd_CheckCube(DdManager *dd, DdNode *g);
extern int Cudd_VarsAreSymmetric(DdManager * dd, DdNode * f, int index1, int index2);
extern DdNode * Cudd_bddCompose(DdManager *dd, DdNode *f, DdNode *g, int v);
extern DdNode * Cudd_addCompose(DdManager *dd, DdNode *f, DdNode *g, int v);
extern DdNode * Cudd_addPermute(DdManager *manager, DdNode *node, int *permut);
extern DdNode * Cudd_addSwapVariables(DdManager *dd, DdNode *f, DdNode **x, DdNode **y, int n);
extern DdNode * Cudd_bddPermute(DdManager *manager, DdNode *node, int *permut);
extern DdNode * Cudd_bddVarMap(DdManager *manager, DdNode *f);
extern int Cudd_SetVarMap(DdManager *manager, DdNode **x, DdNode **y, int n);
extern DdNode * Cudd_bddSwapVariables(DdManager *dd, DdNode *f, DdNode **x, DdNode **y, int n);
extern DdNode * Cudd_bddAdjPermuteX(DdManager *dd, DdNode *B, DdNode **x, int n);
extern DdNode * Cudd_addVectorCompose(DdManager *dd, DdNode *f, DdNode **vector);
extern DdNode * Cudd_addGeneralVectorCompose(DdManager *dd, DdNode *f, DdNode **vectorOn, DdNode **vectorOff);
extern DdNode * Cudd_addNonSimCompose(DdManager *dd, DdNode *f, DdNode **vector);
extern DdNode * Cudd_bddVectorCompose(DdManager *dd, DdNode *f, DdNode **vector);
extern int Cudd_bddApproxConjDecomp(DdManager *dd, DdNode *f, DdNode ***conjuncts);
extern int Cudd_bddApproxDisjDecomp(DdManager *dd, DdNode *f, DdNode ***disjuncts);
extern int Cudd_bddIterConjDecomp(DdManager *dd, DdNode *f, DdNode ***conjuncts);
extern int Cudd_bddIterDisjDecomp(DdManager *dd, DdNode *f, DdNode ***disjuncts);
extern int Cudd_bddGenConjDecomp(DdManager *dd, DdNode *f, DdNode ***conjuncts);
extern int Cudd_bddGenDisjDecomp(DdManager *dd, DdNode *f, DdNode ***disjuncts);
extern int Cudd_bddVarConjDecomp(DdManager *dd, DdNode * f, DdNode ***conjuncts);
extern int Cudd_bddVarDisjDecomp(DdManager *dd, DdNode * f, DdNode ***disjuncts);
extern DdNode * Cudd_FindEssential(DdManager *dd, DdNode *f);
extern int Cudd_bddIsVarEssential(DdManager *manager, DdNode *f, int id, int phase);
extern DdTlcInfo * Cudd_FindTwoLiteralClauses(DdManager * dd, DdNode * f);
extern int Cudd_PrintTwoLiteralClauses(DdManager * dd, DdNode * f, char **names, FILE *fp);
extern int Cudd_ReadIthClause(DdTlcInfo * tlc, int i, unsigned *var1, unsigned *var2, int *phase1, int *phase2);
extern void Cudd_tlcInfoFree(DdTlcInfo * t);
extern int Cudd_DumpBlif(DdManager *dd, int n, DdNode **f, char const * const *inames, char const * const *onames, char *mname, FILE *fp, int mv);
extern int Cudd_DumpBlifBody(DdManager *dd, int n, DdNode **f, char const * const *inames, char const * const *onames, FILE *fp, int mv);
extern int Cudd_DumpDot(DdManager *dd, int n, DdNode **f, char const * const *inames, char const * const *onames, FILE *fp);
extern int Cudd_DumpDaVinci(DdManager *dd, int n, DdNode **f, char const * const *inames, char const * const *onames, FILE *fp);
extern int Cudd_DumpDDcal(DdManager *dd, int n, DdNode **f, char const * const *inames, char const * const *onames, FILE *fp);
extern int Cudd_DumpFactoredForm(DdManager *dd, int n, DdNode **f, char const * const *inames, char const * const *onames, FILE *fp);
extern char * Cudd_FactoredFormString(DdManager *dd, DdNode *f, char const * const * inames);
extern DdNode * Cudd_bddConstrain(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * Cudd_bddRestrict(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * Cudd_bddNPAnd(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * Cudd_addConstrain(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode ** Cudd_bddConstrainDecomp(DdManager *dd, DdNode *f);
extern DdNode * Cudd_addRestrict(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode ** Cudd_bddCharToVect(DdManager *dd, DdNode *f);
extern DdNode * Cudd_bddLICompaction(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * Cudd_bddSqueeze(DdManager *dd, DdNode *l, DdNode *u);
extern DdNode * Cudd_bddInterpolate(DdManager * dd, DdNode * l, DdNode * u);
extern DdNode * Cudd_bddMinimize(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * Cudd_SubsetCompress(DdManager *dd, DdNode *f, int nvars, int threshold);
extern DdNode * Cudd_SupersetCompress(DdManager *dd, DdNode *f, int nvars, int threshold);
extern int Cudd_addHarwell(FILE *fp, DdManager *dd, DdNode **E, DdNode ***x, DdNode ***y, DdNode ***xn, DdNode ***yn_, int *nx, int *ny, int *m, int *n, int bx, int sx, int by, int sy, int pr);
extern DdManager * Cudd_Init(unsigned int numVars, unsigned int numVarsZ, unsigned int numSlots, unsigned int cacheSize, size_t maxMemory);
extern void Cudd_Quit(DdManager *unique);
extern int Cudd_PrintLinear(DdManager *table);
extern int Cudd_ReadLinear(DdManager *table, int x, int y);
extern DdNode * Cudd_bddLiteralSetIntersection(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_addMatrixMultiply(DdManager *dd, DdNode *A, DdNode *B, DdNode **z, int nz);
extern DdNode * Cudd_addTimesPlus(DdManager *dd, DdNode *A, DdNode *B, DdNode **z, int nz);
extern DdNode * Cudd_addTriangle(DdManager *dd, DdNode *f, DdNode *g, DdNode **z, int nz);
extern DdNode * Cudd_addOuterSum(DdManager *dd, DdNode *M, DdNode *r, DdNode *c);
extern DdNode * Cudd_PrioritySelect(DdManager *dd, DdNode *R, DdNode **x, DdNode **y, DdNode **z, DdNode *Pi, int n, DD_PRFP PiFunc);
extern DdNode * Cudd_Xgty(DdManager *dd, int N, DdNode **z, DdNode **x, DdNode **y);
extern DdNode * Cudd_Xeqy(DdManager *dd, int N, DdNode **x, DdNode **y);
extern DdNode * Cudd_addXeqy(DdManager *dd, int N, DdNode **x, DdNode **y);
extern DdNode * Cudd_Dxygtdxz(DdManager *dd, int N, DdNode **x, DdNode **y, DdNode **z);
extern DdNode * Cudd_Dxygtdyz(DdManager *dd, int N, DdNode **x, DdNode **y, DdNode **z);
extern DdNode * Cudd_Inequality(DdManager * dd, int  N, int c, DdNode ** x, DdNode ** y);
extern DdNode * Cudd_Disequality(DdManager * dd, int  N, int c, DdNode ** x, DdNode ** y);
extern DdNode * Cudd_bddInterval(DdManager * dd, int  N, DdNode ** x, unsigned int lowerB, unsigned int upperB);
extern DdNode * Cudd_CProjection(DdManager *dd, DdNode *R, DdNode *Y);
extern DdNode * Cudd_addHamming(DdManager *dd, DdNode **xVars, DdNode **yVars, int nVars);
extern int Cudd_MinHammingDist(DdManager *dd, DdNode *f, int *minterm, int upperBound);
extern DdNode * Cudd_bddClosestCube(DdManager *dd, DdNode * f, DdNode *g, int *distance);
extern int Cudd_addRead(FILE *fp, DdManager *dd, DdNode **E, DdNode ***x, DdNode ***y, DdNode ***xn, DdNode ***yn_, int *nx, int *ny, int *m, int *n, int bx, int sx, int by, int sy);
extern int Cudd_bddRead(FILE *fp, DdManager *dd, DdNode **E, DdNode ***x, DdNode ***y, int *nx, int *ny, int *m, int *n, int bx, int sx, int by, int sy);
extern void Cudd_Ref(DdNode *n);
extern void Cudd_RecursiveDeref(DdManager *table, DdNode *n);
extern void Cudd_IterDerefBdd(DdManager *table, DdNode *n);
extern void Cudd_DelayedDerefBdd(DdManager * table, DdNode * n);
extern void Cudd_RecursiveDerefZdd(DdManager *table, DdNode *n);
extern void Cudd_Deref(DdNode *node);
extern int Cudd_CheckZeroRef(DdManager *manager);
extern int Cudd_ReduceHeap(DdManager *table, Cudd_ReorderingType heuristic, int minsize);
extern int Cudd_ShuffleHeap(DdManager *table, int *permutation);
extern DdNode * Cudd_Eval(DdManager *dd, DdNode *f, int *inputs);
extern DdNode * Cudd_ShortestPath(DdManager *manager, DdNode *f, int *weight, int *support, int *length);
extern DdNode * Cudd_LargestCube(DdManager *manager, DdNode *f, int *length);
extern int Cudd_ShortestLength(DdManager *manager, DdNode *f, int *weight);
extern DdNode * Cudd_Decreasing(DdManager *dd, DdNode *f, int i);
extern DdNode * Cudd_Increasing(DdManager *dd, DdNode *f, int i);
extern int Cudd_EquivDC(DdManager *dd, DdNode *F, DdNode *G, DdNode *D);
extern int Cudd_bddLeqUnless(DdManager *dd, DdNode *f, DdNode *g, DdNode *D);
extern int Cudd_EqualSupNorm(DdManager *dd, DdNode *f, DdNode *g, CUDD_VALUE_TYPE tolerance, int pr);
extern DdNode * Cudd_bddMakePrime(DdManager *dd, DdNode *cube, DdNode *f);
extern DdNode * Cudd_bddMaximallyExpand(DdManager *dd, DdNode *lb, DdNode *ub, DdNode *f);
extern DdNode * Cudd_bddLargestPrimeUnate(DdManager *dd , DdNode *f, DdNode *phaseBdd);
extern double * Cudd_CofMinterm(DdManager *dd, DdNode *node);
extern DdNode * Cudd_SolveEqn(DdManager * bdd, DdNode *F, DdNode *Y, DdNode **G, int **yIndex, int n);
extern DdNode * Cudd_VerifySol(DdManager * bdd, DdNode *F, DdNode **G, int *yIndex, int n);
extern DdNode * Cudd_SplitSet(DdManager *manager, DdNode *S, DdNode **xVars, int n, double m);
extern DdNode * Cudd_SubsetHeavyBranch(DdManager *dd, DdNode *f, int numVars, int threshold);
extern DdNode * Cudd_SupersetHeavyBranch(DdManager *dd, DdNode *f, int numVars, int threshold);
extern DdNode * Cudd_SubsetShortPaths(DdManager *dd, DdNode *f, int numVars, int threshold, int hardlimit);
extern DdNode * Cudd_SupersetShortPaths(DdManager *dd, DdNode *f, int numVars, int threshold, int hardlimit);
extern void Cudd_SymmProfile(DdManager *table, int lower, int upper);
extern unsigned int Cudd_Prime(unsigned int p);
extern int Cudd_Reserve(DdManager *manager, int amount);
extern int Cudd_PrintMinterm(DdManager *manager, DdNode *node);
extern int Cudd_bddPrintCover(DdManager *dd, DdNode *l, DdNode *u);
extern int Cudd_PrintDebug(DdManager *dd, DdNode *f, int n, int pr);
extern int Cudd_PrintSummary(DdManager * dd, DdNode * f, int n, int mode);
extern int Cudd_DagSize(DdNode *node);
extern int Cudd_EstimateCofactor(DdManager *dd, DdNode * node, int i, int phase);
extern int Cudd_EstimateCofactorSimple(DdNode * node, int i);
extern int Cudd_SharingSize(DdNode **nodeArray, int n);
extern double Cudd_CountMinterm(DdManager *manager, DdNode *node, int nvars);
#ifdef EPD_H_
extern int Cudd_EpdCountMinterm(DdManager const *manager, DdNode *node, int nvars, EpDouble *epd);
#endif
extern long double Cudd_LdblCountMinterm(DdManager const *manager, DdNode *node, int nvars);
extern int Cudd_EpdPrintMinterm(DdManager const * dd, DdNode * node, int nvars);
extern double Cudd_CountPath(DdNode *node);
extern double Cudd_CountPathsToNonZero(DdNode *node);
extern int Cudd_SupportIndices(DdManager * dd, DdNode * f, int **indices);
extern DdNode * Cudd_Support(DdManager *dd, DdNode *f);
extern int * Cudd_SupportIndex(DdManager *dd, DdNode *f);
extern int Cudd_SupportSize(DdManager *dd, DdNode *f);
extern int Cudd_VectorSupportIndices(DdManager * dd, DdNode ** F, int n, int **indices);
extern DdNode * Cudd_VectorSupport(DdManager *dd, DdNode **F, int n);
extern int * Cudd_VectorSupportIndex(DdManager *dd, DdNode **F, int n);
extern int Cudd_VectorSupportSize(DdManager *dd, DdNode **F, int n);
extern int Cudd_ClassifySupport(DdManager *dd, DdNode *f, DdNode *g, DdNode **common, DdNode **onlyF, DdNode **onlyG);
extern int Cudd_CountLeaves(DdNode *node);
extern int Cudd_bddPickOneCube(DdManager *ddm, DdNode *node, char *string);
extern DdNode * Cudd_bddPickOneMinterm(DdManager *dd, DdNode *f, DdNode **vars, int n);
extern DdNode ** Cudd_bddPickArbitraryMinterms(DdManager *dd, DdNode *f, DdNode **vars, int n, int k);
extern DdNode * Cudd_SubsetWithMaskVars(DdManager *dd, DdNode *f, DdNode **vars, int nvars, DdNode **maskVars, int mvars);
extern DdGen * Cudd_FirstCube(DdManager *dd, DdNode *f, int **cube, CUDD_VALUE_TYPE *value);
extern int Cudd_NextCube(DdGen *gen, int **cube, CUDD_VALUE_TYPE *value);
extern DdGen * Cudd_FirstPrime(DdManager *dd, DdNode *l, DdNode *u, int **cube);
extern int Cudd_NextPrime(DdGen *gen, int **cube);
extern DdNode * Cudd_bddComputeCube(DdManager *dd, DdNode **vars, int *phase, int n);
extern DdNode * Cudd_addComputeCube(DdManager *dd, DdNode **vars, int *phase, int n);
extern DdNode * Cudd_CubeArrayToBdd(DdManager *dd, int *array);
extern int Cudd_BddToCubeArray(DdManager *dd, DdNode *cube, int *array);
extern DdGen * Cudd_FirstNode(DdManager *dd, DdNode *f, DdNode **node);
extern int Cudd_NextNode(DdGen *gen, DdNode **node);
extern int Cudd_GenFree(DdGen *gen);
extern int Cudd_IsGenEmpty(DdGen *gen);
extern DdNode * Cudd_IndicesToCube(DdManager *dd, int *array, int n);
extern void Cudd_PrintVersion(FILE *fp);
extern double Cudd_AverageDistance(DdManager *dd);
extern int32_t Cudd_Random(DdManager * dd);
extern void Cudd_Srandom(DdManager * dd, int32_t seed);
extern double Cudd_Density(DdManager *dd, DdNode *f, int nvars);
extern void Cudd_OutOfMem(size_t size);
extern void Cudd_OutOfMemSilent(size_t size);
extern int Cudd_zddCount(DdManager *zdd, DdNode *P);
extern double Cudd_zddCountDouble(DdManager *zdd, DdNode *P);
extern DdNode * Cudd_zddProduct(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_zddUnateProduct(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_zddWeakDiv(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_zddDivide(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_zddWeakDivF(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_zddDivideF(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * Cudd_zddComplement(DdManager *dd, DdNode *node);
extern DdNode * Cudd_zddIsop(DdManager *dd, DdNode *L, DdNode *U, DdNode **zdd_I);
extern DdNode * Cudd_bddIsop(DdManager *dd, DdNode *L, DdNode *U);
extern DdNode * Cudd_MakeBddFromZddCover(DdManager *dd, DdNode *node);
extern int Cudd_zddDagSize(DdNode *p_node);
extern double Cudd_zddCountMinterm(DdManager *zdd, DdNode *node, int path);
extern void Cudd_zddPrintSubtable(DdManager *table);
extern DdNode * Cudd_zddPortFromBdd(DdManager *dd, DdNode *B);
extern DdNode * Cudd_zddPortToBdd(DdManager *dd, DdNode *f);
extern int Cudd_zddReduceHeap(DdManager *table, Cudd_ReorderingType heuristic, int minsize);
extern int Cudd_zddShuffleHeap(DdManager *table, int *permutation);
extern DdNode * Cudd_zddIte(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * Cudd_zddUnion(DdManager *dd, DdNode *P, DdNode *Q);
extern DdNode * Cudd_zddIntersect(DdManager *dd, DdNode *P, DdNode *Q);
extern DdNode * Cudd_zddDiff(DdManager *dd, DdNode *P, DdNode *Q);
extern DdNode * Cudd_zddDiffConst(DdManager *zdd, DdNode *P, DdNode *Q);
extern DdNode * Cudd_zddSubset1(DdManager *dd, DdNode *P, int var);
extern DdNode * Cudd_zddSubset0(DdManager *dd, DdNode *P, int var);
extern DdNode * Cudd_zddChange(DdManager *dd, DdNode *P, int var);
extern void Cudd_zddSymmProfile(DdManager *table, int lower, int upper);
extern int Cudd_zddPrintMinterm(DdManager *zdd, DdNode *node);
extern int Cudd_zddPrintCover(DdManager *zdd, DdNode *node);
extern int Cudd_zddPrintDebug(DdManager *zdd, DdNode *f, int n, int pr);
extern DdGen * Cudd_zddFirstPath(DdManager *zdd, DdNode *f, int **path);
extern int Cudd_zddNextPath(DdGen *gen, int **path);
extern char * Cudd_zddCoverPathToString(DdManager *zdd, int *path, char *str);
extern DdNode * Cudd_zddSupport(DdManager * dd, DdNode * f);
extern int Cudd_zddDumpDot(DdManager *dd, int n, DdNode **f, char const * const *inames, char const * const *onames, FILE *fp);
extern int Cudd_bddSetPiVar(DdManager *dd, int index);
extern int Cudd_bddSetPsVar(DdManager *dd, int index);
extern int Cudd_bddSetNsVar(DdManager *dd, int index);
extern int Cudd_bddIsPiVar(DdManager *dd, int index);
extern int Cudd_bddIsPsVar(DdManager *dd, int index);
extern int Cudd_bddIsNsVar(DdManager *dd, int index);
extern int Cudd_bddSetPairIndex(DdManager *dd, int index, int pairIndex);
extern int Cudd_bddReadPairIndex(DdManager *dd, int index);
extern int Cudd_bddSetVarToBeGrouped(DdManager *dd, int index);
extern int Cudd_bddSetVarHardGroup(DdManager *dd, int index);
extern int Cudd_bddResetVarToBeGrouped(DdManager *dd, int index);
extern int Cudd_bddIsVarToBeGrouped(DdManager *dd, int index);
extern int Cudd_bddSetVarToBeUngrouped(DdManager *dd, int index);
extern int Cudd_bddIsVarToBeUngrouped(DdManager *dd, int index);
extern int Cudd_bddIsVarHardGroup(DdManager *dd, int index);
#ifdef MTR_H_
extern MtrNode * Cudd_ReadTree(DdManager *dd);
extern void Cudd_SetTree(DdManager *dd, MtrNode *tree);
extern void Cudd_FreeTree(DdManager *dd);
extern MtrNode * Cudd_ReadZddTree(DdManager *dd);
extern void Cudd_SetZddTree(DdManager *dd, MtrNode *tree);
extern void Cudd_FreeZddTree(DdManager *dd);
extern MtrNode * Cudd_MakeTreeNode(DdManager *dd, unsigned int low, unsigned int size, unsigned int type);
extern MtrNode * Cudd_MakeZddTreeNode(DdManager *dd, unsigned int low, unsigned int size, unsigned int type);
#endif

#ifdef __cplusplus
} /* end of extern "C" */
#endif

#endif /* CUDD_H_ */

cuddAPI.c
105019
/**
  @file

  @ingroup cudd

  @brief Application interface functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void fixVarTree (MtrNode *treenode, int *perm, int size);
static int addMultiplicityGroups (DdManager *dd, MtrNode *treenode, int multiplicity, char *vmask, char *lmask);

/** \endcond */



/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Returns a new %ADD variable.

  @details The new variable has an index equal to the largest previous
  index plus 1.  An %ADD variable differs from a %BDD variable because
  it points to the arithmetic zero, instead of having a complement
  pointer to 1.

  @return a pointer to the new variable if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddNewVar Cudd_addIthVar Cudd_addConst
  Cudd_addNewVarAtLevel

*/
DdNode *
Cudd_addNewVar(
  DdManager * dd)
{
    DdNode *res;

    if ((unsigned int) dd->size >= CUDD_MAXINDEX - 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }
    do {
	dd->reordered = 0;
	res = cuddUniqueInter(dd,dd->size,DD_ONE(dd),DD_ZERO(dd));
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_addNewVar */


/**
  @brief Returns a new %ADD variable at a specified level.

  @details The new variable has an index equal to the largest previous
  index plus 1 and is positioned at the specified level in the order.

  @return a pointer to the new variable if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addNewVar Cudd_addIthVar Cudd_bddNewVarAtLevel

*/
DdNode *
Cudd_addNewVarAtLevel(
  DdManager * dd,
  int  level)
{
    DdNode *res;

    if ((unsigned int) dd->size >= CUDD_MAXINDEX - 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }
    if (level >= dd->size) return(Cudd_addIthVar(dd,level));
    if (!cuddInsertSubtables(dd,1,level)) return(NULL);
    do {
	dd->reordered = 0;
	res = cuddUniqueInter(dd,dd->size - 1,DD_ONE(dd),DD_ZERO(dd));
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_addNewVarAtLevel */


/**
  @brief Returns a new %BDD variable.

  @details The new variable has an index equal to the largest previous
  index plus 1.

  @return a pointer to the new variable if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addNewVar Cudd_bddIthVar Cudd_bddNewVarAtLevel

*/
DdNode *
Cudd_bddNewVar(
  DdManager * dd)
{
    DdNode *res;

    if ((unsigned int) dd->size >= CUDD_MAXINDEX - 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }
    res = cuddUniqueInter(dd,dd->size,dd->one,Cudd_Not(dd->one));

    return(res);

} /* end of Cudd_bddNewVar */


/**
  @brief Returns a new %BDD variable at a specified level.

  @details The new variable has an index equal to the largest previous
  index plus 1 and is positioned at the specified level in the order.

  @return a pointer to the new variable if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddNewVar Cudd_bddIthVar Cudd_addNewVarAtLevel

*/
DdNode *
Cudd_bddNewVarAtLevel(
  DdManager * dd,
  int  level)
{
    DdNode *res;

    if ((unsigned int) dd->size >= CUDD_MAXINDEX - 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }
    if (level >= dd->size) return(Cudd_bddIthVar(dd,level));
    if (!cuddInsertSubtables(dd,1,level)) return(NULL);
    res = dd->vars[dd->size - 1];

    return(res);

} /* end of Cudd_bddNewVarAtLevel */


/**
  @brief Returns 1 if the given node is a %BDD variable; 0 otherwise.

  @sideeffect None

*/
int
Cudd_bddIsVar(
  DdManager * dd,
  DdNode * f)
{
    DdNode *one = DD_ONE(dd);
    return(f != 0 && cuddT(f) == one && cuddE(f) == Cudd_Not(one));

} /* end of Cudd_bddIsVar */


/**
  @brief Returns the %ADD variable with index i.

  @details Retrieves the %ADD variable with index i if it already
  exists, or creates a new %ADD variable.  An %ADD variable differs from
  a %BDD variable because it points to the arithmetic zero, instead of
  having a complement pointer to 1.

  @return a pointer to the variable if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addNewVar Cudd_bddIthVar Cudd_addConst
  Cudd_addNewVarAtLevel

*/
DdNode *
Cudd_addIthVar(
  DdManager * dd,
  int  i)
{
    DdNode *res;

    if ((unsigned int) i >= CUDD_MAXINDEX - 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }
    do {
	dd->reordered = 0;
	res = cuddUniqueInter(dd,i,DD_ONE(dd),DD_ZERO(dd));
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_addIthVar */


/**
  @brief Returns the %BDD variable with index i.

  @details Retrieves the %BDD variable with index i if it already
  exists, or creates a new %BDD variable.

  @return a pointer to the variable if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddNewVar Cudd_addIthVar Cudd_bddNewVarAtLevel
  Cudd_ReadVars

*/
DdNode *
Cudd_bddIthVar(
  DdManager * dd,
  int  i)
{
    DdNode *res;

    if ((unsigned int) i >= CUDD_MAXINDEX - 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }
    if (i < dd->size) {
	res = dd->vars[i];
    } else {
	res = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
    }

    return(res);

} /* end of Cudd_bddIthVar */


/**
  @brief Returns the %ZDD variable with index i.

  @details Retrieves the %ZDD variable with index i if it already
  exists, or creates a new %ZDD variable.

  @return a pointer to the variable if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddIthVar Cudd_addIthVar

*/
DdNode *
Cudd_zddIthVar(
  DdManager * dd,
  int  i)
{
    DdNode *res;
    DdNode *zvar;
    DdNode *lower;
    int j;

    if ((unsigned int) i >= CUDD_MAXINDEX - 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }
    /* The i-th variable function has the following structure:
    ** at the level corresponding to index i there is a node whose "then"
    ** child points to the universe, and whose "else" child points to zero.
    ** Above that level there are nodes with identical children.
    */

    /* First we build the node at the level of index i. */
    lower = (i < dd->sizeZ - 1) ? dd->univ[dd->permZ[i]+1] : DD_ONE(dd);
    do {
	dd->reordered = 0;
	zvar = cuddUniqueInterZdd(dd, i, lower, DD_ZERO(dd));
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    if (zvar == NULL)
	return(NULL);
    cuddRef(zvar);

    /* Now we add the "filler" nodes above the level of index i. */
    for (j = dd->permZ[i] - 1; j >= 0; j--) {
	do {
	    dd->reordered = 0;
	    res = cuddUniqueInterZdd(dd, dd->invpermZ[j], zvar, zvar);
	} while (dd->reordered == 1);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(dd,zvar);
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDerefZdd(dd,zvar);
	zvar = res;
    }
    cuddDeref(zvar);
    return(zvar);

} /* end of Cudd_zddIthVar */


/**
  @brief Creates one or more %ZDD variables for each %BDD variable.

  @details If some %ZDD variables already exist, only the missing
  variables are created.  Parameter multiplicity allows the caller to
  control how many variables are created for each %BDD variable in
  existence. For instance, if ZDDs are used to represent covers, two
  %ZDD variables are required for each %BDD variable.  The order of the
  %BDD variables is transferred to the %ZDD variables. If a variable
  group tree exists for the %BDD variables, a corresponding %ZDD
  variable group tree is created by expanding the %BDD variable
  tree. In any case, the %ZDD variables derived from the same %BDD
  variable are merged in a %ZDD variable group. If a %ZDD variable group
  tree exists, it is freed.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_bddNewVar Cudd_bddIthVar Cudd_bddNewVarAtLevel

*/
int
Cudd_zddVarsFromBddVars(
  DdManager * dd /**< %DD manager */,
  int multiplicity /**< how many %ZDD variables are created for each %BDD variable */)
{
    int res;
    int i, j;
    int allnew;
    int *permutation;

    if (multiplicity < 1) {
        dd->errorCode = CUDD_INVALID_ARG;
        return(0);
    }
    allnew = dd->sizeZ == 0;
    if (dd->size * multiplicity > dd->sizeZ) {
	res = cuddResizeTableZdd(dd,dd->size * multiplicity - 1);
	if (res == 0) return(0);
    }
    /* Impose the order of the BDD variables to the ZDD variables. */
    if (allnew) {
	for (i = 0; i < dd->size; i++) {
	    for (j = 0; j < multiplicity; j++) {
		dd->permZ[i * multiplicity + j] =
		    dd->perm[i] * multiplicity + j;
		dd->invpermZ[dd->permZ[i * multiplicity + j]] =
		    i * multiplicity + j;
	    }
	}
	for (i = 0; i < dd->sizeZ; i++) {
	    dd->univ[i]->index = dd->invpermZ[i];
	}
    } else {
	permutation = ALLOC(int,dd->sizeZ);
	if (permutation == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	for (i = 0; i < dd->size; i++) {
	    for (j = 0; j < multiplicity; j++) {
		permutation[i * multiplicity + j] =
		    dd->invperm[i] * multiplicity + j;
	    }
	}
	for (i = dd->size * multiplicity; i < dd->sizeZ; i++) {
	    permutation[i] = i;
	}
	res = Cudd_zddShuffleHeap(dd, permutation);
	FREE(permutation);
	if (res == 0) return(0);
    }
    /* Copy and expand the variable group tree if it exists. */
    if (dd->treeZ != NULL) {
	Cudd_FreeZddTree(dd);
    }
    if (dd->tree != NULL) {
	dd->treeZ = Mtr_CopyTree(dd->tree, multiplicity);
	if (dd->treeZ == NULL) return(0);
    } else if (multiplicity > 1) {
	dd->treeZ = Mtr_InitGroupTree(0, dd->sizeZ);
	if (dd->treeZ == NULL) return(0);
	dd->treeZ->index = dd->invpermZ[0];
    }
    /* Create groups for the ZDD variables derived from the same BDD variable.
    */
    if (multiplicity > 1) {
	char *vmask, *lmask;

	vmask = ALLOC(char, dd->size);
	if (vmask == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	lmask =  ALLOC(char, dd->size);
	if (lmask == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	for (i = 0; i < dd->size; i++) {
	    vmask[i] = lmask[i] = 0;
	}
	res = addMultiplicityGroups(dd,dd->treeZ,multiplicity,vmask,lmask);
	FREE(vmask);
	FREE(lmask);
	if (res == 0) return(0);
    }
    return(1);

} /* end of Cudd_zddVarsFromBddVars */


/**
  @brief Returns the maximum possible index for a variable.

  @sideeffect None
*/
unsigned int
Cudd_ReadMaxIndex(void)
{
    return(CUDD_MAXINDEX);

} /* end of Cudd_ReadMaxIndex */


/**
  @brief Returns the %ADD for constant c.

  @details Retrieves the %ADD for constant c if it already
  exists, or creates a new %ADD.

  @return a pointer to the %ADD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addNewVar Cudd_addIthVar

*/
DdNode *
Cudd_addConst(
  DdManager * dd,
  CUDD_VALUE_TYPE  c)
{
    return(cuddUniqueConst(dd,c));

} /* end of Cudd_addConst */


/**
  @brief Returns 1 if the node is a constant node.

  @details A constant node is not an internal node.  The pointer
  passed to Cudd_IsConstant may be either regular or complemented.

  @sideeffect none

*/
int Cudd_IsConstant(DdNode *node)
{
    return Cudd_Regular(node)->index == CUDD_CONST_INDEX;

} /* end of Cudd_IsConstant */


/**
  @brief Returns 1 if a %DD node is not constant.

  @details This function is useful to test the results of
  Cudd_bddIteConstant, Cudd_addIteConstant, Cudd_addEvalConst. These
  results may be a special value signifying non-constant. In the other
  cases Cudd_IsConstant can be used.

  @sideeffect None

  @see Cudd_IsConstant Cudd_bddIteConstant Cudd_addIteConstant
  Cudd_addEvalConst

*/
int
Cudd_IsNonConstant(
  DdNode *f)
{
    return(f == DD_NON_CONSTANT || !Cudd_IsConstantInt(f));

} /* end of Cudd_IsNonConstant */


/**
  @brief Returns the then child of an internal node.

  @details If <code>node</code> is a constant node, the result is
  unpredictable.

  @sideeffect none

  @see Cudd_E Cudd_V

*/
DdNode *
Cudd_T(DdNode *node)
{
    return Cudd_Regular(node)->type.kids.T;

} /* end of Cudd_T */


/**
  @brief Returns the else child of an internal node.

  @details If <code>node</code> is a constant node, the result is
  unpredictable.

  @sideeffect none

  @see Cudd_T Cudd_V

*/
DdNode *
Cudd_E(DdNode *node)
{
    return Cudd_Regular(node)->type.kids.E;

} /* end of Cudd_E */


/**
  @brief Returns the value of a constant node.

  @details If <code>node</code> is an internal node, the result is
  unpredictable.

  @sideeffect none

  @see Cudd_T Cudd_E

*/
CUDD_VALUE_TYPE
Cudd_V(DdNode *node)
{
    return Cudd_Regular(node)->type.value;

} /* end of Cudd_V */


/**
  @brief Returns the start time of the manager.

  @details This is initially set to the number of milliseconds since
  the program started, but may be reset by the application.

  @sideeffect None

  @see Cudd_SetStartTime Cudd_ResetStartTime Cudd_ReadTimeLimit

*/
unsigned long
Cudd_ReadStartTime(
  DdManager * unique)
{
    return unique->startTime;

} /* end of Cudd_ReadStartTime */


/**
  @brief Returns the time elapsed since the start time of the manager.

  @details The time is expressed in milliseconds.

  @sideeffect None

  @see Cudd_ReadStartTime Cudd_SetStartTime

*/
unsigned long
Cudd_ReadElapsedTime(
  DdManager * unique)
{
  return util_cpu_time() - unique->startTime;

} /* end of Cudd_ReadElapsedTime */


/**
  @brief Sets the start time of the manager.

  @details The time must be expressed in milliseconds.

  @sideeffect None

  @see Cudd_ReadStartTime Cudd_ResetStartTime Cudd_ReadElapsedTime
  Cudd_SetTimeLimit

*/
void
Cudd_SetStartTime(
  DdManager * unique,
  unsigned long st)
{
    unique->startTime = st;

} /* end of Cudd_SetStartTime */


/**
  @brief Resets the start time of the manager.

  @sideeffect None

  @see Cudd_ReadStartTime Cudd_SetStartTime Cudd_SetTimeLimit

*/
void
Cudd_ResetStartTime(
  DdManager * unique)
{
    unique->startTime = util_cpu_time();

} /* end of Cudd_ResetStartTime */


/**
  @brief Returns the time limit for the manager.

  @details This is initially set to a very large number, but may be
  reset by the application.  The time is expressed in milliseconds.

  @sideeffect None

  @see Cudd_SetTimeLimit Cudd_UpdateTimeLimit Cudd_UnsetTimeLimit
  Cudd_IncreaseTimeLimit Cudd_TimeLimited Cudd_ReadStartTime

*/
unsigned long
Cudd_ReadTimeLimit(
  DdManager * unique)
{
    return unique->timeLimit;

} /* end of Cudd_ReadTimeLimit */


/**
  @brief Sets the time limit for the manager.

  @details The time must be expressed in milliseconds.

  @return the old time limit.

  @sideeffect None

  @see Cudd_ReadTimeLimit Cudd_UnsetTimeLimit Cudd_UpdateTimeLimit
  Cudd_IncreaseTimeLimit Cudd_TimeLimited Cudd_SetStartTime

*/
unsigned long
Cudd_SetTimeLimit(
  DdManager * unique,
  unsigned long tl)
{
    unsigned long ret = unique->timeLimit;
    unique->timeLimit = tl;
    return(ret);

} /* end of Cudd_SetTimeLimit */


/**
  @brief Updates the time limit for the manager.

  @details Updates the time limit for the manager by subtracting the
  elapsed time from it.

  @sideeffect None

  @see Cudd_ReadTimeLimit Cudd_SetTimeLimit Cudd_UnsetTimeLimit
  Cudd_IncreaseTimeLimit Cudd_TimeLimited Cudd_SetStartTime

*/
void
Cudd_UpdateTimeLimit(
  DdManager * unique)
{
    unsigned long elapsed;
    if (unique->timeLimit == ~0UL)
        return;
    elapsed = util_cpu_time() - unique->startTime;
    if (unique->timeLimit >= elapsed) {
        unique->timeLimit -= elapsed;
    } else {
        unique->timeLimit = 0;
    }

} /* end of Cudd_UpdateTimeLimit */


/**
  @brief Increases the time limit for the manager.

  @details The time increase must be expressed in milliseconds.

  @sideeffect None

  @see Cudd_ReadTimeLimit Cudd_SetTimeLimit Cudd_UnsetTimeLimit
  Cudd_UpdateTimeLimit Cudd_TimeLimited Cudd_SetStartTime

*/
void
Cudd_IncreaseTimeLimit(
  DdManager * unique,
  unsigned long increase)
{
    if (unique->timeLimit == ~0UL)
        unique->timeLimit = increase;
    else
        unique->timeLimit += increase;

} /* end of Cudd_IncreaseTimeLimit */


/**
  @brief Unsets the time limit for the manager.

  @details Actually, sets it to a very large value.

  @sideeffect None

  @see Cudd_ReadTimeLimit Cudd_SetTimeLimit Cudd_UpdateTimeLimit
  Cudd_IncreaseTimeLimit Cudd_TimeLimited Cudd_SetStartTime

*/
void
Cudd_UnsetTimeLimit(
  DdManager * unique)
{
    unique->timeLimit = ~0UL;

} /* end of Cudd_UnsetTimeLimit */


/**
  @brief Returns true if the time limit for the manager is set.

  @sideeffect None

  @see Cudd_ReadTimeLimit Cudd_SetTimeLimit Cudd_UpdateTimeLimit
  Cudd_UnsetTimeLimit Cudd_IncreaseTimeLimit

*/
int
Cudd_TimeLimited(
  DdManager * unique)
{
    return unique->timeLimit != ~0UL;

} /* end of Cudd_TimeLimited */


/**
  @brief Installs a termination callback.

  @details Registers a callback function that is called from time
  to time to decide whether computation should be abandoned.

  @sideeffect None

  @see Cudd_UnregisterTerminationCallback

*/
void
Cudd_RegisterTerminationCallback(
  DdManager *unique,
  DD_THFP callback,
  void * callback_arg)
{
    unique->terminationCallback = callback;
    unique->tcbArg = callback_arg;

} /* end of Cudd_RegisterTerminationCallback */


/**
  @brief Unregisters a termination callback.

  @sideeffect None

  @see Cudd_RegisterTerminationCallback

*/
void
Cudd_UnregisterTerminationCallback(
  DdManager *unique)
{
    unique->terminationCallback = NULL;
    unique->tcbArg = NULL;

}  /* end of Cudd_UnregisterTerminationCallback */


/**
  @brief Installs an out-of-memory callback.

  @details Registers a callback function that is called when
  a discretionary memory allocation fails.

  @return the old callback function.

  @sideeffect None

  @see Cudd_UnregisterOutOfMemoryCallback Cudd_OutOfMem Cudd_OutOfMemSilent

*/
DD_OOMFP
Cudd_RegisterOutOfMemoryCallback(
  DdManager *unique,
  DD_OOMFP callback)
{
  DD_OOMFP ret = unique->outOfMemCallback;
  unique->outOfMemCallback = callback;
  return(ret);

} /* end of Cudd_RegisterOutOfMemoryCallback */


/**
  @brief Unregister an out-of-memory callback.

  @sideeffect None

  @see Cudd_RegisterOutOfMemoryCallback Cudd_OutOfMem Cudd_OutOfMemSilent

*/
void
Cudd_UnregisterOutOfMemoryCallback(
  DdManager *unique)
{
  unique->outOfMemCallback = Cudd_OutOfMemSilent;

} /* end of Cudd_UnregisterOutOfMemoryCallback */


/**
  @brief Register a timeout handler function.

  @details To unregister a handler, register a NULL pointer.

  @sideeffect None

  @see Cudd_ReadTimeoutHandler
*/
void
Cudd_RegisterTimeoutHandler(
  DdManager *unique,
  DD_TOHFP handler,
  void *arg)
{
    unique->timeoutHandler = handler;
    unique->tohArg = arg;

} /* end of Cudd_RegisterTimeoutHandler */


/**
  @brief Read the current timeout handler function.

  @sideeffect If argp is non-null, the second argument to
  the handler is written to the location it points to.

  @see Cudd_RegisterTimeoutHandler
*/
DD_TOHFP
Cudd_ReadTimeoutHandler(
  DdManager *unique,
  void **argp)
{
    if (argp != NULL)
        *argp = unique->tohArg;
    return unique->timeoutHandler;

} /* end of Cudd_ReadTimeoutHandler */


/**
  @brief Enables automatic dynamic reordering of BDDs and ADDs.

  @details Parameter method is used to determine the method used for
  reordering. If CUDD_REORDER_SAME is passed, the method is unchanged.

  @sideeffect None

  @see Cudd_AutodynDisable Cudd_ReorderingStatus
  Cudd_AutodynEnableZdd

*/
void
Cudd_AutodynEnable(
  DdManager * unique,
  Cudd_ReorderingType  method)
{
    unique->autoDyn = 1;
    if (method != CUDD_REORDER_SAME) {
	unique->autoMethod = method;
    }
#ifndef DD_NO_DEATH_ROW
    /* If reordering is enabled, using the death row causes too many
    ** invocations. Hence, we shrink the death row to just one entry.
    */
    cuddClearDeathRow(unique);
    unique->deathRowDepth = 1;
    unique->deadMask = unique->deathRowDepth - 1;
    if ((unsigned) unique->nextDead > unique->deadMask) {
	unique->nextDead = 0;
    }
    unique->deathRow = REALLOC(DdNodePtr, unique->deathRow,
	unique->deathRowDepth);
#endif
    return;

} /* end of Cudd_AutodynEnable */


/**
  @brief Disables automatic dynamic reordering.

  @sideeffect None

  @see Cudd_AutodynEnable Cudd_ReorderingStatus
  Cudd_AutodynDisableZdd

*/
void
Cudd_AutodynDisable(
  DdManager * unique)
{
    unique->autoDyn = 0;
    return;

} /* end of Cudd_AutodynDisable */


/**
  @brief Reports the status of automatic dynamic reordering of BDDs
  and ADDs.

  @details The location pointed by parameter method is set to
  the reordering method currently selected if method is non-null.

  @return 1 if automatic reordering is enabled; 0 otherwise.

  @sideeffect The location pointed by parameter method is set to the
  reordering method currently selected if method is non-null.

  @see Cudd_AutodynEnable Cudd_AutodynDisable
  Cudd_ReorderingStatusZdd

*/
int
Cudd_ReorderingStatus(
  DdManager * unique,
  Cudd_ReorderingType * method)
{
    if (method)
	*method = unique->autoMethod;
    return(unique->autoDyn);

} /* end of Cudd_ReorderingStatus */


/**
  @brief Enables automatic dynamic reordering of ZDDs.

  @details Parameter method is used to determine the method used for
  reordering ZDDs.  If CUDD_REORDER_SAME is passed, the method is
  unchanged.

  @sideeffect None

  @see Cudd_AutodynDisableZdd Cudd_ReorderingStatusZdd
  Cudd_AutodynEnable

*/
void
Cudd_AutodynEnableZdd(
  DdManager * unique,
  Cudd_ReorderingType method)
{
    unique->autoDynZ = 1;
    if (method != CUDD_REORDER_SAME) {
	unique->autoMethodZ = method;
    }
    return;

} /* end of Cudd_AutodynEnableZdd */


/**
  @brief Disables automatic dynamic reordering of ZDDs.

  @sideeffect None

  @see Cudd_AutodynEnableZdd Cudd_ReorderingStatusZdd
  Cudd_AutodynDisable

*/
void
Cudd_AutodynDisableZdd(
  DdManager * unique)
{
    unique->autoDynZ = 0;
    return;

} /* end of Cudd_AutodynDisableZdd */


/**
  @brief Reports the status of automatic dynamic reordering of ZDDs.

  @details Parameter method is set to the %ZDD reordering method currently
  selected.

  @return 1 if automatic reordering is enabled; 0 otherwise.

  @sideeffect Parameter method is set to the %ZDD reordering method currently
  selected.

  @see Cudd_AutodynEnableZdd Cudd_AutodynDisableZdd
  Cudd_ReorderingStatus

*/
int
Cudd_ReorderingStatusZdd(
  DdManager * unique,
  Cudd_ReorderingType * method)
{
    *method = unique->autoMethodZ;
    return(unique->autoDynZ);

} /* end of Cudd_ReorderingStatusZdd */


/**
  @brief Tells whether the realignment of %ZDD order to %BDD order is
  enabled.

  @return 1 if the realignment of %ZDD order to %BDD order is enabled; 0
  otherwise.

  @sideeffect None

  @see Cudd_zddRealignEnable Cudd_zddRealignDisable
  Cudd_bddRealignEnable Cudd_bddRealignDisable

*/
int
Cudd_zddRealignmentEnabled(
  DdManager * unique)
{
    return(unique->realign);

} /* end of Cudd_zddRealignmentEnabled */


/**
  @brief Enables realignment of %ZDD order to %BDD order.

  @details Enables realignment of the %ZDD variable order to the
  %BDD variable order after the BDDs and ADDs have been reordered.  The
  number of %ZDD variables must be a multiple of the number of %BDD
  variables for realignment to make sense. If this condition is not met,
  Cudd_ReduceHeap will return 0. Let <code>M</code> be the
  ratio of the two numbers. For the purpose of realignment, the %ZDD
  variables from <code>M*i</code> to <code>(M+1)*i-1</code> are
  reagarded as corresponding to %BDD variable <code>i</code>. Realignment
  is initially disabled.

  @sideeffect None

  @see Cudd_ReduceHeap Cudd_zddRealignDisable
  Cudd_zddRealignmentEnabled Cudd_bddRealignDisable
  Cudd_bddRealignmentEnabled

*/
void
Cudd_zddRealignEnable(
  DdManager * unique)
{
    unique->realign = 1;
    return;

} /* end of Cudd_zddRealignEnable */


/**
  @brief Disables realignment of %ZDD order to %BDD order.

  @sideeffect None

  @see Cudd_zddRealignEnable Cudd_zddRealignmentEnabled
  Cudd_bddRealignEnable Cudd_bddRealignmentEnabled

*/
void
Cudd_zddRealignDisable(
  DdManager * unique)
{
    unique->realign = 0;
    return;

} /* end of Cudd_zddRealignDisable */


/**
  @brief Tells whether the realignment of %BDD order to %ZDD order is
  enabled.

  @return 1 if the realignment of %BDD order to %ZDD order is enabled; 0
  otherwise.

  @sideeffect None

  @see Cudd_bddRealignEnable Cudd_bddRealignDisable
  Cudd_zddRealignEnable Cudd_zddRealignDisable

*/
int
Cudd_bddRealignmentEnabled(
  DdManager * unique)
{
    return(unique->realignZ);

} /* end of Cudd_bddRealignmentEnabled */


/**
  @brief Enables realignment of %BDD order to %ZDD order.

  @details Enables realignment of the %BDD variable order to the
  %ZDD variable order after the ZDDs have been reordered.  The
  number of %ZDD variables must be a multiple of the number of %BDD
  variables for realignment to make sense. If this condition is not met,
  Cudd_zddReduceHeap will return 0. Let <code>M</code> be the
  ratio of the two numbers. For the purpose of realignment, the %ZDD
  variables from <code>M*i</code> to <code>(M+1)*i-1</code> are
  reagarded as corresponding to %BDD variable <code>i</code>. Realignment
  is initially disabled.

  @sideeffect None

  @see Cudd_zddReduceHeap Cudd_bddRealignDisable
  Cudd_bddRealignmentEnabled Cudd_zddRealignDisable
  Cudd_zddRealignmentEnabled

*/
void
Cudd_bddRealignEnable(
  DdManager * unique)
{
    unique->realignZ = 1;
    return;

} /* end of Cudd_bddRealignEnable */


/**
  @brief Disables realignment of %ZDD order to %BDD order.

  @sideeffect None

  @see Cudd_bddRealignEnable Cudd_bddRealignmentEnabled
  Cudd_zddRealignEnable Cudd_zddRealignmentEnabled

*/
void
Cudd_bddRealignDisable(
  DdManager * unique)
{
    unique->realignZ = 0;
    return;

} /* end of Cudd_bddRealignDisable */


/**
  @brief Returns the one constant of the manager.

  @details The one constant is common to ADDs and BDDs.

  @sideeffect None

  @see Cudd_ReadZero Cudd_ReadLogicZero Cudd_ReadZddOne

*/
DdNode *
Cudd_ReadOne(
  DdManager * dd)
{
    return(dd->one);

} /* end of Cudd_ReadOne */


/**
  @brief Returns the %ZDD for the constant 1 function.

  @details The representation of the constant 1 function as a %ZDD
  depends on how many variables it (nominally) depends on. The index
  of the topmost variable in the support is given as argument
  <code>i</code>.

  @sideeffect None

  @see Cudd_ReadOne

*/
DdNode *
Cudd_ReadZddOne(
  DdManager * dd,
  int  i)
{
    if (i < 0)
	return(NULL);
    return(i < dd->sizeZ ? dd->univ[i] : DD_ONE(dd));

} /* end of Cudd_ReadZddOne */



/**
  @brief Returns the zero constant of the manager.

  @details The zero constant is the arithmetic zero, rather than the
  logic zero. The latter is the complement of the one constant.

  @sideeffect None

  @see Cudd_ReadOne Cudd_ReadLogicZero

*/
DdNode *
Cudd_ReadZero(
  DdManager * dd)
{
    return(DD_ZERO(dd));

} /* end of Cudd_ReadZero */


/**
  @brief Returns the logic zero constant of the manager.

  @details The logic zero constant is the complement of the one
  constant, and is distinct from the arithmetic zero.

  @sideeffect None

  @see Cudd_ReadOne Cudd_ReadZero

*/
DdNode *
Cudd_ReadLogicZero(
  DdManager * dd)
{
    return(Cudd_Not(DD_ONE(dd)));

} /* end of Cudd_ReadLogicZero */


/**
  @brief Reads the plus-infinity constant from the manager.

  @sideeffect None

*/
DdNode *
Cudd_ReadPlusInfinity(
  DdManager * dd)
{
    return(dd->plusinfinity);

} /* end of Cudd_ReadPlusInfinity */


/**
  @brief Reads the minus-infinity constant from the manager.

  @sideeffect None

*/
DdNode *
Cudd_ReadMinusInfinity(
  DdManager * dd)
{
    return(dd->minusinfinity);

} /* end of Cudd_ReadMinusInfinity */


/**
  @brief Reads the background constant of the manager.

  @sideeffect None

*/
DdNode *
Cudd_ReadBackground(
  DdManager * dd)
{
    return(dd->background);

} /* end of Cudd_ReadBackground */


/**
  @brief Sets the background constant of the manager.

  @details It assumes that the DdNode pointer bck is already
  referenced.

  @sideeffect None

*/
void
Cudd_SetBackground(
  DdManager * dd,
  DdNode * bck)
{
    dd->background = bck;

} /* end of Cudd_SetBackground */


/**
  @brief Reads the number of slots in the cache.

  @sideeffect None

  @see Cudd_ReadCacheUsedSlots

*/
unsigned int
Cudd_ReadCacheSlots(
  DdManager * dd)
{
    return(dd->cacheSlots);

} /* end of Cudd_ReadCacheSlots */


/**
  @brief Reads the fraction of used slots in the cache.

  @details The unused slots are those in which no valid data is
  stored. Garbage collection, variable reordering, and cache resizing
  may cause used slots to become unused.

  @sideeffect None

  @see Cudd_ReadCacheSlots

*/
double
Cudd_ReadCacheUsedSlots(
  DdManager * dd)
{
    size_t used = 0;
    int slots = dd->cacheSlots;
    DdCache *cache = dd->cache;
    int i;

    for (i = 0; i < slots; i++) {
	used += cache[i].h != 0;
    }

    return((double)used / (double) dd->cacheSlots);

} /* end of Cudd_ReadCacheUsedSlots */


/**
  @brief Returns the number of cache look-ups.

  @sideeffect None

  @see Cudd_ReadCacheHits

*/
double
Cudd_ReadCacheLookUps(
  DdManager * dd)
{
    return(dd->cacheHits + dd->cacheMisses +
	   dd->totCachehits + dd->totCacheMisses);

} /* end of Cudd_ReadCacheLookUps */


/**
  @brief Returns the number of cache hits.

  @sideeffect None

  @see Cudd_ReadCacheLookUps

*/
double
Cudd_ReadCacheHits(
  DdManager * dd)
{
    return(dd->cacheHits + dd->totCachehits);

} /* end of Cudd_ReadCacheHits */


/**
  @brief Returns the number of recursive calls.

  @details Returns the number of recursive calls if the package is
  compiled with DD_COUNT defined.

  @sideeffect None

*/
double
Cudd_ReadRecursiveCalls(
  DdManager * dd)
{
#ifdef DD_COUNT
    return(dd->recursiveCalls);
#else
    (void) dd; /* avoid warning */
    return(-1.0);
#endif

} /* end of Cudd_ReadRecursiveCalls */



/**
  @brief Reads the hit rate that causes resizinig of the computed
  table.

  @sideeffect None

  @see Cudd_SetMinHit

*/
unsigned int
Cudd_ReadMinHit(
  DdManager * dd)
{
    /* Internally, the package manipulates the ratio of hits to
    ** misses instead of the ratio of hits to accesses. */
    return((unsigned int) (0.5 + 100 * dd->minHit / (1 + dd->minHit)));

} /* end of Cudd_ReadMinHit */


/**
  @brief Sets the hit rate that causes resizinig of the computed
  table.

  @details Sets the minHit parameter of the manager. This
  parameter controls the resizing of the computed table. If the hit
  rate is larger than the specified value, and the cache is not
  already too large, then its size is doubled.

  @sideeffect None

  @see Cudd_ReadMinHit

*/
void
Cudd_SetMinHit(
  DdManager * dd,
  unsigned int hr)
{
    /* Internally, the package manipulates the ratio of hits to
    ** misses instead of the ratio of hits to accesses. */
    dd->minHit = (double) hr / (100.0 - (double) hr);

} /* end of Cudd_SetMinHit */


/**
  @brief Reads the looseUpTo parameter of the manager.

  @sideeffect None

  @see Cudd_SetLooseUpTo Cudd_ReadMinHit Cudd_ReadMinDead

*/
unsigned int
Cudd_ReadLooseUpTo(
  DdManager * dd)
{
    return(dd->looseUpTo);

} /* end of Cudd_ReadLooseUpTo */


/**
  @brief Sets the looseUpTo parameter of the manager.

  @details This parameter of the manager controls the threshold beyond
  which no fast growth of the unique table is allowed. The threshold
  is given as a number of slots. If the value passed to this function
  is 0, the function determines a suitable value based on the
  available memory.

  @sideeffect None

  @see Cudd_ReadLooseUpTo Cudd_SetMinHit

*/
void
Cudd_SetLooseUpTo(
  DdManager * dd,
  unsigned int lut)
{
    if (lut == 0) {
	unsigned long datalimit = getSoftDataLimit();
	lut = (unsigned int) (datalimit / (sizeof(DdNode) *
					   DD_MAX_LOOSE_FRACTION));
    }
    dd->looseUpTo = lut;

} /* end of Cudd_SetLooseUpTo */


/**
  @brief Returns the soft limit for the cache size.

  @sideeffect None

  @see Cudd_ReadMaxCacheHard

*/
unsigned int
Cudd_ReadMaxCache(
  DdManager * dd)
{
    return(2 * dd->cacheSlots + dd->cacheSlack);

} /* end of Cudd_ReadMaxCache */


/**
  @brief Reads the maxCacheHard parameter of the manager.

  @sideeffect None

  @see Cudd_SetMaxCacheHard Cudd_ReadMaxCache

*/
unsigned int
Cudd_ReadMaxCacheHard(
  DdManager * dd)
{
    return(dd->maxCacheHard);

} /* end of Cudd_ReadMaxCache */


/**
  @brief Sets the maxCacheHard parameter of the manager.

  @details The cache cannot grow larger than maxCacheHard
  entries. This parameter allows an application to control the
  trade-off of memory versus speed. If the value passed to this
  function is 0, the function determines a suitable maximum cache size
  based on the available memory.

  @sideeffect None

  @see Cudd_ReadMaxCacheHard Cudd_SetMaxCache

*/
void
Cudd_SetMaxCacheHard(
  DdManager * dd,
  unsigned int mc)
{
    if (mc == 0) {
	unsigned long datalimit = getSoftDataLimit();
	mc = (unsigned int) (datalimit / (sizeof(DdCache) *
					  DD_MAX_CACHE_FRACTION));
    }
    dd->maxCacheHard = mc;

} /* end of Cudd_SetMaxCacheHard */


/**
  @brief Returns the number of %BDD variables in existance.

  @sideeffect None

  @see Cudd_ReadZddSize

*/
int
Cudd_ReadSize(
  DdManager * dd)
{
    return(dd->size);

} /* end of Cudd_ReadSize */


/**
  @brief Returns the number of %ZDD variables in existance.

  @sideeffect None

  @see Cudd_ReadSize

*/
int
Cudd_ReadZddSize(
  DdManager * dd)
{
    return(dd->sizeZ);

} /* end of Cudd_ReadZddSize */


/**
  @brief Returns the total number of slots of the unique table.

  @details This number is mainly for diagnostic purposes.

  @sideeffect None

*/
unsigned int
Cudd_ReadSlots(
  DdManager * dd)
{
    return(dd->slots);

} /* end of Cudd_ReadSlots */


/**
  @brief Reads the fraction of used slots in the unique table.

  @details The unused slots are those in which no valid data is
  stored. Garbage collection, variable reordering, and subtable
  resizing may cause used slots to become unused.

  @sideeffect None

  @see Cudd_ReadSlots

*/
double
Cudd_ReadUsedSlots(
  DdManager * dd)
{
    size_t used = 0;
    int i, j;
    int size = dd->size;
    DdNodePtr *nodelist;
    DdSubtable *subtable;
    DdNode *node;
    DdNode *sentinel = &(dd->sentinel);

    /* Scan each BDD/ADD subtable. */
    for (i = 0; i < size; i++) {
	subtable = &(dd->subtables[i]);
	nodelist = subtable->nodelist;
	for (j = 0; (unsigned) j < subtable->slots; j++) {
	    node = nodelist[j];
	    if (node != sentinel) {
		used++;
	    }
	}
    }

    /* Scan the ZDD subtables. */
    size = dd->sizeZ;

    for (i = 0; i < size; i++) {
	subtable = &(dd->subtableZ[i]);
	nodelist = subtable->nodelist;
	for (j = 0; (unsigned) j < subtable->slots; j++) {
	    node = nodelist[j];
	    if (node != NULL) {
		used++;
	    }
	}
    }

    /* Constant table. */
    subtable = &(dd->constants);
    nodelist = subtable->nodelist;
    for (j = 0; (unsigned) j < subtable->slots; j++) {
	node = nodelist[j];
	if (node != NULL) {
	    used++;
	}
    }

    return((double)used / (double) dd->slots);

} /* end of Cudd_ReadUsedSlots */


/**
  @brief Computes the expected fraction of used slots in the unique
  table.

  @details This expected value is based on the assumption that the
  hash function distributes the keys randomly; it can be compared with
  the result of Cudd_ReadUsedSlots to monitor the performance of the
  unique table hash function.

  @sideeffect None

  @see Cudd_ReadSlots Cudd_ReadUsedSlots

*/
double
Cudd_ExpectedUsedSlots(
  DdManager * dd)
{
    int i;
    int size = dd->size;
    DdSubtable *subtable;
    double empty = 0.0;

    /* To each subtable we apply the corollary to Theorem 8.5 (occupancy
    ** distribution) from Sedgewick and Flajolet's Analysis of Algorithms.
    ** The corollary says that for a table with M buckets and a load ratio
    ** of r, the expected number of empty buckets is asymptotically given
    ** by M * exp(-r).
    */

    /* Scan each BDD/ADD subtable. */
    for (i = 0; i < size; i++) {
	subtable = &(dd->subtables[i]);
	empty += (double) subtable->slots *
	    exp(-(double) subtable->keys / (double) subtable->slots);
    }

    /* Scan the ZDD subtables. */
    size = dd->sizeZ;

    for (i = 0; i < size; i++) {
	subtable = &(dd->subtableZ[i]);
	empty += (double) subtable->slots *
	    exp(-(double) subtable->keys / (double) subtable->slots);
    }

    /* Constant table. */
    subtable = &(dd->constants);
    empty += (double) subtable->slots *
	exp(-(double) subtable->keys / (double) subtable->slots);

    return(1.0 - empty / (double) dd->slots);

} /* end of Cudd_ExpectedUsedSlots */


/**
  @brief Returns the number of nodes in the unique table.

  @details Returns the total number of nodes currently in the unique
  table, including the dead nodes.

  @sideeffect None

  @see Cudd_ReadDead

*/
unsigned int
Cudd_ReadKeys(
  DdManager * dd)
{
    return(dd->keys);

} /* end of Cudd_ReadKeys */


/**
  @brief Returns the number of dead nodes in the unique table.

  @sideeffect None

  @see Cudd_ReadKeys

*/
unsigned int
Cudd_ReadDead(
  DdManager * dd)
{
    return(dd->dead);

} /* end of Cudd_ReadDead */


/**
  @brief Reads the minDead parameter of the manager.

  @details The minDead parameter is used by the package to decide
  whether to collect garbage or resize a subtable of the unique table
  when the subtable becomes too full. The application can indirectly
  control the value of minDead by setting the looseUpTo parameter.

  @sideeffect None

  @see Cudd_ReadDead Cudd_ReadLooseUpTo Cudd_SetLooseUpTo

*/
unsigned int
Cudd_ReadMinDead(
  DdManager * dd)
{
    return(dd->minDead);

} /* end of Cudd_ReadMinDead */


/**
  @brief Returns the number of times reordering has occurred.

  @details The number includes both the calls to Cudd_ReduceHeap from
  the application program and those automatically performed by the
  package. However, calls that do not even initiate reordering are not
  counted. A call may not initiate reordering if there are fewer than
  minsize live nodes in the manager, or if CUDD_REORDER_NONE is specified
  as reordering method. The calls to Cudd_ShuffleHeap are not counted.

  @sideeffect None

  @see Cudd_ReduceHeap Cudd_ReadReorderingTime

*/
unsigned int
Cudd_ReadReorderings(
  DdManager * dd)
{
    return(dd->reorderings);

} /* end of Cudd_ReadReorderings */


/**
  @brief Returns the maximum number of times reordering may be invoked.

  @sideeffect None

  @see Cudd_ReadReorderings Cudd_SetMaxReorderings Cudd_ReduceHeap

*/
unsigned int
Cudd_ReadMaxReorderings(
  DdManager * dd)
{
    return(dd->maxReorderings);

} /* end of Cudd_ReadMaxReorderings */


/**
  @brief Sets the maximum number of times reordering may be invoked.

  @details The default value is (practically) infinite.

  @sideeffect None

  @see Cudd_ReadReorderings Cudd_ReadMaxReorderings Cudd_ReduceHeap

*/
void
Cudd_SetMaxReorderings(
  DdManager * dd, unsigned int mr)
{
    dd->maxReorderings = mr;

} /* end of Cudd_SetMaxReorderings */


/**
  @brief Returns the time spent in reordering.

  @details Returns the number of milliseconds spent reordering
  variables since the manager was initialized. The time spent in collecting
  garbage before reordering is included.

  @sideeffect None

  @see Cudd_ReadReorderings

*/
long
Cudd_ReadReorderingTime(
  DdManager * dd)
{
    return(dd->reordTime);

} /* end of Cudd_ReadReorderingTime */


/**
  @brief Returns the number of times garbage collection has occurred.

  @details The number includes both the calls from reordering
  procedures and those caused by requests to create new nodes.

  @sideeffect None

  @see Cudd_ReadGarbageCollectionTime

*/
int
Cudd_ReadGarbageCollections(
  DdManager * dd)
{
    return(dd->garbageCollections);

} /* end of Cudd_ReadGarbageCollections */


/**
  @brief Returns the time spent in garbage collection.

  @details Returns the number of milliseconds spent doing garbage
  collection since the manager was initialized.

  @sideeffect None

  @see Cudd_ReadGarbageCollections

*/
long
Cudd_ReadGarbageCollectionTime(
  DdManager * dd)
{
    return(dd->GCTime);

} /* end of Cudd_ReadGarbageCollectionTime */


/**
  @brief Returns the number of nodes freed.

  @details Returns the number of nodes returned to the free list if the
  keeping of this statistic is enabled; -1 otherwise. This statistic is
  enabled only if the package is compiled with DD_STATS defined.

  @sideeffect None

  @see Cudd_ReadNodesDropped

*/
double
Cudd_ReadNodesFreed(
  DdManager * dd)
{
#ifdef DD_STATS
    return(dd->nodesFreed);
#else
    (void) dd; /* avoid warning */
    return(-1.0);
#endif

} /* end of Cudd_ReadNodesFreed */


/**
  @brief Returns the number of nodes dropped.

  @details Returns the number of nodes killed by dereferencing if the
  keeping of this statistic is enabled; -1 otherwise. This statistic is
  enabled only if the package is compiled with DD_STATS defined.

  @sideeffect None

  @see Cudd_ReadNodesFreed

*/
double
Cudd_ReadNodesDropped(
  DdManager * dd)
{
#ifdef DD_STATS
    return(dd->nodesDropped);
#else
    (void) dd; /* avoid warning */
    return(-1.0);
#endif

} /* end of Cudd_ReadNodesDropped */


/**
  @brief Returns the number of look-ups in the unique table.

  @details Returns the number of look-ups in the unique table if the
  keeping of this statistic is enabled; -1 otherwise. This statistic is
  enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.

  @sideeffect None

  @see Cudd_ReadUniqueLinks

*/
double
Cudd_ReadUniqueLookUps(
  DdManager * dd)
{
#ifdef DD_UNIQUE_PROFILE
    return(dd->uniqueLookUps);
#else
    (void) dd; /* avoid warning */
    return(-1.0);
#endif

} /* end of Cudd_ReadUniqueLookUps */


/**
  @brief Returns the number of links followed in the unique table.

  @details Returns the number of links followed during look-ups in the
  unique table if the keeping of this statistic is enabled; -1 otherwise.
  If an item is found in the first position of its collision list, the
  number of links followed is taken to be 0. If it is in second position,
  the number of links is 1, and so on. This statistic is enabled only if
  the package is compiled with DD_UNIQUE_PROFILE defined.

  @sideeffect None

  @see Cudd_ReadUniqueLookUps

*/
double
Cudd_ReadUniqueLinks(
  DdManager * dd)
{
#ifdef DD_UNIQUE_PROFILE
    return(dd->uniqueLinks);
#else
    (void) dd; /* avoid warning */
    return(-1.0);
#endif

} /* end of Cudd_ReadUniqueLinks */


/**
  @brief Reads the siftMaxVar parameter of the manager.

  @details This parameter gives the maximum number of variables that
  will be sifted for each invocation of sifting.

  @sideeffect None

  @see Cudd_ReadSiftMaxSwap Cudd_SetSiftMaxVar

*/
int
Cudd_ReadSiftMaxVar(
  DdManager * dd)
{
    return(dd->siftMaxVar);

} /* end of Cudd_ReadSiftMaxVar */


/**
  @brief Sets the siftMaxVar parameter of the manager.

  @details This parameter gives the maximum number of variables that
  will be sifted for each invocation of sifting.

  @sideeffect None

  @see Cudd_SetSiftMaxSwap Cudd_ReadSiftMaxVar

*/
void
Cudd_SetSiftMaxVar(
  DdManager * dd,
  int  smv)
{
    dd->siftMaxVar = smv;

} /* end of Cudd_SetSiftMaxVar */


/**
  @brief Reads the siftMaxSwap parameter of the manager.

  @details This parameter gives the maximum number of swaps that will
  be attempted for each invocation of sifting. The real number of
  swaps may exceed the set limit because the package will always
  complete the sifting of the variable that causes the limit to be
  reached.

  @sideeffect None

  @see Cudd_ReadSiftMaxVar Cudd_SetSiftMaxSwap

*/
int
Cudd_ReadSiftMaxSwap(
  DdManager * dd)
{
    return(dd->siftMaxSwap);

} /* end of Cudd_ReadSiftMaxSwap */


/**
  @brief Sets the siftMaxSwap parameter of the manager.

  @details This parameter gives the maximum number of swaps that will
  be attempted for each invocation of sifting. The real number of
  swaps may exceed the set limit because the package will always
  complete the sifting of the variable that causes the limit to be
  reached.

  @sideeffect None

  @see Cudd_SetSiftMaxVar Cudd_ReadSiftMaxSwap

*/
void
Cudd_SetSiftMaxSwap(
  DdManager * dd,
  int  sms)
{
    dd->siftMaxSwap = sms;

} /* end of Cudd_SetSiftMaxSwap */


/**
  @brief Reads the maxGrowth parameter of the manager.

  @details This parameter determines how much the number of nodes can
  grow during sifting of a variable.  Overall, sifting never increases
  the size of the decision diagrams.  This parameter only refers to
  intermediate results.  A lower value will speed up sifting, possibly
  at the expense of quality.

  @sideeffect None

  @see Cudd_SetMaxGrowth Cudd_ReadMaxGrowthAlternate

*/
double
Cudd_ReadMaxGrowth(
  DdManager * dd)
{
    return(dd->maxGrowth);

} /* end of Cudd_ReadMaxGrowth */


/**
  @brief Sets the maxGrowth parameter of the manager.

  @details This parameter determines how much the number of nodes can
  grow during sifting of a variable.  Overall, sifting never increases
  the size of the decision diagrams.  This parameter only refers to
  intermediate results.  A lower value will speed up sifting, possibly
  at the expense of quality.

  @sideeffect None

  @see Cudd_ReadMaxGrowth Cudd_SetMaxGrowthAlternate

*/
void
Cudd_SetMaxGrowth(
  DdManager * dd,
  double mg)
{
    dd->maxGrowth = mg;

} /* end of Cudd_SetMaxGrowth */


/**
  @brief Reads the maxGrowthAlt parameter of the manager.

  @details This parameter is analogous to the maxGrowth paramter, and
  is used every given number of reorderings instead of maxGrowth.  The
  number of reorderings is set with Cudd_SetReorderingCycle.  If the
  number of reorderings is 0 (default) maxGrowthAlt is never used.

  @sideeffect None

  @see Cudd_ReadMaxGrowth Cudd_SetMaxGrowthAlternate
  Cudd_SetReorderingCycle Cudd_ReadReorderingCycle

*/
double
Cudd_ReadMaxGrowthAlternate(
  DdManager * dd)
{
    return(dd->maxGrowthAlt);

} /* end of Cudd_ReadMaxGrowthAlternate */


/**
  @brief Sets the maxGrowthAlt parameter of the manager.

  @details This parameter is analogous to the maxGrowth paramter, and
  is used every given number of reorderings instead of maxGrowth.  The
  number of reorderings is set with Cudd_SetReorderingCycle.  If the
  number of reorderings is 0 (default) maxGrowthAlt is never used.

  @sideeffect None

  @see Cudd_ReadMaxGrowthAlternate Cudd_SetMaxGrowth
  Cudd_SetReorderingCycle Cudd_ReadReorderingCycle

*/
void
Cudd_SetMaxGrowthAlternate(
  DdManager * dd,
  double mg)
{
    dd->maxGrowthAlt = mg;

} /* end of Cudd_SetMaxGrowthAlternate */


/**
  @brief Reads the reordCycle parameter of the manager.

  @details This parameter determines how often the alternate threshold
  on maximum growth is used in reordering.

  @sideeffect None

  @see Cudd_ReadMaxGrowthAlternate Cudd_SetMaxGrowthAlternate
  Cudd_SetReorderingCycle

*/
int
Cudd_ReadReorderingCycle(
  DdManager * dd)
{
    return(dd->reordCycle);

} /* end of Cudd_ReadReorderingCycle */


/**
  @brief Sets the reordCycle parameter of the manager.

  @details This parameter determines how often the alternate threshold
  on maximum growth is used in reordering.

  @sideeffect None

  @see Cudd_ReadMaxGrowthAlternate Cudd_SetMaxGrowthAlternate
  Cudd_ReadReorderingCycle

*/
void
Cudd_SetReorderingCycle(
  DdManager * dd,
  int cycle)
{
    dd->reordCycle = cycle;

} /* end of Cudd_SetReorderingCycle */


/**
  @brief Returns the variable group tree of the manager.

  @sideeffect None

  @see Cudd_SetTree Cudd_FreeTree Cudd_ReadZddTree

*/
MtrNode *
Cudd_ReadTree(
  DdManager * dd)
{
    return(dd->tree);

} /* end of Cudd_ReadTree */


/**
  @brief Sets the variable group tree of the manager.

  @sideeffect None

  @see Cudd_FreeTree Cudd_ReadTree Cudd_SetZddTree

*/
void
Cudd_SetTree(
  DdManager * dd,
  MtrNode * tree)
{
    if (dd->tree != NULL) {
	Mtr_FreeTree(dd->tree);
    }
    dd->tree = tree;
    if (tree == NULL) return;

    fixVarTree(tree, dd->perm, dd->size);
    return;

} /* end of Cudd_SetTree */


/**
  @brief Frees the variable group tree of the manager.

  @sideeffect None

  @see Cudd_SetTree Cudd_ReadTree Cudd_FreeZddTree

*/
void
Cudd_FreeTree(
  DdManager * dd)
{
    if (dd->tree != NULL) {
	Mtr_FreeTree(dd->tree);
	dd->tree = NULL;
    }
    return;

} /* end of Cudd_FreeTree */


/**
  @brief Returns the variable group tree of the manager.

  @sideeffect None

  @see Cudd_SetZddTree Cudd_FreeZddTree Cudd_ReadTree

*/
MtrNode *
Cudd_ReadZddTree(
  DdManager * dd)
{
    return(dd->treeZ);

} /* end of Cudd_ReadZddTree */


/**
  @brief Sets the %ZDD variable group tree of the manager.

  @sideeffect None

  @see Cudd_FreeZddTree Cudd_ReadZddTree Cudd_SetTree

*/
void
Cudd_SetZddTree(
  DdManager * dd,
  MtrNode * tree)
{
    if (dd->treeZ != NULL) {
	Mtr_FreeTree(dd->treeZ);
    }
    dd->treeZ = tree;
    if (tree == NULL) return;

    fixVarTree(tree, dd->permZ, dd->sizeZ);
    return;

} /* end of Cudd_SetZddTree */


/**
  @brief Frees the variable group tree of the manager.

  @sideeffect None

  @see Cudd_SetZddTree Cudd_ReadZddTree Cudd_FreeTree

*/
void
Cudd_FreeZddTree(
  DdManager * dd)
{
    if (dd->treeZ != NULL) {
	Mtr_FreeTree(dd->treeZ);
	dd->treeZ = NULL;
    }
    return;

} /* end of Cudd_FreeZddTree */


/**
  @brief Returns the index of the node.

  @details The node pointer can be either regular or complemented.

  @sideeffect None

  @see Cudd_ReadIndex

*/
unsigned int
Cudd_NodeReadIndex(
  DdNode * node)
{
    return((unsigned int) Cudd_Regular(node)->index);

} /* end of Cudd_NodeReadIndex */


/**
  @brief Returns the current position of the i-th variable in the
  order.

  @details If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX;
  otherwise, if the index is out of bounds returns -1.

  @sideeffect None

  @see Cudd_ReadInvPerm Cudd_ReadPermZdd

*/
int
Cudd_ReadPerm(
  DdManager * dd,
  int  i)
{
    if (i == CUDD_CONST_INDEX) return(CUDD_CONST_INDEX);
    if (i < 0 || i >= dd->size) return(-1);
    return(dd->perm[i]);

} /* end of Cudd_ReadPerm */


/**
  @brief Returns the current position of the i-th %ZDD variable in the
  order.

  @details If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX;
  otherwise, if the index is out of bounds returns -1.

  @sideeffect None

  @see Cudd_ReadInvPermZdd Cudd_ReadPerm

*/
int
Cudd_ReadPermZdd(
  DdManager * dd,
  int  i)
{
    if (i == CUDD_CONST_INDEX) return(CUDD_CONST_INDEX);
    if (i < 0 || i >= dd->sizeZ) return(-1);
    return(dd->permZ[i]);

} /* end of Cudd_ReadPermZdd */


/**
  @brief Returns the index of the variable currently in the i-th
  position of the order.

  @details If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX;
  otherwise, if the index is out of bounds returns -1.

  @sideeffect None

  @see Cudd_ReadPerm Cudd_ReadInvPermZdd

*/
int
Cudd_ReadInvPerm(
  DdManager * dd,
  int  i)
{
    if (i == CUDD_CONST_INDEX) return(CUDD_CONST_INDEX);
    if (i < 0 || i >= dd->size) return(-1);
    return(dd->invperm[i]);

} /* end of Cudd_ReadInvPerm */


/**
  @brief Returns the index of the %ZDD variable currently in the i-th
  position of the order.

  @details If the index is CUDD_CONST_INDEX, returns CUDD_CONST_INDEX;
  otherwise, if the index is out of bounds returns -1.

  @sideeffect None

  @see Cudd_ReadPerm Cudd_ReadInvPermZdd

*/
int
Cudd_ReadInvPermZdd(
  DdManager * dd,
  int  i)
{
    if (i == CUDD_CONST_INDEX) return(CUDD_CONST_INDEX);
    if (i < 0 || i >= dd->sizeZ) return(-1);
    return(dd->invpermZ[i]);

} /* end of Cudd_ReadInvPermZdd */


/**
  @brief Returns the i-th element of the vars array.

  @details Returns the i-th element of the vars array if it falls
  within the array bounds; NULL otherwise. If i is the index of an
  existing variable, this function produces the same result as
  Cudd_bddIthVar. However, if the i-th var does not exist yet,
  Cudd_bddIthVar will create it, whereas Cudd_ReadVars will not.

  @sideeffect None

  @see Cudd_bddIthVar

*/
DdNode *
Cudd_ReadVars(
  DdManager * dd,
  int  i)
{
    if (i < 0 || i > dd->size) return(NULL);
    return(dd->vars[i]);

} /* end of Cudd_ReadVars */


/**
  @brief Reads the epsilon parameter of the manager.

  @details The epsilon parameter control the comparison between
  floating point numbers.

  @sideeffect None

  @see Cudd_SetEpsilon

*/
CUDD_VALUE_TYPE
Cudd_ReadEpsilon(
  DdManager * dd)
{
    return(dd->epsilon);

} /* end of Cudd_ReadEpsilon */


/**
  @brief Sets the epsilon parameter of the manager to ep.

  @details The epsilon parameter control the comparison between
  floating point numbers.

  @sideeffect None

  @see Cudd_ReadEpsilon

*/
void
Cudd_SetEpsilon(
  DdManager * dd,
  CUDD_VALUE_TYPE  ep)
{
    dd->epsilon = ep;

} /* end of Cudd_SetEpsilon */


/**
  @brief Reads the groupcheck parameter of the manager.

  @details The groupcheck parameter determines the aggregation
  criterion in group sifting.

  @sideeffect None

  @see Cudd_SetGroupcheck

*/
Cudd_AggregationType
Cudd_ReadGroupcheck(
  DdManager * dd)
{
    return(dd->groupcheck);

} /* end of Cudd_ReadGroupCheck */


/**
  @brief Sets the parameter groupcheck of the manager to gc.

  @details The groupcheck parameter determines the aggregation
  criterion in group sifting.

  @sideeffect None

  @see Cudd_ReadGroupCheck

*/
void
Cudd_SetGroupcheck(
  DdManager * dd,
  Cudd_AggregationType gc)
{
    dd->groupcheck = gc;

} /* end of Cudd_SetGroupcheck */


/**
  @brief Tells whether garbage collection is enabled.

  @return 1 if garbage collection is enabled; 0 otherwise.

  @sideeffect None

  @see Cudd_EnableGarbageCollection Cudd_DisableGarbageCollection

*/
int
Cudd_GarbageCollectionEnabled(
  DdManager * dd)
{
    return(dd->gcEnabled);

} /* end of Cudd_GarbageCollectionEnabled */


/**
  @brief Enables garbage collection.

  @details Garbage collection is initially enabled. Therefore it is
  necessary to call this function only if garbage collection has been
  explicitly disabled.

  @sideeffect None

  @see Cudd_DisableGarbageCollection Cudd_GarbageCollectionEnabled

*/
void
Cudd_EnableGarbageCollection(
  DdManager * dd)
{
    dd->gcEnabled = 1;

} /* end of Cudd_EnableGarbageCollection */


/**
  @brief Disables garbage collection.

  @details Garbage collection is initially enabled. This function may
  be called to disable it.  However, garbage collection will still
  occur when a new node must be created and no memory is left, or when
  garbage collection is required for correctness. (E.g., before
  reordering.)

  @sideeffect None

  @see Cudd_EnableGarbageCollection Cudd_GarbageCollectionEnabled

*/
void
Cudd_DisableGarbageCollection(
  DdManager * dd)
{
    dd->gcEnabled = 0;

} /* end of Cudd_DisableGarbageCollection */


/**
  @brief Tells whether dead nodes are counted towards triggering
  reordering.

  @return 1 if dead nodes are counted; 0 otherwise.

  @sideeffect None

  @see Cudd_TurnOnCountDead Cudd_TurnOffCountDead

*/
int
Cudd_DeadAreCounted(
  DdManager * dd)
{
    return(dd->countDead == 0 ? 1 : 0);

} /* end of Cudd_DeadAreCounted */


/**
  @brief Causes the dead nodes to be counted towards triggering
  reordering.

  @details This causes more frequent reorderings. By default dead
  nodes are not counted.

  @sideeffect Changes the manager.

  @see Cudd_TurnOffCountDead Cudd_DeadAreCounted

*/
void
Cudd_TurnOnCountDead(
  DdManager * dd)
{
    dd->countDead = 0;

} /* end of Cudd_TurnOnCountDead */


/**
  @brief Causes the dead nodes not to be counted towards triggering
  reordering.

  @details This causes less frequent reorderings. By default dead
  nodes are not counted. Therefore there is no need to call this
  function unless Cudd_TurnOnCountDead has been previously called.

  @sideeffect Changes the manager.

  @see Cudd_TurnOnCountDead Cudd_DeadAreCounted

*/
void
Cudd_TurnOffCountDead(
  DdManager * dd)
{
    dd->countDead = ~0U;

} /* end of Cudd_TurnOffCountDead */


/**
  @brief Returns the current value of the recombination parameter used
  in group sifting.

  @details A larger (positive) value makes the aggregation of
  variables due to the second difference criterion more likely. A
  smaller (negative) value makes aggregation less likely.

  @sideeffect None

  @see Cudd_SetRecomb

*/
int
Cudd_ReadRecomb(
  DdManager * dd)
{
    return(dd->recomb);

} /* end of Cudd_ReadRecomb */


/**
  @brief Sets the value of the recombination parameter used in group
  sifting.

  @details A larger (positive) value makes the aggregation of
  variables due to the second difference criterion more likely. A
  smaller (negative) value makes aggregation less likely. The default
  value is 0.

  @sideeffect Changes the manager.

  @see Cudd_ReadRecomb

*/
void
Cudd_SetRecomb(
  DdManager * dd,
  int  recomb)
{
    dd->recomb = recomb;

} /* end of Cudd_SetRecomb */


/**
  @brief Returns the current value of the symmviolation parameter used
  in group sifting.

  @details This parameter is used in group sifting to decide how many
  violations to the symmetry conditions <code>f10 = f01</code> or
  <code>f11 = f00</code> are tolerable when checking for aggregation
  due to extended symmetry. The value should be between 0 and 100. A
  small value causes fewer variables to be aggregated. The default
  value is 0.

  @sideeffect None

  @see Cudd_SetSymmviolation

*/
int
Cudd_ReadSymmviolation(
  DdManager * dd)
{
    return(dd->symmviolation);

} /* end of Cudd_ReadSymmviolation */


/**
  @brief Sets the value of the symmviolation parameter used
  in group sifting.

  @details This parameter is used in group sifting to decide how many
  violations to the symmetry conditions <code>f10 = f01</code> or
  <code>f11 = f00</code> are tolerable when checking for aggregation
  due to extended symmetry. The value should be between 0 and 100. A
  small value causes fewer variables to be aggregated. The default
  value is 0.

  @sideeffect Changes the manager.

  @see Cudd_ReadSymmviolation

*/
void
Cudd_SetSymmviolation(
  DdManager * dd,
  int  symmviolation)
{
    dd->symmviolation = symmviolation;

} /* end of Cudd_SetSymmviolation */


/**
  @brief Returns the current value of the arcviolation parameter used
  in group sifting.

  @details This parameter is used to decide how many arcs into
  <code>y</code> not coming from <code>x</code> are tolerable when
  checking for aggregation due to extended symmetry. The value should
  be between 0 and 100. A small value causes fewer variables to be
  aggregated. The default value is 0.

  @sideeffect None

  @see Cudd_SetArcviolation

*/
int
Cudd_ReadArcviolation(
  DdManager * dd)
{
    return(dd->arcviolation);

} /* end of Cudd_ReadArcviolation */


/**
  @brief Sets the value of the arcviolation parameter used
  in group sifting.

  @details This parameter is used to decide how many arcs into
  <code>y</code> not coming from <code>x</code> are tolerable when
  checking for aggregation due to extended symmetry. The value should
  be between 0 and 100. A small value causes fewer variables to be
  aggregated. The default value is 0.

  @sideeffect None

  @see Cudd_ReadArcviolation

*/
void
Cudd_SetArcviolation(
  DdManager * dd,
  int  arcviolation)
{
    dd->arcviolation = arcviolation;

} /* end of Cudd_SetArcviolation */


/**
  @brief Reads the current size of the population used by the
  genetic algorithm for variable reordering.

  @details A larger population size will cause the genetic algorithm
  to take more time, but will generally produce better results. The
  default value is 0, in which case the package uses three times the
  number of variables as population size, with a maximum of 120.

  @sideeffect None

  @see Cudd_SetPopulationSize

*/
int
Cudd_ReadPopulationSize(
  DdManager * dd)
{
    return(dd->populationSize);

} /* end of Cudd_ReadPopulationSize */


/**
  @brief Sets the size of the population used by the
  genetic algorithm for variable reordering.

  @details A larger population size will cause the genetic algorithm
  to take more time, but will generally produce better results. The
  default value is 0, in which case the package uses three times the
  number of variables as population size, with a maximum of 120.

  @sideeffect Changes the manager.

  @see Cudd_ReadPopulationSize

*/
void
Cudd_SetPopulationSize(
  DdManager * dd,
  int  populationSize)
{
    dd->populationSize = populationSize;

} /* end of Cudd_SetPopulationSize */


/**
  @brief Reads the current number of crossovers used by the
  genetic algorithm for variable reordering.

  @details A larger number of crossovers will cause the genetic
  algorithm to take more time, but will generally produce better
  results. The default value is 0, in which case the package uses
  three times the number of variables as number of crossovers, with a
  maximum of 60.

  @sideeffect None

  @see Cudd_SetNumberXovers

*/
int
Cudd_ReadNumberXovers(
  DdManager * dd)
{
    return(dd->numberXovers);

} /* end of Cudd_ReadNumberXovers */


/**
  @brief Sets the number of crossovers used by the
  genetic algorithm for variable reordering.

  @details A larger number of crossovers will cause the genetic
  algorithm to take more time, but will generally produce better
  results. The default value is 0, in which case the package uses
  three times the number of variables as number of crossovers, with a
  maximum of 60.

  @sideeffect None

  @see Cudd_ReadNumberXovers

*/
void
Cudd_SetNumberXovers(
  DdManager * dd,
  int  numberXovers)
{
    dd->numberXovers = numberXovers;

} /* end of Cudd_SetNumberXovers */


/**
  @brief Returns the order randomization factor.

  @details If non-zero this factor is used to determine a perturbation
  of the next reordering threshold.  Larger factors cause larger
  perturbations.

  @sideeffect None

  @see Cudd_SetOrderRandomization

*/
unsigned int
Cudd_ReadOrderRandomization(
  DdManager * dd)
{
    return(dd->randomizeOrder);

} /* end of Cudd_ReadOrderRandomization */


/**
  @brief Sets the order randomization factor.

  @sideeffect None

  @see Cudd_ReadOrderRandomization

*/
void
Cudd_SetOrderRandomization(
  DdManager * dd,
  unsigned int factor)
{
    dd->randomizeOrder = factor;

} /* end of Cudd_SetOrderRandomization */


/**
  @brief Returns the memory in use by the manager measured in bytes.

  @sideeffect None

*/
size_t
Cudd_ReadMemoryInUse(
  DdManager * dd)
{
    return(dd->memused);

} /* end of Cudd_ReadMemoryInUse */


/**
  @brief Prints out statistics and settings for a CUDD manager.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
Cudd_PrintInfo(
  DdManager * dd,
  FILE * fp)
{
    int retval;
    Cudd_ReorderingType autoMethod, autoMethodZ;

    /* Modifiable parameters. */
    retval = fprintf(fp,"**** CUDD modifiable parameters ****\n");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Hard limit for cache size: %u\n",
		     Cudd_ReadMaxCacheHard(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Cache hit threshold for resizing: %u%%\n",
		     Cudd_ReadMinHit(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Garbage collection enabled: %s\n",
		     Cudd_GarbageCollectionEnabled(dd) ? "yes" : "no");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Limit for fast unique table growth: %u\n",
		     Cudd_ReadLooseUpTo(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,
		     "Maximum number of variables sifted per reordering: %d\n",
		     Cudd_ReadSiftMaxVar(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,
		     "Maximum number of variable swaps per reordering: %d\n",
		     Cudd_ReadSiftMaxSwap(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Maximum growth while sifting a variable: %g\n",
		     Cudd_ReadMaxGrowth(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Dynamic reordering of BDDs enabled: %s\n",
		     Cudd_ReorderingStatus(dd,&autoMethod) ? "yes" : "no");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Default BDD reordering method: %d\n",
		     (int) autoMethod);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Dynamic reordering of ZDDs enabled: %s\n",
		     Cudd_ReorderingStatusZdd(dd,&autoMethodZ) ? "yes" : "no");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Default ZDD reordering method: %d\n",
		     (int) autoMethodZ);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Realignment of ZDDs to BDDs enabled: %s\n",
		     Cudd_zddRealignmentEnabled(dd) ? "yes" : "no");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Realignment of BDDs to ZDDs enabled: %s\n",
		     Cudd_bddRealignmentEnabled(dd) ? "yes" : "no");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Dead nodes counted in triggering reordering: %s\n",
		     Cudd_DeadAreCounted(dd) ? "yes" : "no");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Group checking criterion: %u\n",
		     (unsigned int) Cudd_ReadGroupcheck(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Recombination threshold: %d\n", Cudd_ReadRecomb(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Symmetry violation threshold: %d\n",
		     Cudd_ReadSymmviolation(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Arc violation threshold: %d\n",
		     Cudd_ReadArcviolation(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"GA population size: %d\n",
		     Cudd_ReadPopulationSize(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of crossovers for GA: %d\n",
		     Cudd_ReadNumberXovers(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Next reordering threshold: %u\n",
		     Cudd_ReadNextReordering(dd));
    if (retval == EOF) return(0);

    /* Non-modifiable parameters. */
    retval = fprintf(fp,"**** CUDD non-modifiable parameters ****\n");
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Memory in use: %" PRIszt "\n",
                     Cudd_ReadMemoryInUse(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Peak number of nodes: %ld\n",
		     Cudd_ReadPeakNodeCount(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Peak number of live nodes: %d\n",
		     Cudd_ReadPeakLiveNodeCount(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of BDD variables: %d\n", dd->size);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of ZDD variables: %d\n", dd->sizeZ);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of cache entries: %u\n", dd->cacheSlots);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of cache look-ups: %.0f\n",
		     Cudd_ReadCacheLookUps(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of cache hits: %.0f\n",
		     Cudd_ReadCacheHits(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of cache insertions: %.0f\n",
		     dd->cacheinserts);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of cache collisions: %.0f\n",
		     dd->cachecollisions);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of cache deletions: %.0f\n",
		     dd->cachedeletions);
    if (retval == EOF) return(0);
    retval = cuddCacheProfile(dd,fp);
    if (retval == 0) return(0);
    retval = fprintf(fp,"Soft limit for cache size: %u\n",
		     Cudd_ReadMaxCache(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of buckets in unique table: %u\n", dd->slots);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Used buckets in unique table: %.2f%% (expected %.2f%%)\n",
		     100.0 * Cudd_ReadUsedSlots(dd),
		     100.0 * Cudd_ExpectedUsedSlots(dd));
    if (retval == EOF) return(0);
#ifdef DD_UNIQUE_PROFILE
    retval = fprintf(fp,"Unique lookups: %.0f\n", dd->uniqueLookUps);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Unique links: %.0f (%g per lookup)\n",
	    dd->uniqueLinks, dd->uniqueLinks / dd->uniqueLookUps);
    if (retval == EOF) return(0);
#endif
    retval = fprintf(fp,"Number of BDD and ADD nodes: %u\n", dd->keys);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of ZDD nodes: %u\n", dd->keysZ);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of dead BDD and ADD nodes: %u\n", dd->dead);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Number of dead ZDD nodes: %u\n", dd->deadZ);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Total number of nodes allocated: %.0f\n",
		     dd->allocated);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Total number of nodes reclaimed: %.0f\n",
		     dd->reclaimed);
    if (retval == EOF) return(0);
#ifdef DD_STATS
    retval = fprintf(fp,"Nodes freed: %.0f\n", dd->nodesFreed);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Nodes dropped: %.0f\n", dd->nodesDropped);
    if (retval == EOF) return(0);
#endif
#ifdef DD_COUNT
    retval = fprintf(fp,"Number of recursive calls: %.0f\n",
		     Cudd_ReadRecursiveCalls(dd));
    if (retval == EOF) return(0);
#endif
    retval = fprintf(fp,"Garbage collections so far: %d\n",
		     Cudd_ReadGarbageCollections(dd));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Time for garbage collection: %.2f sec\n",
		     ((double)Cudd_ReadGarbageCollectionTime(dd)/1000.0));
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Reorderings so far: %d\n", dd->reorderings);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Time for reordering: %.2f sec\n",
		     ((double)Cudd_ReadReorderingTime(dd)/1000.0));
    if (retval == EOF) return(0);
#ifdef DD_COUNT
    retval = fprintf(fp,"Node swaps in reordering: %.0f\n",
	Cudd_ReadSwapSteps(dd));
    if (retval == EOF) return(0);
#endif

    return(1);

} /* end of Cudd_PrintInfo */


/**
  @brief Reports the peak number of nodes.

  @details This number includes node on the free list. At the peak,
  the number of nodes on the free list is guaranteed to be less than
  DD_MEM_CHUNK.

  @sideeffect None

  @see Cudd_ReadNodeCount Cudd_PrintInfo

*/
long
Cudd_ReadPeakNodeCount(
  DdManager * dd)
{
    long count = 0;
    DdNodePtr *scan = dd->memoryList;

    while (scan != NULL) {
	count += DD_MEM_CHUNK;
	scan = (DdNodePtr *) *scan;
    }
    return(count);

} /* end of Cudd_ReadPeakNodeCount */


/**
  @brief Reports the peak number of live nodes.

  @sideeffect None

  @see Cudd_ReadNodeCount Cudd_PrintInfo Cudd_ReadPeakNodeCount

*/
int
Cudd_ReadPeakLiveNodeCount(
  DdManager * dd)
{
    unsigned int live = dd->keys - dd->dead;

    if (live > dd->peakLiveNodes) {
	dd->peakLiveNodes = live;
    }
    return((int)dd->peakLiveNodes);

} /* end of Cudd_ReadPeakLiveNodeCount */


/**
  @brief Reports the number of nodes in BDDs and ADDs.

  @details This number does not include the isolated projection
  functions and the unused constants. These nodes that are not counted
  are not part of the DDs manipulated by the application.

  @sideeffect None

  @see Cudd_ReadPeakNodeCount Cudd_zddReadNodeCount

*/
long
Cudd_ReadNodeCount(
  DdManager * dd)
{
    long count;
    int i;

#ifndef DD_NO_DEATH_ROW
    cuddClearDeathRow(dd);
#endif

    count = (long) (dd->keys - dd->dead);

    /* Count isolated projection functions. Their number is subtracted
    ** from the node count because they are not part of the BDDs.
    */
    for (i=0; i < dd->size; i++) {
	if (dd->vars[i]->ref == 1) count--;
    }
    /* Subtract from the count the unused constants. */
    if (DD_ZERO(dd)->ref == 1) count--;
    if (DD_PLUS_INFINITY(dd)->ref == 1) count--;
    if (DD_MINUS_INFINITY(dd)->ref == 1) count--;

    return(count);

} /* end of Cudd_ReadNodeCount */



/**
  @brief Reports the number of nodes in ZDDs.

  @details This number always includes the two constants 1 and 0.

  @sideeffect None

  @see Cudd_ReadPeakNodeCount Cudd_ReadNodeCount

*/
long
Cudd_zddReadNodeCount(
  DdManager * dd)
{
    return((long)(dd->keysZ - dd->deadZ + 2));

} /* end of Cudd_zddReadNodeCount */


/**
  @brief Adds a function to a hook.

  @details A hook is a list of
  application-provided functions called on certain occasions by the
  package.

  @return 1 if the function is successfully added; 2 if the function
  was already in the list; 0 otherwise.

  @sideeffect None

  @see Cudd_RemoveHook

*/
int
Cudd_AddHook(
  DdManager * dd,
  DD_HFP f,
  Cudd_HookType where)
{
    DdHook **hook, *nextHook, *newHook;

    switch (where) {
    case CUDD_PRE_GC_HOOK:
	hook = &(dd->preGCHook);
	break;
    case CUDD_POST_GC_HOOK:
	hook = &(dd->postGCHook);
	break;
    case CUDD_PRE_REORDERING_HOOK:
	hook = &(dd->preReorderingHook);
	break;
    case CUDD_POST_REORDERING_HOOK:
	hook = &(dd->postReorderingHook);
	break;
    default:
        return(0);
    }
    /* Scan the list and find whether the function is already there.
    ** If so, just return. */
    nextHook = *hook;
    while (nextHook != NULL) {
	if (nextHook->f == f) {
	    return(2);
	}
	hook = &(nextHook->next);
	nextHook = nextHook->next;
    }
    /* The function was not in the list. Create a new item and append it
    ** to the end of the list. */
    newHook = ALLOC(DdHook,1);
    if (newHook == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    newHook->next = NULL;
    newHook->f = f;
    *hook = newHook;
    return(1);

} /* end of Cudd_AddHook */


/**
  @brief Removes a function from a hook.

  @details A hook is a list of application-provided functions called
  on certain occasions by the package.

  @return 1 if successful; 0 the function was not in the list.

  @sideeffect None

  @see Cudd_AddHook

*/
int
Cudd_RemoveHook(
  DdManager * dd,
  DD_HFP f,
  Cudd_HookType where)
{
    DdHook **hook, *nextHook;

    switch (where) {
    case CUDD_PRE_GC_HOOK:
	hook = &(dd->preGCHook);
	break;
    case CUDD_POST_GC_HOOK:
	hook = &(dd->postGCHook);
	break;
    case CUDD_PRE_REORDERING_HOOK:
	hook = &(dd->preReorderingHook);
	break;
    case CUDD_POST_REORDERING_HOOK:
	hook = &(dd->postReorderingHook);
	break;
    default:
        return(0);
    }
    nextHook = *hook;
    while (nextHook != NULL) {
	if (nextHook->f == f) {
	    *hook = nextHook->next;
	    FREE(nextHook);
	    return(1);
	}
	hook = &(nextHook->next);
	nextHook = nextHook->next;
    }

    return(0);

} /* end of Cudd_RemoveHook */


/**
  @brief Checks whether a function is in a hook.

  @details A hook is a list of application-provided functions called
  on certain occasions by the package.

  @return 1 if the function is found; 0 otherwise.

  @sideeffect None

  @see Cudd_AddHook Cudd_RemoveHook

*/
int
Cudd_IsInHook(
  DdManager * dd,
  DD_HFP f,
  Cudd_HookType where)
{
    DdHook *hook;

    switch (where) {
    case CUDD_PRE_GC_HOOK:
	hook = dd->preGCHook;
	break;
    case CUDD_POST_GC_HOOK:
	hook = dd->postGCHook;
	break;
    case CUDD_PRE_REORDERING_HOOK:
	hook = dd->preReorderingHook;
	break;
    case CUDD_POST_REORDERING_HOOK:
	hook = dd->postReorderingHook;
	break;
    default:
        return(0);
    }
    /* Scan the list and find whether the function is already there. */
    while (hook != NULL) {
	if (hook->f == f) {
	    return(1);
	}
	hook = hook->next;
    }
    return(0);

} /* end of Cudd_IsInHook */


/**
  @brief Sample hook function to call before reordering.

  @details Prints on the manager's stdout reordering method and initial size.
  
  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_StdPostReordHook

*/
int
Cudd_StdPreReordHook(
  DdManager *dd,
  const char *str,
  void *data)
{
    Cudd_ReorderingType method = (Cudd_ReorderingType) (ptruint) data;
    int retval;

    retval = fprintf(dd->out,"%s reordering with ", str);
    if (retval == EOF) return(0);
    switch (method) {
    case CUDD_REORDER_SIFT_CONVERGE:
    case CUDD_REORDER_SYMM_SIFT_CONV:
    case CUDD_REORDER_GROUP_SIFT_CONV:
    case CUDD_REORDER_WINDOW2_CONV:
    case CUDD_REORDER_WINDOW3_CONV:
    case CUDD_REORDER_WINDOW4_CONV:
    case CUDD_REORDER_LINEAR_CONVERGE:
	retval = fprintf(dd->out,"converging ");
	if (retval == EOF) return(0);
	break;
    default:
	break;
    }
    switch (method) {
    case CUDD_REORDER_RANDOM:
    case CUDD_REORDER_RANDOM_PIVOT:
	retval = fprintf(dd->out,"random");
	break;
    case CUDD_REORDER_SIFT:
    case CUDD_REORDER_SIFT_CONVERGE:
	retval = fprintf(dd->out,"sifting");
	break;
    case CUDD_REORDER_SYMM_SIFT:
    case CUDD_REORDER_SYMM_SIFT_CONV:
	retval = fprintf(dd->out,"symmetric sifting");
	break;
    case CUDD_REORDER_LAZY_SIFT:
	retval = fprintf(dd->out,"lazy sifting");
	break;
    case CUDD_REORDER_GROUP_SIFT:
    case CUDD_REORDER_GROUP_SIFT_CONV:
	retval = fprintf(dd->out,"group sifting");
	break;
    case CUDD_REORDER_WINDOW2:
    case CUDD_REORDER_WINDOW3:
    case CUDD_REORDER_WINDOW4:
    case CUDD_REORDER_WINDOW2_CONV:
    case CUDD_REORDER_WINDOW3_CONV:
    case CUDD_REORDER_WINDOW4_CONV:
	retval = fprintf(dd->out,"window");
	break;
    case CUDD_REORDER_ANNEALING:
	retval = fprintf(dd->out,"annealing");
	break;
    case CUDD_REORDER_GENETIC:
	retval = fprintf(dd->out,"genetic");
	break;
    case CUDD_REORDER_LINEAR:
    case CUDD_REORDER_LINEAR_CONVERGE:
	retval = fprintf(dd->out,"linear sifting");
	break;
    case CUDD_REORDER_EXACT:
	retval = fprintf(dd->out,"exact");
	break;
    default:
	return(0);
    }
    if (retval == EOF) return(0);

    retval = fprintf(dd->out,": from %ld to ... ", strcmp(str, "BDD") == 0 ?
		     Cudd_ReadNodeCount(dd) : Cudd_zddReadNodeCount(dd));
    if (retval == EOF) return(0);
    fflush(dd->out);
    return(1);

} /* end of Cudd_StdPreReordHook */


/**
  @brief Sample hook function to call after reordering.

  @details Prints on the manager's stdout final size and reordering time.
  
  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_StdPreReordHook

*/
int
Cudd_StdPostReordHook(
  DdManager *dd,
  const char *str,
  void *data)
{
    unsigned long initialTime = (unsigned long) (ptruint) data;
    int retval;
    unsigned long finalTime = util_cpu_time();
    double totalTimeSec = (double)(finalTime - initialTime) / 1000.0;

    retval = fprintf(dd->out,"%ld nodes in %g sec\n", strcmp(str, "BDD") == 0 ?
		     Cudd_ReadNodeCount(dd) : Cudd_zddReadNodeCount(dd),
		     totalTimeSec);
    if (retval == EOF) return(0);
    retval = fflush(dd->out);
    if (retval == EOF) return(0);
    return(1);

} /* end of Cudd_StdPostReordHook */


/**
  @brief Enables reporting of reordering stats.

  @return 1 if successful; 0 otherwise.

  @sideeffect Installs functions in the pre-reordering and post-reordering
  hooks.

  @see Cudd_DisableReorderingReporting Cudd_ReorderingReporting

*/
int
Cudd_EnableReorderingReporting(
  DdManager *dd)
{
    if (!Cudd_AddHook(dd, Cudd_StdPreReordHook, CUDD_PRE_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_AddHook(dd, Cudd_StdPostReordHook, CUDD_POST_REORDERING_HOOK)) {
	return(0);
    }
    return(1);

} /* end of Cudd_EnableReorderingReporting */


/**
  @brief Disables reporting of reordering stats.

  @return 1 if successful; 0 otherwise.

  @sideeffect Removes functions from the pre-reordering and post-reordering
  hooks.

  @see Cudd_EnableReorderingReporting Cudd_ReorderingReporting

*/
int
Cudd_DisableReorderingReporting(
  DdManager *dd)
{
    if (!Cudd_RemoveHook(dd, Cudd_StdPreReordHook, CUDD_PRE_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_RemoveHook(dd, Cudd_StdPostReordHook, CUDD_POST_REORDERING_HOOK)) {
	return(0);
    }
    return(1);

} /* end of Cudd_DisableReorderingReporting */


/**
  @brief Returns 1 if reporting of reordering stats is enabled; 0
  otherwise.

  @sideeffect none

  @see Cudd_EnableReorderingReporting Cudd_DisableReorderingReporting

*/
int
Cudd_ReorderingReporting(
  DdManager *dd)
{
    return(Cudd_IsInHook(dd, Cudd_StdPreReordHook, CUDD_PRE_REORDERING_HOOK));

} /* end of Cudd_ReorderingReporting */


/**
  @brief Hook function to print the current variable order.

  @details It may be called before or after reordering. Prints on the
  manager's stdout a parenthesized list that describes the variable
  groups.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_StdPreReordHook

*/
int
Cudd_PrintGroupedOrder(
  DdManager * dd,
  const char *str,
  void *data)
{
    (void) data; /* avoid warning */
    int isBdd = strcmp(str, "ZDD");
    MtrNode *tree = isBdd ? dd->tree : dd->treeZ;
    int *invperm = isBdd ? dd->invperm : dd->invpermZ;
    int size = isBdd ? dd->size : dd->sizeZ;
    if (tree == NULL) {
        int i, retval;
        for (i=0; i < size; i++) {
            retval = fprintf(dd->out, "%c%d", i==0 ? '(' : ',', invperm[i]);
            if (retval == EOF) return(0);
        }
        retval = fprintf(dd->out,")\n");
        return (retval != EOF);
    } else {
        return Mtr_PrintGroupedOrder(tree,invperm,dd->out);
    }
        
} /* end of Cudd_PrintGroupedOrder */


/**
  @brief Enables monitoring of ordering.

  @return 1 if successful; 0 otherwise.

  @sideeffect Installs functions in the pre-reordering and post-reordering
  hooks.

  @see Cudd_EnableReorderingReporting

*/
int
Cudd_EnableOrderingMonitoring(
  DdManager *dd)
{
    if (!Cudd_AddHook(dd, Cudd_PrintGroupedOrder, CUDD_PRE_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_AddHook(dd, Cudd_StdPreReordHook, CUDD_PRE_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_AddHook(dd, Cudd_StdPostReordHook, CUDD_POST_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_AddHook(dd, Cudd_PrintGroupedOrder, CUDD_POST_REORDERING_HOOK)) {
	return(0);
    }
    return(1);

} /* end of Cudd_EnableOrderingMonitoring */


/**
  @brief Disables monitoring of ordering.

  @return 1 if successful; 0 otherwise.

  @sideeffect Removes functions from the pre-reordering and post-reordering
  hooks.

  @see Cudd_EnableOrderingMonitoring

*/
int
Cudd_DisableOrderingMonitoring(
  DdManager *dd)
{
    if (!Cudd_RemoveHook(dd, Cudd_StdPreReordHook, CUDD_PRE_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_RemoveHook(dd, Cudd_PrintGroupedOrder, CUDD_PRE_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_RemoveHook(dd, Cudd_PrintGroupedOrder, CUDD_POST_REORDERING_HOOK)) {
	return(0);
    }
    if (!Cudd_RemoveHook(dd, Cudd_StdPostReordHook, CUDD_POST_REORDERING_HOOK)) {
	return(0);
    }
    return(1);

} /* end of Cudd_DisableOrderingMonitoring */


/**
  @brief Returns 1 if monitoring of ordering is enabled; 0 otherwise.

  @sideeffect none

  @see Cudd_EnableOrderingMonitoring Cudd_DisableOrderingMonitoring

*/
int
Cudd_OrderingMonitoring(
  DdManager *dd)
{
    return(Cudd_IsInHook(dd, Cudd_PrintGroupedOrder, CUDD_PRE_REORDERING_HOOK));

} /* end of Cudd_OrderingMonitoring */


/**
  @brief Sets the application hook.

  @sideeffect None

  @see Cudd_ReadApplicationHook

*/
void
Cudd_SetApplicationHook(
  DdManager *dd,
  void * value)
{
    dd->hooks = value;  

} /* end of Cudd_SetApplicationHook */


/**
  @brief Reads the application hook.

  @sideeffect None

  @see Cudd_SetApplicationHook

*/
void *
Cudd_ReadApplicationHook(
  DdManager *dd)
{
    return(dd->hooks);  

} /* end of Cudd_ReadApplicationHook */


/**
  @brief Returns the code of the last error.

  @details The error codes are defined in cudd.h.

  @sideeffect None

  @see Cudd_ClearErrorCode

*/
Cudd_ErrorType
Cudd_ReadErrorCode(
  DdManager *dd)
{
    return(dd->errorCode);

} /* end of Cudd_ReadErrorCode */


/**
  @brief Clear the error code of a manager.

  @sideeffect None

  @see Cudd_ReadErrorCode

*/
void
Cudd_ClearErrorCode(
  DdManager *dd)
{
    dd->errorCode = CUDD_NO_ERROR;

} /* end of Cudd_ClearErrorCode */


/**
  @brief Installs a handler for failed memory allocations.

  @details Changing the handler only has an effect if the wrappers
  in safe_mem.c are in use.

  @return the current handler.
*/
DD_OOMFP
Cudd_InstallOutOfMemoryHandler(
  DD_OOMFP newHandler)
{
    DD_OOMFP oldHandler = MMoutOfMemory;
    MMoutOfMemory = newHandler;
    return oldHandler;

} /* end of Cudd_InstallOutOfMemoryHandler */


/**
  @brief Reads the stdout of a manager.

  @details This is the file pointer to which messages normally going
  to stdout are written. It is initialized to stdout. Cudd_SetStdout
  allows the application to redirect it.

  @sideeffect None

  @see Cudd_SetStdout Cudd_ReadStderr

*/
FILE *
Cudd_ReadStdout(
  DdManager *dd)
{
    return(dd->out);

} /* end of Cudd_ReadStdout */


/**
  @brief Sets the stdout of a manager.

  @sideeffect None

  @see Cudd_ReadStdout Cudd_SetStderr

*/
void
Cudd_SetStdout(
  DdManager *dd,
  FILE *fp)
{
    dd->out = fp;

} /* end of Cudd_SetStdout */


/**
  @brief Reads the stderr of a manager.

  @details This is the file pointer to which messages normally going
  to stderr are written. It is initialized to stderr. Cudd_SetStderr
  allows the application to redirect it.

  @sideeffect None

  @see Cudd_SetStderr Cudd_ReadStdout

*/
FILE *
Cudd_ReadStderr(
  DdManager *dd)
{
    return(dd->err);

} /* end of Cudd_ReadStderr */


/**
  @brief Sets the stderr of a manager.

  @sideeffect None

  @see Cudd_ReadStderr Cudd_SetStdout

*/
void
Cudd_SetStderr(
  DdManager *dd,
  FILE *fp)
{
    dd->err = fp;

} /* end of Cudd_SetStderr */


/**
  @brief Returns the threshold for the next dynamic reordering.

  @details The threshold is in terms of number of nodes and is in
  effect only if reordering is enabled. The count does not include the
  dead nodes, unless the countDead parameter of the manager has been
  changed from its default setting.

  @sideeffect None

  @see Cudd_SetNextReordering

*/
unsigned int
Cudd_ReadNextReordering(
  DdManager *dd)
{
    return(dd->nextDyn);

} /* end of Cudd_ReadNextReordering */


/**
  @brief Sets the threshold for the next dynamic reordering.

  @details The threshold is in terms of number of nodes and is in
  effect only if reordering is enabled. The count does not include the
  dead nodes, unless the countDead parameter of the manager has been
  changed from its default setting.

  @sideeffect None

  @see Cudd_ReadNextReordering

*/
void
Cudd_SetNextReordering(
  DdManager *dd,
  unsigned int next)
{
    dd->nextDyn = next;

} /* end of Cudd_SetNextReordering */


/**
  @brief Reads the number of elementary reordering steps.

  @sideeffect none

*/
double
Cudd_ReadSwapSteps(
  DdManager *dd)
{
#ifdef DD_COUNT
    return(dd->swapSteps);
#else
    (void) dd; /* avoid warning */
    return(-1);
#endif

} /* end of Cudd_ReadSwapSteps */


/**
  @brief Reads the maximum allowed number of live nodes.

  @details When this number is exceeded, the package returns NULL.

  @sideeffect none

  @see Cudd_SetMaxLive

*/
unsigned int
Cudd_ReadMaxLive(
  DdManager *dd)
{
    return(dd->maxLive);

} /* end of Cudd_ReadMaxLive */


/**
  @brief Sets the maximum allowed number of live nodes.

  @details When this number is exceeded, the package returns NULL.

  @sideeffect none

  @see Cudd_ReadMaxLive

*/
void
Cudd_SetMaxLive(
  DdManager *dd,
  unsigned int maxLive)
{
    dd->maxLive = maxLive;

} /* end of Cudd_SetMaxLive */


/**
  @brief Reads the maximum allowed memory.

  @details When this number is exceeded, the package returns NULL.

  @sideeffect none

  @see Cudd_SetMaxMemory

*/
size_t
Cudd_ReadMaxMemory(
  DdManager *dd)
{
    return(dd->maxmemhard);

} /* end of Cudd_ReadMaxMemory */


/**
  @brief Sets the maximum allowed memory.

  @details When this number is exceeded, the package returns NULL.

  @return the previous limit.

  @sideeffect none

  @see Cudd_ReadMaxMemory

*/
size_t
Cudd_SetMaxMemory(
  DdManager *dd,
  size_t maxMemory)
{
    size_t oldLimit = dd->maxmemhard;
    dd->maxmemhard = maxMemory;
    return oldLimit;

} /* end of Cudd_SetMaxMemory */


/**
  @brief Prevents sifting of a variable.

  @details This function sets a flag to prevent sifting of a
  variable.

  @return 1 if successful; 0 otherwise (i.e., invalid variable index).

  @sideeffect Changes the "bindVar" flag in DdSubtable.

  @see Cudd_bddUnbindVar

*/
int
Cudd_bddBindVar(
  DdManager *dd /**< manager */,
  int index /**< variable index */)
{
    if (index >= dd->size || index < 0) return(0);
    dd->subtables[dd->perm[index]].bindVar = 1;
    return(1);

} /* end of Cudd_bddBindVar */


/**
  @brief Allows the sifting of a variable.

  @details This function resets the flag that prevents the sifting
  of a variable. In successive variable reorderings, the variable will
  NOT be skipped, that is, sifted.  Initially all variables can be
  sifted. It is necessary to call this function only to re-enable
  sifting after a call to Cudd_bddBindVar.

  @return 1 if successful; 0 otherwise (i.e., invalid variable index).

  @sideeffect Changes the "bindVar" flag in DdSubtable.

  @see Cudd_bddBindVar

*/
int
Cudd_bddUnbindVar(
  DdManager *dd /**< manager */,
  int index /**< variable index */)
{
    if (index >= dd->size || index < 0) return(0);
    dd->subtables[dd->perm[index]].bindVar = 0;
    return(1);

} /* end of Cudd_bddUnbindVar */


/**
  @brief Tells whether a variable can be sifted.

  @details This function returns 1 if a variable is enabled for
  sifting.  Initially all variables can be sifted. This function
  returns 0 if there has been a previous call to Cudd_bddBindVar for
  that variable not followed by a call to Cudd_bddUnbindVar. The
  function returns 0 also in the case in which the index of the
  variable is out of bounds.

  @sideeffect none

  @see Cudd_bddBindVar Cudd_bddUnbindVar

*/
int
Cudd_bddVarIsBound(
  DdManager *dd /**< manager */,
  int index /**< variable index */)
{
    if (index >= dd->size || index < 0) return(0);
    return(dd->subtables[dd->perm[index]].bindVar);

} /* end of Cudd_bddVarIsBound */


/**
  @brief Sets a variable type to primary input.

  @details The variable type is used by lazy sifting.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddSetPsVar Cudd_bddSetNsVar Cudd_bddIsPiVar

*/
int
Cudd_bddSetPiVar(
  DdManager *dd /**< manager */,
  int index /**< variable index */)
{
    if (index >= dd->size || index < 0) return (0);
    dd->subtables[dd->perm[index]].varType = CUDD_VAR_PRIMARY_INPUT;
    return(1);

} /* end of Cudd_bddSetPiVar */


/**
  @brief Sets a variable type to present state.

  @details The variable type is used by lazy sifting.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddSetPiVar Cudd_bddSetNsVar Cudd_bddIsPsVar

*/
int
Cudd_bddSetPsVar(
  DdManager *dd /**< manager */,
  int index /**< variable index */)
{
    if (index >= dd->size || index < 0) return (0);
    dd->subtables[dd->perm[index]].varType = CUDD_VAR_PRESENT_STATE;
    return(1);

} /* end of Cudd_bddSetPsVar */


/**
  @brief Sets a variable type to next state.

  @details The variable type is used by lazy sifting.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddSetPiVar Cudd_bddSetPsVar Cudd_bddIsNsVar

*/
int
Cudd_bddSetNsVar(
  DdManager *dd /**< manager */,
  int index /**< variable index */)
{
    if (index >= dd->size || index < 0) return (0);
    dd->subtables[dd->perm[index]].varType = CUDD_VAR_NEXT_STATE;
    return(1);

} /* end of Cudd_bddSetNsVar */


/**
  @brief Checks whether a variable is primary input.

  @return 1 if the variable's type is primary input; 0 if the variable
  exists but is not a primary input; -1 if the variable does not
  exist.

  @sideeffect none

  @see Cudd_bddSetPiVar Cudd_bddIsPsVar Cudd_bddIsNsVar

*/
int
Cudd_bddIsPiVar(
  DdManager *dd /**< manager */,
  int index /**< variable index */)
{
    if (index >= dd->size || index < 0) return -1;
    return (dd->subtables[dd->perm[index]].varType == CUDD_VAR_PRIMARY_INPUT);

} /* end of Cudd_bddIsPiVar */


/**
  @brief Checks whether a variable is present state.

  @return 1 if the variable's type is present state; 0 if the variable
  exists but is not a present state; -1 if the variable does not
  exist.

  @sideeffect none

  @see Cudd_bddSetPsVar Cudd_bddIsPiVar Cudd_bddIsNsVar

*/
int
Cudd_bddIsPsVar(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return -1;
    return (dd->subtables[dd->perm[index]].varType == CUDD_VAR_PRESENT_STATE);

} /* end of Cudd_bddIsPsVar */


/**
  @brief Checks whether a variable is next state.

  @return 1 if the variable's type is present state; 0 if the variable
  exists but is not a present state; -1 if the variable does not
  exist.

  @sideeffect none

  @see Cudd_bddSetNsVar Cudd_bddIsPiVar Cudd_bddIsPsVar

*/
int
Cudd_bddIsNsVar(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return -1;
    return (dd->subtables[dd->perm[index]].varType == CUDD_VAR_NEXT_STATE);

} /* end of Cudd_bddIsNsVar */


/**
  @brief Sets a corresponding pair index for a given index.

  @details These pair indices are present and next state variable.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddReadPairIndex

*/
int
Cudd_bddSetPairIndex(
  DdManager *dd /**< manager */,
  int index /**< variable index */,
  int pairIndex /**< corresponding variable index */)
{
    if (index >= dd->size || index < 0) return(0);
    dd->subtables[dd->perm[index]].pairIndex = pairIndex;
    return(1);

} /* end of Cudd_bddSetPairIndex */


/**
  @brief Reads a corresponding pair index for a given index.

  @details These pair indices are present and next state variable.

  @return the corresponding variable index if the variable exists; -1
  otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddSetPairIndex

*/
int
Cudd_bddReadPairIndex(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return -1;
    return dd->subtables[dd->perm[index]].pairIndex;

} /* end of Cudd_bddReadPairIndex */


/**
  @brief Sets a variable to be grouped.

  @details This function is used for lazy sifting.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddSetVarHardGroup Cudd_bddResetVarToBeGrouped

*/
int
Cudd_bddSetVarToBeGrouped(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(0);
    if (dd->subtables[dd->perm[index]].varToBeGrouped <= CUDD_LAZY_SOFT_GROUP) {
	dd->subtables[dd->perm[index]].varToBeGrouped = CUDD_LAZY_SOFT_GROUP;
    }
    return(1);

} /* end of Cudd_bddSetVarToBeGrouped */


/**
  @brief Sets a variable to be a hard group.

  @details This function is used for lazy sifting.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddSetVarToBeGrouped Cudd_bddResetVarToBeGrouped
  Cudd_bddIsVarHardGroup

*/
int
Cudd_bddSetVarHardGroup(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(0);
    dd->subtables[dd->perm[index]].varToBeGrouped = CUDD_LAZY_HARD_GROUP;
    return(1);

} /* end of Cudd_bddSetVarHardGrouped */


/**
  @brief Resets a variable not to be grouped.

  @details This function is used for lazy sifting.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddSetVarToBeGrouped Cudd_bddSetVarHardGroup

*/
int
Cudd_bddResetVarToBeGrouped(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(0);
    if (dd->subtables[dd->perm[index]].varToBeGrouped <=
	CUDD_LAZY_SOFT_GROUP) {
	dd->subtables[dd->perm[index]].varToBeGrouped = CUDD_LAZY_NONE;
    }
    return(1);

} /* end of Cudd_bddResetVarToBeGrouped */


/**
  @brief Checks whether a variable is set to be grouped.

  @details This function is used for lazy sifting.

  @sideeffect none

*/
int
Cudd_bddIsVarToBeGrouped(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(-1);
    if (dd->subtables[dd->perm[index]].varToBeGrouped == CUDD_LAZY_UNGROUP)
	return(0);
    else
	return(dd->subtables[dd->perm[index]].varToBeGrouped);

} /* end of Cudd_bddIsVarToBeGrouped */


/**
  @brief Sets a variable to be ungrouped.

  @details This function is used for lazy sifting.

  @return 1 if successful; 0 otherwise.

  @sideeffect modifies the manager

  @see Cudd_bddIsVarToBeUngrouped

*/
int
Cudd_bddSetVarToBeUngrouped(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(0);
    dd->subtables[dd->perm[index]].varToBeGrouped = CUDD_LAZY_UNGROUP;
    return(1);

} /* end of Cudd_bddSetVarToBeGrouped */


/**
  @brief Checks whether a variable is set to be ungrouped.

  @details This function is used for lazy sifting.

  @return 1 if the variable is marked to be ungrouped; 0 if the
  variable exists, but it is not marked to be ungrouped; -1 if the
  variable does not exist.

  @sideeffect none

  @see Cudd_bddSetVarToBeUngrouped

*/
int
Cudd_bddIsVarToBeUngrouped(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(-1);
    return dd->subtables[dd->perm[index]].varToBeGrouped == CUDD_LAZY_UNGROUP;

} /* end of Cudd_bddIsVarToBeGrouped */


/**
  @brief Checks whether a variable is set to be in a hard group.

  @details This function is used for lazy sifting.

  @return 1 if the variable is marked to be in a hard group; 0 if the
  variable exists, but it is not marked to be in a hard group; -1 if
  the variable does not exist.

  @sideeffect none

  @see Cudd_bddSetVarHardGroup

*/
int
Cudd_bddIsVarHardGroup(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(-1);
    if (dd->subtables[dd->perm[index]].varToBeGrouped == CUDD_LAZY_HARD_GROUP)
	return(1);
    return(0);

} /* end of Cudd_bddIsVarToBeGrouped */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Fixes a variable group tree.

  @sideeffect Changes the variable group tree.

*/
static void
fixVarTree(
  MtrNode * treenode,
  int * perm,
  int  size)
{
    treenode->index = treenode->low;
    treenode->low = ((int) treenode->index < size) ?
	(MtrHalfWord) perm[treenode->index] : treenode->index;
    if (treenode->child != NULL)
	fixVarTree(treenode->child, perm, size);
    if (treenode->younger != NULL)
	fixVarTree(treenode->younger, perm, size);
    return;

} /* end of fixVarTree */


/**
  @brief Adds multiplicity groups to a %ZDD variable group tree.

  @details This function creates the groups for set of %ZDD variables
  (whose cardinality is given by parameter multiplicity) that are
  created for each %BDD variable in Cudd_zddVarsFromBddVars. The crux
  of the matter is to determine the index each new group. (The index
  of the first variable in the group.)  We first build all the groups
  for the children of a node, and then deal with the %ZDD variables
  that are directly attached to the node. The problem for these is
  that the tree itself does not provide information on their position
  inside the group. While we deal with the children of the node,
  therefore, we keep track of all the positions they occupy. The
  remaining positions in the tree can be freely used. Also, we keep
  track of all the variables placed in the children. All the remaining
  variables are directly attached to the group. We can then place any
  pair of variables not yet grouped in any pair of available positions
  in the node.

  @return 1 if successful; 0 otherwise.

  @sideeffect Changes the variable group tree.

  @see Cudd_zddVarsFromBddVars

*/
static int
addMultiplicityGroups(
  DdManager *dd /**< manager */,
  MtrNode *treenode /**< current tree node */,
  int multiplicity /**< how many %ZDD vars per %BDD var */,
  char *vmask /**< variable pairs for which a group has been already built */,
  char *lmask /**< levels for which a group has already been built*/)
{
    int startV, stopV, startL;
    int i, j;
    MtrNode *auxnode = treenode;

    while (auxnode != NULL) {
	if (auxnode->child != NULL) {
	    addMultiplicityGroups(dd,auxnode->child,multiplicity,vmask,lmask);
	}
	/* Build remaining groups. */
	startV = dd->permZ[auxnode->index] / multiplicity;
	startL = auxnode->low / multiplicity;
	stopV = startV + auxnode->size / multiplicity;
	/* Walk down vmask starting at startV and build missing groups. */
	for (i = startV, j = startL; i < stopV; i++) {
	    if (vmask[i] == 0) {
		MtrNode *node;
		while (lmask[j] == 1) j++;
		node = Mtr_MakeGroup(auxnode, j * multiplicity, multiplicity,
				     MTR_FIXED);
		if (node == NULL) {
		    return(0);
		}
		node->index = dd->invpermZ[i * multiplicity];
		vmask[i] = 1;
		lmask[j] = 1;
	    }
	}
	auxnode = auxnode->younger;
    }
    return(1);

} /* end of addMultiplicityGroups */

cuddAddAbs.c
15462
/**
  @file 

  @ingroup cudd

  @brief Quantification functions for ADDs.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int addCheckPositiveCube (DdManager *manager, DdNode *cube);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Existentially Abstracts all the variables in cube from f.

  @details Abstracts all the variables in cube from f by summing
  over all possible values taken by the variables.

  @return the abstracted %ADD.

  @sideeffect None

  @see Cudd_addUnivAbstract Cudd_bddExistAbstract
  Cudd_addOrAbstract

*/
DdNode *
Cudd_addExistAbstract(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode *res;

    if (addCheckPositiveCube(manager, cube) == 0) {
        (void) fprintf(manager->err,"Error: Can only abstract cubes");
        return(NULL);
    }

    do {
	manager->reordered = 0;
	res = cuddAddExistAbstractRecur(manager, f, cube);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_addExistAbstract */


/**
  @brief Universally Abstracts all the variables in cube from f.

  @details Abstracts all the variables in cube from f by taking
  the product over all possible values taken by the variable.

  @return the abstracted %ADD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addExistAbstract Cudd_bddUnivAbstract
  Cudd_addOrAbstract

*/
DdNode *
Cudd_addUnivAbstract(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode		*res;

    if (addCheckPositiveCube(manager, cube) == 0) {
	(void) fprintf(manager->err,"Error:  Can only abstract cubes");
	return(NULL);
    }

    do {
	manager->reordered = 0;
	res = cuddAddUnivAbstractRecur(manager, f, cube);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_addUnivAbstract */


/**
  @brief Disjunctively abstracts all the variables in cube from the
  0-1 %ADD f.

  @details Abstracts all the variables in cube from the 0-1 %ADD f
  by taking the disjunction over all possible values taken by the
  variables.

  @return the abstracted %ADD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addUnivAbstract Cudd_addExistAbstract

*/
DdNode *
Cudd_addOrAbstract(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode *res;

    if (addCheckPositiveCube(manager, cube) == 0) {
        (void) fprintf(manager->err,"Error: Can only abstract cubes");
        return(NULL);
    }

    do {
	manager->reordered = 0;
	res = cuddAddOrAbstractRecur(manager, f, cube);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }
    return(res);

} /* end of Cudd_addOrAbstract */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_addExistAbstract.

  @details Returns the %ADD obtained by abstracting the variables of
  cube from f, if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
cuddAddExistAbstractRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode	*T, *E, *res, *res1, *res2, *zero;

    statLine(manager);
    zero = DD_ZERO(manager);

    /* Cube is guaranteed to be a cube at this point. */	
    if (f == zero || cuddIsConstant(cube)) {  
        return(f);
    }

    /* Abstract a variable that does not appear in f => multiply by 2. */
    if (cuddI(manager,f->index) > cuddI(manager,cube->index)) {
	res1 = cuddAddExistAbstractRecur(manager, f, cuddT(cube));
	if (res1 == NULL) return(NULL);
	cuddRef(res1);
	/* Use the "internal" procedure to be alerted in case of
	** dynamic reordering. If dynamic reordering occurs, we
	** have to abort the entire abstraction.
	*/
	res = cuddAddApplyRecur(manager,Cudd_addPlus,res1,res1);
	if (res == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDeref(manager,res1);
	cuddDeref(res);
        return(res);
    }

    if ((res = cuddCacheLookup2(manager, Cudd_addExistAbstract, f, cube)) != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(manager);

    T = cuddT(f);
    E = cuddE(f);

    /* If the two indices are the same, so are their levels. */
    if (f->index == cube->index) {
	res1 = cuddAddExistAbstractRecur(manager, T, cuddT(cube));
	if (res1 == NULL) return(NULL);
        cuddRef(res1);
	res2 = cuddAddExistAbstractRecur(manager, E, cuddT(cube));
	if (res2 == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    return(NULL);
	}
        cuddRef(res2);
	res = cuddAddApplyRecur(manager, Cudd_addPlus, res1, res2);
	if (res == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    Cudd_RecursiveDeref(manager,res2);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDeref(manager,res1);
	Cudd_RecursiveDeref(manager,res2);
	cuddCacheInsert2(manager, Cudd_addExistAbstract, f, cube, res);
	cuddDeref(res);
        return(res);
    } else { /* if (cuddI(manager,f->index) < cuddI(manager,cube->index)) */
	res1 = cuddAddExistAbstractRecur(manager, T, cube);
	if (res1 == NULL) return(NULL);
        cuddRef(res1);
	res2 = cuddAddExistAbstractRecur(manager, E, cube);
	if (res2 == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    return(NULL);
	}
        cuddRef(res2);
	res = (res1 == res2) ? res1 :
	    cuddUniqueInter(manager, (int) f->index, res1, res2);
	if (res == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    Cudd_RecursiveDeref(manager,res2);
	    return(NULL);
	}
	cuddDeref(res1);
	cuddDeref(res2);
	cuddCacheInsert2(manager, Cudd_addExistAbstract, f, cube, res);
        return(res);
    }	    

} /* end of cuddAddExistAbstractRecur */


/**
  @brief Performs the recursive step of Cudd_addUnivAbstract.

  @return the %ADD obtained by abstracting the variables of cube from
  f, if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
cuddAddUnivAbstractRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode	*T, *E, *res, *res1, *res2, *one, *zero;

    statLine(manager);
    one = DD_ONE(manager);
    zero = DD_ZERO(manager);

    /* Cube is guaranteed to be a cube at this point.
    ** zero and one are the only constatnts c such that c*c=c.
    */
    if (f == zero || f == one || cube == one) {  
	return(f);
    }

    /* Abstract a variable that does not appear in f. */
    if (cuddI(manager,f->index) > cuddI(manager,cube->index)) {
	res1 = cuddAddUnivAbstractRecur(manager, f, cuddT(cube));
	if (res1 == NULL) return(NULL);
	cuddRef(res1);
	/* Use the "internal" procedure to be alerted in case of
	** dynamic reordering. If dynamic reordering occurs, we
	** have to abort the entire abstraction.
	*/
	res = cuddAddApplyRecur(manager, Cudd_addTimes, res1, res1);
	if (res == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDeref(manager,res1);
	cuddDeref(res);
	return(res);
    }

    if ((res = cuddCacheLookup2(manager, Cudd_addUnivAbstract, f, cube)) != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(manager);

    T = cuddT(f);
    E = cuddE(f);

    /* If the two indices are the same, so are their levels. */
    if (f->index == cube->index) {
	res1 = cuddAddUnivAbstractRecur(manager, T, cuddT(cube));
	if (res1 == NULL) return(NULL);
        cuddRef(res1);
	res2 = cuddAddUnivAbstractRecur(manager, E, cuddT(cube));
	if (res2 == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    return(NULL);
	}
        cuddRef(res2);
	res = cuddAddApplyRecur(manager, Cudd_addTimes, res1, res2);
	if (res == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    Cudd_RecursiveDeref(manager,res2);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDeref(manager,res1);
	Cudd_RecursiveDeref(manager,res2);
	cuddCacheInsert2(manager, Cudd_addUnivAbstract, f, cube, res);
	cuddDeref(res);
        return(res);
    } else { /* if (cuddI(manager,f->index) < cuddI(manager,cube->index)) */
	res1 = cuddAddUnivAbstractRecur(manager, T, cube);
	if (res1 == NULL) return(NULL);
        cuddRef(res1);
	res2 = cuddAddUnivAbstractRecur(manager, E, cube);
	if (res2 == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    return(NULL);
	}
        cuddRef(res2);
	res = (res1 == res2) ? res1 :
	    cuddUniqueInter(manager, (int) f->index, res1, res2);
	if (res == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    Cudd_RecursiveDeref(manager,res2);
	    return(NULL);
	}
	cuddDeref(res1);
	cuddDeref(res2);
	cuddCacheInsert2(manager, Cudd_addUnivAbstract, f, cube, res);
        return(res);
    }

} /* end of cuddAddUnivAbstractRecur */


/**
  @brief Performs the recursive step of Cudd_addOrAbstract.

  @return the %ADD obtained by abstracting the variables of cube from
  f, if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
cuddAddOrAbstractRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode	*T, *E, *res, *res1, *res2, *one;

    statLine(manager);
    one = DD_ONE(manager);

    /* Cube is guaranteed to be a cube at this point. */
    if (cuddIsConstant(f) || cube == one) {  
	return(f);
    }

    /* Abstract a variable that does not appear in f. */
    if (cuddI(manager,f->index) > cuddI(manager,cube->index)) {
	res = cuddAddOrAbstractRecur(manager, f, cuddT(cube));
	return(res);
    }

    if ((res = cuddCacheLookup2(manager, Cudd_addOrAbstract, f, cube)) != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(manager);

    T = cuddT(f);
    E = cuddE(f);

    /* If the two indices are the same, so are their levels. */
    if (f->index == cube->index) {
	res1 = cuddAddOrAbstractRecur(manager, T, cuddT(cube));
	if (res1 == NULL) return(NULL);
        cuddRef(res1);
	if (res1 != one) {
	    res2 = cuddAddOrAbstractRecur(manager, E, cuddT(cube));
	    if (res2 == NULL) {
		Cudd_RecursiveDeref(manager,res1);
		return(NULL);
	    }
	    cuddRef(res2);
	    res = cuddAddApplyRecur(manager, Cudd_addOr, res1, res2);
	    if (res == NULL) {
		Cudd_RecursiveDeref(manager,res1);
		Cudd_RecursiveDeref(manager,res2);
		return(NULL);
	    }
	    cuddRef(res);
	    Cudd_RecursiveDeref(manager,res1);
	    Cudd_RecursiveDeref(manager,res2);
	} else {
	    res = res1;
	}
	cuddCacheInsert2(manager, Cudd_addOrAbstract, f, cube, res);
	cuddDeref(res);
        return(res);
    } else { /* if (cuddI(manager,f->index) < cuddI(manager,cube->index)) */
	res1 = cuddAddOrAbstractRecur(manager, T, cube);
	if (res1 == NULL) return(NULL);
        cuddRef(res1);
	res2 = cuddAddOrAbstractRecur(manager, E, cube);
	if (res2 == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    return(NULL);
	}
        cuddRef(res2);
	res = (res1 == res2) ? res1 :
	    cuddUniqueInter(manager, (int) f->index, res1, res2);
	if (res == NULL) {
	    Cudd_RecursiveDeref(manager,res1);
	    Cudd_RecursiveDeref(manager,res2);
	    return(NULL);
	}
	cuddDeref(res1);
	cuddDeref(res2);
	cuddCacheInsert2(manager, Cudd_addOrAbstract, f, cube, res);
        return(res);
    }

} /* end of cuddAddOrAbstractRecur */



/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Checks whether cube is an %ADD representing the product
  of positive literals.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
addCheckPositiveCube(
  DdManager * manager,
  DdNode * cube)
{
    if (Cudd_IsComplement(cube)) return(0);
    if (cube == DD_ONE(manager)) return(1);
    if (cuddIsConstant(cube)) return(0);
    if (cuddE(cube) == DD_ZERO(manager)) {
        return(addCheckPositiveCube(manager, cuddT(cube)));
    }
    return(0);

} /* end of addCheckPositiveCube */

cuddAddApply.c
18658
/**
  @file

  @ingroup cudd

  @brief Apply functions for ADDs and their operators.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Applies op to the corresponding discriminants of f and g.

  @return a pointer to the result if succssful; NULL otherwise.

  @sideeffect None

  @see Cudd_addMonadicApply Cudd_addPlus Cudd_addTimes
  Cudd_addThreshold Cudd_addSetNZ Cudd_addDivide Cudd_addMinus Cudd_addMinimum
  Cudd_addMaximum Cudd_addOneZeroMaximum Cudd_addDiff Cudd_addAgreement
  Cudd_addOr Cudd_addNand Cudd_addNor Cudd_addXor Cudd_addXnor

*/
DdNode *
Cudd_addApply(
  DdManager * dd /**< manager */,
  DD_AOP op /**< operator */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddAddApplyRecur(dd,op,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_addApply */


/**
  @brief Integer and floating point addition.

  @return NULL if not a terminal case; f+g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addPlus(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *res;
    DdNode *F, *G;
    CUDD_VALUE_TYPE value;

    F = *f; G = *g;
    if (F == DD_ZERO(dd)) return(G);
    if (G == DD_ZERO(dd)) return(F);
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	value = cuddV(F)+cuddV(G);
	res = cuddUniqueConst(dd,value);
	return(res);
    }
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addPlus */


/**
  @brief Integer and floating point multiplication.

  @details This function can be used also to take the AND of two 0-1
  ADDs.

  @return NULL if not a terminal case; f * g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addTimes(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *res;
    DdNode *F, *G;
    CUDD_VALUE_TYPE value;

    F = *f; G = *g;
    if (F == DD_ZERO(dd) || G == DD_ZERO(dd)) return(DD_ZERO(dd));
    if (F == DD_ONE(dd)) return(G);
    if (G == DD_ONE(dd)) return(F);
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	value = cuddV(F)*cuddV(G);
	res = cuddUniqueConst(dd,value);
	return(res);
    }
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addTimes */


/**
  @brief f if f&ge;g; 0 if f&lt;g.

  @details Threshold operator for Apply (f if f &ge;g; 0 if f&lt;g).

  @return NULL if not a terminal case; f op g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addThreshold(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == G || F == DD_PLUS_INFINITY(dd)) return(F);
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	if (cuddV(F) >= cuddV(G)) {
	    return(F);
	} else {
	    return(DD_ZERO(dd));
	}
    }
    return(NULL);

} /* end of Cudd_addThreshold */


/**
  @brief This operator sets f to the value of g wherever g != 0.

  @return NULL if not a terminal case; f op g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addSetNZ(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == G) return(F);
    if (F == DD_ZERO(dd)) return(G);
    if (G == DD_ZERO(dd)) return(F);
    if (cuddIsConstant(G)) return(G);
    return(NULL);

} /* end of Cudd_addSetNZ */


/**
  @brief Integer and floating point division.

  @return NULL if not a terminal case; f / g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addDivide(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *res;
    DdNode *F, *G;
    CUDD_VALUE_TYPE value;

    F = *f; G = *g;
    /* We would like to use F == G -> F/G == 1, but F and G may
    ** contain zeroes. */
    if (F == DD_ZERO(dd)) return(DD_ZERO(dd));
    if (G == DD_ONE(dd)) return(F);
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	value = cuddV(F)/cuddV(G);
	res = cuddUniqueConst(dd,value);
	return(res);
    }
    return(NULL);

} /* end of Cudd_addDivide */


/**
  @brief Integer and floating point subtraction.

  @return NULL if not a terminal case; f - g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addMinus(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *res;
    DdNode *F, *G;
    CUDD_VALUE_TYPE value;

    F = *f; G = *g;
    if (F == G) return(DD_ZERO(dd));
    if (F == DD_ZERO(dd)) return(cuddAddNegateRecur(dd,G));
    if (G == DD_ZERO(dd)) return(F);
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	value = cuddV(F)-cuddV(G);
	res = cuddUniqueConst(dd,value);
	return(res);
    }
    return(NULL);

} /* end of Cudd_addMinus */


/**
  @brief Integer and floating point min.

  @details Integer and floating point min for Cudd_addApply.
  
  @return NULL if not a terminal case; min(f,g) otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addMinimum(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == DD_PLUS_INFINITY(dd)) return(G);
    if (G == DD_PLUS_INFINITY(dd)) return(F);
    if (F == G) return(F);
#if 0
    /* These special cases probably do not pay off. */
    if (F == DD_MINUS_INFINITY(dd)) return(F);
    if (G == DD_MINUS_INFINITY(dd)) return(G);
#endif
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	if (cuddV(F) <= cuddV(G)) {
	    return(F);
	} else {
	    return(G);
	}
    }
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addMinimum */


/**
  @brief Integer and floating point max.

  @details Integer and floating point max for Cudd_addApply.

  @return NULL if not a terminal case; max(f,g) otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addMaximum(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == G) return(F);
    if (F == DD_MINUS_INFINITY(dd)) return(G);
    if (G == DD_MINUS_INFINITY(dd)) return(F);
#if 0
    /* These special cases probably do not pay off. */
    if (F == DD_PLUS_INFINITY(dd)) return(F);
    if (G == DD_PLUS_INFINITY(dd)) return(G);
#endif
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	if (cuddV(F) >= cuddV(G)) {
	    return(F);
	} else {
	    return(G);
	}
    }
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addMaximum */


/**
  @brief Returns 1 if f &gt; g and 0 otherwise.

  @details Used in conjunction with Cudd_addApply.

  @return NULL if not a terminal case.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addOneZeroMaximum(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{

    if (*f == *g) return(DD_ZERO(dd));
    if (*g == DD_PLUS_INFINITY(dd))
	return DD_ZERO(dd);
    if (cuddIsConstant(*f) && cuddIsConstant(*g)) {
	if (cuddV(*f) > cuddV(*g)) {
	    return(DD_ONE(dd));
	} else {
	    return(DD_ZERO(dd));
	}
    }

    return(NULL);

} /* end of Cudd_addOneZeroMaximum */


/**
  @brief Returns plusinfinity if f=g; returns min(f,g) if f!=g.

  @return NULL if not a terminal case; f op g otherwise, where f op g
  is plusinfinity if f=g; min(f,g) if f!=g.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addDiff(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == G) return(DD_PLUS_INFINITY(dd));
    if (F == DD_PLUS_INFINITY(dd)) return(G);
    if (G == DD_PLUS_INFINITY(dd)) return(F);
    if (cuddIsConstant(F) && cuddIsConstant(G)) {
	if (cuddV(F) != cuddV(G)) {
	    if (cuddV(F) < cuddV(G)) {
		return(F);
	    } else {
		return(G);
	    }
	} else {
	    return(DD_PLUS_INFINITY(dd));
	}
    }
    return(NULL);

} /* end of Cudd_addDiff */


/**
  @brief f if f==g; background if f!=g.

  @return NULL if not a terminal case; f op g otherwise, where f op g
  is f if f==g; background if f!=g.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addAgreement(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == G) return(F);
    if (F == dd->background) return(F);
    if (G == dd->background) return(G);
    if (cuddIsConstant(F) && cuddIsConstant(G)) return(dd->background);
    return(NULL);

} /* end of Cudd_addAgreement */


/**
  @brief Disjunction of two 0-1 ADDs.

  @return NULL if not a terminal case; f OR g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addOr(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == DD_ONE(dd) || G == DD_ONE(dd)) return(DD_ONE(dd));
    if (cuddIsConstant(F)) return(G);
    if (cuddIsConstant(G)) return(F);
    if (F == G) return(F);
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addOr */


/**
  @brief NAND of two 0-1 ADDs.

  @return NULL if not a terminal case; f NAND g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addNand(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == DD_ZERO(dd) || G == DD_ZERO(dd)) return(DD_ONE(dd));
    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ZERO(dd));
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addNand */


/**
  @brief NOR of two 0-1 ADDs.

  @return NULL if not a terminal case; f NOR g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addNor(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == DD_ONE(dd) || G == DD_ONE(dd)) return(DD_ZERO(dd));
    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ONE(dd));
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addNor */


/**
  @brief XOR of two 0-1 ADDs.

  @return NULL if not a terminal case; f XOR g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addXor(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == G) return(DD_ZERO(dd));
    if (F == DD_ONE(dd) && G == DD_ZERO(dd)) return(DD_ONE(dd));
    if (G == DD_ONE(dd) && F == DD_ZERO(dd)) return(DD_ONE(dd));
    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ZERO(dd));
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addXor */


/**
  @brief XNOR of two 0-1 ADDs.

  @return NULL if not a terminal case; f XNOR g otherwise.

  @sideeffect None

  @see Cudd_addApply

*/
DdNode *
Cudd_addXnor(
  DdManager * dd,
  DdNode ** f,
  DdNode ** g)
{
    DdNode *F, *G;

    F = *f; G = *g;
    if (F == G) return(DD_ONE(dd));
    if (F == DD_ONE(dd) && G == DD_ONE(dd)) return(DD_ONE(dd));
    if (G == DD_ZERO(dd) && F == DD_ZERO(dd)) return(DD_ONE(dd));
    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ZERO(dd));
    if (F > G) { /* swap f and g */
	*f = G;
	*g = F;
    }
    return(NULL);

} /* end of Cudd_addXnor */


/**
  @brief Applies op to the discriminants of f.

  @return a pointer to the result if succssful; NULL otherwise.

  @sideeffect None

  @see Cudd_addApply Cudd_addLog

*/
DdNode *
Cudd_addMonadicApply(
  DdManager * dd,
  DD_MAOP op,
  DdNode * f)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddAddMonadicApplyRecur(dd,op,f);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_addMonadicApply */


/**
  @brief Natural logarithm of an %ADD.

  @details The discriminants of f must be positive double's.

  @return NULL if not a terminal case; log(f) otherwise.

  @sideeffect None

  @see Cudd_addMonadicApply

*/
DdNode *
Cudd_addLog(
  DdManager * dd,
  DdNode * f)
{
    if (cuddIsConstant(f)) {
	CUDD_VALUE_TYPE value = log(cuddV(f));
	DdNode *res = cuddUniqueConst(dd,value);
	return(res);
    }
    return(NULL);

} /* end of Cudd_addLog */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_addApply.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see cuddAddMonadicApplyRecur

*/
DdNode *
cuddAddApplyRecur(
  DdManager * dd,
  DD_AOP op,
  DdNode * f,
  DdNode * g)
{
    DdNode *res,
	   *fv, *fvn, *gv, *gvn,
	   *T, *E;
    int ford, gord;
    unsigned int index;
    DD_CTFP cacheOp;

    /* Check terminal cases. Op may swap f and g to increase the
     * cache hit rate.
     */
    statLine(dd);
    res = (*op)(dd,&f,&g);
    if (res != NULL) return(res);

    /* Check cache. */
    cacheOp = (DD_CTFP) op;
    res = cuddCacheLookup2(dd,cacheOp,f,g);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    ford = cuddI(dd,f->index);
    gord = cuddI(dd,g->index);
    if (ford <= gord) {
	index = f->index;
	fv = cuddT(f);
	fvn = cuddE(f);
    } else {
	index = g->index;
	fv = fvn = f;
    }
    if (gord <= ford) {
	gv = cuddT(g);
	gvn = cuddE(g);
    } else {
	gv = gvn = g;
    }

    T = cuddAddApplyRecur(dd,op,fv,gv);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = cuddAddApplyRecur(dd,op,fvn,gvn);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd,T);
	return(NULL);
    }
    cuddRef(E);

    res = (T == E) ? T : cuddUniqueInter(dd,(int)index,T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, T);
	Cudd_RecursiveDeref(dd, E);
	return(NULL);
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert2(dd,cacheOp,f,g,res);

    return(res);

} /* end of cuddAddApplyRecur */


/**
  @brief Performs the recursive step of Cudd_addMonadicApply.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see cuddAddApplyRecur

*/
DdNode *
cuddAddMonadicApplyRecur(
  DdManager * dd,
  DD_MAOP op,
  DdNode * f)
{
    DdNode *res, *ft, *fe, *T, *E;
    unsigned int index;

    /* Check terminal cases. */
    statLine(dd);
    res = (*op)(dd,f);
    if (res != NULL) return(res);

    /* Check cache. */
    res = cuddCacheLookup1(dd,op,f);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    index = f->index;
    ft = cuddT(f);
    fe = cuddE(f);

    T = cuddAddMonadicApplyRecur(dd,op,ft);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = cuddAddMonadicApplyRecur(dd,op,fe);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd,T);
	return(NULL);
    }
    cuddRef(E);

    res = (T == E) ? T : cuddUniqueInter(dd,(int)index,T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, T);
	Cudd_RecursiveDeref(dd, E);
	return(NULL);
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert1(dd,op,f,res);

    return(res);

} /* end of cuddAddMonadicApplyRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

cuddAddFind.c
8030
/**
  @file

  @ingroup cudd

  @brief Functions to find maximum and minimum in an %ADD and to
  extract the i-th bit.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * addDoIthBit (DdManager *dd, DdNode *f, DdNode *index);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Finds the maximum discriminant of f.

  @return a pointer to a constant %ADD.

  @sideeffect None

*/
DdNode *
Cudd_addFindMax(
  DdManager * dd,
  DdNode * f)
{
    DdNode *t, *e, *res;

    statLine(dd);
    if (cuddIsConstant(f)) {
	return(f);
    }

    res = cuddCacheLookup1(dd,Cudd_addFindMax,f);
    if (res != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(dd);

    t  = Cudd_addFindMax(dd,cuddT(f));
    if (t == DD_PLUS_INFINITY(dd)) return(t);

    e  = Cudd_addFindMax(dd,cuddE(f));

    res = (cuddV(t) >= cuddV(e)) ? t : e;

    cuddCacheInsert1(dd,Cudd_addFindMax,f,res);

    return(res);

} /* end of Cudd_addFindMax */


/**
  @brief Finds the minimum discriminant of f.

  @return a pointer to a constant %ADD.

  @sideeffect None

*/
DdNode *
Cudd_addFindMin(
  DdManager * dd,
  DdNode * f)
{
    DdNode *t, *e, *res;

    statLine(dd);
    if (cuddIsConstant(f)) {
	return(f);
    }

    res = cuddCacheLookup1(dd,Cudd_addFindMin,f);
    if (res != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(dd);

    t  = Cudd_addFindMin(dd,cuddT(f));
    if (t == DD_MINUS_INFINITY(dd)) return(t);

    e  = Cudd_addFindMin(dd,cuddE(f));

    res = (cuddV(t) <= cuddV(e)) ? t : e;

    cuddCacheInsert1(dd,Cudd_addFindMin,f,res);

    return(res);

} /* end of Cudd_addFindMin */


/**
  @brief Extracts the i-th bit from an %ADD.

  @details Produces an %ADD from another %ADD by replacing all
  discriminants whose i-th bit is equal to 1 with 1, and all other
  discriminants with 0. The i-th bit refers to the integer
  representation of the leaf value. If the value has a fractional
  part, it is ignored. Repeated calls to this procedure allow one to
  transform an integer-valued %ADD into an array of ADDs, one for each
  bit of the leaf values.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addBddIthBit

*/
DdNode *
Cudd_addIthBit(
  DdManager * dd,
  DdNode * f,
  int  bit)
{
    DdNode *res;
    DdNode *index;
    
    /* Use a constant node to remember the bit, so that we can use the
    ** global cache.
    */
    index = cuddUniqueConst(dd,(CUDD_VALUE_TYPE) bit);
    if (index == NULL) return(NULL);
    cuddRef(index);

    do {
	dd->reordered = 0;
	res = addDoIthBit(dd, f, index);
    } while (dd->reordered == 1);

    if (res == NULL) {
	Cudd_RecursiveDeref(dd, index);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, index);
    cuddDeref(res);
    return(res);

} /* end of Cudd_addIthBit */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step for Cudd_addIthBit.

  @return a pointer to the %BDD if successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
addDoIthBit(
  DdManager * dd,
  DdNode * f,
  DdNode * index)
{
    DdNode *res, *T, *E;
    DdNode *fv, *fvn;
    unsigned int mask, value;
    DdHalfWord v;

    statLine(dd);
    /* Check terminal case. */
    if (cuddIsConstant(f)) {
	mask = 1U << ((unsigned int) cuddV(index));
	value = (unsigned) (int) cuddV(f);
	return((value & mask) == 0 ? DD_ZERO(dd) : DD_ONE(dd));
    }

    /* Check cache. */
    res = cuddCacheLookup2(dd,addDoIthBit,f,index);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    v = f->index;
    fv = cuddT(f); fvn = cuddE(f);

    T = addDoIthBit(dd,fv,index);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = addDoIthBit(dd,fvn,index);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);

    res = (T == E) ? T : cuddUniqueInter(dd,v,T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, T);
	Cudd_RecursiveDeref(dd, E);
	return(NULL);
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert2(dd,addDoIthBit,f,index,res);

    return(res);

} /* end of addDoIthBit */


cuddAddInv.c
6077
/**
  @file

  @ingroup cudd

  @brief Function to compute the scalar inverse of an %ADD.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes the scalar inverse of an %ADD.
  
  @details Computes an n %ADD where the discriminants are the
  multiplicative inverses of the corresponding discriminants of the
  argument %ADD.

  @return a pointer to the resulting %ADD in case of success. Returns
  NULL if any discriminants smaller than epsilon is encountered.

  @sideeffect None

*/
DdNode *
Cudd_addScalarInverse(
  DdManager * dd,
  DdNode * f,
  DdNode * epsilon)
{
    DdNode *res;

    if (!cuddIsConstant(epsilon)) {
	(void) fprintf(dd->err,"Invalid epsilon\n");
	return(NULL);
    }
    do {
	dd->reordered = 0;
	res  = cuddAddScalarInverseRecur(dd,f,epsilon);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addScalarInverse */

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of addScalarInverse.

  @return a pointer to the resulting %ADD in case of success. Returns
  NULL if any discriminants smaller than epsilon is encountered.

  @sideeffect None

*/
DdNode *
cuddAddScalarInverseRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * epsilon)
{
    DdNode *t, *e, *res;
    CUDD_VALUE_TYPE value;

    statLine(dd);
    if (cuddIsConstant(f)) {
	if (ddAbs(cuddV(f)) < cuddV(epsilon)) return(NULL);
	value = 1.0 / cuddV(f);
	res = cuddUniqueConst(dd,value);
	return(res);
    }

    res = cuddCacheLookup2(dd,Cudd_addScalarInverse,f,epsilon);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    t = cuddAddScalarInverseRecur(dd,cuddT(f),epsilon);
    if (t == NULL) return(NULL);
    cuddRef(t);

    e = cuddAddScalarInverseRecur(dd,cuddE(f),epsilon);
    if (e == NULL) {
	Cudd_RecursiveDeref(dd, t);
	return(NULL);
    }
    cuddRef(e);

    res = (t == e) ? t : cuddUniqueInter(dd,(int)f->index,t,e);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, t);
	Cudd_RecursiveDeref(dd, e);
	return(NULL);
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert2(dd,Cudd_addScalarInverse,f,epsilon,res);

    return(res);

} /* end of cuddAddScalarInverseRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


cuddAddIte.c
15444
/**
  @file 

  @ingroup cudd

  @brief %ADD ITE function and satellites.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void addVarToConst (DdNode *f, DdNode **gp, DdNode **hp, DdNode *one, DdNode *zero);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements ITE(f,g,h).

  @details This procedure assumes that f is a 0-1 %ADD.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_bddIte Cudd_addIteConstant Cudd_addApply

*/
DdNode *
Cudd_addIte(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddAddIteRecur(dd,f,g,h);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addIte */


/**
  @brief Implements ITEconstant for %ADDs.

  @details f must be a 0-1 %ADD.  No new nodes are created. This
  function can be used, for instance, to check that g has a constant
  value (specified by h) whenever f is 1. If the constant value is
  unknown, then one should use Cudd_addEvalConst.

  @return a pointer to the resulting %ADD (which may or may not be
  constant) or DD_NON_CONSTANT.

  @sideeffect None

  @see Cudd_addIte Cudd_addEvalConst Cudd_bddIteConstant

*/
DdNode *
Cudd_addIteConstant(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    DdNode *one,*zero;
    DdNode *Fv,*Fnv,*Gv,*Gnv,*Hv,*Hnv,*r,*t,*e;
    int topf,topg,toph,v;

    statLine(dd);
    /* Trivial cases. */
    if (f == (one = DD_ONE(dd))) {	/* ITE(1,G,H) = G */
        return(g);
    }
    if (f == (zero = DD_ZERO(dd))) {	/* ITE(0,G,H) = H */
        return(h);
    }

    /* From now on, f is known not to be a constant. */
    addVarToConst(f,&g,&h,one,zero);

    /* Check remaining one variable cases. */
    if (g == h) { 			/* ITE(F,G,G) = G */
        return(g);
    }
    if (cuddIsConstant(g) && cuddIsConstant(h)) {
        return(DD_NON_CONSTANT);
    }

    topf = cuddI(dd,f->index);
    topg = cuddI(dd,g->index);
    toph = cuddI(dd,h->index);
    v = ddMin(topg,toph);

    /* ITE(F,G,H) = (x,G,H) (non constant) if F = (x,1,0), x < top(G,H). */
    if (topf < v && cuddIsConstant(cuddT(f)) && cuddIsConstant(cuddE(f))) {
	return(DD_NON_CONSTANT);
    }

    /* Check cache. */
    r = cuddConstantLookup(dd,DD_ADD_ITE_CONSTANT_TAG,f,g,h);
    if (r != NULL) {
        return(r);
    }

    /* Compute cofactors. */
    if (topf <= v) {
	v = ddMin(topf,v);	/* v = top_var(F,G,H) */
        Fv = cuddT(f); Fnv = cuddE(f);
    } else {
        Fv = Fnv = f;
    }
    if (topg == v) {
        Gv = cuddT(g); Gnv = cuddE(g);
    } else {
        Gv = Gnv = g;
    }
    if (toph == v) {
        Hv = cuddT(h); Hnv = cuddE(h);
    } else {
        Hv = Hnv = h;
    }
    
    /* Recursive step. */
    t = Cudd_addIteConstant(dd,Fv,Gv,Hv);
    if (t == DD_NON_CONSTANT || !cuddIsConstant(t)) {
	cuddCacheInsert(dd, DD_ADD_ITE_CONSTANT_TAG, f, g, h, DD_NON_CONSTANT);
	return(DD_NON_CONSTANT);
    }
    e = Cudd_addIteConstant(dd,Fnv,Gnv,Hnv);
    if (e == DD_NON_CONSTANT || !cuddIsConstant(e) || t != e) {
	cuddCacheInsert(dd, DD_ADD_ITE_CONSTANT_TAG, f, g, h, DD_NON_CONSTANT);
	return(DD_NON_CONSTANT);
    }
    cuddCacheInsert(dd, DD_ADD_ITE_CONSTANT_TAG, f, g, h, t);
    return(t);

} /* end of Cudd_addIteConstant */


/**
  @brief Checks whether %ADD g is constant whenever %ADD f is 1.

  @details f must be a 0-1 %ADD.  If f is identically 0, the check is
  assumed to be successful, and the background value is returned.  No
  new nodes are created.

  @return a pointer to the resulting %ADD (which may or may not be
  constant) or DD_NON_CONSTANT.

  @sideeffect None

  @see Cudd_addIteConstant Cudd_addLeq

*/
DdNode *
Cudd_addEvalConst(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *zero;
    DdNode *Fv,*Fnv,*Gv,*Gnv,*r,*t,*e;
    int topf,topg;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(f));
#endif

    statLine(dd);
    /* Terminal cases. */
    if (f == DD_ONE(dd) || cuddIsConstant(g)) {
        return(g);
    }
    if (f == (zero = DD_ZERO(dd))) {
        return(dd->background);
    }

#ifdef DD_DEBUG
    assert(!cuddIsConstant(f));
#endif
    /* From now on, f and g are known not to be constants. */

    topf = cuddI(dd,f->index);
    topg = cuddI(dd,g->index);

    /* Check cache. */
    r = cuddConstantLookup(dd,DD_ADD_EVAL_CONST_TAG,f,g,g);
    if (r != NULL) {
        return(r);
    }

    /* Compute cofactors. */
    if (topf <= topg) {
        Fv = cuddT(f); Fnv = cuddE(f);
    } else {
        Fv = Fnv = f;
    }
    if (topg <= topf) {
        Gv = cuddT(g); Gnv = cuddE(g);
    } else {
        Gv = Gnv = g;
    }
    
    /* Recursive step. */
    if (Fv != zero) {
	t = Cudd_addEvalConst(dd,Fv,Gv);
	if (t == DD_NON_CONSTANT || !cuddIsConstant(t)) {
	    cuddCacheInsert2(dd, Cudd_addEvalConst, f, g, DD_NON_CONSTANT);
	    return(DD_NON_CONSTANT);
	}
	if (Fnv != zero) {
	    e = Cudd_addEvalConst(dd,Fnv,Gnv);
	    if (e == DD_NON_CONSTANT || !cuddIsConstant(e) || t != e) {
		cuddCacheInsert2(dd, Cudd_addEvalConst, f, g, DD_NON_CONSTANT);
		return(DD_NON_CONSTANT);
	    }
	}
	cuddCacheInsert2(dd,Cudd_addEvalConst,f,g,t);
	return(t);
    } else { /* Fnv must be != zero */
	e = Cudd_addEvalConst(dd,Fnv,Gnv);
	cuddCacheInsert2(dd, Cudd_addEvalConst, f, g, e);
	return(e);
    }

} /* end of Cudd_addEvalConst */


/**
  @brief Computes the complement of an %ADD a la C language.

  @details The complement of 0 is 1 and the complement of everything
  else is 0.

  @return a pointer to the resulting %ADD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addNegate

*/
DdNode *
Cudd_addCmpl(
  DdManager * dd,
  DdNode * f)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddAddCmplRecur(dd,f);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addCmpl */


/**
  @brief Determines whether f is less than or equal to g.

  @details No new nodes are created. This procedure works for arbitrary ADDs.
  For 0-1 ADDs Cudd_addEvalConst is more efficient.

  @return 1 if f is less than or equal to g; 0 otherwise.

  @sideeffect None

  @see Cudd_addIteConstant Cudd_addEvalConst Cudd_bddLeq

*/
int
Cudd_addLeq(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *tmp, *fv, *fvn, *gv, *gvn;
    int topf, topg, res;

    /* Terminal cases. */
    if (f == g) return(1);

    statLine(dd);
    if (cuddIsConstant(f)) {
	if (cuddIsConstant(g)) return(cuddV(f) <= cuddV(g));
	if (f == DD_MINUS_INFINITY(dd)) return(1);
	if (f == DD_PLUS_INFINITY(dd)) return(0); /* since f != g */
    }
    if (g == DD_PLUS_INFINITY(dd)) return(1);
    if (g == DD_MINUS_INFINITY(dd)) return(0); /* since f != g */

    /* Check cache. */
    tmp = cuddCacheLookup2(dd,(DD_CTFP)Cudd_addLeq,f,g);
    if (tmp != NULL) {
	return(tmp == DD_ONE(dd));
    }

    /* Compute cofactors. One of f and g is not constant. */
    topf = cuddI(dd,f->index);
    topg = cuddI(dd,g->index);
    if (topf <= topg) {
	fv = cuddT(f); fvn = cuddE(f);
    } else {
	fv = fvn = f;
    }
    if (topg <= topf) {
	gv = cuddT(g); gvn = cuddE(g);
    } else {
	gv = gvn = g;
    }

    res = Cudd_addLeq(dd,fvn,gvn) && Cudd_addLeq(dd,fv,gv);

    /* Store result in cache and return. */
    cuddCacheInsert2(dd,(DD_CTFP) Cudd_addLeq,f,g,
		     Cudd_NotCond(DD_ONE(dd),res==0));
    return(res);

} /* end of Cudd_addLeq */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_addIte(f,g,h).

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addIte

*/
DdNode *
cuddAddIteRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    DdNode *one,*zero;
    DdNode *r,*Fv,*Fnv,*Gv,*Gnv,*Hv,*Hnv,*t,*e;
    int topf,topg,toph,v;
    unsigned int index;

    statLine(dd);
    /* Trivial cases. */

    /* One variable cases. */
    if (f == (one = DD_ONE(dd))) {	/* ITE(1,G,H) = G */
        return(g);
    }
    if (f == (zero = DD_ZERO(dd))) {	/* ITE(0,G,H) = H */
        return(h);
    }

    /* From now on, f is known to not be a constant. */
    addVarToConst(f,&g,&h,one,zero);

    /* Check remaining one variable cases. */
    if (g == h) {			/* ITE(F,G,G) = G */
        return(g);
    }

    if (g == one) {			/* ITE(F,1,0) = F */
        if (h == zero) return(f);
    }

    topf = cuddI(dd,f->index);
    topg = cuddI(dd,g->index);
    toph = cuddI(dd,h->index);
    v = ddMin(topg,toph);

    /* A shortcut: ITE(F,G,H) = (x,G,H) if F=(x,1,0), x < top(G,H). */
    if (topf < v && cuddT(f) == one && cuddE(f) == zero) {
	r = cuddUniqueInter(dd,(int)f->index,g,h);
	return(r);
    }
    if (topf < v && cuddT(f) == zero && cuddE(f) == one) {
	r = cuddUniqueInter(dd,(int)f->index,h,g);
	return(r);
    }

    /* Check cache. */
    r = cuddCacheLookup(dd,DD_ADD_ITE_TAG,f,g,h);
    if (r != NULL) {
        return(r);
    }

    checkWhetherToGiveUp(dd);

    /* Compute cofactors. */
    index = f->index;
    if (topf <= v) {
	v = ddMin(topf,v);	/* v = top_var(F,G,H) */
        Fv = cuddT(f); Fnv = cuddE(f);
    } else {
        Fv = Fnv = f;
    }
    if (topg == v) {
	index = g->index;
        Gv = cuddT(g); Gnv = cuddE(g);
    } else {
        Gv = Gnv = g;
    }
    if (toph == v) {
	index = h->index;
        Hv = cuddT(h); Hnv = cuddE(h);
    } else {
        Hv = Hnv = h;
    }
    
    /* Recursive step. */
    t = cuddAddIteRecur(dd,Fv,Gv,Hv);
    if (t == NULL) return(NULL);
    cuddRef(t);

    e = cuddAddIteRecur(dd,Fnv,Gnv,Hnv);
    if (e == NULL) {
	Cudd_RecursiveDeref(dd,t);
	return(NULL);
    }
    cuddRef(e);

    r = (t == e) ? t : cuddUniqueInter(dd,index,t,e);
    if (r == NULL) {
	Cudd_RecursiveDeref(dd,t);
	Cudd_RecursiveDeref(dd,e);
	return(NULL);
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert(dd,DD_ADD_ITE_TAG,f,g,h,r);

    return(r);

} /* end of cuddAddIteRecur */


/**
  @brief Performs the recursive step of Cudd_addCmpl.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addCmpl

*/
DdNode *
cuddAddCmplRecur(
  DdManager * dd,
  DdNode * f)
{
    DdNode *one,*zero;
    DdNode *r,*Fv,*Fnv,*t,*e;

    statLine(dd);
    one = DD_ONE(dd);
    zero = DD_ZERO(dd); 

    if (cuddIsConstant(f)) {
        if (f == zero) {
	    return(one);
	} else {
	    return(zero);
	}
    }
    r = cuddCacheLookup1(dd,Cudd_addCmpl,f);
    if (r != NULL) {
	return(r);
    }
    checkWhetherToGiveUp(dd);
    Fv = cuddT(f);
    Fnv = cuddE(f);
    t = cuddAddCmplRecur(dd,Fv);
    if (t == NULL) return(NULL);
    cuddRef(t);
    e = cuddAddCmplRecur(dd,Fnv);
    if (e == NULL) {
	Cudd_RecursiveDeref(dd,t);
	return(NULL);
    }
    cuddRef(e);
    r = (t == e) ? t : cuddUniqueInter(dd,(int)f->index,t,e);
    if (r == NULL) {
	Cudd_RecursiveDeref(dd, t);
	Cudd_RecursiveDeref(dd, e);
	return(NULL);
    }
    cuddDeref(t);
    cuddDeref(e);
    cuddCacheInsert1(dd,Cudd_addCmpl,f,r);
    return(r);

} /* end of cuddAddCmplRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Replaces variables with constants if possible (part of
  canonical form).

  @sideeffect None

*/
static void
addVarToConst(
  DdNode * f,
  DdNode ** gp,
  DdNode ** hp,
  DdNode * one,
  DdNode * zero)
{
    DdNode *g = *gp;
    DdNode *h = *hp;

    if (f == g) { /* ITE(F,F,H) = ITE(F,1,H) = F + H */
	*gp = one;
    }

    if (f == h) { /* ITE(F,G,F) = ITE(F,G,0) = F * G */
	*hp = zero;
    }

} /* end of addVarToConst */

cuddAddNeg.c
7421
/**
  @file

  @ingroup cudd

  @brief Function to compute the negation of an %ADD.

  @author Fabio Somenzi, Balakrishna Kumthekar

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Computes the additive inverse of an %ADD.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addCmpl

*/
DdNode *
Cudd_addNegate(
  DdManager * dd,
  DdNode * f)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddAddNegateRecur(dd,f);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addNegate */


/**
  @brief Rounds off the discriminants of an %ADD.

  @details The discriminants are rounded off to N digits after the
  decimal.

  @return a pointer to the result %ADD if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_addRoundOff(
  DdManager * dd,
  DdNode * f,
  int  N)
{
    DdNode *res;
    double trunc = pow(10.0,(double)N);

    do {
	dd->reordered = 0;
	res = cuddAddRoundOffRecur(dd,f,trunc);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addRoundOff */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_addNegate.

  @return a pointer to the result.

  @sideeffect None

*/
DdNode *
cuddAddNegateRecur(
  DdManager * dd,
  DdNode * f)
{
    DdNode *res,
	    *fv, *fvn,
	    *T, *E;

    statLine(dd);
    /* Check terminal cases. */
    if (cuddIsConstant(f)) {
	res = cuddUniqueConst(dd,-cuddV(f));
	return(res);
    }

    /* Check cache */
    res = cuddCacheLookup1(dd,Cudd_addNegate,f);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive Step */
    fv = cuddT(f);
    fvn = cuddE(f);
    T = cuddAddNegateRecur(dd,fv);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = cuddAddNegateRecur(dd,fvn);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd,T);
	return(NULL);
    }
    cuddRef(E);
    res = (T == E) ? T : cuddUniqueInter(dd,(int)f->index,T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, T);
	Cudd_RecursiveDeref(dd, E);
	return(NULL);
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert1(dd,Cudd_addNegate,f,res);

    return(res);

} /* end of cuddAddNegateRecur */


/**
  @brief Implements the recursive step of Cudd_addRoundOff.

  @return a pointer to the result.

  @sideeffect None

*/
DdNode *
cuddAddRoundOffRecur(
  DdManager * dd,
  DdNode * f,
  double  trunc)
{

    DdNode *res, *fv, *fvn, *T, *E;
    double n;
    DD_CTFP1 cacheOp;

    statLine(dd);
    if (cuddIsConstant(f)) {
	n = ceil(cuddV(f)*trunc)/trunc;
	res = cuddUniqueConst(dd,n);
	return(res);
    }
    cacheOp = (DD_CTFP1) Cudd_addRoundOff;
    res = cuddCacheLookup1(dd,cacheOp,f);
    if (res != NULL) {
	return(res);
    }
    checkWhetherToGiveUp(dd);
    /* Recursive Step */
    fv = cuddT(f);
    fvn = cuddE(f);
    T = cuddAddRoundOffRecur(dd,fv,trunc);
    if (T == NULL) {
       return(NULL);
    }
    cuddRef(T);
    E = cuddAddRoundOffRecur(dd,fvn,trunc);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd,T);
	return(NULL);
    }
    cuddRef(E);
    res = (T == E) ? T : cuddUniqueInter(dd,(int)f->index,T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd,T);
	Cudd_RecursiveDeref(dd,E);
	return(NULL);
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert1(dd,cacheOp,f,res);
    return(res);

} /* end of cuddAddRoundOffRecur */

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

cuddAddWalsh.c
10664
/**
  @file

  @ingroup cudd

  @brief Functions that generate Walsh matrices and residue
  functions in %ADD form.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * addWalshInt (DdManager *dd, DdNode **x, DdNode **y, int n);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Generates a Walsh matrix in %ADD form.

  @return a pointer to the matrixi if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_addWalsh(
  DdManager * dd,
  DdNode ** x,
  DdNode ** y,
  int  n)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = addWalshInt(dd, x, y, n);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addWalsh */


/**
  @brief Builds an %ADD for the residue modulo m of an n-bit
  number.

  @details The modulus must be at least 2, and the number of bits at
  least 1. Parameter options specifies whether the MSB should be on top
  or the LSB; and whther the number whose residue is computed is in
  two's complement notation or not. The macro CUDD_RESIDUE_DEFAULT
  specifies LSB on top and unsigned number. The macro CUDD_RESIDUE_MSB
  specifies MSB on top, and the macro CUDD_RESIDUE_TC specifies two's
  complement residue. To request MSB on top and two's complement residue
  simultaneously, one can OR the two macros:
  CUDD_RESIDUE_MSB | CUDD_RESIDUE_TC.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

*/
DdNode *
Cudd_addResidue(
  DdManager * dd /**< manager */,
  int  n /**< number of bits */,
  int  m /**< modulus */,
  int  options /**< options */,
  int  top /**< index of top variable */)
{
    int msbLsb;	/* MSB on top (1) or LSB on top (0) */
    int tc;	/* two's complement (1) or unsigned (0) */
    int i, j, k, t, residue, thisOne, previous, index;
    DdNode **array[2], *var, *tmp, *res;

    /* Sanity check. */
    if (n < 1 && m < 2) return(NULL);

    msbLsb = options & CUDD_RESIDUE_MSB;
    tc = options & CUDD_RESIDUE_TC;

    /* Allocate and initialize working arrays. */
    array[0] = ALLOC(DdNode *,m);
    if (array[0] == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    array[1] = ALLOC(DdNode *,m);
    if (array[1] == NULL) {
	FREE(array[0]);
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < m; i++) {
	array[0][i] = array[1][i] = NULL;
    }

    /* Initialize residues. */
    for (i = 0; i < m; i++) {
	tmp = cuddUniqueConst(dd,(CUDD_VALUE_TYPE) i);
	if (tmp == NULL) {
	    for (j = 0; j < i; j++) {
		Cudd_RecursiveDeref(dd,array[1][j]);
	    }
	    FREE(array[0]);
	    FREE(array[1]);
	    return(NULL);
	}
	cuddRef(tmp);
	array[1][i] = tmp;
    }

    /* Main iteration. */
    residue = 1;	/* residue of 2**0 */
    for (k = 0; k < n; k++) {
	/* Choose current and previous arrays. */
	thisOne = k & 1;
	previous = thisOne ^ 1;
	/* Build an ADD projection function. */
	if (msbLsb) {
	    index = top+n-k-1;
	} else {
	    index = top+k;
	}
	var = cuddUniqueInter(dd,index,DD_ONE(dd),DD_ZERO(dd));
	if (var == NULL) {
	    for (j = 0; j < m; j++) {
		Cudd_RecursiveDeref(dd,array[previous][j]);
	    }
	    FREE(array[0]);
	    FREE(array[1]);
	    return(NULL);
	}
	cuddRef(var);
	for (i = 0; i < m; i ++) {
	    t = (i + residue) % m;
	    tmp = Cudd_addIte(dd,var,array[previous][t],array[previous][i]);
	    if (tmp == NULL) {
		for (j = 0; j < i; j++) {
		    Cudd_RecursiveDeref(dd,array[thisOne][j]);
		}
		for (j = 0; j < m; j++) {
		    Cudd_RecursiveDeref(dd,array[previous][j]);
		}
		FREE(array[0]);
		FREE(array[1]);
		return(NULL);
	    }
	    cuddRef(tmp);
	    array[thisOne][i] = tmp;
	}
	/* One layer completed. Free the other array for the next iteration. */
	for (i = 0; i < m; i++) {
	    Cudd_RecursiveDeref(dd,array[previous][i]);
	}
	Cudd_RecursiveDeref(dd,var);
	/* Update residue of 2**k. */
	residue = (2 * residue) % m;
	/* Adjust residue for MSB, if this is a two's complement number. */
	if (tc && (k == n - 1)) {
	    residue = (m - residue) % m;
	}
    }

    /* We are only interested in the 0-residue node of the top layer. */
    for (i = 1; i < m; i++) {
	Cudd_RecursiveDeref(dd,array[(n - 1) & 1][i]);
    }
    res = array[(n - 1) & 1][0];

    FREE(array[0]);
    FREE(array[1]);

    cuddDeref(res);
    return(res);

} /* end of Cudd_addResidue */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_addWalsh.

  @return a pointer to the matrixi if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addWalsh

*/
static DdNode *
addWalshInt(
  DdManager * dd,
  DdNode ** x,
  DdNode ** y,
  int  n)
{
    DdNode *one, *minusone;
    DdNode *t = NULL, *u, *t1, *u1, *v, *w;
    int     i;

    one = DD_ONE(dd);
    if (n == 0) return(one);

    /* Build bottom part of ADD outside loop */
    minusone = cuddUniqueConst(dd,(CUDD_VALUE_TYPE) -1);
    if (minusone == NULL) return(NULL);
    cuddRef(minusone);
    v = Cudd_addIte(dd, y[n-1], minusone, one);
    if (v == NULL) {
	Cudd_RecursiveDeref(dd, minusone);
	return(NULL);
    }
    cuddRef(v);
    u = Cudd_addIte(dd, x[n-1], v, one);
    if (u == NULL) {
	Cudd_RecursiveDeref(dd, minusone);
	Cudd_RecursiveDeref(dd, v);
	return(NULL);
    }
    cuddRef(u);
    Cudd_RecursiveDeref(dd, v);
    if (n>1) {
	w = Cudd_addIte(dd, y[n-1], one, minusone);
	if (w == NULL) {
	    Cudd_RecursiveDeref(dd, minusone);
	    Cudd_RecursiveDeref(dd, u);
	    return(NULL);
	}
	cuddRef(w);
	t = Cudd_addIte(dd, x[n-1], w, minusone);
	if (t == NULL) {
	    Cudd_RecursiveDeref(dd, minusone);
	    Cudd_RecursiveDeref(dd, u);
	    Cudd_RecursiveDeref(dd, w);
	    return(NULL);
	}
	cuddRef(t);
	Cudd_RecursiveDeref(dd, w);
    }
    cuddDeref(minusone); /* minusone is in the result; it won't die */

    /* Loop to build the rest of the ADD */
    for (i=n-2; i>=0; i--) {
	t1 = t; u1 = u;
	v = Cudd_addIte(dd, y[i], t1, u1);
	if (v == NULL) {
	    Cudd_RecursiveDeref(dd, u1);
	    Cudd_RecursiveDeref(dd, t1);
	    return(NULL);
	}
	cuddRef(v);
	u = Cudd_addIte(dd, x[i], v, u1);
	if (u == NULL) {
	    Cudd_RecursiveDeref(dd, u1);
	    Cudd_RecursiveDeref(dd, t1);
	    Cudd_RecursiveDeref(dd, v);
	    return(NULL);
	}
	cuddRef(u);
	Cudd_RecursiveDeref(dd, v);
	if (i>0) {
	    w = Cudd_addIte(dd, y[i], u1, t1);
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, u1);
		Cudd_RecursiveDeref(dd, t1);
		Cudd_RecursiveDeref(dd, u);
		return(NULL);
	    }
	    cuddRef(w);
	    t = Cudd_addIte(dd, x[i], w, t1);
	    if (u == NULL) {
		Cudd_RecursiveDeref(dd, u1);
		Cudd_RecursiveDeref(dd, t1);
		Cudd_RecursiveDeref(dd, u);
		Cudd_RecursiveDeref(dd, w);
		return(NULL);
	    }
	    cuddRef(t);
	    Cudd_RecursiveDeref(dd, w);
	}
	Cudd_RecursiveDeref(dd, u1);
	Cudd_RecursiveDeref(dd, t1);
    }

    cuddDeref(u);
    return(u);

} /* end of addWalshInt */

cuddAndAbs.c
10360
/**
  @file

  @ingroup cudd

  @brief Combined AND and existential abstraction for BDDs

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Takes the AND of two BDDs and simultaneously abstracts the
  variables in cube.

  @details The variables are existentially abstracted.
  Cudd_bddAndAbstract implements the semiring matrix multiplication
  algorithm for the boolean semiring.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addMatrixMultiply Cudd_addTriangle Cudd_bddAnd

*/
DdNode *
Cudd_bddAndAbstract(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  DdNode * cube)
{
    DdNode *res;

    do {
	manager->reordered = 0;
	res = cuddBddAndAbstractRecur(manager, f, g, cube);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }
    return(res);

} /* end of Cudd_bddAndAbstract */


/**
  @brief Takes the AND of two BDDs and simultaneously abstracts
  variables unless too many nodes are needed.

  @details The variables in cube are existentially abstracted.

  @return a pointer to the result is successful; NULL otherwise.
  In particular, if the number of new nodes created exceeds
  <code>limit</code>, this function returns NULL.

  @sideeffect None

  @see Cudd_bddAndAbstract

*/
DdNode *
Cudd_bddAndAbstractLimit(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  DdNode * cube,
  unsigned int limit)
{
    DdNode *res;
    unsigned int saveLimit = manager->maxLive;

    manager->maxLive = (manager->keys - manager->dead) +
      (manager->keysZ - manager->deadZ) + limit;
    do {
	manager->reordered = 0;
	res = cuddBddAndAbstractRecur(manager, f, g, cube);
    } while (manager->reordered == 1);
    manager->maxLive = saveLimit;
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }
    return(res);

} /* end of Cudd_bddAndAbstractLimit */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Takes the AND of two BDDs and simultaneously abstracts the
  variables in cube.

  @details The variables are existentially abstracted.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddAndAbstract

*/
DdNode *
cuddBddAndAbstractRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  DdNode * cube)
{
    DdNode *F, *ft, *fe, *G, *gt, *ge;
    DdNode *one, *zero, *r, *t, *e;
    int topf, topg, top, topcube;
    unsigned int index;

    statLine(manager);
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* Terminal cases. */
    if (f == zero || g == zero || f == Cudd_Not(g)) return(zero);
    if (f == one && g == one)	return(one);

    if (cube == one) {
	return(cuddBddAndRecur(manager, f, g));
    }
    if (f == one || f == g) {
	return(cuddBddExistAbstractRecur(manager, g, cube));
    }
    if (g == one) {
	return(cuddBddExistAbstractRecur(manager, f, cube));
    }
    /* At this point f, g, and cube are not constant. */

    if (f > g) { /* Try to increase cache efficiency. */
	DdNode *tmp = f;
	f = g;
	g = tmp;
    }

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    topf = manager->perm[F->index];
    topg = manager->perm[G->index];
    top = ddMin(topf, topg);
    topcube = manager->perm[cube->index];

    while (topcube < top) {
	cube = cuddT(cube);
	if (cube == one) {
	    return(cuddBddAndRecur(manager, f, g));
	}
	topcube = manager->perm[cube->index];
    }
    /* Now, topcube >= top. */

    /* Check cache. */
    if (F->ref != 1 || G->ref != 1) {
	r = cuddCacheLookup(manager, DD_BDD_AND_ABSTRACT_TAG, f, g, cube);
	if (r != NULL) {
	    return(r);
	}
    }

    checkWhetherToGiveUp(manager);

    if (topf == top) {
	index = F->index;
	ft = cuddT(F);
	fe = cuddE(F);
	if (Cudd_IsComplement(f)) {
	    ft = Cudd_Not(ft);
	    fe = Cudd_Not(fe);
	}
    } else {
	index = G->index;
	ft = fe = f;
    }

    if (topg == top) {
	gt = cuddT(G);
	ge = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gt = Cudd_Not(gt);
	    ge = Cudd_Not(ge);
	}
    } else {
	gt = ge = g;
    }

    if (topcube == top) {	/* quantify */
	DdNode *Cube = cuddT(cube);
	t = cuddBddAndAbstractRecur(manager, ft, gt, Cube);
	if (t == NULL) return(NULL);
	/* Special case: 1 OR anything = 1. Hence, no need to compute
	** the else branch if t is 1. Likewise t + t * anything == t.
	** Notice that t == fe implies that fe does not depend on the
	** variables in Cube. Likewise for t == ge.
	*/
	if (t == one || t == fe || t == ge) {
	    if (F->ref != 1 || G->ref != 1)
		cuddCacheInsert(manager, DD_BDD_AND_ABSTRACT_TAG,
				f, g, cube, t);
	    return(t);
	}
	cuddRef(t);
	/* Special case: t + !t * anything == t + anything. */
	if (t == Cudd_Not(fe)) {
	    e = cuddBddExistAbstractRecur(manager, ge, Cube);
	} else if (t == Cudd_Not(ge)) {
	    e = cuddBddExistAbstractRecur(manager, fe, Cube);
	} else {
	    e = cuddBddAndAbstractRecur(manager, fe, ge, Cube);
	}
	if (e == NULL) {
	    Cudd_IterDerefBdd(manager, t);
	    return(NULL);
	}
	if (t == e) {
	    r = t;
	    cuddDeref(t);
	} else {
	    cuddRef(e);
	    r = cuddBddAndRecur(manager, Cudd_Not(t), Cudd_Not(e));
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	    cuddRef(r);
	    Cudd_DelayedDerefBdd(manager, t);
	    Cudd_DelayedDerefBdd(manager, e);
	    cuddDeref(r);
	}
    } else {
	t = cuddBddAndAbstractRecur(manager, ft, gt, cube);
	if (t == NULL) return(NULL);
	cuddRef(t);
	e = cuddBddAndAbstractRecur(manager, fe, ge, cube);
	if (e == NULL) {
	    Cudd_IterDerefBdd(manager, t);
	    return(NULL);
	}
	if (t == e) {
	    r = t;
	    cuddDeref(t);
	} else {
	    cuddRef(e);
	    if (Cudd_IsComplement(t)) {
		r = cuddUniqueInter(manager, (int) index,
				    Cudd_Not(t), Cudd_Not(e));
		if (r == NULL) {
		    Cudd_IterDerefBdd(manager, t);
		    Cudd_IterDerefBdd(manager, e);
		    return(NULL);
		}
		r = Cudd_Not(r);
	    } else {
		r = cuddUniqueInter(manager,(int)index,t,e);
		if (r == NULL) {
		    Cudd_IterDerefBdd(manager, t);
		    Cudd_IterDerefBdd(manager, e);
		    return(NULL);
		}
	    }
	    cuddDeref(e);
	    cuddDeref(t);
	}
    }

    if (F->ref != 1 || G->ref != 1)
	cuddCacheInsert(manager, DD_BDD_AND_ABSTRACT_TAG, f, g, cube, r);
    return (r);

} /* end of cuddBddAndAbstractRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


cuddAnneal.c
19718
/**
  @file

  @ingroup cudd

  @brief Reordering of DDs based on simulated annealing

  @author Jae-Young Jang, Jorgen Sivesind

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* Annealing parameters */
#define BETA 0.6 
#define ALPHA 0.90
#define EXC_PROB 0.4 
#define JUMP_UP_PROB 0.36
#define MAXGEN_RATIO 15.0
#define STOP_TEMP 1.0

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int stopping_criterion (int c1, int c2, int c3, int c4, double temp);
static double random_generator (DdManager *dd);
static int ddExchange (DdManager *table, int x, int y, double temp);
static int ddJumpingAux (DdManager *table, int x, int x_low, int x_high, double temp);
static Move * ddJumpingUp (DdManager *table, int x, int x_low, int initial_size);
static Move * ddJumpingDown (DdManager *table, int x, int x_high, int initial_size);
static int siftBackwardProb (DdManager *table, Move *moves, int size, double temp);
static void copyOrder (DdManager *table, int *array, int lower, int upper);
static int restoreOrder (DdManager *table, int *array, int lower, int upper);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Get new variable-order by simulated annealing algorithm.

  @details Get x, y by random selection. Choose either
  exchange or jump randomly. In case of jump, choose between jump_up
  and jump_down randomly. Do exchange or jump and get optimal case.
  Loop until there is no improvement or temperature reaches
  minimum.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
cuddAnnealing(
  DdManager * table,
  int  lower,
  int  upper)
{
    int         nvars;
    int         size;
    int         x,y;
    int         result;
    int		c1, c2, c3, c4;
    int		BestCost;
    int		*BestOrder;
    double	NewTemp, temp;
    double	rand1;
    int         innerloop, maxGen;
    int         ecount, ucount, dcount;
   
    nvars = upper - lower + 1;

    result = cuddSifting(table,lower,upper);
#ifdef DD_STATS
    (void) fprintf(table->out,"\n");
#endif
    if (result == 0) return(0);

    size = (int) (table->keys - table->isolated);

    /* Keep track of the best order. */
    BestCost = size;
    BestOrder = ALLOC(int,nvars);
    if (BestOrder == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    copyOrder(table,BestOrder,lower,upper);

    temp = BETA * size;
    maxGen = (int) (MAXGEN_RATIO * nvars);

    c1 = size + 10;
    c2 = c1 + 10;
    c3 = size;
    c4 = c2 + 10;
    ecount = ucount = dcount = 0;
 
    while (!stopping_criterion(c1, c2, c3, c4, temp)) {
#ifdef DD_STATS
	(void) fprintf(table->out,"temp=%f\tsize=%d\tgen=%d\t",
		       temp,size,maxGen);
	table->tosses = table->acceptances = 0;
#endif
	for (innerloop = 0; innerloop < maxGen; innerloop++) {
	    /* Choose x, y  randomly. */
	    x = (int) Cudd_Random(table) % nvars;
	    do {
		y = (int) Cudd_Random(table) % nvars;
	    } while (x == y);
	    x += lower;
	    y += lower;
	    if (x > y) {
		int tmp = x;
		x = y;
		y = tmp;
	    }

	    /* Choose move with roulette wheel. */
	    rand1 = random_generator(table);
	    if (rand1 < EXC_PROB) {
		result = ddExchange(table,x,y,temp);       /* exchange */
		ecount++;
#if 0
		(void) fprintf(table->out,
			       "Exchange of %d and %d: size = %d\n",
			       x,y,table->keys - table->isolated);
#endif
	    } else if (rand1 < EXC_PROB + JUMP_UP_PROB) {
		result = ddJumpingAux(table,y,x,y,temp); /* jumping_up */
		ucount++;
#if 0
		(void) fprintf(table->out,
			       "Jump up of %d to %d: size = %d\n",
			       y,x,table->keys - table->isolated);
#endif
	    } else {
		result = ddJumpingAux(table,x,x,y,temp); /* jumping_down */
		dcount++;
#if 0
		(void) fprintf(table->out,
			       "Jump down of %d to %d: size = %d\n",
			       x,y,table->keys - table->isolated);
#endif
	    }

	    if (!result) {
		FREE(BestOrder);
		return(0);
	    }

	    size = (int) (table->keys - table->isolated); /* keep current size */
	    if (size < BestCost) {			/* update best order */
		BestCost = size;
		copyOrder(table,BestOrder,lower,upper);
	    }
	}
	c1 = c2;
	c2 = c3;
	c3 = c4;
	c4 = size;
	NewTemp = ALPHA * temp;
	if (NewTemp >= 1.0) {
	    maxGen = (int)(log(NewTemp) / log(temp) * maxGen);
	}
	temp = NewTemp;	                /* control variable */
#ifdef DD_STATS
	(void) fprintf(table->out,"uphill = %d\taccepted = %d\n",
		       table->tosses,table->acceptances);
	fflush(table->out);
#endif
    }

    result = restoreOrder(table,BestOrder,lower,upper);
    FREE(BestOrder);
    if (!result) return(0);
#ifdef DD_STATS
    fprintf(table->out,"#:N_EXCHANGE %8d : total exchanges\n",ecount);
    fprintf(table->out,"#:N_JUMPUP   %8d : total jumps up\n",ucount);
    fprintf(table->out,"#:N_JUMPDOWN %8d : total jumps down",dcount);
#endif
    return(1);

} /* end of cuddAnnealing */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
  @brief Checks termination condition.

  @details If temperature is STOP_TEMP or there is no improvement
  then terminates.

  @return 1 if the termination criterion is met; 0 otherwise.

  @sideeffect None

*/
static int
stopping_criterion(
  int  c1,
  int  c2,
  int  c3,
  int  c4,
  double  temp)
{
    if (STOP_TEMP < temp) {
	return(0);
    } else if ((c1 == c2) && (c1 == c3) && (c1 == c4)) {
	return(1);
    } else {
	return(0);
    }

} /* end of stopping_criterion */


/**
  @brief Random number generator.

  @return a double precision value between 0.0 and 1.0.

  @sideeffect None

*/
static double
random_generator(DdManager * dd)
{
    return((double)(Cudd_Random(dd) / 2147483561.0));

} /* end of random_generator */


/**
  @brief Exchanges two variables, x and y.

  @details This is the same funcion as ddSwapping except for the
  comparison expression.  Use probability function, exp(-size_change/temp).

  @sideeffect None

*/
static int
ddExchange(
  DdManager * table,
  int  x,
  int  y,
  double  temp)
{
    Move       *move,*moves;
    int        tmp;
    int        x_ref,y_ref;
    int        x_next,y_next;
    int        size, result;
    int        initial_size, limit_size;

    x_ref = x;
    y_ref = y;

    x_next = cuddNextHigh(table,x);
    y_next = cuddNextLow(table,y);
    moves = NULL;
    initial_size = limit_size = (int) (table->keys - table->isolated);

    for (;;) {
	if (x_next == y_next) {
	    size = cuddSwapInPlace(table,x,x_next);
	    if (size == 0) goto ddExchangeOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddExchangeOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    size = cuddSwapInPlace(table,y_next,y);
	    if (size == 0) goto ddExchangeOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddExchangeOutOfMem;
	    move->x = y_next;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    size = cuddSwapInPlace(table,x,x_next);
	    if (size == 0) goto ddExchangeOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddExchangeOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    tmp = x;
	    x = y;
	    y = tmp;
	} else if (x == y_next) {
	    size = cuddSwapInPlace(table,x,x_next);
	    if (size == 0) goto ddExchangeOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddExchangeOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    tmp = x;
	    x = y;
	    y = tmp;
	} else {
	    size = cuddSwapInPlace(table,x,x_next);
	    if (size == 0) goto ddExchangeOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddExchangeOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    size = cuddSwapInPlace(table,y_next,y);
	    if (size == 0) goto ddExchangeOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddExchangeOutOfMem;
	    move->x = y_next;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    x = x_next;
	    y = y_next;
	}

	x_next = cuddNextHigh(table,x);
	y_next = cuddNextLow(table,y);
	if (x_next > y_ref) break;

	if ((double) size > DD_MAX_REORDER_GROWTH * (double) limit_size) {
	    break;
	} else if (size < limit_size) {
	    limit_size = size;
	}
    }

    if (y_next>=x_ref) {
        size = cuddSwapInPlace(table,y_next,y);
        if (size == 0) goto ddExchangeOutOfMem;
        move = (Move *)cuddDynamicAllocNode(table);
        if (move == NULL) goto ddExchangeOutOfMem;
        move->x = y_next;
        move->y = y;
        move->size = size;
        move->next = moves;
        moves = move;
    }

    /* move backward and stop at best position or accept uphill move */
    result = siftBackwardProb(table,moves,initial_size,temp);
    if (!result) goto ddExchangeOutOfMem;

    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(1);

ddExchangeOutOfMem:
    while (moves != NULL) {
        move = moves->next;
        cuddDeallocMove(table, moves);
        moves = move;
    }
    return(0);

} /* end of ddExchange */


/**
  @brief Moves a variable to a specified position.

  @details If x==x_low, it executes jumping_down. If x==x_high, it
  executes jumping_up. This funcion is similar to ddSiftingAux.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddJumpingAux(
  DdManager * table,
  int  x,
  int  x_low,
  int  x_high,
  double  temp)
{
    Move       *move;
    Move       *moves;        /* list of moves */
    int        initial_size;
    int        result;

    initial_size = (int) (table->keys - table->isolated);

#ifdef DD_DEBUG
    assert(table->subtables[x].keys > 0);
#endif

    moves = NULL;

    if (cuddNextLow(table,x) < x_low) {
	if (cuddNextHigh(table,x) > x_high) return(1);
	moves = ddJumpingDown(table,x,x_high,initial_size);
	/* after that point x --> x_high unless early termination */
	if (moves == NULL) goto ddJumpingAuxOutOfMem;
	/* move backward and stop at best position or accept uphill move */
	result = siftBackwardProb(table,moves,initial_size,temp);
	if (!result) goto ddJumpingAuxOutOfMem;
    } else if (cuddNextHigh(table,x) > x_high) {
	moves = ddJumpingUp(table,x,x_low,initial_size);
	/* after that point x --> x_low unless early termination */
	if (moves == NULL) goto ddJumpingAuxOutOfMem;
	/* move backward and stop at best position or accept uphill move */
	result = siftBackwardProb(table,moves,initial_size,temp);
	if (!result) goto ddJumpingAuxOutOfMem;
    } else {
	(void) fprintf(table->err,"Unexpected condition in ddJumping\n");
	goto ddJumpingAuxOutOfMem;
    }
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(1);

ddJumpingAuxOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(0);

} /* end of ddJumpingAux */


/**
  @brief This function is for jumping up.

  @details This is a simplified version of ddSiftingUp. It does not
  use lower bounding.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
ddJumpingUp(
  DdManager * table,
  int  x,
  int  x_low,
  int  initial_size)
{
    Move       *moves;
    Move       *move;
    int        y;
    int        size;
    int        limit_size = initial_size;

    moves = NULL;
    y = cuddNextLow(table,x);
    while (y >= x_low) {
	size = cuddSwapInPlace(table,y,x);
	if (size == 0) goto ddJumpingUpOutOfMem;
	move = (Move *)cuddDynamicAllocNode(table);
	if (move == NULL) goto ddJumpingUpOutOfMem;
	move->x = y;
	move->y = x;
	move->size = size;
	move->next = moves;
	moves = move;
	if ((double) size > table->maxGrowth * (double) limit_size) {
	    break;
	} else if (size < limit_size) {
	    limit_size = size;
	}
	x = y;
	y = cuddNextLow(table,x);
    }
    return(moves);

ddJumpingUpOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(NULL);

} /* end of ddJumpingUp */


/**
  @brief This function is for jumping down.

  @details This is a simplified version of ddSiftingDown. It does not
  use lower bounding.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
ddJumpingDown(
  DdManager * table,
  int  x,
  int  x_high,
  int  initial_size)
{
    Move       *moves;
    Move       *move;
    int        y;
    int        size;
    int        limit_size = initial_size;

    moves = NULL;
    y = cuddNextHigh(table,x);
    while (y <= x_high) {
	size = cuddSwapInPlace(table,x,y);
	if (size == 0) goto ddJumpingDownOutOfMem;
	move = (Move *)cuddDynamicAllocNode(table);
	if (move == NULL) goto ddJumpingDownOutOfMem;
	move->x = x;
	move->y = y;
	move->size = size;
	move->next = moves;
	moves = move;
	if ((double) size > table->maxGrowth * (double) limit_size) {
	    break;
	} else if (size < limit_size) {
	    limit_size = size;
	}
	x = y;
	y = cuddNextHigh(table,x);
    }
    return(moves);

ddJumpingDownOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(NULL);

} /* end of ddJumpingDown */


/**
  @brief Returns the %DD to the best position encountered during
  sifting if there was improvement.

  @details Otherwise, "tosses a coin" to decide whether to keep
  the current configuration or return the %DD to the original
  one.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
siftBackwardProb(
  DdManager * table,
  Move * moves,
  int  size,
  double  temp)
{
    Move   *move;
    int    res;
    int    best_size = size;
    double coin, threshold;

    /* Look for best size during the last sifting */
    for (move = moves; move != NULL; move = move->next) {
	if (move->size < best_size) {
	    best_size = move->size;
	}
    }
    
    /* If best_size equals size, the last sifting did not produce any
    ** improvement. We now toss a coin to decide whether to retain
    ** this change or not.
    */
    if (best_size == size) {
	coin = random_generator(table);
#ifdef DD_STATS
	table->tosses++;
#endif
	threshold = exp(-((double)(table->keys - table->isolated -
                                   (unsigned int) size))/temp);
	if (coin < threshold) {
#ifdef DD_STATS
	    table->acceptances++;
#endif
	    return(1);
	}
    }

    /* Either there was improvement, or we have decided not to
    ** accept the uphill move. Go to best position.
    */
    res = (int) (table->keys - table->isolated);
    for (move = moves; move != NULL; move = move->next) {
	if (res == best_size) return(1);
	res = cuddSwapInPlace(table,(int)move->x,(int)move->y);
	if (!res) return(0);
    }

    return(1);

} /* end of sift_backward_prob */


/**
  @brief Copies the current variable order to array.

  @details At the same time inverts the permutation.

  @sideeffect None

*/
static void
copyOrder(
  DdManager * table,
  int * array,
  int  lower,
  int  upper)
{
    int i;
    int nvars;

    nvars = upper - lower + 1;
    for (i = 0; i < nvars; i++) {
	array[i] = table->invperm[i+lower];
    }

} /* end of copyOrder */


/**
  @brief Restores the variable order in array by a series of sifts up.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
restoreOrder(
  DdManager * table,
  int * array,
  int  lower,
  int  upper)
{
    int i, x, y, size;
    int nvars = upper - lower + 1;

    for (i = 0; i < nvars; i++) {
	x = table->perm[array[i]];
#ifdef DD_DEBUG
    assert(x >= lower && x <= upper);
#endif
	y = cuddNextLow(table,x);
	while (y >= i + lower) {
	    size = cuddSwapInPlace(table,y,x);
	    if (size == 0) return(0);
	    x = y;
	    y = cuddNextLow(table,x);
	}
    }

    return(1);

} /* end of restoreOrder */


cuddApa.c
26589
/**
  @file

  @ingroup cudd

  @brief Arbitrary precision arithmetic functions.

  @details This file provides just enough functionality as needed
  by CUDD to compute the number of minterms of functions with many
  variables.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* These constants define the digits used in the representation of
** arbitrary precision integers.
*/
#define DD_APA_BITS	((int) sizeof(DdApaDigit) * 8)
#define DD_APA_BASE	((DdApaDoubleDigit) 1 << DD_APA_BITS)
#define DD_APA_MASK	(DD_APA_BASE - 1)

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
   @brief Type used for intermediate results.
*/
typedef uint64_t DdApaDoubleDigit;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/**
  @brief Extract the least significant digit of a double digit.

  @sideeffect None

  @see DD_MSDIGIT

*/
#define DD_LSDIGIT(x)	((x) & DD_APA_MASK)


/**
  @brief Extract the most significant digit of a double digit.

  @sideeffect None

  @see DD_LSDIGIT

*/
#define DD_MSDIGIT(x)	((x) >> DD_APA_BITS)

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdApaNumber cuddApaCountMintermAux (DdManager const * manager, DdNode * node, int digits, DdApaNumber mmax, DdApaNumber mmin, st_table * table);
static enum st_retval cuddApaStCountfree (void * key, void * value, void * arg);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Returns the number of digits for an arbitrary precision
  integer.

  @details Finds the number of digits for an arbitrary precision
  integer given the maximum number of binary digits.  The number of
  binary digits should be positive.

  @sideeffect None

*/
int
Cudd_ApaNumberOfDigits(
  int binaryDigits)
{
    int digits;

    digits = binaryDigits / DD_APA_BITS;
    if ((digits * DD_APA_BITS) != binaryDigits)
	digits++;
    return(digits);

} /* end of Cudd_ApaNumberOfDigits */


/**
  @brief Allocates memory for an arbitrary precision integer.

  @return a pointer to the allocated memory if successful;
  NULL otherwise.

  @sideeffect None

  @see Cudd_FreeApaNumber
*/
DdApaNumber
Cudd_NewApaNumber(
  int digits)
{
    return(ALLOC(DdApaDigit, digits));

} /* end of Cudd_NewApaNumber */


/**
  @brief Frees an arbitrary precision integer.

  @sideeffect None

  @see Cudd_NewApaNumber
*/
void
Cudd_FreeApaNumber(
  DdApaNumber number)
{
    FREE(number);

} /* end of Cudd_FreeApaNumber */


/**
  @brief Makes a copy of an arbitrary precision integer.

  @sideeffect Changes parameter <code>dest</code>.

*/
void
Cudd_ApaCopy(
  int digits,
  DdConstApaNumber source,
  DdApaNumber dest)
{
    int i;

    for (i = 0; i < digits; i++) {
	dest[i] = source[i];
    }

} /* end of Cudd_ApaCopy */


/**
  @brief Adds two arbitrary precision integers.

  @return the carry out of the most significant digit.

  @sideeffect The result of the sum is stored in parameter <code>sum</code>.

*/
DdApaDigit
Cudd_ApaAdd(
  int  digits,
  DdConstApaNumber a,
  DdConstApaNumber b,
  DdApaNumber sum)
{
    int i;
    DdApaDoubleDigit partial = 0;

    for (i = digits - 1; i >= 0; i--) {
	partial = DD_MSDIGIT(partial) + a[i] + b[i];
	sum[i] = (DdApaDigit) DD_LSDIGIT(partial);
    }
    return((DdApaDigit) DD_MSDIGIT(partial));

} /* end of Cudd_ApaAdd */


/**
  @brief Subtracts two arbitrary precision integers.

  @return the borrow out of the most significant digit.

  @sideeffect The result of the subtraction is stored in parameter
  <code>diff</code>.

*/
DdApaDigit
Cudd_ApaSubtract(
  int  digits,
  DdConstApaNumber a,
  DdConstApaNumber b,
  DdApaNumber diff)
{
    int i;
    DdApaDoubleDigit partial = DD_APA_BASE;

    for (i = digits - 1; i >= 0; i--) {
        partial = DD_MSDIGIT(partial) + DD_APA_MASK + a[i] - b[i];
	diff[i] = (DdApaDigit) DD_LSDIGIT(partial);
    }
    return((DdApaDigit) DD_MSDIGIT(partial) - 1);

} /* end of Cudd_ApaSubtract */


/**
  @brief Divides an arbitrary precision integer by a digit.

  @return the remainder digit.

  @sideeffect The quotient is returned in parameter <code>quotient</code>.

*/
DdApaDigit
Cudd_ApaShortDivision(
  int  digits,
  DdConstApaNumber dividend,
  DdApaDigit divisor,
  DdApaNumber quotient)
{
    int i;
    DdApaDigit remainder;
    DdApaDoubleDigit partial;

    remainder = 0;
    for (i = 0; i < digits; i++) {
	partial = remainder * DD_APA_BASE + dividend[i];
	quotient[i] = (DdApaDigit) (partial/(DdApaDoubleDigit)divisor);
	remainder = (DdApaDigit) (partial % divisor);
    }

    return(remainder);

} /* end of Cudd_ApaShortDivision */


/**
  @brief Divides an arbitrary precision integer by an integer.

  @details Divides an arbitrary precision integer by a 32-bit unsigned
  integer. This procedure relies on the assumption that the number of
  bits of a DdApaDigit plus the number of bits of an unsigned int is
  less the number of bits of the mantissa of a double. This guarantees
  that the product of a DdApaDigit and an unsigned int can be
  represented without loss of precision by a double. On machines where
  this assumption is not satisfied, this procedure will malfunction.

  @return the remainder.

  @sideeffect The quotient is returned in parameter <code>quotient</code>.

  @deprecated The assumption on which the correctness of this function rests
  is not satisfied by modern-day 64-bit CPUs.

  @see Cudd_ApaShortDivision

*/
unsigned int
Cudd_ApaIntDivision(
  int  digits,
  DdConstApaNumber dividend,
  unsigned int divisor,
  DdApaNumber quotient)
{
    int i;
    double partial;
    unsigned int remainder = 0;
    double ddiv = (double) divisor;

    for (i = 0; i < digits; i++) {
	partial = (double) remainder * DD_APA_BASE + dividend[i];
	quotient[i] = (DdApaDigit) (partial / ddiv);
	remainder = (unsigned int) (partial - ((double)quotient[i] * ddiv));
    }

    return(remainder);

} /* end of Cudd_ApaIntDivision */


/**
  @brief Shifts right an arbitrary precision integer by one binary
  place.

  @details The most significant binary digit of the result is taken
  from parameter <code>in</code>.

  @sideeffect The result is returned in parameter <code>b</code>.

*/
void
Cudd_ApaShiftRight(
  int digits,
  DdApaDigit in,
  DdConstApaNumber a,
  DdApaNumber b)
{
    int i;

    for (i = digits - 1; i > 0; i--) {
	b[i] = (a[i] >> 1) | ((a[i-1] & 1) << (DD_APA_BITS - 1));
    }
    b[0] = (a[0] >> 1) | (in << (DD_APA_BITS - 1));

} /* end of Cudd_ApaShiftRight */


/**
  @brief Sets an arbitrary precision integer to a one-digit literal.

  @sideeffect The result is returned in parameter <code>number</code>.

*/
void
Cudd_ApaSetToLiteral(
  int digits,
  DdApaNumber number,
  DdApaDigit literal)
{
    int i;

    for (i = 0; i < digits - 1; i++)
	number[i] = 0;
    number[digits - 1] = literal;

} /* end of Cudd_ApaSetToLiteral */


/**
  @brief Sets an arbitrary precision integer to a power of two.

  @details If the power of two is too large to be represented, the number
  is set to 0.

  @sideeffect The result is returned in parameter <code>number</code>.

*/
void
Cudd_ApaPowerOfTwo(
  int digits,
  DdApaNumber number,
  int power)
{
    int i;
    int index;

    for (i = 0; i < digits; i++)
	number[i] = 0;
    i = digits - 1 - power / DD_APA_BITS;
    if (i < 0) return;
    index = power & (DD_APA_BITS - 1);
    number[i] = (DdApaDigit) 1 << index;

} /* end of Cudd_ApaPowerOfTwo */


/**
  @brief Compares two arbitrary precision integers.

  @return 1 if the first number is larger; 0 if they are equal; -1 if
  the second number is larger.

  @sideeffect None

*/
int
Cudd_ApaCompare(
  int digitsFirst,
  DdConstApaNumber first,
  int digitsSecond,
  DdConstApaNumber second)
{
    int i;
    int firstNZ, secondNZ;

    /* Find first non-zero in both numbers. */
    for (firstNZ = 0; firstNZ < digitsFirst; firstNZ++)
	if (first[firstNZ] != 0) break;
    for (secondNZ = 0; secondNZ < digitsSecond; secondNZ++)
	if (second[secondNZ] != 0) break;
    if (digitsFirst - firstNZ > digitsSecond - secondNZ) return(1);
    else if (digitsFirst - firstNZ < digitsSecond - secondNZ) return(-1);
    for (i = 0; i < digitsFirst - firstNZ; i++) {
	if (first[firstNZ + i] > second[secondNZ + i]) return(1);
	else if (first[firstNZ + i] < second[secondNZ + i]) return(-1);
    }
    return(0);

} /* end of Cudd_ApaCompare */


/**
  @brief Compares the ratios of two arbitrary precision integers to two
  unsigned ints.

  @return 1 if the first number is larger; 0 if they are equal; -1 if
  the second number is larger.

  @sideeffect None

*/
int
Cudd_ApaCompareRatios(
  int digitsFirst,
  DdConstApaNumber firstNum,
  unsigned int firstDen,
  int digitsSecond,
  DdConstApaNumber secondNum,
  unsigned int secondDen)
{
    int result;
    DdApaNumber first, second;
    unsigned int firstRem, secondRem;

    first = Cudd_NewApaNumber(digitsFirst);
    firstRem = Cudd_ApaIntDivision(digitsFirst,firstNum,firstDen,first);
    second = Cudd_NewApaNumber(digitsSecond);
    secondRem = Cudd_ApaIntDivision(digitsSecond,secondNum,secondDen,second);
    result = Cudd_ApaCompare(digitsFirst,first,digitsSecond,second);
    FREE(first);
    FREE(second);
    if (result == 0) {
	if ((double)firstRem/firstDen > (double)secondRem/secondDen)
	    return(1);
	else if ((double)firstRem/firstDen < (double)secondRem/secondDen)
	    return(-1);
    }
    return(result);

} /* end of Cudd_ApaCompareRatios */


/**
  @brief Prints an arbitrary precision integer in hexadecimal format.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_ApaPrintDecimal Cudd_ApaPrintExponential

*/
int
Cudd_ApaPrintHex(
  FILE * fp,
  int digits,
  DdConstApaNumber number)
{
    int i, result;

    for (i = 0; i < digits; i++) {
        result = fprintf(fp, "%0*x", (int) sizeof(DdApaDigit) * 2, number[i]);
	if (result == EOF)
	    return(0);
    }
    return(1);

} /* end of Cudd_ApaPrintHex */


/**
  @brief Prints an arbitrary precision integer in decimal format.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_ApaPrintHex Cudd_ApaPrintExponential

*/
int
Cudd_ApaPrintDecimal(
  FILE * fp,
  int digits,
  DdConstApaNumber number)
{
    int i, result;
    DdApaDigit remainder;
    DdApaNumber work;
    unsigned char *decimal;
    int leadingzero;
    int decimalDigits = (int) (digits * log10((double) DD_APA_BASE)) + 1;

    work = Cudd_NewApaNumber(digits);
    if (work == NULL)
	return(0);
    decimal = ALLOC(unsigned char, decimalDigits);
    if (decimal == NULL) {
	FREE(work);
	return(0);
    }
    Cudd_ApaCopy(digits,number,work);
    for (i = decimalDigits - 1; i >= 0; i--) {
	remainder = Cudd_ApaShortDivision(digits,work,(DdApaDigit) 10,work);
	decimal[i] = (unsigned char) remainder;
    }
    FREE(work);

    leadingzero = 1;
    for (i = 0; i < decimalDigits; i++) {
	leadingzero = leadingzero && (decimal[i] == 0);
	if ((!leadingzero) || (i == (decimalDigits - 1))) {
	    result = fprintf(fp,"%1d",decimal[i]);
	    if (result == EOF) {
		FREE(decimal);
		return(0);
	    }
	}
    }
    FREE(decimal);
    return(1);

} /* end of Cudd_ApaPrintDecimal */


/**
  @brief converts an arbitrary precision integer to a string in decimal format.

  @return the string if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_ApaPrintDecimal

*/
char *
Cudd_ApaStringDecimal(
  int digits,
  DdConstApaNumber number)
{
    int i, fsd;
    DdApaDigit remainder;
    DdApaNumber work;
    char *decimal, *ret;
    int decimalDigits = (int) (digits * log10((double) DD_APA_BASE)) + 1;

    work = Cudd_NewApaNumber(digits);
    if (work == NULL) {
	return(0);
    }
    decimal = ALLOC(char, decimalDigits);
    if (decimal == NULL) {
	FREE(work);
	return(0);
    }
    Cudd_ApaCopy(digits,number,work);
    for (i = decimalDigits - 1; i >= 0; i--) {
	remainder = Cudd_ApaShortDivision(digits,work,(DdApaDigit) 10,work);
	decimal[i] = (char) remainder;
    }
    FREE(work);

    /* Find first significant digit. */
    for (fsd = 0; fsd < decimalDigits-1; fsd++) {
        if (decimal[fsd] != 0)
            break;
    }
    ret = ALLOC(char, decimalDigits - fsd + 1);
    if (ret == NULL) {
        FREE(decimal);
        return(NULL);
    }
    for (i = fsd; i < decimalDigits; i++) {
        ret[i-fsd] = decimal[i] + '0';
    }
    ret[decimalDigits-fsd] = '\0';
    FREE(decimal);
    return(ret);

} /* end of Cudd_ApaStringDecimal */


/**
  @brief Prints an arbitrary precision integer in exponential format.

  @details Prints as an integer if precision is at least the number of
  digits to be printed.  If precision does not allow printing of all
  digits, rounds to nearest breaking ties so that the last printed
  digit is even.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_ApaPrintHex Cudd_ApaPrintDecimal

*/
int
Cudd_ApaPrintExponential(
  FILE * fp,
  int digits,
  DdConstApaNumber number,
  int precision)
{
    int i, first, last, result;
    DdApaDigit remainder;
    DdApaNumber work;
    unsigned char *decimal, carry;
    /* We add an extra digit to have room for rounding up. */
    int decimalDigits = (int) (digits * log10((double) DD_APA_BASE)) + 2;

    /* Convert to decimal. */
    work = Cudd_NewApaNumber(digits);
    if (work == NULL)
	return(0);
    decimal = ALLOC(unsigned char, decimalDigits);
    if (decimal == NULL) {
	FREE(work);
	return(0);
    }
    Cudd_ApaCopy(digits,number,work);
    first = decimalDigits - 1;
    for (i = decimalDigits - 1; i >= 0; i--) {
	remainder = Cudd_ApaShortDivision(digits,work,(DdApaDigit) 10,work);
	decimal[i] = (unsigned char) remainder;
	if (remainder != 0) first = i; /* keep track of MS non-zero */
    }
    FREE(work);
    last = ddMin(first + precision, decimalDigits);

    /* See if we can print as integer. */
    if (decimalDigits - first <= precision) {
        for (i = first; i < last; i++) {
            result = fprintf(fp,"%1d", decimal[i]);
            if (result == EOF) {
                FREE(decimal);
                return(0);
            }
        }
        FREE(decimal);
        return(1);
    }

    /* If we get here we need to print an exponent.  Take care of rounding. */
    if (last == decimalDigits) {
        carry = 0;
    } else if (decimal[last] < 5) {
        carry = 0;
    } else if (decimal[last] == 5) {
        int nonZero = CUDD_FALSE;
        for (i = last + 1; i < decimalDigits; i++) {
            if (decimal[i] > 0) {
                nonZero = CUDD_TRUE;
                break;
            }
        }
        if (nonZero) {
            carry = 1;
        } else if (decimal[last - 1] & 1) { /* odd */
            carry = 1;
        } else {
            carry = 0;
        }
    } else {
        carry = 1;
    }

    /* Add carry. */
    for (i = last - 1; i >= 0; i--) {
        unsigned char tmp = decimal[i] + carry;
        if (tmp < 10) {
            decimal[i] = tmp;
            break;
        } else {
            decimal[i] = tmp - 10;
        }
    }

    /* Don't print trailing zeros. */
    while (last > first && decimal[last - 1] == 0)
        last--;

    /* Print. */
    for (i = first; i < last; i++) {
	result = fprintf(fp,"%s%1d",i == first+1 ? "." : "", decimal[i]);
	if (result == EOF) {
	    FREE(decimal);
	    return(0);
	}
    }
    FREE(decimal);
    result = fprintf(fp,"e+%02d",decimalDigits - first - 1);
    if (result == EOF) {
	return(0);
    }
    return(1);

} /* end of Cudd_ApaPrintExponential */


/**
  @brief Counts the number of minterms of a %DD.

  @details The function is assumed to depend on nvars variables. The
  minterm count is represented as an arbitrary precision unsigned
  integer, to allow for any number of variables CUDD supports.

  @return a pointer to the array representing the number of minterms
  of the function rooted at node if successful; NULL otherwise.

  @sideeffect The number of digits of the result is returned in
  parameter <code>digits</code>.

  @see Cudd_CountMinterm

*/
DdApaNumber
Cudd_ApaCountMinterm(
  DdManager const * manager,
  DdNode * node,
  int  nvars,
  int * digits)
{
    DdApaNumber	mmax, mmin;
    st_table	*table;
    DdApaNumber	i,count;

    *digits = Cudd_ApaNumberOfDigits(nvars+1);
    mmax = Cudd_NewApaNumber(*digits);
    if (mmax == NULL) {
	return(NULL);
    }
    Cudd_ApaPowerOfTwo(*digits,mmax,nvars);
    mmin = Cudd_NewApaNumber(*digits);
    if (mmin == NULL) {
	FREE(mmax);
	return(NULL);
    }
    Cudd_ApaSetToLiteral(*digits,mmin,0);
    table = st_init_table(st_ptrcmp,st_ptrhash);
    if (table == NULL) {
	FREE(mmax);
	FREE(mmin);
	return(NULL);
    }
    i = cuddApaCountMintermAux(manager, Cudd_Regular(node),*digits,mmax,mmin,table);
    if (i == NULL) {
	FREE(mmax);
	FREE(mmin);
	st_foreach(table, cuddApaStCountfree, NULL);
	st_free_table(table);
	return(NULL);
    }
    count = Cudd_NewApaNumber(*digits);
    if (count == NULL) {
	FREE(mmax);
	FREE(mmin);
	st_foreach(table, cuddApaStCountfree, NULL);
	st_free_table(table);
	if (Cudd_Regular(node)->ref == 1) FREE(i);
	return(NULL);
    }
    if (Cudd_IsComplement(node)) {
	(void) Cudd_ApaSubtract(*digits,mmax,i,count);
    } else {
	Cudd_ApaCopy(*digits,i,count);
    }
    FREE(mmax);
    FREE(mmin);
    st_foreach(table, cuddApaStCountfree, NULL);
    st_free_table(table);
    if (Cudd_Regular(node)->ref == 1) FREE(i);
    return(count);

} /* end of Cudd_ApaCountMinterm */


/**
  @brief Prints the number of minterms of a %BDD or %ADD using arbitrary
  precision arithmetic.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_ApaPrintMintermExp

*/
int
Cudd_ApaPrintMinterm(
  FILE * fp,
  DdManager const * dd,
  DdNode * node,
  int  nvars)
{
    int digits;
    int result;
    DdApaNumber count;

    count = Cudd_ApaCountMinterm(dd,node,nvars,&digits);
    if (count == NULL)
	return(0);
    result = Cudd_ApaPrintDecimal(fp,digits,count);
    FREE(count);
    if (fprintf(fp,"\n") == EOF) {
	return(0);
    }
    return(result);

} /* end of Cudd_ApaPrintMinterm */


/**
  @brief Prints the number of minterms of a %BDD or %ADD in
  exponential format using arbitrary precision arithmetic.

  @details Parameter precision controls the number of signficant
  digits printed.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_ApaPrintMinterm

*/
int
Cudd_ApaPrintMintermExp(
  FILE * fp,
  DdManager const * dd,
  DdNode * node,
  int nvars,
  int precision)
{
    int digits;
    int result;
    DdApaNumber count;

    count = Cudd_ApaCountMinterm(dd,node,nvars,&digits);
    if (count == NULL)
	return(0);
    result = Cudd_ApaPrintExponential(fp,digits,count,precision);
    FREE(count);
    if (fprintf(fp,"\n") == EOF) {
	return(0);
    }
    return(result);

} /* end of Cudd_ApaPrintMintermExp */


/**
  @brief Prints the density of a %BDD or %ADD using arbitrary
  precision arithmetic.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
Cudd_ApaPrintDensity(
  FILE * fp,
  DdManager * dd,
  DdNode * node,
  int nvars)
{
    int digits;
    int result;
    DdApaNumber count,density;
    unsigned int size, remainder, fractional;

    count = Cudd_ApaCountMinterm(dd,node,nvars,&digits);
    if (count == NULL)
	return(0);
    size = (unsigned int) Cudd_DagSize(node);
    density = Cudd_NewApaNumber(digits);
    remainder = Cudd_ApaIntDivision(digits,count,size,density);
    result = Cudd_ApaPrintDecimal(fp,digits,density);
    FREE(count);
    FREE(density);
    fractional = (unsigned int)((double)remainder / size * 1000000);
    if (fprintf(fp,".%u\n", fractional) == EOF) {
	return(0);
    }
    return(result);

} /* end of Cudd_ApaPrintDensity */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_ApaCountMinterm.

  @details It is based on the following identity. Let <code>|f|</code> be the
  number of minterms of <code>f</code>. Then:

      |f| = (|f0|+|f1|)/2

  where f0 and f1 are the two cofactors of f.
  Uses the identity <code>|f'| = mmax - |f|</code>.
  The procedure expects the argument "node" to be a regular pointer, and
  guarantees this condition is met in the recursive calls.
  For efficiency, the result of a call is cached only if the node has
  a reference count greater than 1.

  @return the number of minterms of the function rooted at node.

  @sideeffect None

*/
static DdApaNumber
cuddApaCountMintermAux(
  DdManager const * manager,
  DdNode * node,
  int digits,
  DdApaNumber mmax,
  DdApaNumber mmin,
  st_table * table)
{
    DdNode      *Nt, *Ne;
    DdApaNumber	mint, mint1, mint2;
    DdApaDigit	carryout;

    if (cuddIsConstant(node)) {
        int singleRef = Cudd_Regular(node)->ref == 1;
        if (node == manager->background || node == Cudd_Not(manager->one)) {
            if (singleRef) {
                mint = Cudd_NewApaNumber(digits);
                if (mint == NULL) {
                    return(NULL);
                }
                Cudd_ApaCopy(digits, mmin, mint);
                return(mint);
            } else {
                return(mmin);
            }
	} else {
            if (singleRef) {
                mint = Cudd_NewApaNumber(digits);
                if (mint == NULL) {
                    return(NULL);
                }
                Cudd_ApaCopy(digits, mmax, mint);
                return(mint);
            } else {
                return(mmax);
            }
	}
    }
    if (node->ref > 1 && st_lookup(table, node, (void **) &mint)) {
	return(mint);
    }

    Nt = cuddT(node); Ne = cuddE(node);

    mint1 = cuddApaCountMintermAux(manager, Nt,  digits, mmax, mmin, table);
    if (mint1 == NULL) return(NULL);
    mint2 = cuddApaCountMintermAux(manager, Cudd_Regular(Ne), digits, mmax, mmin, table);
    if (mint2 == NULL) {
	if (Nt->ref == 1) FREE(mint1);
	return(NULL);
    }
    mint = Cudd_NewApaNumber(digits);
    if (mint == NULL) {
	if (Nt->ref == 1) FREE(mint1);
	if (Cudd_Regular(Ne)->ref == 1) FREE(mint2);
	return(NULL);
    }
    if (Cudd_IsComplement(Ne)) {
	(void) Cudd_ApaSubtract(digits,mmax,mint2,mint);
	carryout = Cudd_ApaAdd(digits,mint1,mint,mint);
    } else {
	carryout = Cudd_ApaAdd(digits,mint1,mint2,mint);
    }
    Cudd_ApaShiftRight(digits,carryout,mint,mint);
    /* If the refernce count of a child is 1, its minterm count
    ** hasn't been stored in table.  Therefore, it must be explicitly
    ** freed here. */
    if (Nt->ref == 1) FREE(mint1);
    if (Cudd_Regular(Ne)->ref == 1) FREE(mint2);

    if (node->ref > 1) {
	if (st_insert(table, node, mint) == ST_OUT_OF_MEM) {
	    FREE(mint);
	    return(NULL);
	}
    }
    return(mint);

} /* end of cuddApaCountMintermAux */


/**
  @brief Frees the memory used to store the minterm counts recorded
  in the visited table.

  @return ST_CONTINUE.

  @sideeffect None

*/
static enum st_retval
cuddApaStCountfree(
  void * key,
  void * value,
  void * arg)
{
    DdApaNumber	d;

    (void) key; /* avoid warning */
    (void) arg; /* avoid warning */
    d = (DdApaNumber) value;
    FREE(d);
    return(ST_CONTINUE);

} /* end of cuddApaStCountfree */

cuddApprox.c
65063
/**
  @file

  @ingroup cudd

  @brief Procedures to approximate a given %BDD.

  @see cuddSubsetHB.c cuddSubsetSP.c cuddGenCof.c

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifdef __STDC__
#include <float.h>
#else
#define DBL_MAX_EXP 1024
#endif
#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define NOTHING		0
#define REPLACE_T	1
#define REPLACE_E	2
#define REPLACE_N	3
#define REPLACE_TT	4
#define REPLACE_TE	5

#define DONT_CARE	0
#define CARE		1
#define TOTAL_CARE	2
#define CARE_ERROR	3

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
 ** @brief Data structure to store the information on each node.
 **
 ** @details It keeps the number of minterms of the function rooted at
 ** this node in terms of the number of variables specified by the
 ** user; the number of minterms of the complement; the impact of the
 ** number of minterms of this function on the number of minterms of
 ** the root function; the reference count of the node from within the
 ** root function; the flag that says whether the node intersects the
 ** care set; the flag that says whether the node should be replaced
 ** and how; the results of subsetting in both phases.
 */
typedef struct NodeData {
    double mintermsP;		/**< minterms for the regular node */
    double mintermsN;		/**< minterms for the complemented node */
    int functionRef;		/**< references from within this function */
    char care;			/**< node intersects care set */
    char replace;		/**< replacement decision */
    short int parity;		/**< 1: even; 2: odd; 3: both */
    DdNode *resultP;		/**< result for even parity */
    DdNode *resultN;		/**< result for odd parity */
} NodeData;

/**
 **  @brief Main bookkeeping data structure for approximation algorithms.
 */
typedef struct ApproxInfo {
    DdNode *one;		/**< one constant */
    DdNode *zero;		/**< %BDD zero constant */
    NodeData *page;		/**< per-node information */
    DdHashTable *table;		/**< hash table to access the per-node info */
    int index;			/**< index of the current node */
    double max;			/**< max number of minterms */
    int size;			/**< how many nodes are left */
    double minterms;		/**< how many minterms are left */
} ApproxInfo;

/**
 ** @brief Item of the queue used in the levelized traversal of the %BDD.
 */
typedef struct GlobalQueueItem {
    struct GlobalQueueItem *next;
    struct GlobalQueueItem *cnext;
    DdNode *node;
    double impactP;
    double impactN;
} GlobalQueueItem;

/**
 ** @brief Type of the item of the local queue.
 */
typedef struct LocalQueueItem {
    struct LocalQueueItem *next;
    struct LocalQueueItem *cnext;
    DdNode *node;
    int localRef;
} LocalQueueItem;

    
/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void updateParity (DdNode *node, ApproxInfo *info, int newparity);
static NodeData * gatherInfoAux (DdNode *node, ApproxInfo *info, int parity);
static ApproxInfo * gatherInfo (DdManager *dd, DdNode *node, int numVars, int parity);
static int computeSavings (DdManager *dd, DdNode *f, DdNode *skip, ApproxInfo *info, DdLevelQueue *queue);
static int updateRefs (DdManager *dd, DdNode *f, DdNode *skip, ApproxInfo *info, DdLevelQueue *queue);
static int UAmarkNodes (DdManager *dd, DdNode *f, ApproxInfo *info, int threshold, int safe, double quality);
static DdNode * UAbuildSubset (DdManager *dd, DdNode *node, ApproxInfo *info);
static int RAmarkNodes (DdManager *dd, DdNode *f, ApproxInfo *info, int threshold, double quality);
static int BAmarkNodes (DdManager *dd, DdNode *f, ApproxInfo *info, int threshold, double quality1, double quality0);
static DdNode * RAbuildSubset (DdManager *dd, DdNode *node, ApproxInfo *info);
static int BAapplyBias (DdManager *dd, DdNode *f, DdNode *b, ApproxInfo *info, DdHashTable *cache);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Extracts a dense subset from a %BDD with Shiple's
  underapproximation method.

  @details This procedure uses a variant of Tom Shiple's
  underapproximation method. The main difference from the original
  method is that density is used as cost function.  The parameter
  numVars is the maximum number of variables to be used in minterm
  calculation.  The optimal number should be as close as possible to
  the size of the support of f.  However, it is safe to pass the value
  returned by Cudd_ReadSize for numVars when the number of variables
  is under 1023.  If numVars is larger than 1023, it will cause
  overflow. If a 0 parameter is passed then the procedure will compute
  a value which will avoid overflow but will cause underflow with 2046
  variables or more.

  @return a pointer to the %BDD of the subset if successful; NULL if
  the procedure runs out of memory.

  @sideeffect None

  @see Cudd_SubsetShortPaths Cudd_SubsetHeavyBranch Cudd_ReadSize

*/
DdNode *
Cudd_UnderApprox(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be subset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< when to stop approximation */,
  int  safe /**< enforce safe approximation */,
  double  quality /**< minimum improvement for accepted changes */)
{
    DdNode *subset;

    do {
	dd->reordered = 0;
	subset = cuddUnderApprox(dd, f, numVars, threshold, safe, quality);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(subset);

} /* end of Cudd_UnderApprox */


/**
  @brief Extracts a dense superset from a %BDD with Shiple's
  underapproximation method.

  @details The procedure is identical to the underapproximation
  procedure except for the fact that it works on the complement of the
  given function. Extracting the subset of the complement function is
  equivalent to extracting the superset of the function.  The
  parameter numVars is the maximum number of variables to be used in
  minterm calculation.  The optimal number should be as close as
  possible to the size of the support of f.  However, it is safe to
  pass the value returned by Cudd_ReadSize for numVars when the number
  of variables is under 1023.  If numVars is larger than 1023, it will
  overflow. If a 0 parameter is passed then the procedure will compute
  a value which will avoid overflow but will cause underflow with 2046
  variables or more.
  
  @return a pointer to the %BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory.

  @sideeffect None

  @see Cudd_SupersetHeavyBranch Cudd_SupersetShortPaths Cudd_ReadSize

*/
DdNode *
Cudd_OverApprox(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be superset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< when to stop approximation */,
  int  safe /**< enforce safe approximation */,
  double  quality /**< minimum improvement for accepted changes */)
{
    DdNode *subset, *g;

    g = Cudd_Not(f);    
    do {
	dd->reordered = 0;
	subset = cuddUnderApprox(dd, g, numVars, threshold, safe, quality);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(Cudd_NotCond(subset, (subset != NULL)));
    
} /* end of Cudd_OverApprox */


/**
  @brief Extracts a dense subset from a %BDD with the remapping
  underapproximation method.

  @details This procedure uses a remapping technique and density as
  the cost function.  The parameter numVars is the maximum number of
  variables to be used in minterm calculation.  The optimal number
  should be as close as possible to the size of the support of f.
  However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023.  If numVars is
  larger than 1023, it will cause overflow. If a 0 parameter is passed
  then the procedure will compute a value which will avoid overflow
  but will cause underflow with 2046 variables or more.

  @return a pointer to the %BDD of the subset if successful. NULL if
  the procedure runs out of memory.
  
  @sideeffect None

  @see Cudd_SubsetShortPaths Cudd_SubsetHeavyBranch Cudd_UnderApprox Cudd_ReadSize

*/
DdNode *
Cudd_RemapUnderApprox(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be subset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< when to stop approximation */,
  double  quality /**< minimum improvement for accepted changes */)
{
    DdNode *subset;

    do {
	dd->reordered = 0;
	subset = cuddRemapUnderApprox(dd, f, numVars, threshold, quality);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(subset);

} /* end of Cudd_RemapUnderApprox */


/**
  @brief Extracts a dense superset from a %BDD with the remapping
  underapproximation method.

  @details The procedure is identical to the underapproximation
  procedure except for the fact that it works on the complement of the
  given function. Extracting the subset of the complement function is
  equivalent to extracting the superset of the function. The parameter
  numVars is the maximum number of variables to be used in minterm
  calculation.  The optimal number should be as close as possible to
  the size of the support of f.  However, it is safe to pass the value
  returned by Cudd_ReadSize for numVars when the number of variables
  is under 1023.  If numVars is larger than 1023, it will overflow. If
  a 0 parameter is passed then the procedure will compute a value
  which will avoid overflow but will cause underflow with 2046
  variables or more.

  @return a pointer to the %BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory.
  
  @sideeffect None

  @see Cudd_SupersetHeavyBranch Cudd_SupersetShortPaths Cudd_ReadSize

*/
DdNode *
Cudd_RemapOverApprox(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be superset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< when to stop approximation */,
  double  quality /**< minimum improvement for accepted changes */)
{
    DdNode *subset, *g;

    g = Cudd_Not(f);    
    do {
	dd->reordered = 0;
	subset = cuddRemapUnderApprox(dd, g, numVars, threshold, quality);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(Cudd_NotCond(subset, (subset != NULL)));
    
} /* end of Cudd_RemapOverApprox */


/**
  @brief Extracts a dense subset from a %BDD with the biased
  underapproximation method.

  @details This procedure uses a biased remapping technique and
  density as the cost function. The bias is a function. This procedure
  tries to approximate where the bias is 0 and preserve the given
  function where the bias is 1.  The parameter numVars is the maximum
  number of variables to be used in minterm calculation.  The optimal
  number should be as close as possible to the size of the support of
  f.  However, it is safe to pass the value returned by Cudd_ReadSize
  for numVars when the number of variables is under 1023.  If numVars
  is larger than 1023, it will cause overflow. If a 0 parameter is
  passed then the procedure will compute a value which will avoid
  overflow but will cause underflow with 2046 variables or more.

  @return a pointer to the %BDD of the subset if successful. NULL if
  the procedure runs out of memory.
  
  @sideeffect None

  @see Cudd_SubsetShortPaths Cudd_SubsetHeavyBranch Cudd_UnderApprox
  Cudd_RemapUnderApprox Cudd_ReadSize

*/
DdNode *
Cudd_BiasedUnderApprox(
  DdManager *dd /**< manager */,
  DdNode *f /**< function to be subset */,
  DdNode *b /**< bias function */,
  int numVars /**< number of variables in the support of f */,
  int threshold /**< when to stop approximation */,
  double quality1 /**< minimum improvement for accepted changes when b=1 */,
  double quality0 /**< minimum improvement for accepted changes when b=0 */)
{
    DdNode *subset;

    do {
	dd->reordered = 0;
	subset = cuddBiasedUnderApprox(dd, f, b, numVars, threshold, quality1,
				       quality0);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(subset);

} /* end of Cudd_BiasedUnderApprox */


/**
  @brief Extracts a dense superset from a %BDD with the biased
  underapproximation method.

  @details The procedure is identical to the underapproximation
  procedure except for the fact that it works on the complement of the
  given function. Extracting the subset of the complement function is
  equivalent to extracting the superset of the function.  The
  parameter numVars is the maximum number of variables to be used in
  minterm calculation.  The optimal number should be as close as
  possible to the size of the support of f.  However, it is safe to
  pass the value returned by Cudd_ReadSize for numVars when the number
  of variables is under 1023.  If numVars is larger than 1023, it will
  overflow. If a 0 parameter is passed then the procedure will compute
  a value which will avoid overflow but will cause underflow with 2046
  variables or more.

  @return a pointer to the %BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory.
  
  @sideeffect None

  @see Cudd_SupersetHeavyBranch Cudd_SupersetShortPaths
  Cudd_RemapOverApprox Cudd_BiasedUnderApprox Cudd_ReadSize

*/
DdNode *
Cudd_BiasedOverApprox(
  DdManager *dd /**< manager */,
  DdNode *f /**< function to be superset */,
  DdNode *b /**< bias function */,
  int numVars /**< number of variables in the support of f */,
  int threshold /**< when to stop approximation */,
  double quality1 /**< minimum improvement for accepted changes when b=1*/,
  double quality0 /**< minimum improvement for accepted changes when b=0 */)
{
    DdNode *subset, *g;

    g = Cudd_Not(f);    
    do {
	dd->reordered = 0;
	subset = cuddBiasedUnderApprox(dd, g, b, numVars, threshold, quality1,
				      quality0);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(Cudd_NotCond(subset, (subset != NULL)));
    
} /* end of Cudd_BiasedOverApprox */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Applies Tom Shiple's underappoximation algorithm.

  @details Proceeds in three phases:
  <ul>
  <li> collect information on each node in the %BDD; this is done via DFS.
  <li> traverse the %BDD in top-down fashion and compute for each node
  whether its elimination increases density.
  <li> traverse the %BDD via DFS and actually perform the elimination.
  </ul>

  @return the approximated %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_UnderApprox

*/
DdNode *
cuddUnderApprox(
  DdManager * dd /**< %DD manager */,
  DdNode * f /**< current %DD */,
  int  numVars /**< maximum number of variables */,
  int  threshold /**< threshold under which approximation stops */,
  int  safe /**< enforce safe approximation */,
  double  quality /**< minimum improvement for accepted changes */)
{
    ApproxInfo *info;
    DdNode *subset;
    int result;

    if (f == NULL) {
	fprintf(dd->err, "Cannot subset, nil object\n");
	return(NULL);
    }

    if (Cudd_IsConstantInt(f)) {
	return(f);
    }

    /* Create table where node data are accessible via a hash table. */
    info = gatherInfo(dd, f, numVars, safe);
    if (info == NULL) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    /* Mark nodes that should be replaced by zero. */
    result = UAmarkNodes(dd, f, info, threshold, safe, quality);
    if (result == 0) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	FREE(info->page);
	cuddHashTableGenericQuit(info->table);
	FREE(info);
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    /* Build the result. */
    subset = UAbuildSubset(dd, f, info);
#if 1
    if (subset && info->size < Cudd_DagSize(subset))
	(void) fprintf(dd->err, "Wrong prediction: %d versus actual %d\n",
		       info->size, Cudd_DagSize(subset));
#endif
    FREE(info->page);
    cuddHashTableGenericQuit(info->table);
    FREE(info);

#ifdef DD_DEBUG
    if (subset != NULL) {
	cuddRef(subset);
#if 0
	(void) Cudd_DebugCheck(dd);
	(void) Cudd_CheckKeys(dd);
#endif
	if (!Cudd_bddLeq(dd, subset, f)) {
	    (void) fprintf(dd->err, "Wrong subset\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	}
	cuddDeref(subset);
    }
#endif
    return(subset);

} /* end of cuddUnderApprox */


/**
  @brief Applies the remapping underappoximation algorithm.

  @details Proceeds in three phases:
  <ul>
  <li> collect information on each node in the %BDD; this is done via DFS.
  <li> traverse the %BDD in top-down fashion and compute for each node
  whether remapping increases density.
  <li> traverse the %BDD via DFS and actually perform the elimination.
  </ul>

  @return the approximated %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_RemapUnderApprox

*/
DdNode *
cuddRemapUnderApprox(
  DdManager * dd /**< %DD manager */,
  DdNode * f /**< current %DD */,
  int  numVars /**< maximum number of variables */,
  int  threshold /**< threshold under which approximation stops */,
  double  quality /**< minimum improvement for accepted changes */)
{
    ApproxInfo *info;
    DdNode *subset;
    int result;

    if (f == NULL) {
	fprintf(dd->err, "Cannot subset, nil object\n");
	dd->errorCode = CUDD_INVALID_ARG;
	return(NULL);
    }

    if (Cudd_IsConstantInt(f)) {
	return(f);
    }

    /* Create table where node data are accessible via a hash table. */
    info = gatherInfo(dd, f, numVars, CUDD_TRUE);
    if (info == NULL) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    /* Mark nodes that should be replaced by zero. */
    result = RAmarkNodes(dd, f, info, threshold, quality);
    if (result == 0) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	FREE(info->page);
	cuddHashTableGenericQuit(info->table);
	FREE(info);
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    /* Build the result. */
    subset = RAbuildSubset(dd, f, info);
#if 1
    if (subset && info->size < Cudd_DagSize(subset))
	(void) fprintf(dd->err, "Wrong prediction: %d versus actual %d\n",
		       info->size, Cudd_DagSize(subset));
#endif
    FREE(info->page);
    cuddHashTableGenericQuit(info->table);
    FREE(info);

#ifdef DD_DEBUG
    if (subset != NULL) {
	cuddRef(subset);
#if 0
	(void) Cudd_DebugCheck(dd);
	(void) Cudd_CheckKeys(dd);
#endif
	if (!Cudd_bddLeq(dd, subset, f)) {
	    (void) fprintf(dd->err, "Wrong subset\n");
	}
	cuddDeref(subset);
	dd->errorCode = CUDD_INTERNAL_ERROR;
    }
#endif
    return(subset);

} /* end of cuddRemapUnderApprox */


/**
  @brief Applies the biased remapping underappoximation algorithm.

  @details Proceeds in three phases:
  <ul>
  <li> collect information on each node in the %BDD; this is done via DFS.
  <li> traverse the %BDD in top-down fashion and compute for each node
  whether remapping increases density.
  <li> traverse the %BDD via DFS and actually perform the elimination.
  </ul>

  @return the approximated %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_BiasedUnderApprox

*/
DdNode *
cuddBiasedUnderApprox(
  DdManager *dd /**< %DD manager */,
  DdNode *f /**< current %DD */,
  DdNode *b /**< bias function */,
  int numVars /**< maximum number of variables */,
  int threshold /**< threshold under which approximation stops */,
  double quality1 /**< minimum improvement for accepted changes when b=1 */,
  double quality0 /**< minimum improvement for accepted changes when b=0 */)
{
    ApproxInfo *info;
    DdNode *subset;
    int result;
    DdHashTable	*cache;

    if (f == NULL) {
	fprintf(dd->err, "Cannot subset, nil object\n");
	dd->errorCode = CUDD_INVALID_ARG;
	return(NULL);
    }

    if (Cudd_IsConstantInt(f)) {
	return(f);
    }

    /* Create table where node data are accessible via a hash table. */
    info = gatherInfo(dd, f, numVars, CUDD_TRUE);
    if (info == NULL) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    cache = cuddHashTableInit(dd,2,2);
    result = BAapplyBias(dd, Cudd_Regular(f), b, info, cache);
    if (result == CARE_ERROR) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	cuddHashTableQuit(cache);
	FREE(info->page);
	cuddHashTableGenericQuit(info->table);
	FREE(info);
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    cuddHashTableQuit(cache);

    /* Mark nodes that should be replaced by zero. */
    result = BAmarkNodes(dd, f, info, threshold, quality1, quality0);
    if (result == 0) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	FREE(info->page);
	cuddHashTableGenericQuit(info->table);
	FREE(info);
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    /* Build the result. */
    subset = RAbuildSubset(dd, f, info);
#if 1
    if (subset && info->size < Cudd_DagSize(subset))
	(void) fprintf(dd->err, "Wrong prediction: %d versus actual %d\n",
		       info->size, Cudd_DagSize(subset));
#endif
    FREE(info->page);
    cuddHashTableGenericQuit(info->table);
    FREE(info);

#ifdef DD_DEBUG
    if (subset != NULL) {
	cuddRef(subset);
#if 0
	(void) Cudd_DebugCheck(dd);
	(void) Cudd_CheckKeys(dd);
#endif
	if (!Cudd_bddLeq(dd, subset, f)) {
	    (void) fprintf(dd->err, "Wrong subset\n");
	}
	cuddDeref(subset);
	dd->errorCode = CUDD_INTERNAL_ERROR;
    }
#endif
    return(subset);

} /* end of cuddBiasedUnderApprox */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Recursively update the parity of the paths reaching a node.

  @details Assumes that node is regular and propagates the invariant.

  @sideeffect None

  @see gatherInfoAux

*/
static void
updateParity(
  DdNode * node /**< function to analyze */,
  ApproxInfo * info /**< info on %BDD */,
  int newparity /**< new parity for node */)
{
    NodeData *infoN;
    DdNode *E;

    if ((infoN = (NodeData *) cuddHashTableGenericLookup(info->table, node)) == NULL)
        return;
    if ((infoN->parity & newparity) != 0) return;
    infoN->parity |= (short) newparity;
    if (Cudd_IsConstantInt(node)) return;
    updateParity(cuddT(node),info,newparity);
    E = cuddE(node);
    if (Cudd_IsComplement(E)) {
	updateParity(Cudd_Not(E),info,3-newparity);
    } else {
	updateParity(E,info,newparity);
    }
    return;

} /* end of updateParity */


/**
  @brief Recursively counts minterms and computes reference counts
  of each node in the %BDD.

  @details Similar to the cuddCountMintermAux which recursively counts
  the number of minterms for the dag rooted at each node in terms of
  the total number of variables (max). It assumes that the node
  pointer passed to it is regular and it maintains the invariant.

  @sideeffect None

  @see gatherInfo

*/
static NodeData *
gatherInfoAux(
  DdNode * node /**< function to analyze */,
  ApproxInfo * info /**< info on %BDD */,
  int parity /**< gather parity information */)
{
    DdNode	*N, *Nt, *Ne;
    NodeData	*infoN, *infoT, *infoE;

    N = Cudd_Regular(node);

    /* Check whether entry for this node exists. */
    if ((infoN = (NodeData *) cuddHashTableGenericLookup(info->table, N)) != NULL) {
	if (parity) {
	    /* Update parity and propagate. */
	    updateParity(N, info, 1 +  (int) Cudd_IsComplement(node));
	}
	return(infoN);
    }

    /* Compute the cofactors. */
    Nt = Cudd_NotCond(cuddT(N), N != node);
    Ne = Cudd_NotCond(cuddE(N), N != node);

    infoT = gatherInfoAux(Nt, info, parity);
    if (infoT == NULL) return(NULL);
    infoE = gatherInfoAux(Ne, info, parity);
    if (infoE == NULL) return(NULL);

    infoT->functionRef++;
    infoE->functionRef++;

    /* Point to the correct location in the page. */
    infoN = &(info->page[info->index++]);
    infoN->parity |= (short) (1 + Cudd_IsComplement(node));

    infoN->mintermsP = infoT->mintermsP/2;
    infoN->mintermsN = infoT->mintermsN/2;
    if (Cudd_IsComplement(Ne) ^ Cudd_IsComplement(node)) {
	infoN->mintermsP += infoE->mintermsN/2;
	infoN->mintermsN += infoE->mintermsP/2;
    } else {
	infoN->mintermsP += infoE->mintermsP/2;
	infoN->mintermsN += infoE->mintermsN/2;
    }

    /* Insert entry for the node in the table. */
    if (cuddHashTableGenericInsert(info->table, N, infoN) == 0) {
	return(NULL);
    }
    return(infoN);

} /* end of gatherInfoAux */


/**
  @brief Gathers information about each node.

  @details Counts minterms and computes reference counts of each
  node in the %BDD. The minterm count is separately computed for the
  node and its complement. This is to avoid cancellation
  errors.

  @return a pointer to the data structure holding the information
  gathered if successful; NULL otherwise.

  @sideeffect None

  @see cuddUnderApprox gatherInfoAux

*/
static ApproxInfo *
gatherInfo(
  DdManager * dd /* manager */,
  DdNode * node /* function to be analyzed */,
  int numVars /* number of variables node depends on */,
  int parity /* gather parity information */)
{
    ApproxInfo * info;
    NodeData * infoTop;

    /* If user did not give numVars value, set it to the maximum
    ** exponent that the pow function can take. The -1 is due to the
    ** discrepancy in the value that pow takes and the value that
    ** log gives.
    */
    if (numVars == 0) {
	numVars = DBL_MAX_EXP - 1;
    }

    info = ALLOC(ApproxInfo,1);
    if (info == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    info->max = pow(2.0,(double) numVars);
    info->one = DD_ONE(dd);
    info->zero = Cudd_Not(info->one);
    info->size = Cudd_DagSize(node);
    /* All the information gathered will be stored in a contiguous
    ** piece of memory, which is allocated here. This can be done
    ** efficiently because we have counted the number of nodes of the
    ** BDD. info->index points to the next available entry in the array
    ** that stores the per-node information. */
    info->page = ALLOC(NodeData,info->size);
    if (info->page == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(info);
	return(NULL);
    }
    memset(info->page, 0, info->size * sizeof(NodeData)); /* clear all page */
    info->table = cuddHashTableInit(dd,1,info->size);
    if (info->table == NULL) {
	FREE(info->page);
	FREE(info);
	return(NULL);
    }
    /* We visit the DAG in post-order DFS. Hence, the constant node is
    ** in first position, and the root of the DAG is in last position. */

    /* Info for the constant node: Initialize only fields different from 0. */
    if (cuddHashTableGenericInsert(info->table, info->one, info->page) == 0) {
	FREE(info->page);
	cuddHashTableGenericQuit(info->table);
	FREE(info);
	return(NULL);
    }
    info->page[0].mintermsP = info->max;
    info->index = 1;

    infoTop = gatherInfoAux(node,info,parity);
    if (infoTop == NULL) {
	FREE(info->page);
	cuddHashTableGenericQuit(info->table);
	FREE(info);
	return(NULL);
    }
    if (Cudd_IsComplement(node)) {
	info->minterms = infoTop->mintermsN;
    } else {
	info->minterms = infoTop->mintermsP;
    }

    infoTop->functionRef = 1;
    return(info);

} /* end of gatherInfo */


/**
  @brief Counts the nodes that would be eliminated if a given node
  were replaced by zero.

  @details This procedure uses a queue passed by the caller for
  efficiency: since the queue is left empty at the endof the search,
  it can be reused as is by the next search.

  @return the count (always striclty positive) if successful; 0
  otherwise.

  @sideeffect None

  @see UAmarkNodes RAmarkNodes BAmarkNodes

*/
static int
computeSavings(
  DdManager * dd,
  DdNode * f,
  DdNode * skip,
  ApproxInfo * info,
  DdLevelQueue * queue)
{
    NodeData *infoN;
    LocalQueueItem *item;
    DdNode *node;
    int savings = 0;

    node = Cudd_Regular(f);
    if (node == NULL) return(0);
    skip = Cudd_Regular(skip);
    /* Insert the given node in the level queue. Its local reference
    ** count is set equal to the function reference count so that the
    ** search will continue from it when it is retrieved. */
    item = (LocalQueueItem *)
	cuddLevelQueueFirst(queue,node,cuddI(dd,node->index));
    if (item == NULL)
	return(0);
    infoN = (NodeData *) cuddHashTableGenericLookup(info->table, node);
    item->localRef = infoN->functionRef;

    /* Process the queue. */
    while ((item = (LocalQueueItem *) queue->first) != NULL) {
	node = item->node;
	if (node != skip) {
            infoN = (NodeData *) cuddHashTableGenericLookup(info->table,node);
            if (item->localRef == infoN->functionRef) {
                /* This node is not shared. */
                DdNode *nodeT, *nodeE;
                savings++;
                nodeT = cuddT(node);
                if (!cuddIsConstant(nodeT)) {
                    item = (LocalQueueItem *)
                        cuddLevelQueueEnqueue(queue,nodeT,cuddI(dd,nodeT->index));
                    if (item == NULL) return(0);
                    item->localRef++;
                }
                nodeE = Cudd_Regular(cuddE(node));
                if (!cuddIsConstant(nodeE)) {
                    item = (LocalQueueItem *)
                        cuddLevelQueueEnqueue(queue,nodeE,cuddI(dd,nodeE->index));
                    if (item == NULL) return(0);
                    item->localRef++;
                }
            }
        }
	cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
    }

#ifdef DD_DEBUG
    /* At the end of a local search the queue should be empty. */
    assert(queue->size == 0);
#endif
    return(savings);

} /* end of computeSavings */


/**
  @brief Update function reference counts to account for replacement.

  @return the number of nodes saved if successful; 0 otherwise.

  @sideeffect None

  @see UAmarkNodes RAmarkNodes BAmarkNodes

*/
static int
updateRefs(
  DdManager * dd,
  DdNode * f,
  DdNode * skip,
  ApproxInfo * info,
  DdLevelQueue * queue)
{
    NodeData *infoN;
    LocalQueueItem *item;
    DdNode *node;
    int savings = 0;

    node = Cudd_Regular(f);
    /* Insert the given node in the level queue. Its function reference
    ** count is set equal to 0 so that the search will continue from it
    ** when it is retrieved. */
    item = (LocalQueueItem *) cuddLevelQueueFirst(queue,node,cuddI(dd,node->index));
    if (item == NULL)
	return(0);
    infoN = (NodeData *) cuddHashTableGenericLookup(info->table, node);
    infoN->functionRef = 0;

    if (skip != NULL) {
	/* Increase the function reference count of the node to be skipped
	** by 1 to account for the node pointing to it that will be created. */
	skip = Cudd_Regular(skip);
	infoN = (NodeData *) cuddHashTableGenericLookup(info->table, skip);
	infoN->functionRef++;
    }

    /* Process the queue. */
    while ((item = (LocalQueueItem *) queue->first) != NULL) {
	node = item->node;
	infoN = (NodeData *) cuddHashTableGenericLookup(info->table,node);
	if (infoN->functionRef == 0) {
	    /* This node is not shared or to be be skipped. */
            DdNode *nodeT, *nodeE;
            savings++;
            nodeT = cuddT(node);
            if (!cuddIsConstant(nodeT)) {
                item = (LocalQueueItem *)
                    cuddLevelQueueEnqueue(queue,nodeT,cuddI(dd,nodeT->index));
                if (item == NULL) return(0);
                infoN = (NodeData *) cuddHashTableGenericLookup(info->table,nodeT);
                infoN->functionRef--;
            }
            nodeE = Cudd_Regular(cuddE(node));
            if (!cuddIsConstant(nodeE)) {
                item = (LocalQueueItem *)
                    cuddLevelQueueEnqueue(queue,nodeE,cuddI(dd,nodeE->index));
                if (item == NULL) return(0);
                infoN = (NodeData *) cuddHashTableGenericLookup(info->table,nodeE);
                infoN->functionRef--;
            }
	}
	cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
    }

#ifdef DD_DEBUG
    /* At the end of a local search the queue should be empty. */
    assert(queue->size == 0);
#endif
    return(savings);

} /* end of updateRefs */


/**
  @brief Marks nodes for replacement by zero.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddUnderApprox

*/
static int
UAmarkNodes(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be analyzed */,
  ApproxInfo * info /**< info on %BDD */,
  int  threshold /**< when to stop approximating */,
  int  safe /**< enforce safe approximation */,
  double  quality /**< minimum improvement for accepted changes */)
{
    DdLevelQueue *queue;
    DdLevelQueue *localQueue;
    NodeData *infoN;
    GlobalQueueItem *item;
    DdNode *node;
    double numOnset;
    double impactP, impactN;
    int savings;

#if 0
    (void) printf("initial size = %d initial minterms = %g\n",
		  info->size, info->minterms);
#endif
    queue = cuddLevelQueueInit(dd->size,sizeof(GlobalQueueItem),info->size,dd);
    if (queue == NULL) {
	return(0);
    }
    localQueue = cuddLevelQueueInit(dd->size,sizeof(LocalQueueItem),
				    dd->initSlots,dd);
    if (localQueue == NULL) {
	cuddLevelQueueQuit(queue);
	return(0);
    }
    node = Cudd_Regular(f);
    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,node,cuddI(dd,node->index));
    if (item == NULL) {
	cuddLevelQueueQuit(queue);
	cuddLevelQueueQuit(localQueue);
	return(0);
    }
    if (Cudd_IsComplement(f)) {
	item->impactP = 0.0;
	item->impactN = 1.0;
    } else {
	item->impactP = 1.0;
	item->impactN = 0.0;
    }
    while (queue->first != NULL) {
	/* If the size of the subset is below the threshold, quit. */
	if (info->size <= threshold)
	    break;
	item = (GlobalQueueItem *) queue->first;
	node = item->node;
	node = Cudd_Regular(node);
	infoN = (NodeData *) cuddHashTableGenericLookup(info->table, node);
	if (safe && infoN->parity == 3) {
	    cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
	    continue;
	}
	impactP = item->impactP;
	impactN = item->impactN;
	numOnset = infoN->mintermsP * impactP + infoN->mintermsN * impactN;
	savings = computeSavings(dd,node,NULL,info,localQueue);
	if (savings == 0) {
	    cuddLevelQueueQuit(queue);
	    cuddLevelQueueQuit(localQueue);
	    return(0);
	}
	cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
#if 0
	(void) printf("node %p: impact = %g/%g numOnset = %g savings %d\n",
		      node, impactP, impactN, numOnset, savings);
#endif
	if ((1 - numOnset / info->minterms) >
	    quality * (1 - (double) savings / info->size)) {
	    infoN->replace = CUDD_TRUE;
	    info->size -= savings;
	    info->minterms -=numOnset;
#if 0
	    (void) printf("replace: new size = %d new minterms = %g\n",
			  info->size, info->minterms);
#endif
	    savings -= updateRefs(dd,node,NULL,info,localQueue);
	    assert(savings == 0);
	    continue;
	}
	if (!cuddIsConstant(cuddT(node))) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,cuddT(node),
					 cuddI(dd,cuddT(node)->index));
	    item->impactP += impactP/2.0;
	    item->impactN += impactN/2.0;
	}
	if (!Cudd_IsConstantInt(cuddE(node))) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,Cudd_Regular(cuddE(node)),
					 cuddI(dd,Cudd_Regular(cuddE(node))->index));
	    if (Cudd_IsComplement(cuddE(node))) {
		item->impactP += impactN/2.0;
		item->impactN += impactP/2.0;
	    } else {
		item->impactP += impactP/2.0;
		item->impactN += impactN/2.0;
	    }
	}
    }

    cuddLevelQueueQuit(queue);
    cuddLevelQueueQuit(localQueue);
    return(1);

} /* end of UAmarkNodes */


/**
  @brief Builds the subset %BDD. 

  @details Based on the info table, replaces selected nodes by zero.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see cuddUnderApprox

*/
static DdNode *
UAbuildSubset(
  DdManager * dd /**< %DD manager */,
  DdNode * node /**< current node */,
  ApproxInfo * info /**< node info */)
{

    DdNode *Nt, *Ne, *N, *t, *e, *r;
    NodeData *infoN;

    if (Cudd_IsConstantInt(node))
	return(node);

    N = Cudd_Regular(node);

    if ((infoN = (NodeData *) cuddHashTableGenericLookup(info->table, N)) != NULL) {
	if (infoN->replace == CUDD_TRUE) {
	    return(info->zero);
	}
	if (N == node ) {
	    if (infoN->resultP != NULL) {
		return(infoN->resultP);
	    }
	} else {
	    if (infoN->resultN != NULL) {
		return(infoN->resultN);
	    }
	}
    } else {
	(void) fprintf(dd->err,
		       "Something is wrong, ought to be in info table\n");
	dd->errorCode = CUDD_INTERNAL_ERROR;
	return(NULL);
    }

    Nt = Cudd_NotCond(cuddT(N), Cudd_IsComplement(node));
    Ne = Cudd_NotCond(cuddE(N), Cudd_IsComplement(node));

    t = UAbuildSubset(dd, Nt, info);
    if (t == NULL) {
	return(NULL);
    }
    cuddRef(t);

    e = UAbuildSubset(dd, Ne, info);
    if (e == NULL) {
	Cudd_RecursiveDeref(dd,t);
	return(NULL);
    }
    cuddRef(e);

    if (Cudd_IsComplement(t)) {
	t = Cudd_Not(t);
	e = Cudd_Not(e);
	r = (t == e) ? t : cuddUniqueInter(dd, N->index, t, e);
	if (r == NULL) {
	    Cudd_RecursiveDeref(dd, e);
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
	r = Cudd_Not(r);
    } else {
	r = (t == e) ? t : cuddUniqueInter(dd, N->index, t, e);
	if (r == NULL) {
	    Cudd_RecursiveDeref(dd, e);
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
    }
    cuddDeref(t);
    cuddDeref(e);

    if (N == node) {
	infoN->resultP = r;
    } else {
	infoN->resultN = r;
    }

    return(r);

} /* end of UAbuildSubset */


/**
  @brief Marks nodes for remapping.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddRemapUnderApprox

*/
static int
RAmarkNodes(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be analyzed */,
  ApproxInfo * info /**< info on %BDD */,
  int threshold /**< when to stop approximating */,
  double quality /**< minimum improvement for accepted changes */)
{
    DdLevelQueue *queue;
    DdLevelQueue *localQueue;
    NodeData *infoN, *infoT, *infoE;
    GlobalQueueItem *item;
    DdNode *node, *T, *E;
    DdNode *shared; /* grandchild shared by the two children of node */
    double numOnset;
    double impact, impactP, impactN;
    double minterms;
    int savings;
    int replace;

#if 0
    (void) fprintf(dd->out,"initial size = %d initial minterms = %g\n",
		  info->size, info->minterms);
#endif
    queue = cuddLevelQueueInit(dd->size,sizeof(GlobalQueueItem),info->size,dd);
    if (queue == NULL) {
	return(0);
    }
    localQueue = cuddLevelQueueInit(dd->size,sizeof(LocalQueueItem),
				    dd->initSlots,dd);
    if (localQueue == NULL) {
	cuddLevelQueueQuit(queue);
	return(0);
    }
    /* Enqueue regular pointer to root and initialize impact. */
    node = Cudd_Regular(f);
    item = (GlobalQueueItem *)
	cuddLevelQueueEnqueue(queue,node,cuddI(dd,node->index));
    if (item == NULL) {
	cuddLevelQueueQuit(queue);
	cuddLevelQueueQuit(localQueue);
	return(0);
    }
    if (Cudd_IsComplement(f)) {
	item->impactP = 0.0;
	item->impactN = 1.0;
    } else {
	item->impactP = 1.0;
	item->impactN = 0.0;
    }
    /* The nodes retrieved here are guaranteed to be non-terminal.
    ** The initial node is not terminal because constant nodes are
    ** dealt with in the calling procedure. Subsequent nodes are inserted
    ** only if they are not terminal. */
    while ((item = (GlobalQueueItem *) queue->first) != NULL) {
	/* If the size of the subset is below the threshold, quit. */
	if (info->size <= threshold)
	    break;
	node = item->node;
#ifdef DD_DEBUG
	assert(item->impactP >= 0 && item->impactP <= 1.0);
	assert(item->impactN >= 0 && item->impactN <= 1.0);
	assert(!Cudd_IsComplement(node));
	assert(!Cudd_IsConstantInt(node));
#endif
	if ((infoN = (NodeData *) cuddHashTableGenericLookup(info->table, node)) == NULL) {
	    cuddLevelQueueQuit(queue);
	    cuddLevelQueueQuit(localQueue);
	    return(0);
	}
#ifdef DD_DEBUG
	assert(infoN->parity >= 1 && infoN->parity <= 3);
#endif
	if (infoN->parity == 3) {
	    /* This node can be reached through paths of different parity.
	    ** It is not safe to replace it, because remapping will give
	    ** an incorrect result, while replacement by 0 may cause node
	    ** splitting. */
	    cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
	    continue;
	}
	T = cuddT(node);
	E = cuddE(node);
	shared = NULL;
	impactP = item->impactP;
	impactN = item->impactN;
	if (Cudd_bddLeq(dd,T,E)) {
	    /* Here we know that E is regular. */
#ifdef DD_DEBUG
	    assert(!Cudd_IsComplement(E));
#endif
	    infoT = (NodeData *) cuddHashTableGenericLookup(info->table, T);
	    infoE = (NodeData *) cuddHashTableGenericLookup(info->table, E);
	    if (infoN->parity == 1) {
		impact = impactP;
		minterms = infoE->mintermsP/2.0 - infoT->mintermsP/2.0;
		if (infoE->functionRef == 1 && !cuddIsConstant(E)) {
		    savings = 1 + computeSavings(dd,E,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_E;
	    } else {
#ifdef DD_DEBUG
		assert(infoN->parity == 2);
#endif
		impact = impactN;
		minterms = infoT->mintermsN/2.0 - infoE->mintermsN/2.0;
		if (infoT->functionRef == 1 && !cuddIsConstant(T)) {
		    savings = 1 + computeSavings(dd,T,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_T;
	    }
	    numOnset = impact * minterms;
	} else if (Cudd_bddLeq(dd,E,T)) {
	    /* Here E may be complemented. */
	    DdNode *Ereg = Cudd_Regular(E);
	    infoT = (NodeData *) cuddHashTableGenericLookup(info->table, T);
	    infoE = (NodeData *) cuddHashTableGenericLookup(info->table, Ereg);
	    if (infoN->parity == 1) {
		impact = impactP;
		minterms = infoT->mintermsP/2.0 -
		    ((E == Ereg) ? infoE->mintermsP : infoE->mintermsN)/2.0;
		if (infoT->functionRef == 1 && !cuddIsConstant(T)) {
		    savings = 1 + computeSavings(dd,T,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_T;
	    } else {
#ifdef DD_DEBUG
		assert(infoN->parity == 2);
#endif
		impact = impactN;
		minterms = ((E == Ereg) ? infoE->mintermsN :
			    infoE->mintermsP)/2.0 - infoT->mintermsN/2.0;
		if (infoE->functionRef == 1 && !cuddIsConstant(Ereg)) {
		    savings = 1 + computeSavings(dd,E,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_E;
	    }
	    numOnset = impact * minterms;
	} else {
	    DdNode *Ereg = Cudd_Regular(E);
	    DdNode *TT = cuddT(T);
	    DdNode *ET = Cudd_NotCond(cuddT(Ereg), Cudd_IsComplement(E));
	    if (T->index == Ereg->index && TT == ET) {
		shared = TT;
		replace = REPLACE_TT;
	    } else {
		DdNode *TE = cuddE(T);
		DdNode *EE = Cudd_NotCond(cuddE(Ereg), Cudd_IsComplement(E));
		if (T->index == Ereg->index && TE == EE) {
		    shared = TE;
		    replace = REPLACE_TE;
		} else {
		    replace = REPLACE_N;
		}
	    }
	    numOnset = infoN->mintermsP * impactP + infoN->mintermsN * impactN;
	    savings = computeSavings(dd,node,shared,info,localQueue);
	    if (shared != NULL) {
		NodeData *infoS;
		infoS = (NodeData *) cuddHashTableGenericLookup(info->table, Cudd_Regular(shared));
		if (Cudd_IsComplement(shared)) {
		    numOnset -= (infoS->mintermsN * impactP +
			infoS->mintermsP * impactN)/2.0;
		} else {
		    numOnset -= (infoS->mintermsP * impactP +
			infoS->mintermsN * impactN)/2.0;
		}
		savings--;
	    }
	}

	cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
#if 0
	if (replace == REPLACE_T || replace == REPLACE_E)
	    (void) printf("node %p: impact = %g numOnset = %g savings %d\n",
			  node, impact, numOnset, savings);
	else
	    (void) printf("node %p: impact = %g/%g numOnset = %g savings %d\n",
			  node, impactP, impactN, numOnset, savings);
#endif
	if ((1 - numOnset / info->minterms) >
	    quality * (1 - (double) savings / info->size)) {
	    infoN->replace = (char) replace;
	    info->size -= savings;
	    info->minterms -=numOnset;
#if 0
	    (void) printf("remap(%d): new size = %d new minterms = %g\n",
			  replace, info->size, info->minterms);
#endif
	    if (replace == REPLACE_N) {
		savings -= updateRefs(dd,node,NULL,info,localQueue);
	    } else if (replace == REPLACE_T) {
		savings -= updateRefs(dd,node,E,info,localQueue);
	    } else if (replace == REPLACE_E) {
		savings -= updateRefs(dd,node,T,info,localQueue);
	    } else {
#ifdef DD_DEBUG
		assert(replace == REPLACE_TT || replace == REPLACE_TE);
#endif
		savings -= updateRefs(dd,node,shared,info,localQueue) - 1;
	    }
	    assert(savings == 0);
	} else {
	    replace = NOTHING;
	}
	if (replace == REPLACE_N) continue;
	if ((replace == REPLACE_E || replace == NOTHING) &&
	    !cuddIsConstant(cuddT(node))) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,cuddT(node),
					 cuddI(dd,cuddT(node)->index));
	    if (replace == REPLACE_E) {
		item->impactP += impactP;
		item->impactN += impactN;
	    } else {
		item->impactP += impactP/2.0;
		item->impactN += impactN/2.0;
	    }
	}
	if ((replace == REPLACE_T || replace == NOTHING) &&
	    !Cudd_IsConstantInt(cuddE(node))) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,Cudd_Regular(cuddE(node)),
					 cuddI(dd,Cudd_Regular(cuddE(node))->index));
	    if (Cudd_IsComplement(cuddE(node))) {
		if (replace == REPLACE_T) {
		    item->impactP += impactN;
		    item->impactN += impactP;
		} else {
		    item->impactP += impactN/2.0;
		    item->impactN += impactP/2.0;
		}
	    } else {
		if (replace == REPLACE_T) {
		    item->impactP += impactP;
		    item->impactN += impactN;
		} else {
		    item->impactP += impactP/2.0;
		    item->impactN += impactN/2.0;
		}
	    }
	}
	if ((replace == REPLACE_TT || replace == REPLACE_TE) &&
	    !Cudd_IsConstantInt(shared)) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,Cudd_Regular(shared),
					 cuddI(dd,Cudd_Regular(shared)->index));
	    if (Cudd_IsComplement(shared)) {
	        item->impactP += impactN;
		item->impactN += impactP;
	    } else {
	        item->impactP += impactP;
		item->impactN += impactN;
	    }
	}
    }

    cuddLevelQueueQuit(queue);
    cuddLevelQueueQuit(localQueue);
    return(1);

} /* end of RAmarkNodes */


/**
  @brief Marks nodes for remapping.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddBiasedUnderApprox

*/
static int
BAmarkNodes(
  DdManager *dd /**< manager */,
  DdNode *f /**< function to be analyzed */,
  ApproxInfo *info /**< info on %BDD */,
  int threshold /**< when to stop approximating */,
  double quality1 /**< minimum improvement for accepted changes when b=1 */,
  double quality0 /**< minimum improvement for accepted changes when b=0 */)
{
    DdLevelQueue *queue;
    DdLevelQueue *localQueue;
    NodeData *infoN, *infoT, *infoE;
    GlobalQueueItem *item;
    DdNode *node, *T, *E;
    DdNode *shared; /* grandchild shared by the two children of node */
    double numOnset;
    double impact, impactP, impactN;
    double minterms;
    double quality;
    int savings;
    int replace;

#if 0
    (void) fprintf(dd->out,"initial size = %d initial minterms = %g\n",
		  info->size, info->minterms);
#endif
    queue = cuddLevelQueueInit(dd->size,sizeof(GlobalQueueItem),info->size,dd);
    if (queue == NULL) {
	return(0);
    }
    localQueue = cuddLevelQueueInit(dd->size,sizeof(LocalQueueItem),
				    dd->initSlots,dd);
    if (localQueue == NULL) {
	cuddLevelQueueQuit(queue);
	return(0);
    }
    /* Enqueue regular pointer to root and initialize impact. */
    node = Cudd_Regular(f);
    item = (GlobalQueueItem *)
	cuddLevelQueueEnqueue(queue,node,cuddI(dd,node->index));
    if (item == NULL) {
	cuddLevelQueueQuit(queue);
	cuddLevelQueueQuit(localQueue);
	return(0);
    }
    if (Cudd_IsComplement(f)) {
	item->impactP = 0.0;
	item->impactN = 1.0;
    } else {
	item->impactP = 1.0;
	item->impactN = 0.0;
    }
    /* The nodes retrieved here are guaranteed to be non-terminal.
    ** The initial node is not terminal because constant nodes are
    ** dealt with in the calling procedure. Subsequent nodes are inserted
    ** only if they are not terminal. */
    while (queue->first != NULL) {
	/* If the size of the subset is below the threshold, quit. */
	if (info->size <= threshold)
	    break;
	item = (GlobalQueueItem *) queue->first;
	node = item->node;
#ifdef DD_DEBUG
	assert(item->impactP >= 0 && item->impactP <= 1.0);
	assert(item->impactN >= 0 && item->impactN <= 1.0);
	assert(!Cudd_IsComplement(node));
	assert(!Cudd_IsConstantInt(node));
#endif
	if ((infoN = (NodeData *) cuddHashTableGenericLookup(info->table, node)) == NULL) {
	    cuddLevelQueueQuit(queue);
	    cuddLevelQueueQuit(localQueue);
	    return(0);
	}
	quality = infoN->care ? quality1 : quality0;
#ifdef DD_DEBUG
	assert(infoN->parity >= 1 && infoN->parity <= 3);
#endif
	if (infoN->parity == 3) {
	    /* This node can be reached through paths of different parity.
	    ** It is not safe to replace it, because remapping will give
	    ** an incorrect result, while replacement by 0 may cause node
	    ** splitting. */
	    cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
	    continue;
	}
	T = cuddT(node);
	E = cuddE(node);
	shared = NULL;
	impactP = item->impactP;
	impactN = item->impactN;
	if (Cudd_bddLeq(dd,T,E)) {
	    /* Here we know that E is regular. */
#ifdef DD_DEBUG
	    assert(!Cudd_IsComplement(E));
#endif
	    infoT = (NodeData *) cuddHashTableGenericLookup(info->table, T);
	    infoE = (NodeData *) cuddHashTableGenericLookup(info->table, E);
	    if (infoN->parity == 1) {
		impact = impactP;
		minterms = infoE->mintermsP/2.0 - infoT->mintermsP/2.0;
		if (infoE->functionRef == 1 && !Cudd_IsConstantInt(E)) {
		    savings = 1 + computeSavings(dd,E,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_E;
	    } else {
#ifdef DD_DEBUG
		assert(infoN->parity == 2);
#endif
		impact = impactN;
		minterms = infoT->mintermsN/2.0 - infoE->mintermsN/2.0;
		if (infoT->functionRef == 1 && !Cudd_IsConstantInt(T)) {
		    savings = 1 + computeSavings(dd,T,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_T;
	    }
	    numOnset = impact * minterms;
	} else if (Cudd_bddLeq(dd,E,T)) {
	    /* Here E may be complemented. */
	    DdNode *Ereg = Cudd_Regular(E);
	    infoT = (NodeData *) cuddHashTableGenericLookup(info->table, T);
	    infoE = (NodeData *) cuddHashTableGenericLookup(info->table, Ereg);
	    if (infoN->parity == 1) {
		impact = impactP;
		minterms = infoT->mintermsP/2.0 -
		    ((E == Ereg) ? infoE->mintermsP : infoE->mintermsN)/2.0;
		if (infoT->functionRef == 1 && !Cudd_IsConstantInt(T)) {
		    savings = 1 + computeSavings(dd,T,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_T;
	    } else {
#ifdef DD_DEBUG
		assert(infoN->parity == 2);
#endif
		impact = impactN;
		minterms = ((E == Ereg) ? infoE->mintermsN :
			    infoE->mintermsP)/2.0 - infoT->mintermsN/2.0;
		if (infoE->functionRef == 1 && !Cudd_IsConstantInt(E)) {
		    savings = 1 + computeSavings(dd,E,NULL,info,localQueue);
		    if (savings == 1) {
			cuddLevelQueueQuit(queue);
			cuddLevelQueueQuit(localQueue);
			return(0);
		    }
		} else {
		    savings = 1;
		}
		replace = REPLACE_E;
	    }
	    numOnset = impact * minterms;
	} else {
	    DdNode *Ereg = Cudd_Regular(E);
	    DdNode *TT = cuddT(T);
	    DdNode *ET = Cudd_NotCond(cuddT(Ereg), Cudd_IsComplement(E));
	    if (T->index == Ereg->index && TT == ET) {
		shared = TT;
		replace = REPLACE_TT;
	    } else {
		DdNode *TE = cuddE(T);
		DdNode *EE = Cudd_NotCond(cuddE(Ereg), Cudd_IsComplement(E));
		if (T->index == Ereg->index && TE == EE) {
		    shared = TE;
		    replace = REPLACE_TE;
		} else {
		    replace = REPLACE_N;
		}
	    }
	    numOnset = infoN->mintermsP * impactP + infoN->mintermsN * impactN;
	    savings = computeSavings(dd,node,shared,info,localQueue);
	    if (shared != NULL) {
		NodeData *infoS;
		infoS = (NodeData *) cuddHashTableGenericLookup(info->table, Cudd_Regular(shared));
		if (Cudd_IsComplement(shared)) {
		    numOnset -= (infoS->mintermsN * impactP +
			infoS->mintermsP * impactN)/2.0;
		} else {
		    numOnset -= (infoS->mintermsP * impactP +
			infoS->mintermsN * impactN)/2.0;
		}
		savings--;
	    }
	}

	cuddLevelQueueDequeue(queue,cuddI(dd,node->index));
#if 0
	if (replace == REPLACE_T || replace == REPLACE_E)
	    (void) printf("node %p: impact = %g numOnset = %g savings %d\n",
			  node, impact, numOnset, savings);
	else
	    (void) printf("node %p: impact = %g/%g numOnset = %g savings %d\n",
			  node, impactP, impactN, numOnset, savings);
#endif
	if ((1 - numOnset / info->minterms) >
	    quality * (1 - (double) savings / info->size)) {
	    infoN->replace = (char) replace;
	    info->size -= savings;
	    info->minterms -=numOnset;
#if 0
	    (void) printf("remap(%d): new size = %d new minterms = %g\n",
			  replace, info->size, info->minterms);
#endif
	    if (replace == REPLACE_N) {
		savings -= updateRefs(dd,node,NULL,info,localQueue);
	    } else if (replace == REPLACE_T) {
		savings -= updateRefs(dd,node,E,info,localQueue);
	    } else if (replace == REPLACE_E) {
		savings -= updateRefs(dd,node,T,info,localQueue);
	    } else {
#ifdef DD_DEBUG
		assert(replace == REPLACE_TT || replace == REPLACE_TE);
#endif
		savings -= updateRefs(dd,node,shared,info,localQueue) - 1;
	    }
	    assert(savings == 0);
	} else {
	    replace = NOTHING;
	}
	if (replace == REPLACE_N) continue;
	if ((replace == REPLACE_E || replace == NOTHING) &&
	    !cuddIsConstant(cuddT(node))) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,cuddT(node),
					 cuddI(dd,cuddT(node)->index));
	    if (replace == REPLACE_E) {
		item->impactP += impactP;
		item->impactN += impactN;
	    } else {
		item->impactP += impactP/2.0;
		item->impactN += impactN/2.0;
	    }
	}
	if ((replace == REPLACE_T || replace == NOTHING) &&
	    !Cudd_IsConstantInt(cuddE(node))) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,Cudd_Regular(cuddE(node)),
					 cuddI(dd,Cudd_Regular(cuddE(node))->index));
	    if (Cudd_IsComplement(cuddE(node))) {
		if (replace == REPLACE_T) {
		    item->impactP += impactN;
		    item->impactN += impactP;
		} else {
		    item->impactP += impactN/2.0;
		    item->impactN += impactP/2.0;
		}
	    } else {
		if (replace == REPLACE_T) {
		    item->impactP += impactP;
		    item->impactN += impactN;
		} else {
		    item->impactP += impactP/2.0;
		    item->impactN += impactN/2.0;
		}
	    }
	}
	if ((replace == REPLACE_TT || replace == REPLACE_TE) &&
	    !Cudd_IsConstantInt(shared)) {
	    item = (GlobalQueueItem *) cuddLevelQueueEnqueue(queue,Cudd_Regular(shared),
					 cuddI(dd,Cudd_Regular(shared)->index));
	    if (Cudd_IsComplement(shared)) {
		if (replace == REPLACE_T) {
		    item->impactP += impactN;
		    item->impactN += impactP;
		} else {
		    item->impactP += impactN/2.0;
		    item->impactN += impactP/2.0;
		}
	    } else {
		if (replace == REPLACE_T) {
		    item->impactP += impactP;
		    item->impactN += impactN;
		} else {
		    item->impactP += impactP/2.0;
		    item->impactN += impactN/2.0;
		}
	    }
	}
    }

    cuddLevelQueueQuit(queue);
    cuddLevelQueueQuit(localQueue);
    return(1);

} /* end of BAmarkNodes */


/**
  @brief Builds the subset %BDD for cuddRemapUnderApprox.

  @details Based on the info table, performs remapping or replacement
  at selected nodes.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see cuddRemapUnderApprox

*/
static DdNode *
RAbuildSubset(
  DdManager * dd /**< %DD manager */,
  DdNode * node /**< current node */,
  ApproxInfo * info /**< node info */)
{
    DdNode *Nt, *Ne, *N, *t, *e, *r;
    NodeData *infoN;

    if (Cudd_IsConstantInt(node))
	return(node);

    N = Cudd_Regular(node);

    Nt = Cudd_NotCond(cuddT(N), Cudd_IsComplement(node));
    Ne = Cudd_NotCond(cuddE(N), Cudd_IsComplement(node));

    if ((infoN = (NodeData *) cuddHashTableGenericLookup(info->table, N)) != NULL) {
	if (N == node ) {
	    if (infoN->resultP != NULL) {
		return(infoN->resultP);
	    }
	} else {
	    if (infoN->resultN != NULL) {
		return(infoN->resultN);
	    }
	}
	if (infoN->replace == REPLACE_T) {
	    r = RAbuildSubset(dd, Ne, info);
	    return(r);
	} else if (infoN->replace == REPLACE_E) {
	    r = RAbuildSubset(dd, Nt, info);
	    return(r);
	} else if (infoN->replace == REPLACE_N) {
	    return(info->zero);
	} else if (infoN->replace == REPLACE_TT) {
	    DdNode *Ntt = Cudd_NotCond(cuddT(cuddT(N)),
				       Cudd_IsComplement(node));
	    int index = cuddT(N)->index;
	    e = info->zero;
	    t = RAbuildSubset(dd, Ntt, info);
	    if (t == NULL) {
		return(NULL);
	    }
	    cuddRef(t);
	    if (Cudd_IsComplement(t)) {
		t = Cudd_Not(t);
		e = Cudd_Not(e);
		r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
		if (r == NULL) {
		    Cudd_RecursiveDeref(dd, t);
		    return(NULL);
		}
		r = Cudd_Not(r);
	    } else {
		r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
		if (r == NULL) {
		    Cudd_RecursiveDeref(dd, t);
		    return(NULL);
		}
	    }
	    cuddDeref(t);
	    return(r);
	} else if (infoN->replace == REPLACE_TE) {
	    DdNode *Nte = Cudd_NotCond(cuddE(cuddT(N)),
				       Cudd_IsComplement(node));
	    unsigned int index = cuddT(N)->index;
	    t = info->one;
	    e = RAbuildSubset(dd, Nte, info);
	    if (e == NULL) {
		return(NULL);
	    }
	    cuddRef(e);
	    e = Cudd_Not(e);
	    r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	    if (r == NULL) {
		Cudd_RecursiveDeref(dd, e);
		return(NULL);
	    }
	    r =Cudd_Not(r);
	    cuddDeref(e);
	    return(r);
	}
    } else {
	(void) fprintf(dd->err,
		       "Something is wrong, ought to be in info table\n");
	dd->errorCode = CUDD_INTERNAL_ERROR;
	return(NULL);
    }

    t = RAbuildSubset(dd, Nt, info);
    if (t == NULL) {
	return(NULL);
    }
    cuddRef(t);

    e = RAbuildSubset(dd, Ne, info);
    if (e == NULL) {
	Cudd_RecursiveDeref(dd,t);
	return(NULL);
    }
    cuddRef(e);

    if (Cudd_IsComplement(t)) {
	t = Cudd_Not(t);
	e = Cudd_Not(e);
	r = (t == e) ? t : cuddUniqueInter(dd, N->index, t, e);
	if (r == NULL) {
	    Cudd_RecursiveDeref(dd, e);
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
	r = Cudd_Not(r);
    } else {
	r = (t == e) ? t : cuddUniqueInter(dd, N->index, t, e);
	if (r == NULL) {
	    Cudd_RecursiveDeref(dd, e);
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
    }
    cuddDeref(t);
    cuddDeref(e);

    if (N == node) {
	infoN->resultP = r;
    } else {
	infoN->resultN = r;
    }

    return(r);

} /* end of RAbuildSubset */


/**
  @brief Finds don't care nodes by traversing f and b in parallel.

  @return the care status of the visited f node if successful;
  CARE_ERROR otherwise.

  @sideeffect None

  @see cuddBiasedUnderApprox

*/
static int
BAapplyBias(
  DdManager *dd,
  DdNode *f,
  DdNode *b,
  ApproxInfo *info,
  DdHashTable *cache)
{
    DdNode *one, *zero, *res;
    DdNode *Ft, *Fe, *B, *Bt, *Be;
    int topf, topb;
    NodeData *infoF;
    int careT, careE;

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    if ((infoF = (NodeData *) cuddHashTableGenericLookup(info->table, f)) == NULL)
	return(CARE_ERROR);
    if (f == one) return(TOTAL_CARE);
    if (b == zero) return(infoF->care);
    if (infoF->care == TOTAL_CARE) return(TOTAL_CARE);

    if ((f->ref != 1 || Cudd_Regular(b)->ref != 1) &&
	(res = cuddHashTableLookup2(cache,f,b)) != NULL) {
	if (res->ref == 0) {
	    cache->manager->dead++;
	    cache->manager->constants.dead++;
	}
	return(infoF->care);
    }

    topf = dd->perm[f->index];
    B = Cudd_Regular(b);
    topb = cuddI(dd,B->index);
    if (topf <= topb) {
	Ft = cuddT(f); Fe = cuddE(f);
    } else {
	Ft = Fe = f;
    }
    if (topb <= topf) {
	/* We know that b is not constant because f is not. */
	Bt = cuddT(B); Be = cuddE(B);
	if (Cudd_IsComplement(b)) {
	    Bt = Cudd_Not(Bt);
	    Be = Cudd_Not(Be);
	}
    } else {
	Bt = Be = b;
    }

    careT = BAapplyBias(dd, Ft, Bt, info, cache);
    if (careT == CARE_ERROR)
	return(CARE_ERROR);
    careE = BAapplyBias(dd, Cudd_Regular(Fe), Be, info, cache);
    if (careE == CARE_ERROR)
	return(CARE_ERROR);
    if (careT == TOTAL_CARE && careE == TOTAL_CARE) {
	infoF->care = TOTAL_CARE;
    } else {
	infoF->care = CARE;
    }

    if (f->ref != 1 || Cudd_Regular(b)->ref != 1) {
	ptrint fanout = (ptrint) f->ref * Cudd_Regular(b)->ref;
	cuddSatDec(fanout);
	if (!cuddHashTableInsert2(cache,f,b,one,fanout)) {
	    return(CARE_ERROR);
	}
    }
    return(infoF->care);

} /* end of BAapplyBias */

cuddBddAbs.c
19375
/**
  @file

  @ingroup cudd

  @brief Quantification functions for BDDs.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int bddCheckPositiveCube (DdManager *manager, DdNode *cube);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Existentially abstracts all the variables in cube from f.

  @return the abstracted %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddUnivAbstract Cudd_addExistAbstract

*/
DdNode *
Cudd_bddExistAbstract(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode *res;

    if (bddCheckPositiveCube(manager, cube) == 0) {
        (void) fprintf(manager->err,
		       "Error: Can only abstract positive cubes\n");
	manager->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }

    do {
	manager->reordered = 0;
	res = cuddBddExistAbstractRecur(manager, f, cube);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_bddExistAbstract */


/**
  @brief Existentially abstracts all the variables in cube from f.

  @return the abstracted %BDD if successful; NULL if the intermediate
  result blows up or more new nodes than <code>limit</code> are
  required.

  @sideeffect None

  @see Cudd_bddExistAbstract

*/
DdNode *
Cudd_bddExistAbstractLimit(
  DdManager * manager,
  DdNode * f,
  DdNode * cube,
  unsigned int limit)
{
    DdNode *res;
    unsigned int saveLimit = manager->maxLive;

    if (bddCheckPositiveCube(manager, cube) == 0) {
        (void) fprintf(manager->err,
		       "Error: Can only abstract positive cubes\n");
	manager->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }

    manager->maxLive = (manager->keys - manager->dead) + 
        (manager->keysZ - manager->deadZ) + limit;
    do {
	manager->reordered = 0;
	res = cuddBddExistAbstractRecur(manager, f, cube);
    } while (manager->reordered == 1);
    manager->maxLive = saveLimit;
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_bddExistAbstractLimit */


/**
  @brief Takes the exclusive OR of two BDDs and simultaneously abstracts the
  variables in cube.

  @details The variables are existentially abstracted.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddUnivAbstract Cudd_bddExistAbstract Cudd_bddAndAbstract

*/
DdNode *
Cudd_bddXorExistAbstract(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  DdNode * cube)
{
    DdNode *res;

    if (bddCheckPositiveCube(manager, cube) == 0) {
        (void) fprintf(manager->err,
		       "Error: Can only abstract positive cubes\n");
	manager->errorCode = CUDD_INVALID_ARG;
        return(NULL);
    }

    do {
	manager->reordered = 0;
	res = cuddBddXorExistAbstractRecur(manager, f, g, cube);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_bddXorExistAbstract */


/**
  @brief Universally abstracts all the variables in cube from f.

  @return the abstracted %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddExistAbstract Cudd_addUnivAbstract

*/
DdNode *
Cudd_bddUnivAbstract(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode	*res;

    if (bddCheckPositiveCube(manager, cube) == 0) {
	(void) fprintf(manager->err,
		       "Error: Can only abstract positive cubes\n");
	manager->errorCode = CUDD_INVALID_ARG;
	return(NULL);
    }

    do {
	manager->reordered = 0;
	res = cuddBddExistAbstractRecur(manager, Cudd_Not(f), cube);
    } while (manager->reordered == 1);
    if (res != NULL) res = Cudd_Not(res);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_bddUnivAbstract */


/**
  @brief Computes the boolean difference of f with respect to x.

  @details Computes the boolean difference of f with respect to the
  variable with index x.

  @return the %BDD of the boolean difference if successful; NULL
  otherwise.

  @sideeffect None

*/
DdNode *
Cudd_bddBooleanDiff(
  DdManager * manager,
  DdNode * f,
  int  x)
{
    DdNode *res, *var;

    /* If the variable is not currently in the manager, f cannot
    ** depend on it.
    */
    if (x >= manager->size) return(Cudd_Not(DD_ONE(manager)));
    var = manager->vars[x];

    do {
	manager->reordered = 0;
	res = cuddBddBooleanDiffRecur(manager, Cudd_Regular(f), var);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_bddBooleanDiff */


/**
  @brief Checks whether a variable is dependent on others in a
  function.

  @details No new nodes are created.

  @return 1 if the variable is dependent; 0 otherwise.

  @sideeffect None

*/
int
Cudd_bddVarIsDependent(
  DdManager *dd,		/**< manager */
  DdNode *f,			/**< function */
  DdNode *var			/**< variable */)
{
    DdNode *F, *res, *zero, *ft, *fe;
    unsigned topf, level;
    DD_CTFP cacheOp;
    int retval;

    zero = Cudd_Not(DD_ONE(dd));
    F = Cudd_Regular(f);
    if (cuddIsConstant(F)) return(f == zero);

    /* From now on f is not constant. */
    topf = (unsigned) dd->perm[F->index];
    level = (unsigned) dd->perm[var->index];

    /* Check terminal case. If topf > index of var, f does not depend on var.
    ** Therefore, var is not dependent in f. */
    if (topf > level) {
	return(0);
    }

    cacheOp = (DD_CTFP) Cudd_bddVarIsDependent;
    res = cuddCacheLookup2(dd,cacheOp,f,var);
    if (res != NULL) {
	return(res != zero);
    }

    /* Compute cofactors. */
    ft = Cudd_NotCond(cuddT(F), f != F);
    fe = Cudd_NotCond(cuddE(F), f != F);

    if (topf == level) {
	retval = Cudd_bddLeq(dd,ft,Cudd_Not(fe));
    } else {
	retval = Cudd_bddVarIsDependent(dd,ft,var) &&
	    Cudd_bddVarIsDependent(dd,fe,var);
    }

    cuddCacheInsert2(dd,cacheOp,f,var,Cudd_NotCond(zero,retval));

    return(retval);

} /* Cudd_bddVarIsDependent */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive steps of Cudd_bddExistAbstract.

  @details It is also used by Cudd_bddUnivAbstract.

  @return the %BDD obtained by abstracting the variables of cube from f
  if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddExistAbstract Cudd_bddUnivAbstract

*/
DdNode *
cuddBddExistAbstractRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * cube)
{
    DdNode	*F, *T, *E, *res, *res1, *res2, *one;

    statLine(manager);
    one = DD_ONE(manager);
    F = Cudd_Regular(f);

    /* Cube is guaranteed to be a cube at this point. */	
    if (cube == one || F == one) {  
        return(f);
    }
    /* From now on, f and cube are non-constant. */

    /* Abstract a variable that does not appear in f. */
    while (manager->perm[F->index] > manager->perm[cube->index]) {
	cube = cuddT(cube);
	if (cube == one) return(f);
    }

    /* Check the cache. */
    if (F->ref != 1 && (res = cuddCacheLookup2(manager, Cudd_bddExistAbstract, f, cube)) != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(manager);

    /* Compute the cofactors of f. */
    T = cuddT(F); E = cuddE(F);
    if (f != F) {
	T = Cudd_Not(T); E = Cudd_Not(E);
    }

    /* If the two indices are the same, so are their levels. */
    if (F->index == cube->index) {
	if (T == one || E == one || T == Cudd_Not(E)) {
	    return(one);
	}
	res1 = cuddBddExistAbstractRecur(manager, T, cuddT(cube));
	if (res1 == NULL) return(NULL);
	if (res1 == one) {
	    if (F->ref != 1)
		cuddCacheInsert2(manager, Cudd_bddExistAbstract, f, cube, one);
	    return(one);
	}
        cuddRef(res1);
	res2 = cuddBddExistAbstractRecur(manager, E, cuddT(cube));
	if (res2 == NULL) {
	    Cudd_IterDerefBdd(manager,res1);
	    return(NULL);
	}
        cuddRef(res2);
	res = cuddBddAndRecur(manager, Cudd_Not(res1), Cudd_Not(res2));
	if (res == NULL) {
	    Cudd_IterDerefBdd(manager, res1);
	    Cudd_IterDerefBdd(manager, res2);
	    return(NULL);
	}
	res = Cudd_Not(res);
	cuddRef(res);
	Cudd_IterDerefBdd(manager, res1);
	Cudd_IterDerefBdd(manager, res2);
	if (F->ref != 1)
	    cuddCacheInsert2(manager, Cudd_bddExistAbstract, f, cube, res);
	cuddDeref(res);
        return(res);
    } else { /* if (cuddI(manager,F->index) < cuddI(manager,cube->index)) */
	res1 = cuddBddExistAbstractRecur(manager, T, cube);
	if (res1 == NULL) return(NULL);
        cuddRef(res1);
	res2 = cuddBddExistAbstractRecur(manager, E, cube);
	if (res2 == NULL) {
	    Cudd_IterDerefBdd(manager, res1);
	    return(NULL);
	}
        cuddRef(res2);
	/* ITE takes care of possible complementation of res1 and of the
        ** case in which res1 == res2. */
	res = cuddBddIteRecur(manager, manager->vars[F->index], res1, res2);
	if (res == NULL) {
	    Cudd_IterDerefBdd(manager, res1);
	    Cudd_IterDerefBdd(manager, res2);
	    return(NULL);
	}
	cuddDeref(res1);
	cuddDeref(res2);
	if (F->ref != 1)
	    cuddCacheInsert2(manager, Cudd_bddExistAbstract, f, cube, res);
        return(res);
    }	    

} /* end of cuddBddExistAbstractRecur */


/**
  @brief Takes the exclusive OR of two BDDs and simultaneously abstracts the
  variables in cube.

  @details The variables are existentially abstracted.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddAndAbstract

*/
DdNode *
cuddBddXorExistAbstractRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  DdNode * cube)
{
    DdNode *F, *fv, *fnv, *G, *gv, *gnv;
    DdNode *one, *zero, *r, *t, *e, *Cube;
    int topf, topg, topcube, top;
    unsigned int index;

    statLine(manager);
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* Terminal cases. */
    if (f == g) {
	return(zero);
    }
    if (f == Cudd_Not(g)) {
	return(one);
    }
    if (cube == one) {
	return(cuddBddXorRecur(manager, f, g));
    }
    if (f == one) {
	return(cuddBddExistAbstractRecur(manager, Cudd_Not(g), cube));
    }
    if (g == one) {
	return(cuddBddExistAbstractRecur(manager, Cudd_Not(f), cube));
    }
    if (f == zero) {
	return(cuddBddExistAbstractRecur(manager, g, cube));
    }
    if (g == zero) {
	return(cuddBddExistAbstractRecur(manager, f, cube));
    }

    /* At this point f, g, and cube are not constant. */

    if (f > g) { /* Try to increase cache efficiency. */
	DdNode *tmp = f;
	f = g;
	g = tmp;
    }

    /* Check cache. */
    r = cuddCacheLookup(manager, DD_BDD_XOR_EXIST_ABSTRACT_TAG, f, g, cube);
    if (r != NULL) {
	return(r);
    }

    checkWhetherToGiveUp(manager);

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    F = Cudd_Regular(f);
    topf = manager->perm[F->index];
    G = Cudd_Regular(g);
    topg = manager->perm[G->index];
    top = ddMin(topf, topg);
    topcube = manager->perm[cube->index];

    if (topcube < top) {
	return(cuddBddXorExistAbstractRecur(manager, f, g, cuddT(cube)));
    }
    /* Now, topcube >= top. */

    if (topf == top) {
	index = F->index;
	fv = cuddT(F);
	fnv = cuddE(F);
	if (Cudd_IsComplement(f)) {
	    fv = Cudd_Not(fv);
	    fnv = Cudd_Not(fnv);
	}
    } else {
	index = G->index;
	fv = fnv = f;
    }

    if (topg == top) {
	gv = cuddT(G);
	gnv = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gv = Cudd_Not(gv);
	    gnv = Cudd_Not(gnv);
	}
    } else {
	gv = gnv = g;
    }

    if (topcube == top) {
	Cube = cuddT(cube);
    } else {
	Cube = cube;
    }

    t = cuddBddXorExistAbstractRecur(manager, fv, gv, Cube);
    if (t == NULL) return(NULL);

    /* Special case: 1 OR anything = 1. Hence, no need to compute
    ** the else branch if t is 1.
    */
    if (t == one && topcube == top) {
	cuddCacheInsert(manager, DD_BDD_XOR_EXIST_ABSTRACT_TAG, f, g, cube, one);
	return(one);
    }
    cuddRef(t);

    e = cuddBddXorExistAbstractRecur(manager, fnv, gnv, Cube);
    if (e == NULL) {
	Cudd_IterDerefBdd(manager, t);
	return(NULL);
    }
    cuddRef(e);

    if (topcube == top) {	/* abstract */
	r = cuddBddAndRecur(manager, Cudd_Not(t), Cudd_Not(e));
	if (r == NULL) {
	    Cudd_IterDerefBdd(manager, t);
	    Cudd_IterDerefBdd(manager, e);
	    return(NULL);
	}
	r = Cudd_Not(r);
	cuddRef(r);
	Cudd_IterDerefBdd(manager, t);
	Cudd_IterDerefBdd(manager, e);
	cuddDeref(r);
    } else if (t == e) {
	r = t;
	cuddDeref(t);
	cuddDeref(e);
    } else {
	if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(manager,(int)index,Cudd_Not(t),Cudd_Not(e));
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(manager,(int)index,t,e);
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	}
	cuddDeref(e);
	cuddDeref(t);
    }
    cuddCacheInsert(manager, DD_BDD_XOR_EXIST_ABSTRACT_TAG, f, g, cube, r);
    return (r);

} /* end of cuddBddXorExistAbstractRecur */


/**
  @brief Performs the recursive steps of Cudd_bddBoleanDiff.

  @details Exploits the fact that dF/dx = dF'/dx.

  @return the %BDD obtained by XORing the cofactors of f with respect
  to var if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
cuddBddBooleanDiffRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * var)
{
    DdNode *T, *E, *res, *res1, *res2;

    statLine(manager);
    if (cuddI(manager,f->index) > manager->perm[var->index]) {
	/* f does not depend on var. */
	return(Cudd_Not(DD_ONE(manager)));
    }

    /* From now on, f is non-constant. */

    /* If the two indices are the same, so are their levels. */
    if (f->index == var->index) {
	res = cuddBddXorRecur(manager, cuddT(f), cuddE(f));
        return(res);
    }

    /* From now on, cuddI(manager,f->index) < cuddI(manager,cube->index). */

    /* Check the cache. */
    res = cuddCacheLookup2(manager, cuddBddBooleanDiffRecur, f, var);
    if (res != NULL) {
	return(res);
    }

    /* Compute the cofactors of f. */
    T = cuddT(f); E = cuddE(f);

    res1 = cuddBddBooleanDiffRecur(manager, T, var);
    if (res1 == NULL) return(NULL);
    cuddRef(res1);
    res2 = cuddBddBooleanDiffRecur(manager, Cudd_Regular(E), var);
    if (res2 == NULL) {
	Cudd_IterDerefBdd(manager, res1);
	return(NULL);
    }
    cuddRef(res2);
    /* ITE takes care of possible complementation of res1 and of the
    ** case in which res1 == res2. */
    res = cuddBddIteRecur(manager, manager->vars[f->index], res1, res2);
    if (res == NULL) {
	Cudd_IterDerefBdd(manager, res1);
	Cudd_IterDerefBdd(manager, res2);
	return(NULL);
    }
    cuddDeref(res1);
    cuddDeref(res2);
    cuddCacheInsert2(manager, cuddBddBooleanDiffRecur, f, var, res);
    return(res);

} /* end of cuddBddBooleanDiffRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
  @brief Checks whether cube is a %BDD representing the product of
  positive literals.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
bddCheckPositiveCube(
  DdManager * manager,
  DdNode * cube)
{
    if (Cudd_IsComplement(cube)) return(0);
    if (cube == DD_ONE(manager)) return(1);
    if (cuddIsConstant(cube)) return(0);
    if (cuddE(cube) == Cudd_Not(DD_ONE(manager))) {
        return(bddCheckPositiveCube(manager, cuddT(cube)));
    }
    return(0);

} /* end of bddCheckPositiveCube */


cuddBddCorr.c
12211
/**
  @file

  @ingroup cudd

  @brief Correlation between BDDs.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/** Type of hash-table key. */
typedef struct hashEntry {
    DdNode *f;
    DdNode *g;
} HashEntry;


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

#ifdef CORREL_STATS
static	int	num_calls;
#endif

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static double bddCorrelationAux (DdManager *dd, DdNode *f, DdNode *g, st_table *table);
static double bddCorrelationWeightsAux (DdManager *dd, DdNode *f, DdNode *g, double *prob, st_table *table);
static int CorrelCompare (const void *key1, const void *key2);
static int CorrelHash (void const *key, int modulus);
static enum st_retval CorrelCleanUp (void *key, void *value, void *arg);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes the correlation of f and g.

  @details If f == g, their correlation is 1. If f == g', their
  correlation is 0.

  @return the fraction of minterms in the ON-set of the EXNOR of f and
  g.  If it runs out of memory, returns (double)CUDD_OUT_OF_MEM.

  @sideeffect None

  @see Cudd_bddCorrelationWeights

*/
double
Cudd_bddCorrelation(
  DdManager * manager,
  DdNode * f,
  DdNode * g)
{
    st_table	*table;
    double	correlation;

#ifdef CORREL_STATS
    num_calls = 0;
#endif

    table = st_init_table(CorrelCompare,CorrelHash);
    if (table == NULL) return((double)CUDD_OUT_OF_MEM);
    correlation = bddCorrelationAux(manager,f,g,table);
    st_foreach(table, CorrelCleanUp, NIL(void));
    st_free_table(table);
    return(correlation);

} /* end of Cudd_bddCorrelation */


/**
  @brief Computes the correlation of f and g for given input
  probabilities.

  @details On input, prob\[i\] is supposed to contain the probability
  of the i-th input variable to be 1.  If f == g, their correlation is
  1. If f == g', their correlation is 0.  The correlation of f and the
  constant one gives the probability of f.

  @return the probability that f and g have the same value. If it runs
  out of memory, returns (double)CUDD_OUT_OF_MEM.

  @sideeffect None

  @see Cudd_bddCorrelation

*/
double
Cudd_bddCorrelationWeights(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  double * prob)
{
    st_table	*table;
    double	correlation;

#ifdef CORREL_STATS
    num_calls = 0;
#endif

    table = st_init_table(CorrelCompare,CorrelHash);
    if (table == NULL) return((double)CUDD_OUT_OF_MEM);
    correlation = bddCorrelationWeightsAux(manager,f,g,prob,table);
    st_foreach(table, CorrelCleanUp, NIL(void));
    st_free_table(table);
    return(correlation);

} /* end of Cudd_bddCorrelationWeights */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_bddCorrelation.

  @return the fraction of minterms in the ON-set of the EXNOR of f and
  g.

  @sideeffect None

  @see bddCorrelationWeightsAux

*/
static double
bddCorrelationAux(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  st_table * table)
{
    DdNode	*Fv, *Fnv, *G, *Gv, *Gnv;
    double	min, *pmin, min1, min2;
    void        *dummy;
    HashEntry	*entry;
    int topF, topG;

    statLine(dd);
#ifdef CORREL_STATS
    num_calls++;
#endif

    /* Terminal cases: only work for BDDs. */
    if (f == g) return(1.0);
    if (f == Cudd_Not(g)) return(0.0);

    /* Standardize call using the following properties:
    **     (f EXNOR g)   = (g EXNOR f)
    **     (f' EXNOR g') = (f EXNOR g).
    */
    if (f > g) {
	DdNode *tmp = f;
	f = g; g = tmp;
    }
    if (Cudd_IsComplement(f)) {
	f = Cudd_Not(f);
	g = Cudd_Not(g);
    }
    /* From now on, f is regular. */
    
    entry = ALLOC(HashEntry,1);
    if (entry == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(CUDD_OUT_OF_MEM);
    }
    entry->f = f; entry->g = g;

    /* We do not use the fact that
    ** correlation(f,g') = 1 - correlation(f,g)
    ** to minimize the risk of cancellation.
    */
    if (st_lookup(table, entry, &dummy)) {
        min = *(double *) dummy;
	FREE(entry);
	return(min);
    }

    G = Cudd_Regular(g);
    topF = cuddI(dd,f->index); topG = cuddI(dd,G->index);
    if (topF <= topG) { Fv = cuddT(f); Fnv = cuddE(f); } else { Fv = Fnv = f; }
    if (topG <= topF) { Gv = cuddT(G); Gnv = cuddE(G); } else { Gv = Gnv = G; }

    if (g != G) {
	Gv = Cudd_Not(Gv);
	Gnv = Cudd_Not(Gnv);
    }

    min1 = bddCorrelationAux(dd, Fv, Gv, table) / 2.0;
    if (min1 == (double)CUDD_OUT_OF_MEM) {
	FREE(entry);
	return(CUDD_OUT_OF_MEM);
    }
    min2 = bddCorrelationAux(dd, Fnv, Gnv, table) / 2.0; 
    if (min2 == (double)CUDD_OUT_OF_MEM) {
	FREE(entry);
	return(CUDD_OUT_OF_MEM);
    }
    min = (min1+min2);
    
    pmin = ALLOC(double,1);
    if (pmin == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return((double)CUDD_OUT_OF_MEM);
    }
    *pmin = min;

    if (st_insert(table, entry, pmin) == ST_OUT_OF_MEM) {
	FREE(entry);
	FREE(pmin);
	return((double)CUDD_OUT_OF_MEM);
    }
    return(min);

} /* end of bddCorrelationAux */


/**
  @brief Performs the recursive step of Cudd_bddCorrelationWeigths.

  @sideeffect None

  @see bddCorrelationAux

*/
static double
bddCorrelationWeightsAux(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  double * prob,
  st_table * table)
{
    DdNode	*Fv, *Fnv, *G, *Gv, *Gnv;
    double	min, *pmin, min1, min2;
    void        *dummy;
    HashEntry	*entry;
    int		topF, topG;
    unsigned	index;

    statLine(dd);
#ifdef CORREL_STATS
    num_calls++;
#endif

    /* Terminal cases: only work for BDDs. */
    if (f == g) return(1.0);
    if (f == Cudd_Not(g)) return(0.0);

    /* Standardize call using the following properties:
    **     (f EXNOR g)   = (g EXNOR f)
    **     (f' EXNOR g') = (f EXNOR g).
    */
    if (f > g) {
	DdNode *tmp = f;
	f = g; g = tmp;
    }
    if (Cudd_IsComplement(f)) {
	f = Cudd_Not(f);
	g = Cudd_Not(g);
    }
    /* From now on, f is regular. */
    
    entry = ALLOC(HashEntry,1);
    if (entry == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return((double)CUDD_OUT_OF_MEM);
    }
    entry->f = f; entry->g = g;

    /* We do not use the fact that
    ** correlation(f,g') = 1 - correlation(f,g)
    ** to minimize the risk of cancellation.
    */
    if (st_lookup(table, entry, &dummy)) {
	min = *(double *) dummy;
	FREE(entry);
	return(min);
    }

    G = Cudd_Regular(g);
    topF = cuddI(dd,f->index); topG = cuddI(dd,G->index);
    if (topF <= topG) {
	Fv = cuddT(f); Fnv = cuddE(f);
	index = f->index;
    } else {
	Fv = Fnv = f;
	index = G->index;
    }
    if (topG <= topF) { Gv = cuddT(G); Gnv = cuddE(G); } else { Gv = Gnv = G; }

    if (g != G) {
	Gv = Cudd_Not(Gv);
	Gnv = Cudd_Not(Gnv);
    }

    min1 = bddCorrelationWeightsAux(dd, Fv, Gv, prob, table) * prob[index];
    if (min1 == (double)CUDD_OUT_OF_MEM) {
	FREE(entry);
	return((double)CUDD_OUT_OF_MEM);
    }
    min2 = bddCorrelationWeightsAux(dd, Fnv, Gnv, prob, table) * (1.0 - prob[index]); 
    if (min2 == (double)CUDD_OUT_OF_MEM) {
	FREE(entry);
	return((double)CUDD_OUT_OF_MEM);
    }
    min = (min1+min2);
    
    pmin = ALLOC(double,1);
    if (pmin == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return((double)CUDD_OUT_OF_MEM);
    }
    *pmin = min;

    if (st_insert(table, entry, pmin) == ST_OUT_OF_MEM) {
	FREE(entry);
	FREE(pmin);
	return((double)CUDD_OUT_OF_MEM);
    }
    return(min);

} /* end of bddCorrelationWeightsAux */


/**
  @brief Compares two hash table entries.

  @return 0 if they are identical; 1 otherwise.

  @sideeffect None

*/
static int
CorrelCompare(
  void const * key1,
  void const * key2)
{
    HashEntry const *entry1 = (HashEntry const *) key1;
    HashEntry const *entry2 = (HashEntry const *) key2;
    if (entry1->f != entry2->f || entry1->g != entry2->g) return(1);

    return(0);

} /* end of CorrelCompare */


/**
  @brief Hashes a hash table entry.

  @details It is patterned after st_strhash.

  @return a value between 0 and modulus.

  @sideeffect None

*/
static int
CorrelHash(
  void const * key,
  int  modulus)
{
    HashEntry const *entry = (HashEntry const *) key;
    int val = 0;

    val = (int) (((ptrint)entry->f)*997 + ((ptrint)entry->g));

    return ((val < 0) ? -val : val) % modulus;

} /* end of CorrelHash */


/**
  @brief Frees memory associated with hash table.

  @return ST_CONTINUE.

  @sideeffect None

*/
static enum st_retval
CorrelCleanUp(
  void * key,
  void * value,
  void * arg)
{
    double	  *d = (double *) value;
    HashEntry *entry = (HashEntry *) key;

    (void) arg; /* avoid warning */
    FREE(entry);
    FREE(d);
    return ST_CONTINUE;

} /* end of CorrelCleanUp */

cuddBddIte.c
33952
/**
  @file 

  @ingroup cudd

  @brief %BDD ITE function and satellites.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void bddVarToConst (DdNode *f, DdNode **gp, DdNode **hp, DdNode *one);
static int bddVarToCanonical (DdManager *dd, DdNode **fp, DdNode **gp, DdNode **hp, int *topfp, int *topgp, int *tophp);
static int bddVarToCanonicalSimple (DdManager *dd, DdNode **fp, DdNode **gp, DdNode **hp, int *topfp, int *topgp, int *tophp);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements ITE(f,g,h).

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_addIte Cudd_bddIteConstant Cudd_bddIntersect

*/
DdNode *
Cudd_bddIte(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */,
  DdNode * h /**< third operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddIteRecur(dd,f,g,h);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddIte */


/**
  @brief Implements ITE(f,g,h) unless too many nodes are required.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up or more new nodes than `limit` are
  required.

  @sideeffect None

  @see Cudd_bddIte

*/
DdNode *
Cudd_bddIteLimit(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */,
  DdNode * h /**< third operand */,
  unsigned int limit /**< maximum number of new nodes */)
{
    DdNode *res;
    unsigned int saveLimit = dd->maxLive;

    dd->maxLive = (dd->keys - dd->dead) + (dd->keysZ - dd->deadZ) + limit;
    do {
	dd->reordered = 0;
	res = cuddBddIteRecur(dd,f,g,h);
    } while (dd->reordered == 1);
    dd->maxLive = saveLimit;
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddIteLimit */


/**
  @brief Implements ITEconstant(f,g,h).

  @return a pointer to the resulting %BDD (which may or may not be
  constant) or DD_NON_CONSTANT.

  @details No new nodes are created.

  @sideeffect None

  @see Cudd_bddIte Cudd_bddIntersect Cudd_bddLeq Cudd_addIteConstant

*/
DdNode *
Cudd_bddIteConstant(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */,
  DdNode * h /**< thord operand */)
{
    DdNode	 *r, *Fv, *Fnv, *Gv, *Gnv, *H, *Hv, *Hnv, *t, *e;
    DdNode	 *one = DD_ONE(dd);
    DdNode	 *zero = Cudd_Not(one);
    int		 comple;
    int		 topf, topg, toph, v;

    statLine(dd);
    /* Trivial cases. */
    if (f == one) 			/* ITE(1,G,H) => G */
	return(g);
    
    if (f == zero)			/* ITE(0,G,H) => H */
	return(h);
    
    /* f now not a constant. */
    bddVarToConst(f, &g, &h, one);	/* possibly convert g or h */
					/* to constants */

    if (g == h) 			/* ITE(F,G,G) => G */
	return(g);

    if (Cudd_IsConstantInt(g) && Cudd_IsConstantInt(h)) 
	return(DD_NON_CONSTANT);	/* ITE(F,1,0) or ITE(F,0,1) */
					/* => DD_NON_CONSTANT */
    
    if (g == Cudd_Not(h))
	return(DD_NON_CONSTANT);	/* ITE(F,G,G') => DD_NON_CONSTANT */
					/* if F != G and F != G' */
    
    comple = bddVarToCanonical(dd, &f, &g, &h, &topf, &topg, &toph);

    /* Cache lookup. */
    r = cuddConstantLookup(dd, DD_BDD_ITE_CONSTANT_TAG, f, g, h);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple && r != DD_NON_CONSTANT));
    }

    v = ddMin(topg, toph);

    /* ITE(F,G,H) = (v,G,H) (non constant) if F = (v,1,0), v < top(G,H). */
    if (topf < v && cuddT(f) == one && cuddE(f) == zero) {
	return(DD_NON_CONSTANT);
    }

    /* Compute cofactors. */
    if (topf <= v) {
	v = ddMin(topf, v);		/* v = top_var(F,G,H) */
	Fv = cuddT(f); Fnv = cuddE(f);
    } else {
	Fv = Fnv = f;
    }

    if (topg == v) {
	Gv = cuddT(g); Gnv = cuddE(g);
    } else {
	Gv = Gnv = g;
    }

    if (toph == v) {
	H = Cudd_Regular(h);
	Hv = cuddT(H); Hnv = cuddE(H);
	if (Cudd_IsComplement(h)) {
	    Hv = Cudd_Not(Hv);
	    Hnv = Cudd_Not(Hnv);
	}
    } else {
	Hv = Hnv = h;
    }

    /* Recursion. */
    t = Cudd_bddIteConstant(dd, Fv, Gv, Hv);
    if (t == DD_NON_CONSTANT || !Cudd_IsConstantInt(t)) {
	cuddCacheInsert(dd, DD_BDD_ITE_CONSTANT_TAG, f, g, h, DD_NON_CONSTANT);
	return(DD_NON_CONSTANT);
    }
    e = Cudd_bddIteConstant(dd, Fnv, Gnv, Hnv);
    if (e == DD_NON_CONSTANT || !Cudd_IsConstantInt(e) || t != e) {
	cuddCacheInsert(dd, DD_BDD_ITE_CONSTANT_TAG, f, g, h, DD_NON_CONSTANT);
	return(DD_NON_CONSTANT);
    }
    cuddCacheInsert(dd, DD_BDD_ITE_CONSTANT_TAG, f, g, h, t);
    return(Cudd_NotCond(t,comple));

} /* end of Cudd_bddIteConstant */


/**
  @brief Returns a function included in the intersection of f and g.

  @details The function computed (if not zero) is a witness that the
  intersection is not empty.  Cudd_bddIntersect tries to build as few
  new nodes as possible. If the only result of interest is whether f
  and g intersect, Cudd_bddLeq should be used instead.

  @sideeffect None

  @see Cudd_bddLeq Cudd_bddIteConstant

*/
DdNode *
Cudd_bddIntersect(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddIntersectRecur(dd,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_bddIntersect */


/**
  @brief Computes the conjunction of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddIte Cudd_addApply Cudd_bddAndAbstract Cudd_bddIntersect
  Cudd_bddOr Cudd_bddNand Cudd_bddNor Cudd_bddXor Cudd_bddXnor

*/
DdNode *
Cudd_bddAnd(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddAndRecur(dd,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddAnd */


/**
  @brief Computes the conjunction of two BDDs f and g unless too many
  nodes are required.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up or more new nodes than `limit` are
  required.

  @sideeffect None

  @see Cudd_bddAnd

*/
DdNode *
Cudd_bddAndLimit(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */,
  unsigned int limit /**< maximum number of new nodes */)
{
    DdNode *res;
    unsigned int saveLimit = dd->maxLive;

    dd->maxLive = (dd->keys - dd->dead) + (dd->keysZ - dd->deadZ) + limit;
    do {
	dd->reordered = 0;
	res = cuddBddAndRecur(dd,f,g);
    } while (dd->reordered == 1);
    dd->maxLive = saveLimit;
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddAndLimit */


/**
  @brief Computes the disjunction of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddIte Cudd_addApply Cudd_bddAnd Cudd_bddNand Cudd_bddNor
  Cudd_bddXor Cudd_bddXnor

*/
DdNode *
Cudd_bddOr(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddAndRecur(dd,Cudd_Not(f),Cudd_Not(g));
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    res = Cudd_NotCond(res,res != NULL);
    return(res);

} /* end of Cudd_bddOr */


/**
  @brief Computes the disjunction of two BDDs f and g unless too many
  nodes are required.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up or more new nodes than `limit` are
  required.

  @sideeffect None

  @see Cudd_bddOr

*/
DdNode *
Cudd_bddOrLimit(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */,
  unsigned int limit /**< maximum number of new nodes */)
{
    DdNode *res;
    unsigned int saveLimit = dd->maxLive;

    dd->maxLive = (dd->keys - dd->dead) + (dd->keysZ - dd->deadZ) + limit;
    do {
	dd->reordered = 0;
	res = cuddBddAndRecur(dd,Cudd_Not(f),Cudd_Not(g));
    } while (dd->reordered == 1);
    dd->maxLive = saveLimit;
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    res = Cudd_NotCond(res,res != NULL);
    return(res);

} /* end of Cudd_bddOrLimit */


/**
  @brief Computes the NAND of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddIte Cudd_addApply Cudd_bddAnd Cudd_bddOr Cudd_bddNor
  Cudd_bddXor Cudd_bddXnor

*/
DdNode *
Cudd_bddNand(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /** second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddAndRecur(dd,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    res = Cudd_NotCond(res,res != NULL);
    return(res);

} /* end of Cudd_bddNand */


/**
  @brief Computes the NOR of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddIte Cudd_addApply Cudd_bddAnd Cudd_bddOr Cudd_bddNand
  Cudd_bddXor Cudd_bddXnor

*/
DdNode *
Cudd_bddNor(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddAndRecur(dd,Cudd_Not(f),Cudd_Not(g));
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddNor */


/**
  @brief Computes the exclusive OR of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddIte Cudd_addApply Cudd_bddAnd Cudd_bddOr
  Cudd_bddNand Cudd_bddNor Cudd_bddXnor

*/
DdNode *
Cudd_bddXor(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddXorRecur(dd,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddXor */


/**
  @brief Computes the exclusive NOR of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddIte Cudd_addApply Cudd_bddAnd Cudd_bddOr
  Cudd_bddNand Cudd_bddNor Cudd_bddXor

*/
DdNode *
Cudd_bddXnor(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddXorRecur(dd,f,Cudd_Not(g));
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddXnor */


/**
  @brief Computes the exclusive NOR of two BDDs f and g unless too
  many nodes are required.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up or more new nodes than `limit` are
  required.

  @sideeffect None

  @see Cudd_bddXnor

*/
DdNode *
Cudd_bddXnorLimit(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */,
  unsigned int limit /**< maximum number of new nodes */)
{
    DdNode *res;
    unsigned int saveLimit = dd->maxLive;

    dd->maxLive = (dd->keys - dd->dead) + (dd->keysZ - dd->deadZ) + limit;
    do {
	dd->reordered = 0;
	res = cuddBddXorRecur(dd,f,Cudd_Not(g));
    } while (dd->reordered == 1);
    dd->maxLive = saveLimit;
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddXnorLimit */


/**
  @brief Checks whether f is less than or equal to g.

  @return 1 if f is less than or equal to g; 0 otherwise.

  @details No new nodes are created.

  @sideeffect None

  @see Cudd_bddIteConstant Cudd_addEvalConst

*/
int
Cudd_bddLeq(
  DdManager * dd /**< manager */,
  DdNode * f /**< first operand */,
  DdNode * g /**< second operand */)
{
    DdNode *one, *zero, *tmp, *F, *fv, *fvn, *gv, *gvn;
    int topf, topg, res;

    statLine(dd);
    /* Terminal cases and normalization. */
    if (f == g) return(1);

    if (Cudd_IsComplement(g)) {
	/* Special case: if f is regular and g is complemented,
	** f(1,...,1) = 1 > 0 = g(1,...,1).
	*/
	if (!Cudd_IsComplement(f)) return(0);
	/* Both are complemented: Swap and complement because
	** f <= g <=> g' <= f' and we want the second argument to be regular.
	*/
	tmp = g;
	g = Cudd_Not(f);
	f = Cudd_Not(tmp);
    } else if (Cudd_IsComplement(f) && g < f) {
	tmp = g;
	g = Cudd_Not(f);
	f = Cudd_Not(tmp);
    }

    /* Now g is regular. */
    one = DD_ONE(dd);
    if (g == one) return(1);	/* no need to test against zero */
    if (f == one) return(0);	/* since at this point g != one */
    if (Cudd_Not(f) == g) return(0); /* because neither is constant */
    zero = Cudd_Not(one);
    if (f == zero) return(1);

    /* Here neither f nor g is constant. */

    /* Check cache. */
    F = Cudd_Regular(f);
    if (F->ref != 1 || g->ref != 1) {
        tmp = cuddCacheLookup2(dd,(DD_CTFP)Cudd_bddLeq,f,g);
        if (tmp != NULL) {
            return(tmp == one);
        }
    }

    /* Compute cofactors. */
    topf = dd->perm[F->index];
    topg = dd->perm[g->index];
    if (topf <= topg) {
	fv = cuddT(F); fvn = cuddE(F);
	if (f != F) {
	    fv = Cudd_Not(fv);
	    fvn = Cudd_Not(fvn);
	}
    } else {
	fv = fvn = f;
    }
    if (topg <= topf) {
	gv = cuddT(g); gvn = cuddE(g);
    } else {
	gv = gvn = g;
    }

    /* Recursive calls. Since we want to maximize the probability of
    ** the special case f(1,...,1) > g(1,...,1), we consider the negative
    ** cofactors first. Indeed, the complementation parity of the positive
    ** cofactors is the same as the one of the parent functions.
    */
    res = Cudd_bddLeq(dd,fvn,gvn) && Cudd_bddLeq(dd,fv,gv);

    /* Store result in cache and return. */
    if (F->ref !=1 || g->ref != 1)
        cuddCacheInsert2(dd,(DD_CTFP)Cudd_bddLeq,f,g,(res ? one : zero));
    return(res);

} /* end of Cudd_bddLeq */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_bddIte.

  @return a pointer to the resulting %BDD. NULL if the intermediate
  result blows up or if reordering occurs.

  @sideeffect None

*/
DdNode *
cuddBddIteRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    DdNode	 *one, *zero, *res;
    DdNode	 *r, *Fv, *Fnv, *Gv, *Gnv, *H, *Hv, *Hnv, *t, *e;
    int		 topf, topg, toph, v;
    unsigned int index;
    int		 comple;

    statLine(dd);
    /* Terminal cases. */

    /* One variable cases. */
    if (f == (one = DD_ONE(dd))) 	/* ITE(1,G,H) = G */
	return(g);
    
    if (f == (zero = Cudd_Not(one))) 	/* ITE(0,G,H) = H */
	return(h);
    
    /* From now on, f is known not to be a constant. */
    if (g == one || f == g) {	/* ITE(F,F,H) = ITE(F,1,H) = F + H */
	if (h == zero) {	/* ITE(F,1,0) = F */
	    return(f);
	} else {
	    res = cuddBddAndRecur(dd,Cudd_Not(f),Cudd_Not(h));
	    return(Cudd_NotCond(res,res != NULL));
	}
    } else if (g == zero || f == Cudd_Not(g)) { /* ITE(F,!F,H) = ITE(F,0,H) = !F * H */
	if (h == one) {		/* ITE(F,0,1) = !F */
	    return(Cudd_Not(f));
	} else {
	    res = cuddBddAndRecur(dd,Cudd_Not(f),h);
	    return(res);
	}
    }
    if (h == zero || f == h) {    /* ITE(F,G,F) = ITE(F,G,0) = F * G */
	res = cuddBddAndRecur(dd,f,g);
	return(res);
    } else if (h == one || f == Cudd_Not(h)) { /* ITE(F,G,!F) = ITE(F,G,1) = !F + G */
	res = cuddBddAndRecur(dd,f,Cudd_Not(g));
	return(Cudd_NotCond(res,res != NULL));
    }

    /* Check remaining one variable case. */
    if (g == h) { 		/* ITE(F,G,G) = G */
	return(g);
    } else if (g == Cudd_Not(h)) { /* ITE(F,G,!G) = F <-> G */
	res = cuddBddXorRecur(dd,f,h);
	return(res);
    }
    
    /* From here, there are no constants. */
    comple = bddVarToCanonicalSimple(dd, &f, &g, &h, &topf, &topg, &toph);

    /* f & g are now regular pointers */

    v = ddMin(topg, toph);

    /* A shortcut: ITE(F,G,H) = (v,G,H) if F = (v,1,0), v < top(G,H). */
    if (topf < v && cuddT(f) == one && cuddE(f) == zero) {
	r = cuddUniqueInter(dd, (int) f->index, g, h);
	return(Cudd_NotCond(r,comple && r != NULL));
    }

    /* Check cache. */
    r = cuddCacheLookup(dd, DD_BDD_ITE_TAG, f, g, h);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple));
    }

    checkWhetherToGiveUp(dd);

    /* Compute cofactors. */
    index = f->index;
    if (topf <= v) {
	v = ddMin(topf, v);	/* v = top_var(F,G,H) */
	Fv = cuddT(f); Fnv = cuddE(f);
    } else {
	Fv = Fnv = f;
    }
    if (topg == v) {
	index = g->index;
	Gv = cuddT(g); Gnv = cuddE(g);
    } else {
	Gv = Gnv = g;
    }
    if (toph == v) {
	H = Cudd_Regular(h);
	index = H->index;
	Hv = cuddT(H); Hnv = cuddE(H);
	if (Cudd_IsComplement(h)) {
	    Hv = Cudd_Not(Hv);
	    Hnv = Cudd_Not(Hnv);
	}
    } else {
	Hv = Hnv = h;
    }

    /* Recursive step. */
    t = cuddBddIteRecur(dd,Fv,Gv,Hv);
    if (t == NULL) return(NULL);
    cuddRef(t);

    e = cuddBddIteRecur(dd,Fnv,Gnv,Hnv);
    if (e == NULL) {
	Cudd_IterDerefBdd(dd,t);
	return(NULL);
    }
    cuddRef(e);

    r = (t == e) ? t : cuddUniqueInter(dd,index,t,e);
    if (r == NULL) {
	Cudd_IterDerefBdd(dd,t);
	Cudd_IterDerefBdd(dd,e);
	return(NULL);
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert(dd, DD_BDD_ITE_TAG, f, g, h, r);
    return(Cudd_NotCond(r,comple));

} /* end of cuddBddIteRecur */


/**
  @brief Implements the recursive step of Cudd_bddIntersect.

  @sideeffect None

  @see Cudd_bddIntersect

*/
DdNode *
cuddBddIntersectRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *res;
    DdNode *F, *G, *t, *e;
    DdNode *fv, *fnv, *gv, *gnv;
    DdNode *one, *zero;
    unsigned int index;
    int topf, topg;

    statLine(dd);
    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    /* Terminal cases. */
    if (f == zero || g == zero || f == Cudd_Not(g)) return(zero);
    if (f == g || g == one) return(f);
    if (f == one) return(g);

    /* At this point f and g are not constant. */
    if (f > g) { DdNode *tmp = f; f = g; g = tmp; }
    res = cuddCacheLookup2(dd,Cudd_bddIntersect,f,g);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Find splitting variable. Here we can skip the use of cuddI,
    ** because the operands are known to be non-constant.
    */
    F = Cudd_Regular(f);
    topf = dd->perm[F->index];
    G = Cudd_Regular(g);
    topg = dd->perm[G->index];

    /* Compute cofactors. */
    if (topf <= topg) {
	index = F->index;
	fv = cuddT(F);
	fnv = cuddE(F);
	if (Cudd_IsComplement(f)) {
	    fv = Cudd_Not(fv);
	    fnv = Cudd_Not(fnv);
	}
    } else {
	index = G->index;
	fv = fnv = f;
    }

    if (topg <= topf) {
	gv = cuddT(G);
	gnv = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gv = Cudd_Not(gv);
	    gnv = Cudd_Not(gnv);
	}
    } else {
	gv = gnv = g;
    }

    /* Compute partial results. */
    t = cuddBddIntersectRecur(dd,fv,gv);
    if (t == NULL) return(NULL);
    cuddRef(t);
    if (t != zero) {
	e = zero;
    } else {
	e = cuddBddIntersectRecur(dd,fnv,gnv);
	if (e == NULL) {
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
    }
    cuddRef(e);

    if (t == e) { /* both equal zero */
	res = t;
    } else if (Cudd_IsComplement(t)) {
	res = cuddUniqueInter(dd,(int)index,Cudd_Not(t),Cudd_Not(e));
	if (res == NULL) {
	    Cudd_IterDerefBdd(dd, t);
	    Cudd_IterDerefBdd(dd, e);
	    return(NULL);
	}
	res = Cudd_Not(res);
    } else {
	res = cuddUniqueInter(dd,(int)index,t,e);
	if (res == NULL) {
	    Cudd_IterDerefBdd(dd, t);
	    Cudd_IterDerefBdd(dd, e);
	    return(NULL);
	}
    }
    cuddDeref(e);
    cuddDeref(t);

    cuddCacheInsert2(dd,Cudd_bddIntersect,f,g,res);

    return(res);

} /* end of cuddBddIntersectRecur */


/**
  @brief Implements the recursive step of Cudd_bddAnd.

  @details Takes the conjunction of two BDDs.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddAnd

*/
DdNode *
cuddBddAndRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * g)
{
    DdNode *F, *fv, *fnv, *G, *gv, *gnv;
    DdNode *one, *r, *t, *e;
    int topf, topg;
    unsigned int index;

    statLine(manager);
    one = DD_ONE(manager);

    /* Terminal cases. */
    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    if (F == G) {
	if (f == g) return(f);
	else return(Cudd_Not(one));
    }
    if (F == one) {
	if (f == one) return(g);
	else return(f);
    }
    if (G == one) {
	if (g == one) return(f);
	else return(g);
    }

    /* At this point f and g are not constant. */
    if (f > g) { /* Try to increase cache efficiency. */
	DdNode *tmp = f;
	f = g;
	g = tmp;
	F = Cudd_Regular(f);
	G = Cudd_Regular(g);
    }

    /* Check cache. */
    if (F->ref != 1 || G->ref != 1) {
	r = cuddCacheLookup2(manager, Cudd_bddAnd, f, g);
	if (r != NULL) return(r);
    }

    checkWhetherToGiveUp(manager);

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    topf = manager->perm[F->index];
    topg = manager->perm[G->index];

    /* Compute cofactors. */
    if (topf <= topg) {
	index = F->index;
	fv = cuddT(F);
	fnv = cuddE(F);
	if (Cudd_IsComplement(f)) {
	    fv = Cudd_Not(fv);
	    fnv = Cudd_Not(fnv);
	}
    } else {
	index = G->index;
	fv = fnv = f;
    }

    if (topg <= topf) {
	gv = cuddT(G);
	gnv = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gv = Cudd_Not(gv);
	    gnv = Cudd_Not(gnv);
	}
    } else {
	gv = gnv = g;
    }

    t = cuddBddAndRecur(manager, fv, gv);
    if (t == NULL) return(NULL);
    cuddRef(t);

    e = cuddBddAndRecur(manager, fnv, gnv);
    if (e == NULL) {
	Cudd_IterDerefBdd(manager, t);
	return(NULL);
    }
    cuddRef(e);

    if (t == e) {
	r = t;
    } else {
	if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(manager,(int)index,Cudd_Not(t),Cudd_Not(e));
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(manager,(int)index,t,e);
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	}
    }
    cuddDeref(e);
    cuddDeref(t);
    if (F->ref != 1 || G->ref != 1)
	cuddCacheInsert2(manager, Cudd_bddAnd, f, g, r);
    return(r);

} /* end of cuddBddAndRecur */


/**
  @brief Implements the recursive step of Cudd_bddXor.

  @details Takes the exclusive OR of two BDDs.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddXor

*/
DdNode *
cuddBddXorRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * g)
{
    DdNode *fv, *fnv, *G, *gv, *gnv;
    DdNode *one, *zero, *r, *t, *e;
    int topf, topg;
    unsigned int index;

    statLine(manager);
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* Terminal cases. */
    if (f == g) return(zero);
    if (f == Cudd_Not(g)) return(one);
    if (f > g) { /* Try to increase cache efficiency and simplify tests. */
	DdNode *tmp = f;
	f = g;
	g = tmp;
    }
    if (g == zero) return(f);
    if (g == one) return(Cudd_Not(f));
    if (Cudd_IsComplement(f)) {
	f = Cudd_Not(f);
	g = Cudd_Not(g);
    }
    /* Now the first argument is regular. */
    if (f == one) return(Cudd_Not(g));

    /* At this point f and g are not constant. */

    /* Check cache. */
    r = cuddCacheLookup2(manager, Cudd_bddXor, f, g);
    if (r != NULL) return(r);

    checkWhetherToGiveUp(manager);

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    topf = manager->perm[f->index];
    G = Cudd_Regular(g);
    topg = manager->perm[G->index];

    /* Compute cofactors. */
    if (topf <= topg) {
	index = f->index;
	fv = cuddT(f);
	fnv = cuddE(f);
    } else {
	index = G->index;
	fv = fnv = f;
    }

    if (topg <= topf) {
	gv = cuddT(G);
	gnv = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gv = Cudd_Not(gv);
	    gnv = Cudd_Not(gnv);
	}
    } else {
	gv = gnv = g;
    }

    t = cuddBddXorRecur(manager, fv, gv);
    if (t == NULL) return(NULL);
    cuddRef(t);

    e = cuddBddXorRecur(manager, fnv, gnv);
    if (e == NULL) {
	Cudd_IterDerefBdd(manager, t);
	return(NULL);
    }
    cuddRef(e);

    if (t == e) {
	r = t;
    } else {
	if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(manager,(int)index,Cudd_Not(t),Cudd_Not(e));
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(manager,(int)index,t,e);
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	}
    }
    cuddDeref(e);
    cuddDeref(t);
    cuddCacheInsert2(manager, Cudd_bddXor, f, g, r);
    return(r);

} /* end of cuddBddXorRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Replaces variables with constants if possible.

  @details This function performs part of the transformation to
  standard form by replacing variables with constants if possible.

  @sideeffect None

  @see bddVarToCanonical bddVarToCanonicalSimple

*/
static void
bddVarToConst(
  DdNode * f,
  DdNode ** gp,
  DdNode ** hp,
  DdNode * one)
{
    DdNode *g = *gp;
    DdNode *h = *hp;

    if (f == g) {    /* ITE(F,F,H) = ITE(F,1,H) = F + H */
	*gp = one;
    } else if (f == Cudd_Not(g)) {    /* ITE(F,!F,H) = ITE(F,0,H) = !F * H */
	*gp = Cudd_Not(one);
    }
    if (f == h) {    /* ITE(F,G,F) = ITE(F,G,0) = F * G */
	*hp = Cudd_Not(one);
    } else if (f == Cudd_Not(h)) {    /* ITE(F,G,!F) = ITE(F,G,1) = !F + G */
	*hp = one;
    }

} /* end of bddVarToConst */


/**
  @brief Picks unique member from equiv expressions.

  @details Reduces 2 variable expressions to canonical form.

  @sideeffect None

  @see bddVarToConst bddVarToCanonicalSimple

*/
static int
bddVarToCanonical(
  DdManager * dd,
  DdNode ** fp,
  DdNode ** gp,
  DdNode ** hp,
  int * topfp,
  int * topgp,
  int * tophp)
{
    DdNode	*F, *G, *H, *r, *f, *g, *h;
    DdNode	*one = dd->one;
    int		topf, topg, toph;
    int		comple, change;

    f = *fp;
    g = *gp;
    h = *hp;
    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    H = Cudd_Regular(h);
    topf = cuddI(dd,F->index);
    topg = cuddI(dd,G->index);
    toph = cuddI(dd,H->index);

    change = 0;

    if (G == one) {			/* ITE(F,c,H) */
	if ((topf > toph) || (topf == toph && f > h)) {
	    r = h;
	    h = f;
	    f = r;			/* ITE(F,1,H) = ITE(H,1,F) */
	    if (g != one) {	/* g == zero */
		f = Cudd_Not(f);		/* ITE(F,0,H) = ITE(!H,0,!F) */
		h = Cudd_Not(h);
	    }
	    change = 1;
	}
    } else if (H == one) {		/* ITE(F,G,c) */
	if ((topf > topg) || (topf == topg && f > g)) {
	    r = g;
	    g = f;
	    f = r;			/* ITE(F,G,0) = ITE(G,F,0) */
	    if (h == one) {
		f = Cudd_Not(f);		/* ITE(F,G,1) = ITE(!G,!F,1) */
		g = Cudd_Not(g);
	    }
	    change = 1;
	}
    } else if (g == Cudd_Not(h)) {	/* ITE(F,G,!G) = ITE(G,F,!F) */
	if ((topf > topg) || (topf == topg && f > g)) {
	    r = f;
	    f = g;
	    g = r;
	    h = Cudd_Not(r);
	    change = 1;
	}
    }
    /* adjust pointers so that the first 2 arguments to ITE are regular */
    if (Cudd_IsComplement(f) != 0) {	/* ITE(!F,G,H) = ITE(F,H,G) */
	f = Cudd_Not(f);
	r = g;
	g = h;
	h = r;
	change = 1;
    }
    comple = 0;
    if (Cudd_IsComplement(g) != 0) {	/* ITE(F,!G,H) = !ITE(F,G,!H) */
	g = Cudd_Not(g);
	h = Cudd_Not(h);
	change = 1;
	comple = 1;
    }
    if (change != 0) {
	*fp = f;
	*gp = g;
	*hp = h;
    }
    *topfp = cuddI(dd,f->index);
    *topgp = cuddI(dd,g->index);
    *tophp = cuddI(dd,Cudd_Regular(h)->index);

    return(comple);

} /* end of bddVarToCanonical */


/**
  @brief Picks unique member from equiv expressions.

  @details Makes sure the first two pointers are regular.  This
  mat require the complementation of the result, which is signaled by
  returning 1 instead of 0.  This function is simpler than the general
  case because it assumes that no two arguments are the same or
  complementary, and no argument is constant.

  @sideeffect None

  @see bddVarToConst bddVarToCanonical

*/
static int
bddVarToCanonicalSimple(
  DdManager * dd,
  DdNode ** fp,
  DdNode ** gp,
  DdNode ** hp,
  int * topfp,
  int * topgp,
  int * tophp)
{
    DdNode	*r, *f, *g, *h;
    int		comple, change;

    f = *fp;
    g = *gp;
    h = *hp;

    change = 0;

    /* adjust pointers so that the first 2 arguments to ITE are regular */
    if (Cudd_IsComplement(f)) {	/* ITE(!F,G,H) = ITE(F,H,G) */
	f = Cudd_Not(f);
	r = g;
	g = h;
	h = r;
	change = 1;
    }
    comple = 0;
    if (Cudd_IsComplement(g)) {	/* ITE(F,!G,H) = !ITE(F,G,!H) */
	g = Cudd_Not(g);
	h = Cudd_Not(h);
	change = 1;
	comple = 1;
    }
    if (change) {
	*fp = f;
	*gp = g;
	*hp = h;
    }

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    *topfp = dd->perm[f->index];
    *topgp = dd->perm[g->index];
    *tophp = dd->perm[Cudd_Regular(h)->index];

    return(comple);

} /* end of bddVarToCanonicalSimple */

cuddBridge.c
23247
/**
  @file

  @ingroup cudd

  @brief Translation from %BDD to %ADD and vice versa and transfer
  between different managers.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * addBddDoThreshold (DdManager *dd, DdNode *f, DdNode *val);
static DdNode * addBddDoStrictThreshold (DdManager *dd, DdNode *f, DdNode *val);
static DdNode * addBddDoInterval (DdManager *dd, DdNode *f, DdNode *l, DdNode *u);
static DdNode * addBddDoIthBit (DdManager *dd, DdNode *f, DdNode *index);
static DdNode * ddBddToAddRecur (DdManager *dd, DdNode *B);
static DdNode * cuddBddTransferRecur (DdManager *ddS, DdManager *ddD, DdNode *f, st_table *table);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Converts an %ADD to a %BDD.

  @details Replaces all discriminants greater than or equal to value
  with 1, and all other discriminants with 0.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addBddInterval Cudd_addBddPattern Cudd_BddToAdd
  Cudd_addBddStrictThreshold

*/
DdNode *
Cudd_addBddThreshold(
  DdManager * dd,
  DdNode * f,
  CUDD_VALUE_TYPE  value)
{
    DdNode *res;
    DdNode *val;
    
    val = cuddUniqueConst(dd,value);
    if (val == NULL) return(NULL);
    cuddRef(val);

    do {
	dd->reordered = 0;
	res = addBddDoThreshold(dd, f, val);
    } while (dd->reordered == 1);

    if (res == NULL) {
	Cudd_RecursiveDeref(dd, val);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, val);
    cuddDeref(res);
    return(res);

} /* end of Cudd_addBddThreshold */


/**
  @brief Converts an %ADD to a %BDD.

  @details Replaces all discriminants STRICTLY greater than value with
  1, and all other discriminants with 0.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addBddInterval Cudd_addBddPattern Cudd_BddToAdd 
  Cudd_addBddThreshold

*/
DdNode *
Cudd_addBddStrictThreshold(
  DdManager * dd,
  DdNode * f,
  CUDD_VALUE_TYPE  value)
{
    DdNode *res;
    DdNode *val;
    
    val = cuddUniqueConst(dd,value);
    if (val == NULL) return(NULL);
    cuddRef(val);

    do {
	dd->reordered = 0;
	res = addBddDoStrictThreshold(dd, f, val);
    } while (dd->reordered == 1);

    if (res == NULL) {
	Cudd_RecursiveDeref(dd, val);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, val);
    cuddDeref(res);
    return(res);

} /* end of Cudd_addBddStrictThreshold */


/**
  @brief Converts an %ADD to a %BDD.

  @details Replaces all discriminants greater than or equal to lower
  and less than or equal to upper with 1, and all other discriminants
  with 0.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addBddThreshold Cudd_addBddStrictThreshold 
  Cudd_addBddPattern Cudd_BddToAdd

*/
DdNode *
Cudd_addBddInterval(
  DdManager * dd,
  DdNode * f,
  CUDD_VALUE_TYPE  lower,
  CUDD_VALUE_TYPE  upper)
{
    DdNode *res;
    DdNode *l;
    DdNode *u;
    
    /* Create constant nodes for the interval bounds, so that we can use
    ** the global cache.
    */
    l = cuddUniqueConst(dd,lower);
    if (l == NULL) return(NULL);
    cuddRef(l);
    u = cuddUniqueConst(dd,upper);
    if (u == NULL) {
	Cudd_RecursiveDeref(dd,l);
	return(NULL);
    }
    cuddRef(u);

    do {
	dd->reordered = 0;
	res = addBddDoInterval(dd, f, l, u);
    } while (dd->reordered == 1);

    if (res == NULL) {
	Cudd_RecursiveDeref(dd, l);
	Cudd_RecursiveDeref(dd, u);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, l);
    Cudd_RecursiveDeref(dd, u);
    cuddDeref(res);
    return(res);

} /* end of Cudd_addBddInterval */


/**
  @brief Converts an %ADD to a %BDD by extracting the i-th bit from
  the leaves.

  @details Converts an %ADD to a %BDD by replacing all
  discriminants whose i-th bit is equal to 1 with 1, and all other
  discriminants with 0.  The i-th bit refers to the integer
  representation of the leaf value.  If the value has a fractional
  part, it is ignored.  Repeated calls to this procedure allow one to
  transform an integer-valued %ADD into an array of BDDs, one for each
  bit of the leaf values.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addBddInterval Cudd_addBddPattern Cudd_BddToAdd

*/
DdNode *
Cudd_addBddIthBit(
  DdManager * dd,
  DdNode * f,
  int  bit)
{
    DdNode *res;
    DdNode *index;
    
    index = cuddUniqueConst(dd,(CUDD_VALUE_TYPE) bit);
    if (index == NULL) return(NULL);
    cuddRef(index);

    do {
	dd->reordered = 0;
	res = addBddDoIthBit(dd, f, index);
    } while (dd->reordered == 1);

    if (res == NULL) {
	Cudd_RecursiveDeref(dd, index);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, index);
    cuddDeref(res);
    return(res);

} /* end of Cudd_addBddIthBit */


/**
  @brief Converts a %BDD to a 0-1 %ADD.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addBddPattern Cudd_addBddThreshold Cudd_addBddInterval
  Cudd_addBddStrictThreshold

*/
DdNode *
Cudd_BddToAdd(
  DdManager * dd,
  DdNode * B)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = ddBddToAddRecur(dd, B);
    } while (dd->reordered ==1);
    return(res);

} /* end of Cudd_BddToAdd */


/**
  @brief Converts an %ADD to a %BDD.

  @details Replaces all discriminants different from 0 with 1.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_BddToAdd Cudd_addBddThreshold Cudd_addBddInterval
  Cudd_addBddStrictThreshold

*/
DdNode *
Cudd_addBddPattern(
  DdManager * dd,
  DdNode * f)
{
    DdNode *res;
    
    do {
	dd->reordered = 0;
	res = cuddAddBddDoPattern(dd, f);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addBddPattern */


/**
  @brief Convert a %BDD from a manager to another one.

  @details The orders of the variables in the two managers may be
  different.

  @return a pointer to the %BDD in the destination manager if
  successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_bddTransfer(
  DdManager * ddSource,
  DdManager * ddDestination,
  DdNode * f)
{
    DdNode *res;
    do {
	ddDestination->reordered = 0;
	res = cuddBddTransfer(ddSource, ddDestination, f);
    } while (ddDestination->reordered == 1);
    if (ddDestination->errorCode == CUDD_TIMEOUT_EXPIRED &&
        ddDestination->timeoutHandler) {
        ddDestination->timeoutHandler(ddDestination, ddDestination->tohArg);
    }
    return(res);

} /* end of Cudd_bddTransfer */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Convert a %BDD from a manager to another one.

  @return a pointer to the %BDD in the destination manager if
  successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddTransfer

*/
DdNode *
cuddBddTransfer(
  DdManager * ddS,
  DdManager * ddD,
  DdNode * f)
{
    DdNode *res;
    st_table *table = NULL;
    st_generator *gen = NULL;
    DdNode *key, *value;

    table = st_init_table(st_ptrcmp,st_ptrhash);
    if (table == NULL) goto failure;
    res = cuddBddTransferRecur(ddS, ddD, f, table);
    if (res != NULL) cuddRef(res);

    /* Dereference all elements in the table and dispose of the table.
    ** This must be done also if res is NULL to avoid leaks in case of
    ** reordering. */
    gen = st_init_gen(table);
    if (gen == NULL) goto failure;
    while (st_gen(gen, (void **) &key, (void **) &value)) {
	Cudd_RecursiveDeref(ddD, value);
    }
    st_free_gen(gen); gen = NULL;
    st_free_table(table); table = NULL;

    if (res != NULL) cuddDeref(res);
    return(res);

failure:
    /* No need to free gen because it is always NULL here. */
    if (table != NULL) st_free_table(table);
    return(NULL);

} /* end of cuddBddTransfer */


/**
  @brief Performs the recursive step for Cudd_addBddPattern.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

*/
DdNode *
cuddAddBddDoPattern(
  DdManager * dd,
  DdNode * f)
{
    DdNode *res, *T, *E;
    DdNode *fv, *fvn;
    unsigned int v;

    statLine(dd);
    /* Check terminal case. */
    if (cuddIsConstant(f)) {
	return(Cudd_NotCond(DD_ONE(dd),f == DD_ZERO(dd)));
    }

    /* Check cache. */
    res = cuddCacheLookup1(dd,Cudd_addBddPattern,f);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    v = f->index;
    fv = cuddT(f); fvn = cuddE(f);

    T = cuddAddBddDoPattern(dd,fv);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = cuddAddBddDoPattern(dd,fvn);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);
    if (Cudd_IsComplement(T)) {
	res = (T == E) ? Cudd_Not(T) : cuddUniqueInter(dd,v,Cudd_Not(T),Cudd_Not(E));
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
	res = Cudd_Not(res);
    } else {
	res = (T == E) ? T : cuddUniqueInter(dd,v,T,E);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert1(dd,Cudd_addBddPattern,f,res);

    return(res);

} /* end of cuddAddBddDoPattern */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step for Cudd_addBddThreshold.

  @return a pointer to the %BDD if successful; NULL otherwise.

  @sideeffect None

  @see addBddDoStrictThreshold

*/
static DdNode *
addBddDoThreshold(
  DdManager * dd,
  DdNode * f,
  DdNode * val)
{
    DdNode *res, *T, *E;
    DdNode *fv, *fvn;
    unsigned int v;

    statLine(dd);
    /* Check terminal case. */
    if (cuddIsConstant(f)) {
	return(Cudd_NotCond(DD_ONE(dd),cuddV(f) < cuddV(val)));
    }

    /* Check cache. */
    res = cuddCacheLookup2(dd,addBddDoThreshold,f,val);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    v = f->index;
    fv = cuddT(f); fvn = cuddE(f);

    T = addBddDoThreshold(dd,fv,val);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = addBddDoThreshold(dd,fvn,val);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);
    if (Cudd_IsComplement(T)) {
	res = (T == E) ? Cudd_Not(T) : cuddUniqueInter(dd,v,Cudd_Not(T),Cudd_Not(E));
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
	res = Cudd_Not(res);
    } else {
	res = (T == E) ? T : cuddUniqueInter(dd,v,T,E);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert2(dd,addBddDoThreshold,f,val,res);

    return(res);

} /* end of addBddDoThreshold */


/**
  @brief Performs the recursive step for Cudd_addBddStrictThreshold.

  @return a pointer to the %BDD if successful; NULL otherwise.

  @sideeffect None

  @see addBddDoThreshold

*/
static DdNode *
addBddDoStrictThreshold(
  DdManager * dd,
  DdNode * f,
  DdNode * val)
{
    DdNode *res, *T, *E;
    DdNode *fv, *fvn;
    unsigned int v;

    statLine(dd);
    /* Check terminal case. */
    if (cuddIsConstant(f)) {
	return(Cudd_NotCond(DD_ONE(dd),cuddV(f) <= cuddV(val)));
    }

    /* Check cache. */
    res = cuddCacheLookup2(dd,addBddDoStrictThreshold,f,val);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    v = f->index;
    fv = cuddT(f); fvn = cuddE(f);

    T = addBddDoStrictThreshold(dd,fv,val);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = addBddDoStrictThreshold(dd,fvn,val);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);
    if (Cudd_IsComplement(T)) {
	res = (T == E) ? Cudd_Not(T) : cuddUniqueInter(dd,v,Cudd_Not(T),Cudd_Not(E));
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
	res = Cudd_Not(res);
    } else {
	res = (T == E) ? T : cuddUniqueInter(dd,v,T,E);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert2(dd,addBddDoStrictThreshold,f,val,res);

    return(res);

} /* end of addBddDoStrictThreshold */


/**
  @brief Performs the recursive step for Cudd_addBddInterval.

  @return a pointer to the %BDD if successful; NULL otherwise.

  @sideeffect None

  @see addBddDoThreshold addBddDoStrictThreshold

*/
static DdNode *
addBddDoInterval(
  DdManager * dd,
  DdNode * f,
  DdNode * l,
  DdNode * u)
{
    DdNode *res, *T, *E;
    DdNode *fv, *fvn;
    unsigned int v;

    statLine(dd);
    /* Check terminal case. */
    if (cuddIsConstant(f)) {
	return(Cudd_NotCond(DD_ONE(dd),cuddV(f) < cuddV(l) || cuddV(f) > cuddV(u)));
    }

    /* Check cache. */
    res = cuddCacheLookup(dd,DD_ADD_BDD_DO_INTERVAL_TAG,f,l,u);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    v = f->index;
    fv = cuddT(f); fvn = cuddE(f);

    T = addBddDoInterval(dd,fv,l,u);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = addBddDoInterval(dd,fvn,l,u);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);
    if (Cudd_IsComplement(T)) {
	res = (T == E) ? Cudd_Not(T) : cuddUniqueInter(dd,v,Cudd_Not(T),Cudd_Not(E));
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
	res = Cudd_Not(res);
    } else {
	res = (T == E) ? T : cuddUniqueInter(dd,v,T,E);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert(dd,DD_ADD_BDD_DO_INTERVAL_TAG,f,l,u,res);

    return(res);

} /* end of addBddDoInterval */


/**
  @brief Performs the recursive step for Cudd_addBddIthBit.

  @return a pointer to the %BDD if successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
addBddDoIthBit(
  DdManager * dd,
  DdNode * f,
  DdNode * index)
{
    DdNode *res, *T, *E;
    DdNode *fv, *fvn;
    int mask, value;
    unsigned int v;

    statLine(dd);
    /* Check terminal case. */
    if (cuddIsConstant(f)) {
	mask = 1 << ((int) cuddV(index));
	value = (int) cuddV(f);
	return(Cudd_NotCond(DD_ONE(dd),(value & mask) == 0));
    }

    /* Check cache. */
    res = cuddCacheLookup2(dd,addBddDoIthBit,f,index);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    v = f->index;
    fv = cuddT(f); fvn = cuddE(f);

    T = addBddDoIthBit(dd,fv,index);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = addBddDoIthBit(dd,fvn,index);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);
    if (Cudd_IsComplement(T)) {
	res = (T == E) ? Cudd_Not(T) : cuddUniqueInter(dd,v,Cudd_Not(T),Cudd_Not(E));
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
	res = Cudd_Not(res);
    } else {
	res = (T == E) ? T : cuddUniqueInter(dd,v,T,E);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
    }
    cuddDeref(T);
    cuddDeref(E);

    /* Store result. */
    cuddCacheInsert2(dd,addBddDoIthBit,f,index,res);

    return(res);

} /* end of addBddDoIthBit */


/**
  @brief Performs the recursive step for Cudd_BddToAdd.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

*/
static DdNode *
ddBddToAddRecur(
  DdManager * dd,
  DdNode * B)
{
    DdNode *one;
    DdNode *res, *res1, *T, *E, *Bt, *Be;
    int complement = 0;

    statLine(dd);
    one = DD_ONE(dd);

    if (Cudd_IsConstantInt(B)) {
	if (B == one) {
	    res = one;
	} else {
	    res = DD_ZERO(dd);
	}
	return(res);
    }
    /* Check visited table */
    res = cuddCacheLookup1(dd,ddBddToAddRecur,B);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    if (Cudd_IsComplement(B)) {
	complement = 1;
	Bt = cuddT(Cudd_Regular(B));
	Be = cuddE(Cudd_Regular(B));
    } else {
	Bt = cuddT(B);
	Be = cuddE(B);
    }

    T = ddBddToAddRecur(dd, Bt);
    if (T == NULL) return(NULL);
    cuddRef(T);

    E = ddBddToAddRecur(dd, Be);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);

    /* No need to check for T == E, because it is guaranteed not to happen. */
    res = cuddUniqueInter(dd, (int) Cudd_Regular(B)->index, T, E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd ,T);
	Cudd_RecursiveDeref(dd ,E);
	return(NULL);
    }
    cuddDeref(T);
    cuddDeref(E);

    if (complement) {
	cuddRef(res);
	res1 = cuddAddCmplRecur(dd, res);
	if (res1 == NULL) {
	    Cudd_RecursiveDeref(dd, res);
	    return(NULL);
	}
	cuddRef(res1);
	Cudd_RecursiveDeref(dd, res);
	res = res1;
	cuddDeref(res);
    }

    /* Store result. */
    cuddCacheInsert1(dd,ddBddToAddRecur,B,res);

    return(res);

} /* end of ddBddToAddRecur */


/**
  @brief Performs the recursive step of Cudd_bddTransfer.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see cuddBddTransfer

*/
static DdNode *
cuddBddTransferRecur(
  DdManager * ddS,
  DdManager * ddD,
  DdNode * f,
  st_table * table)
{
    DdNode *ft, *fe, *t, *e, *var, *res;
    DdNode *one, *zero;
    unsigned int index;
    int comple = 0;

    statLine(ddD);
    one = DD_ONE(ddD);
    comple = Cudd_IsComplement(f);

    /* Trivial cases. */
    if (Cudd_IsConstantInt(f)) return(Cudd_NotCond(one, comple));

    /* Make canonical to increase the utilization of the cache. */
    f = Cudd_NotCond(f,comple);
    /* Now f is a regular pointer to a non-constant node. */

    /* Check the cache. */
    if (st_lookup(table, f, (void **) &res))
	return(Cudd_NotCond(res,comple));
    
    /* Recursive step. */
    index = f->index;
    ft = cuddT(f); fe = cuddE(f);

    t = cuddBddTransferRecur(ddS, ddD, ft, table);
    if (t == NULL) {
    	return(NULL);
    }
    cuddRef(t);

    e = cuddBddTransferRecur(ddS, ddD, fe, table);
    if (e == NULL) {
    	Cudd_RecursiveDeref(ddD, t);
    	return(NULL);
    }
    cuddRef(e);

    zero = Cudd_Not(one);
    var = cuddUniqueInter(ddD,index,one,zero);
    if (var == NULL) {
	Cudd_RecursiveDeref(ddD, t);
	Cudd_RecursiveDeref(ddD, e);
    	return(NULL);
    }
    res = cuddBddIteRecur(ddD,var,t,e);
    if (res == NULL) {
	Cudd_RecursiveDeref(ddD, t);
	Cudd_RecursiveDeref(ddD, e);
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(ddD, t);
    Cudd_RecursiveDeref(ddD, e);

    if (st_add_direct(table, f, res) == ST_OUT_OF_MEM) {
	Cudd_RecursiveDeref(ddD, res);
	return(NULL);
    }
    return(Cudd_NotCond(res,comple));

} /* end of cuddBddTransferRecur */


cuddCache.c
23919
/**
  @file

  @ingroup cudd

  @brief Functions for cache insertion and lookup.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#ifdef DD_CACHE_PROFILE
#define DD_HYSTO_BINS 8
#endif

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Initializes the computed table.

  @details It is called by Cudd_Init.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

  @see Cudd_Init

*/
int
cuddInitCache(
  DdManager * unique /**< unique table */,
  unsigned int cacheSize /**< initial size of the cache */,
  unsigned int maxCacheSize /**< cache size beyond which no resizing occurs */)
{
    int i;
    unsigned int logSize;
#ifndef DD_CACHE_PROFILE
    DdNodePtr *mem;
    ptruint offset;
#endif

    /* Round cacheSize to largest power of 2 not greater than the requested
    ** initial cache size. */
    logSize = cuddComputeFloorLog2(ddMax(cacheSize,unique->slots/2));
    cacheSize = 1U << logSize;
    unique->acache = ALLOC(DdCache,cacheSize+1);
    if (unique->acache == NULL) {
	unique->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    /* If the size of the cache entry is a power of 2, we want to
    ** enforce alignment to that power of two. This happens when
    ** DD_CACHE_PROFILE is not defined. */
#ifdef DD_CACHE_PROFILE
    unique->cache = unique->acache;
    unique->memused += (cacheSize) * sizeof(DdCache);
#else
    mem = (DdNodePtr *) unique->acache;
    offset = (ptruint) mem & (sizeof(DdCache) - 1);
    mem += (sizeof(DdCache) - offset) / sizeof(DdNodePtr);
    unique->cache = (DdCache *) mem;
    assert(((ptruint) unique->cache & (sizeof(DdCache) - 1)) == 0);
    unique->memused += (cacheSize+1) * sizeof(DdCache);
#endif
    unique->cacheSlots = cacheSize;
    unique->cacheShift = sizeof(int) * 8 - logSize;
    unique->maxCacheHard = maxCacheSize;
    /* If cacheSlack is non-negative, we can resize. */
    unique->cacheSlack = (int) ddMin(maxCacheSize,
	DD_MAX_CACHE_TO_SLOTS_RATIO*unique->slots) -
	2 * (int) cacheSize;
    Cudd_SetMinHit(unique,DD_MIN_HIT);
    /* Initialize to avoid division by 0 and immediate resizing. */
    unique->cacheMisses = (double) (int) (cacheSize * unique->minHit + 1);
    unique->cacheHits = 0;
    unique->totCachehits = 0;
    /* The sum of cacheMisses and totCacheMisses is always correct,
    ** even though cacheMisses is larger than it should for the reasons
    ** explained above. */
    unique->totCacheMisses = -unique->cacheMisses;
    unique->cachecollisions = 0;
    unique->cacheinserts = 0;
    unique->cacheLastInserts = 0;
    unique->cachedeletions = 0;

    /* Initialize the cache */
    for (i = 0; (unsigned) i < cacheSize; i++) {
	unique->cache[i].h = 0; /* unused slots */
	unique->cache[i].data = NULL; /* invalid entry */
#ifdef DD_CACHE_PROFILE
	unique->cache[i].count = 0;
#endif
    }

    return(1);

} /* end of cuddInitCache */


/**
  @brief Inserts a result in the cache for a function with three
  operands.

  @details The operator tag (see cuddInt.h for details) is split and
  stored into unused bits of the first two pointers.

  @sideeffect None

  @see cuddCacheInsert2 cuddCacheInsert1

*/
void
cuddCacheInsert(
  DdManager * table,
  ptruint op,
  DdNode * f,
  DdNode * g,
  DdNode * h,
  DdNode * data)
{
    int posn;
    DdCache *entry;
    ptruint uf, ug, uh;

    uf = (ptruint) f | (op & 0xe);
    ug = (ptruint) g | (op >> 4);
    uh = (ptruint) h;

    posn = ddCHash2(uh,uf,ug,table->cacheShift);
    entry = &table->cache[posn];

    table->cachecollisions += entry->data != NULL;
    table->cacheinserts++;

    entry->f    = (DdNode *) uf;
    entry->g    = (DdNode *) ug;
    entry->h    = uh;
    entry->data = data;
#ifdef DD_CACHE_PROFILE
    entry->count++;
#endif

} /* end of cuddCacheInsert */


/**
  @brief Inserts a result in the cache for a function with two
  operands.

  @sideeffect None

  @see cuddCacheInsert cuddCacheInsert1

*/
void
cuddCacheInsert2(
  DdManager * table,
  DD_CTFP op,
  DdNode * f,
  DdNode * g,
  DdNode * data)
{
    int posn;
    DdCache *entry;

    posn = ddCHash2(op,f,g,table->cacheShift);
    entry = &table->cache[posn];

    if (entry->data != NULL) {
	table->cachecollisions++;
    }
    table->cacheinserts++;

    entry->f = f;
    entry->g = g;
    entry->h = (ptruint) op;
    entry->data = data;
#ifdef DD_CACHE_PROFILE
    entry->count++;
#endif

} /* end of cuddCacheInsert2 */


/**
  @brief Inserts a result in the cache for a function with two
  operands.

  @sideeffect None

  @see cuddCacheInsert cuddCacheInsert2

*/
void
cuddCacheInsert1(
  DdManager * table,
  DD_CTFP1 op,
  DdNode * f,
  DdNode * data)
{
    int posn;
    DdCache *entry;

    posn = ddCHash2(op,f,f,table->cacheShift);
    entry = &table->cache[posn];

    if (entry->data != NULL) {
	table->cachecollisions++;
    }
    table->cacheinserts++;

    entry->f = f;
    entry->g = f;
    entry->h = (ptruint) op;
    entry->data = data;
#ifdef DD_CACHE_PROFILE
    entry->count++;
#endif

} /* end of cuddCacheInsert1 */


/**
  @brief Looks up in the cache for the result of op applied to f,
  g, and h.

  @return the result if found; it returns NULL if no result is found.

  @sideeffect None

  @see cuddCacheLookup2 cuddCacheLookup1

*/
DdNode *
cuddCacheLookup(
  DdManager * table,
  ptruint op,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    int posn;
    DdCache *en,*cache;
    DdNode *data;
    ptruint uf, ug, uh;

    uf = (ptruint) f | (op & 0xe);
    ug = (ptruint) g | (op >> 4);
    uh = (ptruint) h;

    cache = table->cache;
#ifdef DD_DEBUG
    if (cache == NULL) {
	return(NULL);
    }
#endif

    posn = ddCHash2(uh,uf,ug,table->cacheShift);
    en = &cache[posn];
    if (en->data != NULL && en->f==(DdNodePtr)uf && en->g==(DdNodePtr)ug &&
	en->h==uh) {
	data = Cudd_Regular(en->data);
	table->cacheHits++;
	if (data->ref == 0) {
	    cuddReclaim(table,data);
	}
	return(en->data);
    }

    /* Cache miss: decide whether to resize. */
    table->cacheMisses++;

    if (table->cacheSlack >= 0 &&
	table->cacheHits > table->cacheMisses * table->minHit) {
	cuddCacheResize(table);
    }

    return(NULL);

} /* end of cuddCacheLookup */


/**
  @brief Looks up in the cache for the result of op applied to f,
  g, and h.

  @return the result if found; it returns NULL if no result is found.

  @sideeffect None

  @see cuddCacheLookup2Zdd cuddCacheLookup1Zdd

*/
DdNode *
cuddCacheLookupZdd(
  DdManager * table,
  ptruint op,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    int posn;
    DdCache *en,*cache;
    DdNode *data;
    ptruint uf, ug, uh;

    uf = (ptruint) f | (op & 0xe);
    ug = (ptruint) g | (op >> 4);
    uh = (ptruint) h;

    cache = table->cache;
#ifdef DD_DEBUG
    if (cache == NULL) {
	return(NULL);
    }
#endif

    posn = ddCHash2(uh,uf,ug,table->cacheShift);
    en = &cache[posn];
    if (en->data != NULL && en->f==(DdNodePtr)uf && en->g==(DdNodePtr)ug &&
	en->h==uh) {
	data = Cudd_Regular(en->data);
	table->cacheHits++;
	if (data->ref == 0) {
	    cuddReclaimZdd(table,data);
	}
	return(en->data);
    }

    /* Cache miss: decide whether to resize. */
    table->cacheMisses++;

    if (table->cacheSlack >= 0 &&
	table->cacheHits > table->cacheMisses * table->minHit) {
	cuddCacheResize(table);
    }

    return(NULL);

} /* end of cuddCacheLookupZdd */


/**
  @brief Looks up in the cache for the result of op applied to f
  and g.

  @return the result if found; it returns NULL if no result is found.

  @sideeffect None

  @see cuddCacheLookup cuddCacheLookup1

*/
DdNode *
cuddCacheLookup2(
  DdManager * table,
  DD_CTFP op,
  DdNode * f,
  DdNode * g)
{
    int posn;
    DdCache *en,*cache;
    DdNode *data;

    cache = table->cache;
#ifdef DD_DEBUG
    if (cache == NULL) {
	return(NULL);
    }
#endif

    posn = ddCHash2(op,f,g,table->cacheShift);
    en = &cache[posn];
    if (en->data != NULL && en->f==f && en->g==g && en->h==(ptruint)op) {
	data = Cudd_Regular(en->data);
	table->cacheHits++;
	if (data->ref == 0) {
	    cuddReclaim(table,data);
	}
	return(en->data);
    }

    /* Cache miss: decide whether to resize. */
    table->cacheMisses++;

    if (table->cacheSlack >= 0 &&
	table->cacheHits > table->cacheMisses * table->minHit) {
	cuddCacheResize(table);
    }

    return(NULL);

} /* end of cuddCacheLookup2 */


/**
  @brief Looks up in the cache for the result of op applied to f.

  @return the result if found; it returns NULL if no result is found.

  @sideeffect None

  @see cuddCacheLookup cuddCacheLookup2

*/
DdNode *
cuddCacheLookup1(
  DdManager * table,
  DD_CTFP1 op,
  DdNode * f)
{
    int posn;
    DdCache *en,*cache;
    DdNode *data;

    cache = table->cache;
#ifdef DD_DEBUG
    if (cache == NULL) {
	return(NULL);
    }
#endif

    posn = ddCHash2(op,f,f,table->cacheShift);
    en = &cache[posn];
    if (en->data != NULL && en->f==f && en->h==(ptruint)op) {
	data = Cudd_Regular(en->data);
	table->cacheHits++;
	if (data->ref == 0) {
	    cuddReclaim(table,data);
	}
	return(en->data);
    }

    /* Cache miss: decide whether to resize. */
    table->cacheMisses++;

    if (table->cacheSlack >= 0 &&
	table->cacheHits > table->cacheMisses * table->minHit) {
	cuddCacheResize(table);
    }

    return(NULL);

} /* end of cuddCacheLookup1 */


/**
  @brief Looks up in the cache for the result of op applied to f
  and g.

  @return the result if found; it returns NULL if no result is found.

  @sideeffect None

  @see cuddCacheLookupZdd cuddCacheLookup1Zdd

*/
DdNode *
cuddCacheLookup2Zdd(
  DdManager * table,
  DD_CTFP op,
  DdNode * f,
  DdNode * g)
{
    int posn;
    DdCache *en,*cache;
    DdNode *data;

    cache = table->cache;
#ifdef DD_DEBUG
    if (cache == NULL) {
	return(NULL);
    }
#endif

    posn = ddCHash2(op,f,g,table->cacheShift);
    en = &cache[posn];
    if (en->data != NULL && en->f==f && en->g==g && en->h==(ptruint)op) {
	data = Cudd_Regular(en->data);
	table->cacheHits++;
	if (data->ref == 0) {
	    cuddReclaimZdd(table,data);
	}
	return(en->data);
    }

    /* Cache miss: decide whether to resize. */
    table->cacheMisses++;

    if (table->cacheSlack >= 0 &&
	table->cacheHits > table->cacheMisses * table->minHit) {
	cuddCacheResize(table);
    }

    return(NULL);

} /* end of cuddCacheLookup2Zdd */


/**
  @brief Looks up in the cache for the result of op applied to f.

  @return the result if found; it returns NULL if no result is found.

  @sideeffect None

  @see cuddCacheLookupZdd cuddCacheLookup2Zdd

*/
DdNode *
cuddCacheLookup1Zdd(
  DdManager * table,
  DD_CTFP1 op,
  DdNode * f)
{
    int posn;
    DdCache *en,*cache;
    DdNode *data;

    cache = table->cache;
#ifdef DD_DEBUG
    if (cache == NULL) {
	return(NULL);
    }
#endif

    posn = ddCHash2(op,f,f,table->cacheShift);
    en = &cache[posn];
    if (en->data != NULL && en->f==f && en->h==(ptruint)op) {
	data = Cudd_Regular(en->data);
	table->cacheHits++;
	if (data->ref == 0) {
	    cuddReclaimZdd(table,data);
	}
	return(en->data);
    }

    /* Cache miss: decide whether to resize. */
    table->cacheMisses++;

    if (table->cacheSlack >= 0  &&
	table->cacheHits > table->cacheMisses * table->minHit) {
	cuddCacheResize(table);
    }

    return(NULL);

} /* end of cuddCacheLookup1Zdd */


/**
  @brief Looks up in the cache for the result of op applied to f,
  g, and h.

  @details Assumes that the calling procedure (e.g.,
  Cudd_bddIteConstant) is only interested in whether the result is
  constant or not.

  @return the result if found (possibly DD_NON_CONSTANT); otherwise it
  returns NULL.

  @sideeffect None

  @see cuddCacheLookup

*/
DdNode *
cuddConstantLookup(
  DdManager * table,
  ptruint op,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    int posn;
    DdCache *en,*cache;
    ptruint uf, ug, uh;

    uf = (ptruint) f | (op & 0xe);
    ug = (ptruint) g | (op >> 4);
    uh = (ptruint) h;

    cache = table->cache;
#ifdef DD_DEBUG
    if (cache == NULL) {
	return(NULL);
    }
#endif
    posn = ddCHash2(uh,uf,ug,table->cacheShift);
    en = &cache[posn];

    /* We do not reclaim here because the result should not be
     * referenced, but only tested for being a constant.
     */
    if (en->data != NULL &&
	en->f == (DdNodePtr)uf && en->g == (DdNodePtr)ug && en->h == uh) {
	table->cacheHits++;
	return(en->data);
    }

    /* Cache miss: decide whether to resize. */
    table->cacheMisses++;

    if (table->cacheSlack >= 0 &&
	table->cacheHits > table->cacheMisses * table->minHit) {
	cuddCacheResize(table);
    }

    return(NULL);

} /* end of cuddConstantLookup */


/**
  @brief Computes and prints a profile of the cache usage.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddCacheProfile(
  DdManager * table,
  FILE * fp)
{
    DdCache *cache = table->cache;
    int slots = table->cacheSlots;
    int nzeroes = 0;
    int i, retval;
    double exUsed;

#ifdef DD_CACHE_PROFILE
    double count, mean, meansq, stddev, expected;
    long max, min;
    int imax, imin;
    double *hystogramQ, *hystogramR; /* histograms by quotient and remainder */
    int nbins = DD_HYSTO_BINS;
    int bin;
    long thiscount;
    double totalcount, exStddev;

    meansq = mean = expected = 0.0;
    max = min = (long) cache[0].count;
    imax = imin = 0;
    totalcount = 0.0;

    hystogramQ = ALLOC(double, nbins);
    if (hystogramQ == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    hystogramR = ALLOC(double, nbins);
    if (hystogramR == NULL) {
	FREE(hystogramQ);
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (i = 0; i < nbins; i++) {
	hystogramQ[i] = 0;
	hystogramR[i] = 0;
    }

    for (i = 0; i < slots; i++) {
	thiscount = (long) cache[i].count;
	if (thiscount > max) {
	    max = thiscount;
	    imax = i;
	}
	if (thiscount < min) {
	    min = thiscount;
	    imin = i;
	}
	if (thiscount == 0) {
	    nzeroes++;
	}
	count = (double) thiscount;
	mean += count;
	meansq += count * count;
	totalcount += count;
	expected += count * (double) i;
	bin = (i * nbins) / slots;
	hystogramQ[bin] += (double) thiscount;
	bin = i % nbins;
	hystogramR[bin] += (double) thiscount;
    }
    mean /= (double) slots;
    meansq /= (double) slots;

    /* Compute the standard deviation from both the data and the
    ** theoretical model for a random distribution. */
    stddev = sqrt(meansq - mean*mean);
    exStddev = sqrt((1 - 1/(double) slots) * totalcount / (double) slots);

    retval = fprintf(fp,"Cache average accesses = %g\n",  mean);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Cache access standard deviation = %g ", stddev);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"(expected = %g)\n", exStddev);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Cache max accesses = %ld for slot %d\n", max, imax);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Cache min accesses = %ld for slot %d\n", min, imin);
    if (retval == EOF) return(0);
    exUsed = 100.0 * (1.0 - exp(-totalcount / (double) slots));
    retval = fprintf(fp,"Cache used slots = %.2f%% (expected %.2f%%)\n",
		     100.0 - (double) nzeroes * 100.0 / (double) slots,
		     exUsed);
    if (retval == EOF) return(0);

    if (totalcount > 0) {
	expected /= totalcount;
	retval = fprintf(fp,"Cache access hystogram for %d bins", nbins);
	if (retval == EOF) return(0);
	retval = fprintf(fp," (expected bin value = %g)\nBy quotient:",
			 expected);
	if (retval == EOF) return(0);
	for (i = nbins - 1; i>=0; i--) {
	    retval = fprintf(fp," %.0f", hystogramQ[i]);
	    if (retval == EOF) return(0);
	}
	retval = fprintf(fp,"\nBy residue: ");
	if (retval == EOF) return(0);
	for (i = nbins - 1; i>=0; i--) {
	    retval = fprintf(fp," %.0f", hystogramR[i]);
	    if (retval == EOF) return(0);
	}
	retval = fprintf(fp,"\n");
	if (retval == EOF) return(0);
    }

    FREE(hystogramQ);
    FREE(hystogramR);
#else
    for (i = 0; i < slots; i++) {
	nzeroes += cache[i].h == 0;
    }
    exUsed = 100.0 *
	(1.0 - exp(-(table->cacheinserts - table->cacheLastInserts) /
		   (double) slots));
    retval = fprintf(fp,"Cache used slots = %.2f%% (expected %.2f%%)\n",
		     100.0 - (double) nzeroes * 100.0 / (double) slots,
		     exUsed);
    if (retval == EOF) return(0);
#endif
    return(1);

} /* end of cuddCacheProfile */


/**
  @brief Resizes the cache.

  @sideeffect None

*/
void
cuddCacheResize(
  DdManager * table)
{
    DdCache *cache, *oldcache, *oldacache, *entry, *old;
    int i;
    int posn, shift;
    unsigned int slots, oldslots;
    double offset;
    int moved = 0;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;
#ifndef DD_CACHE_PROFILE
    ptruint misalignment;
    DdNodePtr *mem;
#endif

    oldcache = table->cache;
    oldacache = table->acache;
    oldslots = table->cacheSlots;
    slots = table->cacheSlots = oldslots << 1;

#ifdef DD_VERBOSE
    (void) fprintf(table->err,"Resizing the cache from %d to %d entries\n",
		   oldslots, slots);
    (void) fprintf(table->err,
		   "\thits = %g\tmisses = %g\thit ratio = %5.3f\n",
		   table->cacheHits, table->cacheMisses,
		   table->cacheHits / (table->cacheHits + table->cacheMisses));
#endif

    saveHandler = MMoutOfMemory;
    MMoutOfMemory = table->outOfMemCallback;
    table->acache = cache = ALLOC(DdCache,slots+1);
    MMoutOfMemory = saveHandler;
    /* If we fail to allocate the new table we just give up. */
    if (cache == NULL) {
#ifdef DD_VERBOSE
	(void) fprintf(table->err,"Resizing failed. Giving up.\n");
#endif
	table->cacheSlots = oldslots;
	table->acache = oldacache;
	/* Do not try to resize again. */
	table->maxCacheHard = oldslots - 1;
	table->cacheSlack = - (int) (oldslots + 1);
	return;
    }
    /* If the size of the cache entry is a power of 2, we want to
    ** enforce alignment to that power of two. This happens when
    ** DD_CACHE_PROFILE is not defined. */
#ifdef DD_CACHE_PROFILE
    table->cache = cache;
#else
    mem = (DdNodePtr *) cache;
    misalignment = (ptruint) mem & (sizeof(DdCache) - 1);
    mem += (sizeof(DdCache) - misalignment) / sizeof(DdNodePtr);
    table->cache = cache = (DdCache *) mem;
    assert(((ptruint) table->cache & (sizeof(DdCache) - 1)) == 0);
#endif
    shift = --(table->cacheShift);
    table->memused += (slots - oldslots) * sizeof(DdCache);
    table->cacheSlack -= slots; /* need these many slots to double again */

    /* Clear new cache. */
    for (i = 0; (unsigned) i < slots; i++) {
	cache[i].data = NULL;
	cache[i].h = 0;
#ifdef DD_CACHE_PROFILE
	cache[i].count = 0;
#endif
    }

    /* Copy from old cache to new one. */
    for (i = 0; (unsigned) i < oldslots; i++) {
	old = &oldcache[i];
	if (old->data != NULL) {
	    posn = ddCHash2(old->h,old->f,old->g,shift);
	    entry = &cache[posn];
	    entry->f = old->f;
	    entry->g = old->g;
	    entry->h = old->h;
	    entry->data = old->data;
#ifdef DD_CACHE_PROFILE
	    entry->count = 1;
#endif
	    moved++;
	}
    }

    FREE(oldacache);

    /* Reinitialize measurements so as to avoid division by 0 and
    ** immediate resizing.
    */
    offset = (double) (int) (slots * table->minHit + 1);
    table->totCacheMisses += table->cacheMisses - offset;
    table->cacheMisses = offset;
    table->totCachehits += table->cacheHits;
    table->cacheHits = 0;
    table->cacheLastInserts = table->cacheinserts - (double) moved;

} /* end of cuddCacheResize */


/**
  @brief Flushes the cache.

  @sideeffect None

*/
void
cuddCacheFlush(
  DdManager * table)
{
    int i, slots;
    DdCache *cache;

    slots = table->cacheSlots;
    cache = table->cache;
    for (i = 0; i < slots; i++) {
	table->cachedeletions += cache[i].data != NULL;
	cache[i].data = NULL;
    }
    table->cacheLastInserts = table->cacheinserts;

    return;

} /* end of cuddCacheFlush */


/**
  @brief Returns the floor of the logarithm to the base 2.

  @details The input value is assumed to be greater than 0.

  @sideeffect None

*/
int
cuddComputeFloorLog2(
  unsigned int value)
{
    int floorLog = 0;
#ifdef DD_DEBUG
    assert(value > 0);
#endif
    while (value > 1) {
	floorLog++;
	value >>= 1;
    }
    return(floorLog);

} /* end of cuddComputeFloorLog2 */

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

cuddCheck.c
24032
/**
  @file

  @ingroup cudd

  @brief Functions to check consistency of data structures.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void debugFindParent (DdManager *table, DdNode *node);
#if 0
static void debugCheckParent (DdManager *table, DdNode *node);
#endif

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Checks for inconsistencies in the %DD heap.

  @details The following inconsistencies are checked:
  <ul>
  <li> node has illegal index
  <li> live node has dead children
  <li> node has illegal Then or Else pointers
  <li> %BDD/%ADD node has identical children
  <li> %ZDD node has zero then child
  <li> wrong number of total nodes
  <li> wrong number of dead nodes
  <li> ref count error at node
  </ul>
  
  @return 0 if no inconsistencies are found; DD_OUT_OF_MEM if there is
  not enough memory; 1 otherwise.

  @sideeffect None

  @see Cudd_CheckKeys

*/
int
Cudd_DebugCheck(
  DdManager * table)
{
    unsigned int i;
    int		j,count;
    int		slots;
    DdNodePtr	*nodelist;
    DdNode	*f;
    DdNode	*sentinel = &(table->sentinel);
    st_table	*edgeTable;	/* stores internal ref count for each node */
    st_generator	*gen;
    int		flag = 0;
    int		totalNode;
    int		deadNode;
    int		index;
    int         shift;

    edgeTable = st_init_table(st_ptrcmp,st_ptrhash);
    if (edgeTable == NULL) return(CUDD_OUT_OF_MEM);

    /* Check the BDD/ADD subtables. */
    for (i = 0; i < (unsigned) table->size; i++) {
	index = table->invperm[i];
	if (i != (unsigned) table->perm[index]) {
	    (void) fprintf(table->err,
			   "Permutation corrupted: invperm[%u] = %d\t perm[%d] = %d\n",
			   i, index, index, table->perm[index]);
	}
	nodelist = table->subtables[i].nodelist;
	slots = table->subtables[i].slots;
	shift = table->subtables[i].shift;

	totalNode = 0;
	deadNode = 0;
	for (j = 0; j < slots; j++) {	/* for each subtable slot */
	    f = nodelist[j];
	    while (f != sentinel) {
		totalNode++;
		if (cuddT(f) != NULL && cuddE(f) != NULL && f->ref != 0) {
		    if ((int) f->index != index) {
			(void) fprintf(table->err,
				       "Error: node has illegal index\n");
			cuddPrintNode(f,table->err);
			flag = 1;
		    }
		    if ((unsigned) cuddI(table,cuddT(f)->index) <= i ||
			(unsigned) cuddI(table,Cudd_Regular(cuddE(f))->index)
			<= i) {
			(void) fprintf(table->err,
				       "Error: node has illegal children\n");
			cuddPrintNode(f,table->err);
			flag = 1;
		    }
		    if (Cudd_Regular(cuddT(f)) != cuddT(f)) {
			(void) fprintf(table->err,
				       "Error: node has illegal form\n");
			cuddPrintNode(f,table->err);
			flag = 1;
		    }
		    if (cuddT(f) == cuddE(f)) {
			(void) fprintf(table->err,
				       "Error: node has identical children\n");
			cuddPrintNode(f,table->err);
			flag = 1;
		    }
		    if (cuddT(f)->ref == 0 || Cudd_Regular(cuddE(f))->ref == 0) {
			(void) fprintf(table->err,
				       "Error: live node has dead children\n");
			cuddPrintNode(f,table->err);
			flag =1;
		    }
                    if (ddHash(cuddT(f),cuddE(f),shift) != (unsigned) j) {
                        (void) fprintf(table->err, "Error: misplaced node\n");
			cuddPrintNode(f,table->err);
			flag =1;
                    }
		    /* Increment the internal reference count for the
		    ** then child of the current node.
		    */
		    if (st_lookup_int(edgeTable,cuddT(f),&count)) {
			count++;
		    } else {
			count = 1;
		    }
		    if (st_insert(edgeTable,cuddT(f),
		    (void *)(ptruint)count) == ST_OUT_OF_MEM) {
			st_free_table(edgeTable);
			return(CUDD_OUT_OF_MEM);
		    }

		    /* Increment the internal reference count for the
		    ** else child of the current node.
		    */
		    if (st_lookup_int(edgeTable,Cudd_Regular(cuddE(f)),
				      &count)) {
			count++;
		    } else {
			count = 1;
		    }
		    if (st_insert(edgeTable,Cudd_Regular(cuddE(f)),
		    (void *)(ptruint)count) == ST_OUT_OF_MEM) {
			st_free_table(edgeTable);
			return(CUDD_OUT_OF_MEM);
		    }
		} else if (cuddT(f) != NULL && cuddE(f) != NULL && f->ref == 0) {
		    deadNode++;
#if 0
		    debugCheckParent(table,f);
#endif
		} else {
		    fprintf(table->err,
			    "Error: node has illegal Then or Else pointers\n");
		    cuddPrintNode(f,table->err);
		    flag = 1;
		}

		f = f->next;
	    }	/* for each element of the collision list */
	}	/* for each subtable slot */

	if ((unsigned) totalNode != table->subtables[i].keys) {
	    fprintf(table->err,"Error: wrong number of total nodes\n");
	    flag = 1;
	}
	if ((unsigned) deadNode != table->subtables[i].dead) {
	    fprintf(table->err,"Error: wrong number of dead nodes\n");
	    flag = 1;
	}
    }	/* for each BDD/ADD subtable */

    /* Check the ZDD subtables. */
    for (i = 0; i < (unsigned) table->sizeZ; i++) {
	index = table->invpermZ[i];
	if (i != (unsigned) table->permZ[index]) {
	    (void) fprintf(table->err,
			   "Permutation corrupted: invpermZ[%u] = %d\t permZ[%d] = %d in ZDD\n",
			   i, index, index, table->permZ[index]);
	}
	nodelist = table->subtableZ[i].nodelist;
	slots = table->subtableZ[i].slots;

	totalNode = 0;
	deadNode = 0;
	for (j = 0; j < slots; j++) {	/* for each subtable slot */
	    f = nodelist[j];
	    while (f != NULL) {
		totalNode++;
		if (cuddT(f) != NULL && cuddE(f) != NULL && f->ref != 0) {
		    if ((int) f->index != index) {
			(void) fprintf(table->err,
				       "Error: ZDD node has illegal index\n");
			cuddPrintNode(f,table->err);
			flag = 1;
		    }
		    if (Cudd_IsComplement(cuddT(f)) ||
			Cudd_IsComplement(cuddE(f))) {
			(void) fprintf(table->err,
				       "Error: ZDD node has complemented children\n");
			cuddPrintNode(f,table->err);
			flag = 1;
		    }
		    if ((unsigned) cuddIZ(table,cuddT(f)->index) <= i ||
		    (unsigned) cuddIZ(table,cuddE(f)->index) <= i) {
			(void) fprintf(table->err,
				       "Error: ZDD node has illegal children\n");
			cuddPrintNode(f,table->err);
			cuddPrintNode(cuddT(f),table->err);
			cuddPrintNode(cuddE(f),table->err);
			flag = 1;
		    }
		    if (cuddT(f) == DD_ZERO(table)) {
			(void) fprintf(table->err,
				       "Error: ZDD node has zero then child\n");
			cuddPrintNode(f,table->err);
			flag = 1;
		    }
		    if (cuddT(f)->ref == 0 || cuddE(f)->ref == 0) {
			(void) fprintf(table->err,
				       "Error: ZDD live node has dead children\n");
			cuddPrintNode(f,table->err);
			flag =1;
		    }
		    /* Increment the internal reference count for the
		    ** then child of the current node.
		    */
		    if (st_lookup_int(edgeTable,cuddT(f),&count)) {
			count++;
		    } else {
			count = 1;
		    }
		    if (st_insert(edgeTable,cuddT(f),
		    (void *)(ptruint)count) == ST_OUT_OF_MEM) {
			st_free_table(edgeTable);
			return(CUDD_OUT_OF_MEM);
		    }

		    /* Increment the internal reference count for the
		    ** else child of the current node.
		    */
		    if (st_lookup_int(edgeTable,cuddE(f),&count)) {
			count++;
		    } else {
			count = 1;
		    }
		    if (st_insert(edgeTable,cuddE(f),
		    (void *)(ptruint)count) == ST_OUT_OF_MEM) {
			st_free_table(edgeTable);
			table->errorCode = CUDD_MEMORY_OUT;
			return(CUDD_OUT_OF_MEM);
		    }
		} else if (cuddT(f) != NULL && cuddE(f) != NULL && f->ref == 0) {
		    deadNode++;
#if 0
		    debugCheckParent(table,f);
#endif
		} else {
		    fprintf(table->err,
			    "Error: ZDD node has illegal Then or Else pointers\n");
		    cuddPrintNode(f,table->err);
		    flag = 1;
		}

		f = f->next;
	    }	/* for each element of the collision list */
	}	/* for each subtable slot */

	if ((unsigned) totalNode != table->subtableZ[i].keys) {
	    fprintf(table->err,
		    "Error: wrong number of total nodes in ZDD\n");
	    flag = 1;
	}
	if ((unsigned) deadNode != table->subtableZ[i].dead) {
	    fprintf(table->err,
		    "Error: wrong number of dead nodes in ZDD\n");
	    flag = 1;
	}
    }	/* for each ZDD subtable */

    /* Check the constant table. */
    nodelist = table->constants.nodelist;
    slots = table->constants.slots;

    totalNode = 0;
    deadNode = 0;
    for (j = 0; j < slots; j++) {
	f = nodelist[j];
	while (f != NULL) {
	    totalNode++;
	    if (f->ref != 0) {
		if (f->index != CUDD_CONST_INDEX) {
		    fprintf(table->err,"Error: node has illegal index\n");
		    fprintf(table->err,
			    "       node 0x%" PRIxPTR ", id = %u, ref = %u, value = %g\n",
			    (ptruint)f,f->index,f->ref,cuddV(f));
		    flag = 1;
		}
	    } else {
		deadNode++;
	    }
	    f = f->next;
	}
    }
    if ((unsigned) totalNode != table->constants.keys) {
	(void) fprintf(table->err,
		       "Error: wrong number of total nodes in constants\n");
	flag = 1;
    }
    if ((unsigned) deadNode != table->constants.dead) {
	(void) fprintf(table->err,
		       "Error: wrong number of dead nodes in constants\n");
	flag = 1;
    }
    gen = st_init_gen(edgeTable);
    while (st_gen_int(gen, (void **) &f, &count)) {
	if (count > (int)(f->ref) && f->ref != DD_MAXREF) {
	    fprintf(table->err,"ref count error at node 0x%" PRIxPTR ", count = %d, id = %u, ref = %u, then = 0x%" PRIxPTR ", else = 0x%" PRIxPTR "\n",
                (ptruint)f,count,f->index,f->ref,(ptruint)cuddT(f),(ptruint)cuddE(f));
	    debugFindParent(table,f);
	    flag = 1;
	}
    }
    st_free_gen(gen);
    st_free_table(edgeTable);

    return (flag);

} /* end of Cudd_DebugCheck */


/**
  @brief Checks for several conditions that should not occur.

  @details Checks for the following conditions:
  <ul>
  <li>Wrong sizes of subtables.
  <li>Wrong number of keys found in unique subtable.
  <li>Wrong number of dead found in unique subtable.
  <li>Wrong number of keys found in the constant table
  <li>Wrong number of dead found in the constant table
  <li>Wrong number of total slots found
  <li>Wrong number of maximum keys found
  <li>Wrong number of total dead found
  </ul>
  Reports the average length of non-empty lists.

  @return the number of subtables for which the number of keys is
  wrong.

  @sideeffect None

  @see Cudd_DebugCheck

*/
int
Cudd_CheckKeys(
  DdManager * table)
{
    int size;
    int i,j;
    DdNodePtr *nodelist;
    DdNode *node;
    DdNode *sentinel = &(table->sentinel);
    DdSubtable *subtable;
    int keys;
    int dead;
    int count = 0;
    int totalKeys = 0;
    int totalSlots = 0;
    int totalDead = 0;
    int nonEmpty = 0;
    unsigned int slots;
    int logSlots;
    int shift;

    size = table->size;

    for (i = 0; i < size; i++) {
	subtable = &(table->subtables[i]);
	nodelist = subtable->nodelist;
	keys = subtable->keys;
	dead = subtable->dead;
	totalKeys += keys;
	slots = subtable->slots;
	shift = subtable->shift;
	logSlots = sizeof(int) * 8 - shift;
	if (((slots >> logSlots) << logSlots) != slots) {
	    (void) fprintf(table->err,
			   "Unique table %d is not the right power of 2\n", i);
	    (void) fprintf(table->err,
			   "    slots = %u shift = %d\n", slots, shift);
	}
	totalSlots += slots;
	totalDead += dead;
	for (j = 0; (unsigned) j < slots; j++) {
	    node = nodelist[j];
	    if (node != sentinel) {
		nonEmpty++;
	    }
	    while (node != sentinel) {
		keys--;
		if (node->ref == 0) {
		    dead--;
		}
		node = node->next;
	    }
	}
	if (keys != 0) {
	    (void) fprintf(table->err, "Wrong number of keys found \
in unique table %d (difference=%d)\n", i, keys);
	    count++;
	}
	if (dead != 0) {
	    (void) fprintf(table->err, "Wrong number of dead found \
in unique table no. %d (difference=%d)\n", i, dead);
	}
    }	/* for each BDD/ADD subtable */

    /* Check the ZDD subtables. */
    size = table->sizeZ;

    for (i = 0; i < size; i++) {
	subtable = &(table->subtableZ[i]);
	nodelist = subtable->nodelist;
	keys = subtable->keys;
	dead = subtable->dead;
	totalKeys += keys;
	totalSlots += subtable->slots;
	totalDead += dead;
	for (j = 0; (unsigned) j < subtable->slots; j++) {
	    node = nodelist[j];
	    if (node != NULL) {
		nonEmpty++;
	    }
	    while (node != NULL) {
		keys--;
		if (node->ref == 0) {
		    dead--;
		}
		node = node->next;
	    }
	}
	if (keys != 0) {
	    (void) fprintf(table->err, "Wrong number of keys found \
in ZDD unique table no. %d (difference=%d)\n", i, keys);
	    count++;
	}
	if (dead != 0) {
	    (void) fprintf(table->err, "Wrong number of dead found \
in ZDD unique table no. %d (difference=%d)\n", i, dead);
	}
    }	/* for each ZDD subtable */

    /* Check the constant table. */
    subtable = &(table->constants);
    nodelist = subtable->nodelist;
    keys = subtable->keys;
    dead = subtable->dead;
    totalKeys += keys;
    totalSlots += subtable->slots;
    totalDead += dead;
    for (j = 0; (unsigned) j < subtable->slots; j++) {
	node = nodelist[j];
	if (node != NULL) {
	    nonEmpty++;
	}
	while (node != NULL) {
	    keys--;
	    if (node->ref == 0) {
		dead--;
	    }
	    node = node->next;
	}
    }
    if (keys != 0) {
	(void) fprintf(table->err, "Wrong number of keys found \
in the constant table (difference=%d)\n", keys);
	count++;
    }
    if (dead != 0) {
	(void) fprintf(table->err, "Wrong number of dead found \
in the constant table (difference=%d)\n", dead);
    }
    if ((unsigned) totalKeys != table->keys + table->keysZ) {
	(void) fprintf(table->err, "Wrong number of total keys found \
(difference=%d)\n", (int) (totalKeys-table->keys));
    }
    if ((unsigned) totalSlots != table->slots) {
	(void) fprintf(table->err, "Wrong number of total slots found \
(difference=%d)\n", (int) (totalSlots-table->slots));
    }
    if (table->minDead != (unsigned) (table->gcFrac * table->slots)) {
	(void) fprintf(table->err, "Wrong number of minimum dead found \
(%u vs. %u)\n", table->minDead,
	(unsigned) (table->gcFrac * (double) table->slots));
    }
    if ((unsigned) totalDead != table->dead + table->deadZ) {
	(void) fprintf(table->err, "Wrong number of total dead found \
(difference=%d)\n", (int) (totalDead-table->dead));
    }
    (void) fprintf(table->out,"Average length of non-empty lists = %g\n",
                   (double) table->keys / (double) nonEmpty);

    return(count);

} /* end of Cudd_CheckKeys */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints information about the heap.

  @details Prints to the manager's stdout the number of live nodes for each
  level of the %DD heap that contains at least one live node.  It also
  prints a summary containing:
  <ul>
  <li> total number of tables;
  <li> number of tables with live nodes;
  <li> table with the largest number of live nodes;
  <li> number of nodes in that table.
  </ul>
  If more than one table contains the maximum number of live nodes,
  only the one of lowest index is reported.

  @return 1 in case of success and 0 otherwise.

  @sideeffect None

*/
int
cuddHeapProfile(
  DdManager * dd)
{
    int ntables = dd->size;
    DdSubtable *subtables = dd->subtables;
    int i,		/* loop index */
	nodes,		/* live nodes in i-th layer */
	retval,		/* return value of fprintf */
	largest = -1,	/* index of the table with most live nodes */
	maxnodes = -1,	/* maximum number of live nodes in a table */
	nonempty = 0;	/* number of tables with live nodes */

    /* Print header. */
    retval = fprintf(dd->out,"*** DD heap profile for 0x%" PRIxPTR " ***\n",
		     (ptruint) dd);
    if (retval == EOF) return 0;

    /* Print number of live nodes for each nonempty table. */
    for (i=0; i<ntables; i++) {
	nodes = subtables[i].keys - subtables[i].dead;
	if (nodes) {
	    nonempty++;
	    retval = fprintf(dd->out,"%5d: %5d nodes\n", i, nodes);
	    if (retval == EOF) return 0;
	    if (nodes > maxnodes) {
		maxnodes = nodes;
		largest = i;
	    }
	}
    }

    nodes = dd->constants.keys - dd->constants.dead;
    if (nodes) {
	nonempty++;
	retval = fprintf(dd->out,"const: %5d nodes\n", nodes);
	if (retval == EOF) return 0;
	if (nodes > maxnodes) {
	    maxnodes = nodes;
	    largest = CUDD_CONST_INDEX;
	}
    }

    /* Print summary. */
    retval = fprintf(dd->out,"Summary: %d tables, %d non-empty, largest: %d ",
	  ntables+1, nonempty, largest);
    if (retval == EOF) return 0;
    retval = fprintf(dd->out,"(with %d nodes)\n", maxnodes);
    if (retval == EOF) return 0;

    return(1);

} /* end of cuddHeapProfile */


/**
  @brief Prints out information on a node.

  @sideeffect None

*/
void
cuddPrintNode(
  DdNode * f,
  FILE *fp)
{
    f = Cudd_Regular(f);
    (void) fprintf(fp,"       node 0x%" PRIxPTR ", id = %u, ref = %u, then = 0x%" PRIxPTR ", else = 0x%" PRIxPTR "\n",
        (ptruint)f,f->index,f->ref,(ptruint)cuddT(f),(ptruint)cuddE(f));

} /* end of cuddPrintNode */


/**
  @brief Prints the variable groups as a parenthesized list.

  @details   For each group the level range that it represents is printed.
  After each group, the group's flags are printed, preceded by a `|'.  For
  each flag (except MTR_TERMINAL) a character is printed.
  <ul>
  <li>F: MTR_FIXED
  <li>N: MTR_NEWNODE
  <li>S: MTR_SOFT
  </ul>
  The second argument, silent, if different from 0, causes
  Cudd_PrintVarGroups to only check the syntax of the group tree.

  @sideeffect None

*/
void
cuddPrintVarGroups(
  DdManager * dd /**< manager */,
  MtrNode * root /**< root of the group tree */,
  int zdd /**< 0: %BDD; 1: %ZDD */,
  int silent /**< flag to check tree syntax only */)
{
    MtrNode *node;
    int level;

    assert(root != NULL);
    assert(root->younger == NULL || root->younger->elder == root);
    assert(root->elder == NULL || root->elder->younger == root);
    if (zdd) {
	level = dd->permZ[root->index];
    } else {
	level = dd->perm[root->index];
    }
    if (!silent) (void) printf("(%d",level);
    if (MTR_TEST(root,MTR_TERMINAL) || root->child == NULL) {
	if (!silent) (void) printf(",");
    } else {
	node = root->child;
	while (node != NULL) {
	    assert(node->low >= root->low && (int) (node->low + node->size) <= (int) (root->low + root->size));
	    assert(node->parent == root);
	    cuddPrintVarGroups(dd,node,zdd,silent);
	    node = node->younger;
	}
    }
    if (!silent) {
	(void) printf("%d", (int) (level + root->size - 1));
	if (root->flags != MTR_DEFAULT) {
	    (void) printf("|");
	    if (MTR_TEST(root,MTR_FIXED)) (void) printf("F");
	    if (MTR_TEST(root,MTR_NEWNODE)) (void) printf("N");
	    if (MTR_TEST(root,MTR_SOFT)) (void) printf("S");
	}
	(void) printf(")");
	if (root->parent == NULL) (void) printf("\n");
    }
    assert((root->flags &~(MTR_TERMINAL | MTR_SOFT | MTR_FIXED | MTR_NEWNODE)) == 0);
    return;

} /* end of cuddPrintVarGroups */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Searches the subtables above node for its parents.

  @sideeffect None

*/
static void
debugFindParent(
  DdManager * table,
  DdNode * node)
{
    int         i,j;
    int		slots;
    DdNodePtr	*nodelist;
    DdNode	*f;

    for (i = 0; i < cuddI(table,node->index); i++) {
	nodelist = table->subtables[i].nodelist;
	slots = table->subtables[i].slots;

	for (j=0;j<slots;j++) {
	    f = nodelist[j];
	    while (f != NULL) {
		if (cuddT(f) == node || Cudd_Regular(cuddE(f)) == node) {
		    (void) fprintf(table->out,"parent is at 0x%" PRIxPTR ", id = %u, ref = %u, then = 0x%" PRIxPTR ", else = 0x%" PRIxPTR "\n",
			(ptruint)f,f->index,f->ref,(ptruint)cuddT(f),(ptruint)cuddE(f));
		}
		f = f->next;
	    }
	}
    }

} /* end of debugFindParent */


#if 0
/**
  @brief Reports an error if a (dead) node has a non-dead parent.

  @details Searches all the subtables above node. Very expensive.
  The same check is now implemented more efficiently in ddDebugCheck.

  @sideeffect None

  @see debugFindParent

*/
static void
debugCheckParent(
  DdManager * table,
  DdNode * node)
{
    int         i,j;
    int		slots;
    DdNode	**nodelist,*f;

    for (i = 0; i < cuddI(table,node->index); i++) {
	nodelist = table->subtables[i].nodelist;
	slots = table->subtables[i].slots;

	for (j=0;j<slots;j++) {
	    f = nodelist[j];
	    while (f != NULL) {
		if ((Cudd_Regular(cuddE(f)) == node || cuddT(f) == node) && f->ref != 0) {
		    (void) fprintf(table->err,
				   "error with zero ref count\n");
		    (void) fprintf(table->err,"parent is 0x%x, id = %u, ref = %u, then = 0x%x, else = 0x%x\n",f,f->index,f->ref,cuddT(f),cuddE(f));
		    (void) fprintf(table->err,"child  is 0x%x, id = %u, ref = %u, then = 0x%x, else = 0x%x\n",node,node->index,node->ref,cuddT(node),cuddE(node));
		}
		f = f->next;
	    }
	}
    }
}
#endif

cuddClip.c
14546
/**
  @file

  @ingroup cudd

  @brief Clipping functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * cuddBddClippingAndRecur (DdManager *manager, DdNode *f, DdNode *g, int distance, int direction);
static DdNode * cuddBddClipAndAbsRecur (DdManager *manager, DdNode *f, DdNode *g, DdNode *cube, int distance, int direction);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Approximates the conjunction of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddAnd

*/
DdNode *
Cudd_bddClippingAnd(
  DdManager * dd /**< manager */,
  DdNode * f /**< first conjunct */,
  DdNode * g /**< second conjunct */,
  int  maxDepth /**< maximum recursion depth */,
  int  direction /**< under (0) or over (1) approximation */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddClippingAnd(dd,f,g,maxDepth,direction);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddClippingAnd */


/**
  @brief Approximates the conjunction of two BDDs f and g and
  simultaneously abstracts the variables in cube.

  @details The variables are existentially abstracted.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddAndAbstract Cudd_bddClippingAnd

*/
DdNode *
Cudd_bddClippingAndAbstract(
  DdManager * dd /**< manager */,
  DdNode * f /**< first conjunct */,
  DdNode * g /**< second conjunct */,
  DdNode * cube /**< cube of variables to be abstracted */,
  int  maxDepth /**< maximum recursion depth */,
  int  direction /**< under (0) or over (1) approximation */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddClippingAndAbstract(dd,f,g,cube,maxDepth,direction);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddClippingAndAbstract */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Approximates the conjunction of two BDDs f and g.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddClippingAnd

*/
DdNode *
cuddBddClippingAnd(
  DdManager * dd /**< manager */,
  DdNode * f /**< first conjunct */,
  DdNode * g /**< second conjunct */,
  int  maxDepth /**< maximum recursion depth */,
  int  direction /**< under (0) or over (1) approximation */)
{
    DdNode *res;

    res = cuddBddClippingAndRecur(dd,f,g,maxDepth,direction);

    return(res);

} /* end of cuddBddClippingAnd */


/**
  @brief Approximates the conjunction of two BDDs f and g and
  simultaneously abstracts the variables in cube.

  @return a pointer to the resulting %BDD if successful; NULL if the
  intermediate result blows up.

  @sideeffect None

  @see Cudd_bddClippingAndAbstract

*/
DdNode *
cuddBddClippingAndAbstract(
  DdManager * dd /**< manager */,
  DdNode * f /**< first conjunct */,
  DdNode * g /**< second conjunct */,
  DdNode * cube /**< cube of variables to be abstracted */,
  int  maxDepth /**< maximum recursion depth */,
  int  direction /**< under (0) or over (1) approximation */)
{
    DdNode *res;

    res = cuddBddClipAndAbsRecur(dd,f,g,cube,maxDepth,direction);

    return(res);

} /* end of cuddBddClippingAndAbstract */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_bddClippingAnd.

  @details Takes the conjunction of two BDDs.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see cuddBddClippingAnd

*/
static DdNode *
cuddBddClippingAndRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  int  distance,
  int  direction)
{
    DdNode *F, *ft, *fe, *G, *gt, *ge;
    DdNode *one, *zero, *r, *t, *e;
    int topf, topg;
    unsigned int index;
    DD_CTFP cacheOp;

    statLine(manager);
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* Terminal cases. */
    if (f == zero || g == zero || f == Cudd_Not(g)) return(zero);
    if (f == g || g == one) return(f);
    if (f == one) return(g);
    if (distance == 0) {
	/* One last attempt at returning the right result. We sort of
	** cheat by calling Cudd_bddLeq. */
	if (Cudd_bddLeq(manager,f,g)) return(f);
	if (Cudd_bddLeq(manager,g,f)) return(g);
	if (direction == 1) {
	    if (Cudd_bddLeq(manager,f,Cudd_Not(g)) ||
		Cudd_bddLeq(manager,g,Cudd_Not(f))) return(zero);
	}
	return(Cudd_NotCond(one,(direction == 0)));
    }

    /* At this point f and g are not constant. */
    distance--;

    /* Check cache. Try to increase cache efficiency by sorting the
    ** pointers. */
    if (f > g) {
	DdNode *tmp = f;
	f = g; g = tmp;
    }
    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    cacheOp = (DD_CTFP)
	(direction ? Cudd_bddClippingAnd : cuddBddClippingAnd);
    if (F->ref != 1 || G->ref != 1) {
	r = cuddCacheLookup2(manager, cacheOp, f, g);
	if (r != NULL) return(r);
    }

    checkWhetherToGiveUp(manager);

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    topf = manager->perm[F->index];
    topg = manager->perm[G->index];

    /* Compute cofactors. */
    if (topf <= topg) {
	index = F->index;
	ft = cuddT(F);
	fe = cuddE(F);
	if (Cudd_IsComplement(f)) {
	    ft = Cudd_Not(ft);
	    fe = Cudd_Not(fe);
	}
    } else {
	index = G->index;
	ft = fe = f;
    }

    if (topg <= topf) {
	gt = cuddT(G);
	ge = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gt = Cudd_Not(gt);
	    ge = Cudd_Not(ge);
	}
    } else {
	gt = ge = g;
    }

    t = cuddBddClippingAndRecur(manager, ft, gt, distance, direction);
    if (t == NULL) return(NULL);
    cuddRef(t);
    e = cuddBddClippingAndRecur(manager, fe, ge, distance, direction);
    if (e == NULL) {
	Cudd_RecursiveDeref(manager, t);
	return(NULL);
    }
    cuddRef(e);

    if (t == e) {
	r = t;
    } else {
	if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(manager,(int)index,Cudd_Not(t),Cudd_Not(e));
	    if (r == NULL) {
		Cudd_RecursiveDeref(manager, t);
		Cudd_RecursiveDeref(manager, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(manager,(int)index,t,e);
	    if (r == NULL) {
		Cudd_RecursiveDeref(manager, t);
		Cudd_RecursiveDeref(manager, e);
		return(NULL);
	    }
	}
    }
    cuddDeref(e);
    cuddDeref(t);
    if (F->ref != 1 || G->ref != 1)
	cuddCacheInsert2(manager, cacheOp, f, g, r);
    return(r);

} /* end of cuddBddClippingAndRecur */


/**
  @brief Approximates the AND of two BDDs and simultaneously abstracts the
  variables in cube.

  @details The variables are existentially abstracted.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddClippingAndAbstract

*/
static DdNode *
cuddBddClipAndAbsRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * g,
  DdNode * cube,
  int  distance,
  int  direction)
{
    DdNode *F, *ft, *fe, *G, *gt, *ge;
    DdNode *one, *zero, *r, *t, *e, *Cube;
    int topf, topg, topcube, top;
    unsigned int index;
    ptruint cacheTag;

    statLine(manager);
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* Terminal cases. */
    if (f == zero || g == zero || f == Cudd_Not(g)) return(zero);
    if (f == one && g == one)	return(one);
    if (cube == one) {
	return(cuddBddClippingAndRecur(manager, f, g, distance, direction));
    }
    if (f == one || f == g) {
	return (cuddBddExistAbstractRecur(manager, g, cube));
    }
    if (g == one) {
	return (cuddBddExistAbstractRecur(manager, f, cube));
    }
    if (distance == 0) return(Cudd_NotCond(one,(direction == 0)));

    /* At this point f, g, and cube are not constant. */
    distance--;

    /* Check cache. */
    if (f > g) { /* Try to increase cache efficiency. */
	DdNode *tmp = f;
	f = g; g = tmp;
    }
    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    cacheTag = direction ? DD_BDD_CLIPPING_AND_ABSTRACT_UP_TAG :
	DD_BDD_CLIPPING_AND_ABSTRACT_DOWN_TAG;
    if (F->ref != 1 || G->ref != 1) {
	r = cuddCacheLookup(manager, cacheTag,
			    f, g, cube);
	if (r != NULL) {
	    return(r);
	}
    }

    checkWhetherToGiveUp(manager);

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    topf = manager->perm[F->index];
    topg = manager->perm[G->index];
    top = ddMin(topf, topg);
    topcube = manager->perm[cube->index];

    if (topcube < top) {
	return(cuddBddClipAndAbsRecur(manager, f, g, cuddT(cube),
				      distance, direction));
    }
    /* Now, topcube >= top. */

    if (topf == top) {
	index = F->index;
	ft = cuddT(F);
	fe = cuddE(F);
	if (Cudd_IsComplement(f)) {
	    ft = Cudd_Not(ft);
	    fe = Cudd_Not(fe);
	}
    } else {
	index = G->index;
	ft = fe = f;
    }

    if (topg == top) {
	gt = cuddT(G);
	ge = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gt = Cudd_Not(gt);
	    ge = Cudd_Not(ge);
	}
    } else {
	gt = ge = g;
    }

    if (topcube == top) {
	Cube = cuddT(cube);
    } else {
	Cube = cube;
    }

    t = cuddBddClipAndAbsRecur(manager, ft, gt, Cube, distance, direction);
    if (t == NULL) return(NULL);

    /* Special case: 1 OR anything = 1. Hence, no need to compute
    ** the else branch if t is 1.
    */
    if (t == one && topcube == top) {
	if (F->ref != 1 || G->ref != 1)
	    cuddCacheInsert(manager, cacheTag, f, g, cube, one);
	return(one);
    }
    cuddRef(t);

    e = cuddBddClipAndAbsRecur(manager, fe, ge, Cube, distance, direction);
    if (e == NULL) {
	Cudd_RecursiveDeref(manager, t);
	return(NULL);
    }
    cuddRef(e);

    if (topcube == top) {	/* abstract */
	r = cuddBddClippingAndRecur(manager, Cudd_Not(t), Cudd_Not(e),
				    distance, (direction == 0));
	if (r == NULL) {
	    Cudd_RecursiveDeref(manager, t);
	    Cudd_RecursiveDeref(manager, e);
	    return(NULL);
	}
	r = Cudd_Not(r);
	cuddRef(r);
	Cudd_RecursiveDeref(manager, t);
	Cudd_RecursiveDeref(manager, e);
	cuddDeref(r);
    } else if (t == e) {
	r = t;
	cuddDeref(t);
	cuddDeref(e);
    } else {
	if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(manager,(int)index,Cudd_Not(t),Cudd_Not(e));
	    if (r == NULL) {
		Cudd_RecursiveDeref(manager, t);
		Cudd_RecursiveDeref(manager, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(manager,(int)index,t,e);
	    if (r == NULL) {
		Cudd_RecursiveDeref(manager, t);
		Cudd_RecursiveDeref(manager, e);
		return(NULL);
	    }
	}
	cuddDeref(e);
	cuddDeref(t);
    }
    if (F->ref != 1 || G->ref != 1)
	cuddCacheInsert(manager, cacheTag, f, g, cube, r);
    return (r);

} /* end of cuddBddClipAndAbsRecur */


cuddCof.c
14050
/**
  @file

  @ingroup cudd

  @brief Cofactoring functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int ddVarsAreSymmetricBefore(DdManager * dd, DdNode * f, DdNode * var1, DdNode * var2);
static int ddVarsAreSymmetricBetween(DdManager * dd, DdNode * f1, DdNode * f0, DdNode * var2);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes the cofactor of f with respect to g.

  @details g must be the %BDD or the %ADD of a cube.

  @return a pointer to the cofactor if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddConstrain Cudd_bddRestrict

*/
DdNode *
Cudd_Cofactor(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *res,*zero;

    zero = Cudd_Not(DD_ONE(dd));
    if (g == zero || g == DD_ZERO(dd)) {
	(void) fprintf(dd->err,"Cudd_Cofactor: Invalid restriction 1\n");
	dd->errorCode = CUDD_INVALID_ARG;
	return(NULL);
    }
    do {
	dd->reordered = 0;
	res = cuddCofactorRecur(dd,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_Cofactor */


/**
  @brief Checks whether g is the %BDD of a cube.

  @details The constant 1 is a valid cube, but all other constant
  functions cause cuddCheckCube to return 0.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
Cudd_CheckCube(
  DdManager * dd,
  DdNode * g)
{
    DdNode *g1,*g0,*one,*zero;
    
    one = DD_ONE(dd);
    if (g == one) return(1);
    if (Cudd_Not(g) == one) return(0);

    zero = Cudd_Not(one);
    cuddGetBranches(g,&g1,&g0);

    if (g0 == zero) {
        return(Cudd_CheckCube(dd, g1));
    }
    if (g1 == zero) {
        return(Cudd_CheckCube(dd, g0));
    }
    return(0);

} /* end of Cudd_CheckCube */


/**
   @brief Checks whether two variables are symmetric in a BDD.

   @return 1 if the variables are symmetric; 0 if they are not.

   @details No nodes are built during the check.

   @sideeffect None
*/
int
Cudd_VarsAreSymmetric(
  DdManager * dd /**< manager */,
  DdNode * f /**< BDD whose variables are tested */,
  int index1 /**< index of first variable */,
  int index2 /**< index of second variable */)
{
    DdNode *var1, *var2;

    if (index1 == index2) /* trivial case: symmetry is reflexive */
        return(1);

    if (index1 >= dd->size) {
        if (index2 >= dd->size) {
            return(1); /* f depends on neither variable */
        } else {
            /* f does not depend on var1; check whether it depends on var2 */
            var2 = dd->vars[index2];
            return ddVarsAreSymmetricBetween(dd, f, f, var2);
        }
    } else if (index2 >= dd->size) {
        /* f does not depend on var2; check whether it depends on var1 */
        var1 = dd->vars[index1];
        return  ddVarsAreSymmetricBetween(dd, f, f, var1);
    }

    /* Make sure index1 denotes the variable currently closer to the root. */
    if (dd->perm[index1] < dd->perm[index2]) {
        var1 = dd->vars[index1];
        var2 = dd->vars[index2];
    } else {
        var1 = dd->vars[index2];
        var2 = dd->vars[index1];
    }

    return ddVarsAreSymmetricBefore(dd, f, var1, var2);

} /* end of Cudd_VarsAreSymmetric */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes the children of g.

  @sideeffect None

*/
void
cuddGetBranches(
  DdNode * g,
  DdNode ** g1,
  DdNode ** g0)
{
    DdNode	*G = Cudd_Regular(g);

    *g1 = cuddT(G);
    *g0 = cuddE(G);
    if (Cudd_IsComplement(g)) {
	*g1 = Cudd_Not(*g1);
	*g0 = Cudd_Not(*g0);
    }

} /* end of cuddGetBranches */


/**
  @brief Performs the recursive step of Cudd_Cofactor.

  @return a pointer to the cofactor if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_Cofactor

*/
DdNode *
cuddCofactorRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *one,*zero,*F,*G,*g1,*g0,*f1,*f0,*t,*e,*r;
    int topf,topg;
    int comple;

    statLine(dd);
    F = Cudd_Regular(f);
    if (cuddIsConstant(F)) return(f);

    one = DD_ONE(dd);

    /* The invariant g != 0 is true on entry to this procedure and is
    ** recursively maintained by it. Therefore it suffices to test g
    ** against one to make sure it is not constant.
    */
    if (g == one) return(f);
    /* From now on, f and g are known not to be constants. */

    comple = f != F;
    r = cuddCacheLookup2(dd,Cudd_Cofactor,F,g);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple));
    }

    checkWhetherToGiveUp(dd);

    topf = dd->perm[F->index];
    G = Cudd_Regular(g);
    topg = dd->perm[G->index];

    /* We take the cofactors of F because we are going to rely on
    ** the fact that the cofactors of the complement are the complements
    ** of the cofactors to better utilize the cache. Variable comple
    ** remembers whether we have to complement the result or not.
    */
    if (topf <= topg) {
	f1 = cuddT(F); f0 = cuddE(F);
    } else {
	f1 = f0 = F;
    }
    if (topg <= topf) {
	g1 = cuddT(G); g0 = cuddE(G);
	if (g != G) { g1 = Cudd_Not(g1); g0 = Cudd_Not(g0); }
    } else {
	g1 = g0 = g;
    }

    zero = Cudd_Not(one);
    if (topf >= topg) {
	if (g0 == zero || g0 == DD_ZERO(dd)) {
	    r = cuddCofactorRecur(dd, f1, g1);
	} else if (g1 == zero || g1 == DD_ZERO(dd)) {
	    r = cuddCofactorRecur(dd, f0, g0);
	} else {
	    (void) fprintf(dd->err,
			   "Cudd_Cofactor: Invalid restriction 2\n");
	    dd->errorCode = CUDD_INVALID_ARG;
	    return(NULL);
	}
	if (r == NULL) return(NULL);
    } else /* if (topf < topg) */ {
	t = cuddCofactorRecur(dd, f1, g);
	if (t == NULL) return(NULL);
    	cuddRef(t);
    	e = cuddCofactorRecur(dd, f0, g);
	if (e == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
	cuddRef(e);

	if (t == e) {
	    r = t;
	} else if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(dd,(int)F->index,Cudd_Not(t),Cudd_Not(e));
	    if (r != NULL)
		r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(dd,(int)F->index,t,e);
	}
	if (r == NULL) {
	    Cudd_RecursiveDeref(dd ,e);
	    Cudd_RecursiveDeref(dd ,t);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert2(dd,Cudd_Cofactor,F,g,r);

    return(Cudd_NotCond(r,comple));

} /* end of cuddCofactorRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
   @brief Implements the upper recursive step of Cudd_VarsAreSymmetric().

   @details The assumption is made that the level of index1 is less
   than the level of index2.

   @return 1 if the variables are symmetric for the given function;
   0 if they are not.

   @see Cudd_VarsAreSymmetric ddVarsAreSymmetricBetween

*/
static int
ddVarsAreSymmetricBefore(
  DdManager * dd,
  DdNode * f,
  DdNode * var1,
  DdNode * var2)
{
    DdNode *F, *ft, *fe, *r;
    int top, res, level1;

    statLine(dd);
    F = Cudd_Regular(f);
    if (cuddIsConstant(F)) /* f depends on neither variable */
        return(1);
    top = dd->perm[F->index];
    if (top > dd->perm[var2->index])
        return(1); /* f depends on neither variable */
    /* Cache lookup.  We take advantage of the observation that
     * var1 and var2 are symmetric in f iff they are symmetric in
     * the complement of f. */
    r = cuddCacheLookup(dd, DD_VARS_SYMM_BEFORE_TAG, F, var1, var2);
    if (r != NULL) {
        return(r == DD_ONE(dd) ? 1 : 0);
    }
    level1 = dd->perm[var1->index];
    if (top > level1)
        /* Check whether f1 depends on the variable currently at level2. */
        return ddVarsAreSymmetricBetween(dd, f, f, var2);
    ft = cuddT(F);
    fe = cuddE(F);
    if (F != f) {
        ft = Cudd_Not(ft);
        fe = Cudd_Not(fe);
    }
    if (top < level1) {
        res = ddVarsAreSymmetricBefore(dd, ft, var1, var2);
        if (res)
            res = ddVarsAreSymmetricBefore(dd, fe, var1, var2);
    } else {
        res = ddVarsAreSymmetricBetween(dd, ft, fe, var2);
    }
    /* Cache insertion. */
    cuddCacheInsert(dd, DD_VARS_SYMM_BEFORE_TAG, F, var1, var2,
                    res ? DD_ONE(dd) : Cudd_Not(DD_ONE(dd)));
    return(res);

} /* end of ddVarsAreSymmetricBefore */


/**
   @brief Implements the lower recursive step of Cudd_VarsAreSymmetric().

   @return 1 if the negative cofactor of the first argument w.r.t. the variable
   currently at level2 is the same as the positive cofactor of the second
   argument; 0 if the two cofactors are not the same.

   @see Cudd_VarsAreSymmetric ddVarsAreSymmetricBefore

*/
static int
ddVarsAreSymmetricBetween(
  DdManager * dd,
  DdNode * f1,
  DdNode * f0,
  DdNode * var2)
{
    DdNode *F1, *F0, *f1t, *f1e, *f0t, *f0e, *r;
    int topf1, topf0, top, res;
    int level2 = dd->perm[var2->index];

    statLine(dd);
    F1 = Cudd_Regular(f1);
    F0 = Cudd_Regular(f0);
    if (cuddIsConstant(F1) && cuddIsConstant(F0))
        return f1 == f0;
    /* Here we know that one of f1 and f0 is not constant.  Hence the
     * least index is that of a variable. */
    if (cuddIsConstant(F1))
        topf1 = CUDD_CONST_INDEX;
    else
        topf1 = dd->perm[F1->index];
    if (cuddIsConstant(F0))
        topf0 = CUDD_CONST_INDEX;
    else
        topf0 = dd->perm[F0->index];
    if (topf0 > level2 && topf1 > level2)
        return(f1 == f0);
    /* Cache lookup. */
    r = cuddCacheLookup(dd, DD_VARS_SYMM_BETWEEN_TAG, f1, f0, var2);
    if (r != NULL) {
        return(r == DD_ONE(dd) ? 1 : 0);
    }
    /* Compute cofactors and find top level. */
    if (topf1 <= topf0) {
        top = topf1;
        f1t = cuddT(F1);
        f1e = cuddE(F1);
        if (F1 != f1) {
            f1t = Cudd_Not(f1t);
            f1e = Cudd_Not(f1e);
        }
    } else {
        top = topf0;
        f1t = f1e = f1;
    }
    if (topf0 <= topf1) {
        f0t = cuddT(F0);
        f0e = cuddE(F0);
        if (F0 != f0) {
            f0t = Cudd_Not(f0t);
            f0e = Cudd_Not(f0e);
        }
    } else {
        f0t = f0e = f0;
    }
    if (top < level2) {
        res = ddVarsAreSymmetricBetween(dd, f1t, f0t, var2);
        if (res)
            res = ddVarsAreSymmetricBetween(dd, f1e, f0e, var2);
    } else {
        assert(top == level2);
        res = f1e == f0t;
    }
    /* Cache insertion. */
    cuddCacheInsert(dd, DD_VARS_SYMM_BETWEEN_TAG, f1, f0, var2,
                    res ? DD_ONE(dd) : Cudd_Not(DD_ONE(dd)));
    return(res);

} /* end of ddVarsAreSymmetricBetween */

cuddCompose.c
44880
/**
  @file

  @ingroup cudd

  @brief Functional composition and variable permutation of DDs.

  @details The permutation functions use a local cache because the
  results to be remembered depend on the permutation being applied.
  Since the permutation is just an array, it cannot be stored in the
  global cache. There are different procedured for BDDs and ADDs. This
  is because bddPermuteRecur uses cuddBddIteRecur. If this were
  changed, the procedures could be merged.

  @author Fabio Somenzi and Kavita Ravi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * cuddAddPermuteRecur (DdManager *manager, DdHashTable *table, DdNode *node, int *permut);
static DdNode * cuddBddPermuteRecur (DdManager *manager, DdHashTable *table, DdNode *node, int *permut);
static DdNode * cuddBddVarMapRecur (DdManager *manager, DdNode *f);
static DdNode * cuddAddVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vector, int deepest);
static DdNode * cuddAddNonSimComposeRecur (DdManager *dd, DdNode *f, DdNode **vector, DdNode *key, DdNode *cube, int lastsub);
static DdNode * cuddBddVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vector, int deepest);
static int ddIsIthAddVar (DdManager *dd, DdNode *f, unsigned int i);

static DdNode * cuddAddGeneralVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vectorOn, DdNode **vectorOff, int deepest);
static int ddIsIthAddVarPair (DdManager *dd, DdNode *f, DdNode *g, unsigned int i);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Substitutes g for x_v in the %BDD for f.

  @details v is the index of the variable to be substituted.
  Cudd_bddCompose passes the corresponding projection function to the
  recursive procedure, so that the cache may be used.

  @return the composed %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addCompose

*/
DdNode *
Cudd_bddCompose(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  int  v)
{
    DdNode *proj, *res;

    /* Sanity check. */
    if (v < 0 || v >= dd->size) return(NULL);

    proj =  dd->vars[v];
    do {
	dd->reordered = 0;
	res = cuddBddComposeRecur(dd,f,g,proj);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddCompose */


/**
  @brief Substitutes g for x_v in the %ADD for f.

  @details v is the index of the variable to be substituted. g must be
  a 0-1 %ADD. Cudd_bddCompose passes the corresponding projection
  function to the recursive procedure, so that the cache may be used.

  @return the composed %ADD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddCompose

*/
DdNode *
Cudd_addCompose(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  int  v)
{
    DdNode *proj, *res;

    /* Sanity check. */
    if (v < 0 || v >= dd->size) return(NULL);

    proj =  dd->vars[v];
    do {
	dd->reordered = 0;
	res = cuddAddComposeRecur(dd,f,g,proj);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addCompose */


/**
  @brief Permutes the variables of an %ADD.

  @details Given a permutation in array permut, creates a new %ADD
  with permuted variables. There should be an entry in array permut
  for each variable in the manager. The i-th entry of permut holds the
  index of the variable that is to substitute the i-th
  variable.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_bddPermute Cudd_addSwapVariables

*/
DdNode *
Cudd_addPermute(
  DdManager * manager,
  DdNode * node,
  int * permut)
{
    DdHashTable		*table;
    DdNode		*res;

    do {
	manager->reordered = 0;
	table = cuddHashTableInit(manager,1,2);
	if (table == NULL) return(NULL);
	/* Recursively solve the problem. */
	res = cuddAddPermuteRecur(manager,table,node,permut);
	if (res != NULL) cuddRef(res);
	/* Dispose of local cache. */
	cuddHashTableQuit(table);
    } while (manager->reordered == 1);

    if (res != NULL) cuddDeref(res);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }
    return(res);

} /* end of Cudd_addPermute */


/**
  @brief Swaps two sets of variables of the same size (x and y) in
  the %ADD f.

  @details The size is given by n. The two sets of variables are
  assumed to be disjoint.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addPermute Cudd_bddSwapVariables

*/
DdNode *
Cudd_addSwapVariables(
  DdManager * dd,
  DdNode * f,
  DdNode ** x,
  DdNode ** y,
  int  n)
{
    DdNode *swapped;
    int	 i, j, k;
    int	 *permut;

    permut = ALLOC(int,dd->size);
    if (permut == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < dd->size; i++) permut[i] = i;
    for (i = 0; i < n; i++) {
	j = x[i]->index;
	k = y[i]->index;
	permut[j] = k;
	permut[k] = j;
    }

    swapped = Cudd_addPermute(dd,f,permut);
    FREE(permut);

    return(swapped);

} /* end of Cudd_addSwapVariables */


/**
  @brief Permutes the variables of a %BDD.

  @details Given a permutation in array permut, creates a new %BDD
  with permuted variables. There should be an entry in array permut
  for each variable in the manager. The i-th entry of permut holds the
  index of the variable that is to substitute the i-th variable.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addPermute Cudd_bddSwapVariables

*/
DdNode *
Cudd_bddPermute(
  DdManager * manager,
  DdNode * node,
  int * permut)
{
    DdHashTable		*table;
    DdNode		*res;

    do {
	manager->reordered = 0;
	table = cuddHashTableInit(manager,1,2);
	if (table == NULL) return(NULL);
	res = cuddBddPermuteRecur(manager,table,node,permut);
	if (res != NULL) cuddRef(res);
	/* Dispose of local cache. */
	cuddHashTableQuit(table);

    } while (manager->reordered == 1);

    if (res != NULL) cuddDeref(res);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }
    return(res);

} /* end of Cudd_bddPermute */


/**
  @brief Remaps the variables of a %BDD using the default variable map.

  @details A typical use of this function is to swap two sets of
  variables.  The variable map must be registered with Cudd_SetVarMap.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_bddPermute Cudd_bddSwapVariables Cudd_SetVarMap

*/
DdNode *
Cudd_bddVarMap(
  DdManager * manager /**< %DD manager */,
  DdNode * f /**< function in which to remap variables */)
{
    DdNode *res;

    if (manager->map == NULL) return(NULL);
    do {
	manager->reordered = 0;
	res = cuddBddVarMapRecur(manager, f);
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    return(res);

} /* end of Cudd_bddVarMap */


/**
  @brief Registers a variable mapping with the manager.

  @details Registers with the manager a variable mapping described
  by two sets of variables.  This variable mapping is then used by
  functions like Cudd_bddVarMap.  This function is convenient for
  those applications that perform the same mapping several times.
  However, if several different permutations are used, it may be more
  efficient not to rely on the registered mapping, because changing
  mapping causes the cache to be cleared.  (The initial setting,
  however, does not clear the cache.) The two sets of variables (x and
  y) must have the same size (x and y).  The size is given by n. The
  two sets of variables are normally disjoint, but this restriction is
  not imposeded by the function. When new variables are created, the
  map is automatically extended (each new variable maps to
  itself). The typical use, however, is to wait until all variables
  are created, and then create the map.

  @return 1 if the mapping is successfully registered with the
  manager; 0 otherwise.

  @sideeffect Modifies the manager. May clear the cache.

  @see Cudd_bddVarMap Cudd_bddPermute Cudd_bddSwapVariables

*/
int
Cudd_SetVarMap (
  DdManager *manager /**< %DD manager */,
  DdNode **x /**< first array of variables */,
  DdNode **y /**< second array of variables */,
  int n /**< length of both arrays */)
{
    int i;

    if (manager->map != NULL) {
	cuddCacheFlush(manager);
    } else {
	manager->map = ALLOC(int,manager->maxSize);
	if (manager->map == NULL) {
	    manager->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	manager->memused += sizeof(int) * manager->maxSize;
    }
    /* Initialize the map to the identity. */
    for (i = 0; i < manager->size; i++) {
	manager->map[i] = i;
    }
    /* Create the map. */
    for (i = 0; i < n; i++) {
	manager->map[x[i]->index] = y[i]->index;
	manager->map[y[i]->index] = x[i]->index;
    }
    return(1);

} /* end of Cudd_SetVarMap */


/**
  @brief Swaps two sets of variables of the same size (x and y) in
  the %BDD f.

  @details The size is given by n. The two sets of variables are
  assumed to be disjoint.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_bddPermute Cudd_addSwapVariables

*/
DdNode *
Cudd_bddSwapVariables(
  DdManager * dd,
  DdNode * f,
  DdNode ** x,
  DdNode ** y,
  int  n)
{
    DdNode *swapped;
    int	 i, j, k;
    int	 *permut;

    permut = ALLOC(int,dd->size);
    if (permut == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < dd->size; i++) permut[i] = i;
    for (i = 0; i < n; i++) {
	j = x[i]->index;
	k = y[i]->index;
	permut[j] = k;
	permut[k] = j;
    }

    swapped = Cudd_bddPermute(dd,f,permut);
    FREE(permut);

    return(swapped);

} /* end of Cudd_bddSwapVariables */


/**
  @brief Rearranges a set of variables in the %BDD B.

  @details The size of the set is given by n. This procedure is
  intended for the `randomization' of the priority functions.

  @return a pointer to the %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddPermute Cudd_bddSwapVariables
  Cudd_Dxygtdxz Cudd_Dxygtdyz Cudd_PrioritySelect

*/
DdNode *
Cudd_bddAdjPermuteX(
  DdManager * dd,
  DdNode * B,
  DdNode ** x,
  int  n)
{
    DdNode *swapped;
    int	 i, j, k;
    int	 *permut;

    permut = ALLOC(int,dd->size);
    if (permut == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < dd->size; i++) permut[i] = i;
    for (i = 0; i < n-2; i += 3) {
	j = x[i]->index;
	k = x[i+1]->index;
	permut[j] = k;
	permut[k] = j;
    }

    swapped = Cudd_bddPermute(dd,B,permut);
    FREE(permut);

    return(swapped);

} /* end of Cudd_bddAdjPermuteX */


/**
  @brief Composes an %ADD with a vector of 0-1 ADDs.

  @details Given a vector of 0-1 ADDs, creates a new %ADD by
  substituting the 0-1 ADDs for the variables of the %ADD f.  There
  should be an entry in vector for each variable in the manager.
  If no substitution is sought for a given variable, the corresponding
  projection function should be specified in the vector.
  This function implements simultaneous composition.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addNonSimCompose Cudd_addPermute Cudd_addCompose
  Cudd_bddVectorCompose

*/
DdNode *
Cudd_addVectorCompose(
  DdManager * dd,
  DdNode * f,
  DdNode ** vector)
{
    DdHashTable		*table;
    DdNode		*res;
    int			deepest;
    int                 i;

    do {
	dd->reordered = 0;
	/* Initialize local cache. */
	table = cuddHashTableInit(dd,1,2);
	if (table == NULL) return(NULL);

	/* Find deepest real substitution. */
	for (deepest = dd->size - 1; deepest >= 0; deepest--) {
	    i = dd->invperm[deepest];
	    if (!ddIsIthAddVar(dd,vector[i],i)) {
		break;
	    }
	}

	/* Recursively solve the problem. */
	res = cuddAddVectorComposeRecur(dd,table,f,vector,deepest);
	if (res != NULL) cuddRef(res);

	/* Dispose of local cache. */
	cuddHashTableQuit(table);
    } while (dd->reordered == 1);

    if (res != NULL) cuddDeref(res);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addVectorCompose */


/**
  @brief Composes an %ADD with a vector of ADDs.

  @details Given a vector of ADDs, creates a new %ADD by substituting the
  ADDs for the variables of the %ADD f. vectorOn contains ADDs to be substituted
  for the x_v and vectorOff the ADDs to be substituted for x_v'. There should
  be an entry in vector for each variable in the manager.  If no substitution
  is sought for a given variable, the corresponding projection function should
  be specified in the vector.  This function implements simultaneous
  composition.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addVectorCompose Cudd_addNonSimCompose Cudd_addPermute
  Cudd_addCompose Cudd_bddVectorCompose

*/
DdNode *
Cudd_addGeneralVectorCompose(
  DdManager * dd,
  DdNode * f,
  DdNode ** vectorOn,
  DdNode ** vectorOff)
{
    DdHashTable		*table;
    DdNode		*res;
    int			deepest;
    int                 i;

    do {
	dd->reordered = 0;
	/* Initialize local cache. */
	table = cuddHashTableInit(dd,1,2);
	if (table == NULL) return(NULL);

	/* Find deepest real substitution. */
	for (deepest = dd->size - 1; deepest >= 0; deepest--) {
	    i = dd->invperm[deepest];
	    if (!ddIsIthAddVarPair(dd,vectorOn[i],vectorOff[i],i)) {
		break;
	    }
	}

	/* Recursively solve the problem. */
	res = cuddAddGeneralVectorComposeRecur(dd,table,f,vectorOn,
					       vectorOff,deepest);
	if (res != NULL) cuddRef(res);

	/* Dispose of local cache. */
	cuddHashTableQuit(table);
    } while (dd->reordered == 1);

    if (res != NULL) cuddDeref(res);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addGeneralVectorCompose */


/**
  @brief Composes an %ADD with a vector of 0-1 ADDs.

  @details Given a vector of 0-1 ADDs, creates a new %ADD by
  substituting the 0-1 ADDs for the variables of the %ADD f.  There
  should be an entry in vector for each variable in the manager.
  This function implements non-simultaneous composition. If any of the
  functions being composed depends on any of the variables being
  substituted, then the result depends on the order of composition,
  which in turn depends on the variable order: The variables farther from
  the roots in the order are substituted first.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_addVectorCompose Cudd_addPermute Cudd_addCompose

*/
DdNode *
Cudd_addNonSimCompose(
  DdManager * dd,
  DdNode * f,
  DdNode ** vector)
{
    DdNode		*cube, *key, *var, *tmp, *piece;
    DdNode		*res;
    int			i, lastsub;

    /* The cache entry for this function is composed of three parts:
    ** f itself, the replacement relation, and the cube of the
    ** variables being substituted.
    ** The replacement relation is the product of the terms (yi EXNOR gi).
    ** This apporach allows us to use the global cache for this function,
    ** with great savings in memory with respect to using arrays for the
    ** cache entries.
    ** First we build replacement relation and cube of substituted
    ** variables from the vector specifying the desired composition.
    */
    key = DD_ONE(dd);
    cuddRef(key);
    cube = DD_ONE(dd);
    cuddRef(cube);
    for (i = (int) dd->size - 1; i >= 0; i--) {
	if (ddIsIthAddVar(dd,vector[i],(unsigned int)i)) {
	    continue;
	}
	var = Cudd_addIthVar(dd,i);
	if (var == NULL) {
	    Cudd_RecursiveDeref(dd,key);
	    Cudd_RecursiveDeref(dd,cube);
	    return(NULL);
	}
	cuddRef(var);
	/* Update cube. */
	tmp = Cudd_addApply(dd,Cudd_addTimes,var,cube);
	if (tmp == NULL) {
	    Cudd_RecursiveDeref(dd,key);
	    Cudd_RecursiveDeref(dd,cube);
	    Cudd_RecursiveDeref(dd,var);
	    return(NULL);
	}
	cuddRef(tmp);
	Cudd_RecursiveDeref(dd,cube);
	cube = tmp;
	/* Update replacement relation. */
	piece = Cudd_addApply(dd,Cudd_addXnor,var,vector[i]);
	if (piece == NULL) {
	    Cudd_RecursiveDeref(dd,key);
	    Cudd_RecursiveDeref(dd,var);
	    return(NULL);
	}
	cuddRef(piece);
	Cudd_RecursiveDeref(dd,var);
	tmp = Cudd_addApply(dd,Cudd_addTimes,key,piece);
	if (tmp == NULL) {
	    Cudd_RecursiveDeref(dd,key);
	    Cudd_RecursiveDeref(dd,piece);
	    return(NULL);
	}
	cuddRef(tmp);
	Cudd_RecursiveDeref(dd,key);
	Cudd_RecursiveDeref(dd,piece);
	key = tmp;
    }

    /* Now try composition, until no reordering occurs. */
    do {
	/* Find real substitution with largest index. */
	for (lastsub = dd->size - 1; lastsub >= 0; lastsub--) {
	    if (!ddIsIthAddVar(dd,vector[lastsub],(unsigned int)lastsub)) {
		break;
	    }
	}

	/* Recursively solve the problem. */
	dd->reordered = 0;
	res = cuddAddNonSimComposeRecur(dd,f,vector,key,cube,lastsub+1);
	if (res != NULL) cuddRef(res);

    } while (dd->reordered == 1);

    Cudd_RecursiveDeref(dd,key);
    Cudd_RecursiveDeref(dd,cube);
    if (res != NULL) cuddDeref(res);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addNonSimCompose */


/**
  @brief Composes a %BDD with a vector of BDDs.

  @details Given a vector of BDDs, creates a new %BDD by
  substituting the BDDs for the variables of the %BDD f.  There
  should be an entry in vector for each variable in the manager.
  If no substitution is sought for a given variable, the corresponding
  projection function should be specified in the vector.
  This function implements simultaneous composition.

  @return a pointer to the resulting %BDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_bddPermute Cudd_bddCompose Cudd_addVectorCompose

*/
DdNode *
Cudd_bddVectorCompose(
  DdManager * dd,
  DdNode * f,
  DdNode ** vector)
{
    DdHashTable		*table;
    DdNode		*res;
    int			deepest;
    int                 i;

    do {
	dd->reordered = 0;
	/* Initialize local cache. */
	table = cuddHashTableInit(dd,1,2);
	if (table == NULL) return(NULL);

	/* Find deepest real substitution. */
	for (deepest = dd->size - 1; deepest >= 0; deepest--) {
	    i = dd->invperm[deepest];
	    if (vector[i] != dd->vars[i]) {
		break;
	    }
	}

	/* Recursively solve the problem. */
	res = cuddBddVectorComposeRecur(dd,table,f,vector, deepest);
	if (res != NULL) cuddRef(res);

	/* Dispose of local cache. */
	cuddHashTableQuit(table);
    } while (dd->reordered == 1);

    if (res != NULL) cuddDeref(res);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddVectorCompose */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_bddCompose.

  @details Exploits the fact that the composition of f' with g
  produces the complement of the composition of f with g to better
  utilize the cache.

  @return the composed %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddCompose

*/
DdNode *
cuddBddComposeRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * proj)
{
    DdNode	 *F, *G, *f1, *f0, *g1, *g0, *r, *t, *e;
    unsigned int topindex;
    int		 topf, topg, v;
    int		 comple;

    statLine(dd);
    v = dd->perm[proj->index];
    F = Cudd_Regular(f);
    topf = cuddI(dd,F->index);

    /* Terminal case. Subsumes the test for constant f. */
    if (topf > v) return(f);

    /* We solve the problem for a regular pointer, and then complement
    ** the result if the pointer was originally complemented.
    */
    comple = Cudd_IsComplement(f);

    /* Check cache. */
    r = cuddCacheLookup(dd,DD_BDD_COMPOSE_RECUR_TAG,F,g,proj);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple));
    }

    checkWhetherToGiveUp(dd);

    if (topf == v) {
	/* Compose. */
	f1 = cuddT(F);
	f0 = cuddE(F);
	r = cuddBddIteRecur(dd, g, f1, f0);
	if (r == NULL) return(NULL);
    } else {
	/* Compute cofactors of f and g. Remember the index of the top
	** variable.
	*/
	G = Cudd_Regular(g);
	topg = cuddI(dd,G->index);
	if (topf > topg) {
	    topindex = G->index;
	    f1 = f0 = F;
	} else {
	    topindex = F->index;
	    f1 = cuddT(F);
	    f0 = cuddE(F);
	}
	if (topg > topf) {
	    g1 = g0 = g;
	} else {
	    g1 = cuddT(G);
	    g0 = cuddE(G);
	    if (g != G) {
		g1 = Cudd_Not(g1);
		g0 = Cudd_Not(g0);
	    }
	}
	/* Recursive step. */
	t = cuddBddComposeRecur(dd, f1, g1, proj);
	if (t == NULL) return(NULL);
	cuddRef(t);
	e = cuddBddComposeRecur(dd, f0, g0, proj);
	if (e == NULL) {
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
	cuddRef(e);

	r = cuddBddIteRecur(dd, dd->vars[topindex], t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, t);
	    Cudd_IterDerefBdd(dd, e);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_IterDerefBdd(dd, t); /* t & e not necessarily part of r */
	Cudd_IterDerefBdd(dd, e);
	cuddDeref(r);
    }

    cuddCacheInsert(dd,DD_BDD_COMPOSE_RECUR_TAG,F,g,proj,r);

    return(Cudd_NotCond(r,comple));

} /* end of cuddBddComposeRecur */


/**
  @brief Performs the recursive step of Cudd_addCompose.

  @return the composed %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addCompose

*/
DdNode *
cuddAddComposeRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * proj)
{
    DdNode *f1, *f0, *g1, *g0, *r, *t, *e;
    int v;
    int topf, topg;
    unsigned int topindex;

    statLine(dd);
    v = dd->perm[proj->index];
    topf = cuddI(dd,f->index);

    /* Terminal case. Subsumes the test for constant f. */
    if (topf > v) return(f);

    /* Check cache. */
    r = cuddCacheLookup(dd,DD_ADD_COMPOSE_RECUR_TAG,f,g,proj);
    if (r != NULL) {
	return(r);
    }

    checkWhetherToGiveUp(dd);

    if (topf == v) {
	/* Compose. */
	f1 = cuddT(f);
	f0 = cuddE(f);
	r = cuddAddIteRecur(dd, g, f1, f0);
	if (r == NULL) return(NULL);
    } else {
	/* Compute cofactors of f and g. Remember the index of the top
	** variable.
	*/
	topg = cuddI(dd,g->index);
	if (topf > topg) {
	    topindex = g->index;
	    f1 = f0 = f;
	} else {
	    topindex = f->index;
	    f1 = cuddT(f);
	    f0 = cuddE(f);
	}
	if (topg > topf) {
	    g1 = g0 = g;
	} else {
	    g1 = cuddT(g);
	    g0 = cuddE(g);
	}
	/* Recursive step. */
	t = cuddAddComposeRecur(dd, f1, g1, proj);
	if (t == NULL) return(NULL);
	cuddRef(t);
	e = cuddAddComposeRecur(dd, f0, g0, proj);
	if (e == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
	cuddRef(e);

	if (t == e) {
	    r = t;
	} else {
	    r = cuddUniqueInter(dd, (int) topindex, t, e);
	    if (r == NULL) {
		Cudd_RecursiveDeref(dd, t);
		Cudd_RecursiveDeref(dd, e);
		return(NULL);
	    }
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert(dd,DD_ADD_COMPOSE_RECUR_TAG,f,g,proj,r);

    return(r);

} /* end of cuddAddComposeRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_addPermute.

  @details Recursively puts the %ADD in the order given in the
  array permut. Checks for trivial cases to terminate recursion, then
  splits on the children of this node.  Once the solutions for the
  children are obtained, it puts into the current position the node
  from the rest of the %ADD that should be here. Then returns this %ADD.
  The key here is that the node being visited is NOT put in its proper
  place by this instance, but rather is switched when its proper
  position is reached in the recursion tree.<p>
  The DdNode * that is returned is the same %ADD as passed in as node,
  but in the new order.

  @sideeffect None

  @see Cudd_addPermute cuddBddPermuteRecur

*/
static DdNode *
cuddAddPermuteRecur(
  DdManager * manager /**< %DD manager */,
  DdHashTable * table /**< computed table */,
  DdNode * node /**< %ADD to be reordered */,
  int * permut /**< permutation array */)
{
    DdNode	*T,*E;
    DdNode	*res,*var;
    int		index;
    
    statLine(manager);
    /* Check for terminal case of constant node. */
    if (cuddIsConstant(node)) {
	return(node);
    }

    /* If problem already solved, look up answer and return. */
    if (node->ref != 1 && (res = cuddHashTableLookup1(table,node)) != NULL) {
#ifdef DD_DEBUG
	manager->addPermuteRecurHits++;
#endif
	return(res);
    }

    /* Split and recur on children of this node. */
    T = cuddAddPermuteRecur(manager,table,cuddT(node),permut);
    if (T == NULL) return(NULL);
    cuddRef(T);
    E = cuddAddPermuteRecur(manager,table,cuddE(node),permut);
    if (E == NULL) {
	Cudd_RecursiveDeref(manager, T);
	return(NULL);
    }
    cuddRef(E);

    /* Move variable that should be in this position to this position
    ** by creating a single var ADD for that variable, and calling
    ** cuddAddIteRecur with the T and E we just created.
    */
    index = permut[node->index];
    var = cuddUniqueInter(manager,index,DD_ONE(manager),DD_ZERO(manager));
    if (var == NULL) return(NULL);
    cuddRef(var);
    res = cuddAddIteRecur(manager,var,T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(manager,var);
	Cudd_RecursiveDeref(manager, T);
	Cudd_RecursiveDeref(manager, E);
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(manager,var);
    Cudd_RecursiveDeref(manager, T);
    Cudd_RecursiveDeref(manager, E);

    /* Do not keep the result if the reference count is only 1, since
    ** it will not be visited again.
    */
    if (node->ref != 1) {
	ptrint fanout = (ptrint) node->ref;
	cuddSatDec(fanout);
	if (!cuddHashTableInsert1(table,node,res,fanout)) {
	    Cudd_RecursiveDeref(manager, res);
	    return(NULL);
	}
    }
    cuddDeref(res);
    return(res);

} /* end of cuddAddPermuteRecur */


/**
  @brief Implements the recursive step of Cudd_bddPermute.

  @details Recursively puts the %BDD in the order given in the array permut.
  Checks for trivial cases to terminate recursion, then splits on the
  children of this node.  Once the solutions for the children are
  obtained, it puts into the current position the node from the rest of
  the %BDD that should be here. Then returns this %BDD.
  The key here is that the node being visited is NOT put in its proper
  place by this instance, but rather is switched when its proper position
  is reached in the recursion tree.<p>
  The DdNode * that is returned is the same %BDD as passed in as node,
  but in the new order.

  @sideeffect None

  @see Cudd_bddPermute cuddAddPermuteRecur

*/
static DdNode *
cuddBddPermuteRecur(
  DdManager * manager /**< %DD manager */,
  DdHashTable * table /**< computed table */,
  DdNode * node /**< %BDD to be reordered */,
  int * permut /**< permutation array */)
{
    DdNode	*N,*T,*E;
    DdNode	*res;
    int		index;

    statLine(manager);
    N = Cudd_Regular(node);

    /* Check for terminal case of constant node. */
    if (cuddIsConstant(N)) {
	return(node);
    }

    /* If problem already solved, look up answer and return. */
    if (N->ref != 1 && (res = cuddHashTableLookup1(table,N)) != NULL) {
#ifdef DD_DEBUG
	manager->bddPermuteRecurHits++;
#endif
	return(Cudd_NotCond(res,N != node));
    }

    /* Split and recur on children of this node. */
    T = cuddBddPermuteRecur(manager,table,cuddT(N),permut);
    if (T == NULL) return(NULL);
    cuddRef(T);
    E = cuddBddPermuteRecur(manager,table,cuddE(N),permut);
    if (E == NULL) {
	Cudd_IterDerefBdd(manager, T);
	return(NULL);
    }
    cuddRef(E);

    /* Move variable that should be in this position to this position
    ** by retrieving the single var BDD for that variable, and calling
    ** cuddBddIteRecur with the T and E we just created.
    */
    index = permut[N->index];
    res = cuddBddIteRecur(manager,manager->vars[index],T,E);
    if (res == NULL) {
	Cudd_IterDerefBdd(manager, T);
	Cudd_IterDerefBdd(manager, E);
	return(NULL);
    }
    cuddRef(res);
    Cudd_IterDerefBdd(manager, T);
    Cudd_IterDerefBdd(manager, E);

    /* Do not keep the result if the reference count is only 1, since
    ** it will not be visited again.
    */
    if (N->ref != 1) {
	ptrint fanout = (ptrint) N->ref;
	cuddSatDec(fanout);
	if (!cuddHashTableInsert1(table,N,res,fanout)) {
	    Cudd_IterDerefBdd(manager, res);
	    return(NULL);
	}
    }
    cuddDeref(res);
    return(Cudd_NotCond(res,N != node));

} /* end of cuddBddPermuteRecur */


/**
  @brief Implements the recursive step of Cudd_bddVarMap.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddVarMap

*/
static DdNode *
cuddBddVarMapRecur(
  DdManager *manager /**< %DD manager */,
  DdNode *f /**< %BDD to be remapped */)
{
    DdNode	*F, *T, *E;
    DdNode	*res;
    int		index;

    statLine(manager);
    F = Cudd_Regular(f);

    /* Check for terminal case of constant node. */
    if (cuddIsConstant(F)) {
	return(f);
    }

    /* If problem already solved, look up answer and return. */
    if (F->ref != 1 &&
	(res = cuddCacheLookup1(manager,Cudd_bddVarMap,F)) != NULL) {
	return(Cudd_NotCond(res,F != f));
    }

    checkWhetherToGiveUp(manager);

    /* Split and recur on children of this node. */
    T = cuddBddVarMapRecur(manager,cuddT(F));
    if (T == NULL) return(NULL);
    cuddRef(T);
    E = cuddBddVarMapRecur(manager,cuddE(F));
    if (E == NULL) {
	Cudd_IterDerefBdd(manager, T);
	return(NULL);
    }
    cuddRef(E);

    /* Move variable that should be in this position to this position
    ** by retrieving the single var BDD for that variable, and calling
    ** cuddBddIteRecur with the T and E we just created.
    */
    index = manager->map[F->index];
    res = cuddBddIteRecur(manager,manager->vars[index],T,E);
    if (res == NULL) {
	Cudd_IterDerefBdd(manager, T);
	Cudd_IterDerefBdd(manager, E);
	return(NULL);
    }
    cuddRef(res);
    Cudd_IterDerefBdd(manager, T);
    Cudd_IterDerefBdd(manager, E);

    /* Do not keep the result if the reference count is only 1, since
    ** it will not be visited again.
    */
    if (F->ref != 1) {
	cuddCacheInsert1(manager,Cudd_bddVarMap,F,res);
    }
    cuddDeref(res);
    return(Cudd_NotCond(res,F != f));

} /* end of cuddBddVarMapRecur */


/**
  @brief Performs the recursive step of Cudd_addVectorCompose.

  @sideeffect None

*/
static DdNode *
cuddAddVectorComposeRecur(
  DdManager * dd /**< %DD manager */,
  DdHashTable * table /**< computed table */,
  DdNode * f /**< %ADD in which to compose */,
  DdNode ** vector /**< functions to substitute */,
  int  deepest /**< depth of deepest substitution */)
{
    DdNode	*T,*E;
    DdNode	*res;

    statLine(dd);
    /* If we are past the deepest substitution, return f. */
    if (cuddI(dd,f->index) > deepest) {
	return(f);
    }

    if ((res = cuddHashTableLookup1(table,f)) != NULL) {
#ifdef DD_DEBUG
	dd->addVectorComposeHits++;
#endif
	return(res);
    }

    /* Split and recur on children of this node. */
    T = cuddAddVectorComposeRecur(dd,table,cuddT(f),vector,deepest);
    if (T == NULL)  return(NULL);
    cuddRef(T);
    E = cuddAddVectorComposeRecur(dd,table,cuddE(f),vector,deepest);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);

    /* Retrieve the 0-1 ADD for the current top variable and call
    ** cuddAddIteRecur with the T and E we just created.
    */
    res = cuddAddIteRecur(dd,vector[f->index],T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, T);
	Cudd_RecursiveDeref(dd, E);
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, T);
    Cudd_RecursiveDeref(dd, E);

    /* Do not keep the result if the reference count is only 1, since
    ** it will not be visited again
    */
    if (f->ref != 1) {
	ptrint fanout = (ptrint) f->ref;
	cuddSatDec(fanout);
	if (!cuddHashTableInsert1(table,f,res,fanout)) {
	    Cudd_RecursiveDeref(dd, res);
	    return(NULL);
	}
    }
    cuddDeref(res);
    return(res);

} /* end of cuddAddVectorComposeRecur */


/**
  @brief Performs the recursive step of Cudd_addGeneralVectorCompose.

  @sideeffect None

*/
static DdNode *
cuddAddGeneralVectorComposeRecur(
  DdManager * dd /**< %DD manager */,
  DdHashTable * table /**< computed table */,
  DdNode * f /**< %ADD in which to compose */,
  DdNode ** vectorOn /**< functions to substitute for x_i */,
  DdNode ** vectorOff /**< functions to substitute for x_i' */,
  int  deepest /**< depth of deepest substitution */)
{
    DdNode	*T,*E,*t,*e;
    DdNode	*res;

    /* If we are past the deepest substitution, return f. */
    if (cuddI(dd,f->index) > deepest) {
	return(f);
    }

    if ((res = cuddHashTableLookup1(table,f)) != NULL) {
#ifdef DD_DEBUG
	dd->addGeneralVectorComposeHits++;
#endif
	return(res);
    }

    /* Split and recur on children of this node. */
    T = cuddAddGeneralVectorComposeRecur(dd,table,cuddT(f),
					 vectorOn,vectorOff,deepest);
    if (T == NULL)  return(NULL);
    cuddRef(T);
    E = cuddAddGeneralVectorComposeRecur(dd,table,cuddE(f),
					 vectorOn,vectorOff,deepest);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd, T);
	return(NULL);
    }
    cuddRef(E);

    /* Retrieve the compose ADDs for the current top variable and call
    ** cuddAddApplyRecur with the T and E we just created.
    */
    t = cuddAddApplyRecur(dd,Cudd_addTimes,vectorOn[f->index],T);
    if (t == NULL) {
      Cudd_RecursiveDeref(dd,T);
      Cudd_RecursiveDeref(dd,E);
      return(NULL);
    }
    cuddRef(t);
    e = cuddAddApplyRecur(dd,Cudd_addTimes,vectorOff[f->index],E);
    if (e == NULL) {
      Cudd_RecursiveDeref(dd,T);
      Cudd_RecursiveDeref(dd,E);
      Cudd_RecursiveDeref(dd,t);
      return(NULL);
    }
    cuddRef(e);
    res = cuddAddApplyRecur(dd,Cudd_addPlus,t,e);
    if (res == NULL) {
      Cudd_RecursiveDeref(dd,T);
      Cudd_RecursiveDeref(dd,E);
      Cudd_RecursiveDeref(dd,t);
      Cudd_RecursiveDeref(dd,e);
      return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd,T);
    Cudd_RecursiveDeref(dd,E);
    Cudd_RecursiveDeref(dd,t);
    Cudd_RecursiveDeref(dd,e);

    /* Do not keep the result if the reference count is only 1, since
    ** it will not be visited again
    */
    if (f->ref != 1) {
	ptrint fanout = (ptrint) f->ref;
	cuddSatDec(fanout);
	if (!cuddHashTableInsert1(table,f,res,fanout)) {
	    Cudd_RecursiveDeref(dd, res);
	    return(NULL);
	}
    }
    cuddDeref(res);
    return(res);

} /* end of cuddAddGeneralVectorComposeRecur */


/**
  @brief Performs the recursive step of Cudd_addNonSimCompose.

  @sideeffect None

*/
static DdNode *
cuddAddNonSimComposeRecur(
  DdManager * dd,
  DdNode * f,
  DdNode ** vector,
  DdNode * key,
  DdNode * cube,
  int  lastsub)
{
    DdNode *f1, *f0, *key1, *key0, *cube1, *var;
    DdNode *T,*E;
    DdNode *r;
    int top, topf, topk, topc;
    unsigned int index;
    int i;
    DdNode **vect1;
    DdNode **vect0;

    statLine(dd);
    /* If we are past the deepest substitution, return f. */
    if (cube == DD_ONE(dd) || cuddIsConstant(f)) {
	return(f);
    }

    /* If problem already solved, look up answer and return. */
    r = cuddCacheLookup(dd,DD_ADD_NON_SIM_COMPOSE_TAG,f,key,cube);
    if (r != NULL) {
	return(r);
    }

    checkWhetherToGiveUp(dd);

    /* Find top variable. we just need to look at f, key, and cube,
    ** because all the varibles in the gi are in key.
    */
    topf = cuddI(dd,f->index);
    topk = cuddI(dd,key->index);
    top = ddMin(topf,topk);
    topc = cuddI(dd,cube->index);
    top = ddMin(top,topc);
    index = dd->invperm[top];

    /* Compute the cofactors. */
    if (topf == top) {
	f1 = cuddT(f);
	f0 = cuddE(f);
    } else {
	f1 = f0 = f;
    }
    if (topc == top) {
	cube1 = cuddT(cube);
	/* We want to eliminate vector[index] from key. Otherwise
	** cache performance is severely affected. Hence we
	** existentially quantify the variable with index "index" from key.
	*/
	var = Cudd_addIthVar(dd, (int) index);
	if (var == NULL) {
	    return(NULL);
	}
	cuddRef(var);
	key1 = cuddAddExistAbstractRecur(dd, key, var);
	if (key1 == NULL) {
	    Cudd_RecursiveDeref(dd,var);
	    return(NULL);
	}
	cuddRef(key1);
	Cudd_RecursiveDeref(dd,var);
	key0 = key1;
    } else {
	cube1 = cube;
	if (topk == top) {
	    key1 = cuddT(key);
	    key0 = cuddE(key);
	} else {
	    key1 = key0 = key;
	}
	cuddRef(key1);
    }

    /* Allocate two new vectors for the cofactors of vector. */
    vect1 = ALLOC(DdNode *,lastsub);
    if (vect1 == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	Cudd_RecursiveDeref(dd,key1);
	return(NULL);
    }
    vect0 = ALLOC(DdNode *,lastsub);
    if (vect0 == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	Cudd_RecursiveDeref(dd,key1);
	FREE(vect1);
	return(NULL);
    }

    /* Cofactor the gi. Eliminate vect1[index] and vect0[index], because
    ** we do not need them.
    */
    for (i = 0; i < lastsub; i++) {
	DdNode *gi = vector[i];
	if (gi == NULL) {
	    vect1[i] = vect0[i] = NULL;
	} else if (gi->index == index) {
	    vect1[i] = cuddT(gi);
	    vect0[i] = cuddE(gi);
	} else {
	    vect1[i] = vect0[i] = gi;
	}
    }
    vect1[index] = vect0[index] = NULL;

    /* Recur on children. */
    T = cuddAddNonSimComposeRecur(dd,f1,vect1,key1,cube1,lastsub);
    FREE(vect1);
    if (T == NULL) {
	Cudd_RecursiveDeref(dd,key1);
	FREE(vect0);
	return(NULL);
    }
    cuddRef(T);
    E = cuddAddNonSimComposeRecur(dd,f0,vect0,key0,cube1,lastsub);
    FREE(vect0);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd,key1);
	Cudd_RecursiveDeref(dd,T);
	return(NULL);
    }
    cuddRef(E);
    Cudd_RecursiveDeref(dd,key1);

    /* Retrieve the 0-1 ADD for the current top variable from vector,
    ** and call cuddAddIteRecur with the T and E we just created.
    */
    r = cuddAddIteRecur(dd,vector[index],T,E);
    if (r == NULL) {
	Cudd_RecursiveDeref(dd,T);
	Cudd_RecursiveDeref(dd,E);
	return(NULL);
    }
    cuddRef(r);
    Cudd_RecursiveDeref(dd,T);
    Cudd_RecursiveDeref(dd,E);
    cuddDeref(r);

    /* Store answer to trim recursion. */
    cuddCacheInsert(dd,DD_ADD_NON_SIM_COMPOSE_TAG,f,key,cube,r);

    return(r);

} /* end of cuddAddNonSimComposeRecur */


/**
  @brief Performs the recursive step of Cudd_bddVectorCompose.

  @sideeffect None

*/
static DdNode *
cuddBddVectorComposeRecur(
  DdManager * dd /**< %DD manager */,
  DdHashTable * table /**< computed table */,
  DdNode * f /**< %BDD in which to compose */,
  DdNode ** vector /**< functions to be composed */,
  int deepest /**< depth of the deepest substitution */)
{
    DdNode	*F,*T,*E;
    DdNode	*res;

    statLine(dd);
    F = Cudd_Regular(f);

    /* If we are past the deepest substitution, return f. */
    if (cuddI(dd,F->index) > deepest) {
	return(f);
    }

    /* If problem already solved, look up answer and return. */
    if ((res = cuddHashTableLookup1(table,F)) != NULL) {
#ifdef DD_DEBUG
	dd->bddVectorComposeHits++;
#endif
	return(Cudd_NotCond(res,F != f));
    }

    /* Split and recur on children of this node. */
    T = cuddBddVectorComposeRecur(dd,table,cuddT(F),vector, deepest);
    if (T == NULL) return(NULL);
    cuddRef(T);
    E = cuddBddVectorComposeRecur(dd,table,cuddE(F),vector, deepest);
    if (E == NULL) {
	Cudd_IterDerefBdd(dd, T);
	return(NULL);
    }
    cuddRef(E);

    /* Call cuddBddIteRecur with the BDD that replaces the current top
    ** variable and the T and E we just created.
    */
    res = cuddBddIteRecur(dd,vector[F->index],T,E);
    if (res == NULL) {
	Cudd_IterDerefBdd(dd, T);
	Cudd_IterDerefBdd(dd, E);
	return(NULL);
    }
    cuddRef(res);
    Cudd_IterDerefBdd(dd, T);
    Cudd_IterDerefBdd(dd, E);	

    /* Do not keep the result if the reference count is only 1, since
    ** it will not be visited again.
    */
    if (F->ref != 1) {
	ptrint fanout = (ptrint) F->ref;
	cuddSatDec(fanout);
	if (!cuddHashTableInsert1(table,F,res,fanout)) {
	    Cudd_IterDerefBdd(dd, res);
	    return(NULL);
	}
    }
    cuddDeref(res);
    return(Cudd_NotCond(res,F != f));

} /* end of cuddBddVectorComposeRecur */


/**
  @brief Comparison of a function to the i-th %ADD variable.

  @return 1 if the function is the i-th %ADD variable; 0 otherwise.

  @sideeffect None

*/
static int
ddIsIthAddVar(
  DdManager * dd,
  DdNode * f,
  unsigned int  i)
{
    return(f->index == i && cuddT(f) == DD_ONE(dd) && cuddE(f) == DD_ZERO(dd));

} /* end of ddIsIthAddVar */


/**
  @brief Comparison of a pair of functions to the i-th %ADD variable.

  @return 1 if the functions are the i-th %ADD variable and its
  complement; 0 otherwise.

  @sideeffect None

*/
static int
ddIsIthAddVarPair(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  unsigned int  i)
{
    return(f->index == i && g->index == i && 
	   cuddT(f) == DD_ONE(dd) && cuddE(f) == DD_ZERO(dd) &&
	   cuddT(g) == DD_ZERO(dd) && cuddE(g) == DD_ONE(dd));

} /* end of ddIsIthAddVarPair */

cuddDecomp.c
59815
/**
  @file

  @ingroup cudd

  @brief Functions for %BDD decomposition.

  @author Kavita Ravi, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/
#define DEPTH 5
#define THRESHOLD 10
#define NONE 0
#define PAIR_ST 1
#define PAIR_CR 2
#define G_ST 3
#define G_CR 4
#define H_ST 5
#define H_CR 6
#define BOTH_G 7
#define BOTH_H 8

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/
/**
 * @brief Type of a pair of conjoined BDDs.
 */
typedef struct Conjuncts {
    DdNode *g;
    DdNode *h;
} Conjuncts;

/**
   @brief Stats for one node.
*/
typedef struct  NodeStat {
    int distance;
    int localRef;
} NodeStat;


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/


#define FactorsNotStored(factors)  ((int)((ptrint)(factors) & 01))

#define FactorsComplement(factors) ((Conjuncts *)((ptrint)(factors) | 01))

#define FactorsUncomplement(factors) ((Conjuncts *)((ptrint)(factors) ^ 01))

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static NodeStat * CreateBotDist (DdNode * node, st_table * distanceTable);
static double CountMinterms (DdManager * dd, DdNode * node, double max, st_table * mintermTable, FILE *fp);
static void ConjunctsFree (DdManager * dd, Conjuncts * factors);
static int PairInTables (DdNode * g, DdNode * h, st_table * ghTable);
static Conjuncts * CheckTablesCacheAndReturn (DdManager *manager, DdNode * node, DdNode * g, DdNode * h, st_table * ghTable, st_table * cacheTable);
static Conjuncts * PickOnePair (DdManager * manager, DdNode * node, DdNode * g1, DdNode * h1, DdNode * g2, DdNode * h2, st_table * ghTable, st_table * cacheTable);
static Conjuncts * CheckInTables (DdManager * manager, DdNode * node, DdNode * g1, DdNode * h1, DdNode * g2, DdNode * h2, st_table * ghTable, st_table * cacheTable, int * outOfMem);
static Conjuncts * ZeroCase (DdManager * dd, DdNode * node, Conjuncts * factorsNv, st_table * ghTable, st_table * cacheTable, int switched);
static Conjuncts * BuildConjuncts (DdManager * dd, DdNode * node, st_table * distanceTable, st_table * cacheTable, int approxDistance, int maxLocalRef, st_table * ghTable, st_table * mintermTable, int32_t *lastTimeG);
static int cuddConjunctsAux (DdManager * dd, DdNode * f, DdNode ** c1, DdNode ** c2);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs two-way conjunctive decomposition of a %BDD.

  @details This procedure owes its name to the use of supersetting to
  obtain an initial factor of the given function.  The conjuncts
  produced by this procedure tend to be imbalanced.

  @return the number of conjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddApproxDisjDecomp Cudd_bddIterConjDecomp
  Cudd_bddGenConjDecomp Cudd_bddVarConjDecomp Cudd_RemapOverApprox
  Cudd_bddSqueeze Cudd_bddLICompaction

*/
int
Cudd_bddApproxConjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** conjuncts /**< address of the first factor */)
{
    DdNode *superset1, *superset2, *glocal, *hlocal;
    int nvars = Cudd_SupportSize(dd,f);

    /* Find a tentative first factor by overapproximation and minimization. */
    superset1 = Cudd_RemapOverApprox(dd,f,nvars,0,1.0);
    if (superset1 == NULL) return(0);
    cuddRef(superset1);
    superset2 = Cudd_bddSqueeze(dd,f,superset1);
    if (superset2 == NULL) {
	Cudd_RecursiveDeref(dd,superset1);
	return(0);
    }
    cuddRef(superset2);
    Cudd_RecursiveDeref(dd,superset1);

    /* Compute the second factor by minimization. */
    hlocal = Cudd_bddLICompaction(dd,f,superset2);
    if (hlocal == NULL) {
	Cudd_RecursiveDeref(dd,superset2);
	return(0);
    }
    cuddRef(hlocal);

    /* Refine the first factor by minimization. If h turns out to be f, this
    ** step guarantees that g will be 1. */
    glocal = Cudd_bddLICompaction(dd,superset2,hlocal);
    if (glocal == NULL) {
	Cudd_RecursiveDeref(dd,superset2);
	Cudd_RecursiveDeref(dd,hlocal);
	return(0);
    }
    cuddRef(glocal);
    Cudd_RecursiveDeref(dd,superset2);

    if (glocal != DD_ONE(dd)) {
	if (hlocal != DD_ONE(dd)) {
	    *conjuncts = ALLOC(DdNode *,2);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,glocal);
		Cudd_RecursiveDeref(dd,hlocal);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = glocal;
	    (*conjuncts)[1] = hlocal;
	    return(2);
	} else {
	    Cudd_RecursiveDeref(dd,hlocal);
	    *conjuncts = ALLOC(DdNode *,1);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,glocal);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = glocal;
	    return(1);
	}
    } else {
	Cudd_RecursiveDeref(dd,glocal);
	*conjuncts = ALLOC(DdNode *,1);
	if (*conjuncts == NULL) {
	    Cudd_RecursiveDeref(dd,hlocal);
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	(*conjuncts)[0] = hlocal;
	return(1);
    }

} /* end of Cudd_bddApproxConjDecomp */


/**
  @brief Performs two-way disjunctive decomposition of a %BDD.

  @details The disjuncts produced by this procedure tend to be
  imbalanced.

  @return the number of disjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddApproxConjDecomp Cudd_bddIterDisjDecomp
  Cudd_bddGenDisjDecomp Cudd_bddVarDisjDecomp

*/
int
Cudd_bddApproxDisjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** disjuncts /**< address of the array of the disjuncts */)
{
    int result, i;

    result = Cudd_bddApproxConjDecomp(dd,Cudd_Not(f),disjuncts);
    for (i = 0; i < result; i++) {
	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
    }
    return(result);

} /* end of Cudd_bddApproxDisjDecomp */


/**
  @brief Performs two-way conjunctive decomposition of a %BDD.

  @details This procedure owes its name to the iterated use of
  supersetting to obtain a factor of the given function.  The
  conjuncts produced by this procedure tend to be imbalanced.

  @return the number of conjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddIterDisjDecomp Cudd_bddApproxConjDecomp
  Cudd_bddGenConjDecomp Cudd_bddVarConjDecomp Cudd_RemapOverApprox
  Cudd_bddSqueeze Cudd_bddLICompaction

*/
int
Cudd_bddIterConjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** conjuncts /**< address of the array of conjuncts */)
{
    DdNode *superset1, *superset2, *old[2], *res[2];
    int sizeOld, sizeNew;
    int nvars = Cudd_SupportSize(dd,f);

    old[0] = DD_ONE(dd);
    cuddRef(old[0]);
    old[1] = f;
    cuddRef(old[1]);
    sizeOld = Cudd_SharingSize(old,2);

    do {
	/* Find a tentative first factor by overapproximation and
	** minimization. */
	superset1 = Cudd_RemapOverApprox(dd,old[1],nvars,0,1.0);
	if (superset1 == NULL) {
	    Cudd_RecursiveDeref(dd,old[0]);
	    Cudd_RecursiveDeref(dd,old[1]);
	    return(0);
	}
	cuddRef(superset1);
	superset2 = Cudd_bddSqueeze(dd,old[1],superset1);
	if (superset2 == NULL) {
	    Cudd_RecursiveDeref(dd,old[0]);
	    Cudd_RecursiveDeref(dd,old[1]);
	    Cudd_RecursiveDeref(dd,superset1);
	    return(0);
	}
	cuddRef(superset2);
	Cudd_RecursiveDeref(dd,superset1);
	res[0] = Cudd_bddAnd(dd,old[0],superset2);
	if (res[0] == NULL) {
	    Cudd_RecursiveDeref(dd,superset2);
	    Cudd_RecursiveDeref(dd,old[0]);
	    Cudd_RecursiveDeref(dd,old[1]);
	    return(0);
	}
	cuddRef(res[0]);
	Cudd_RecursiveDeref(dd,superset2);
	if (res[0] == old[0]) {
	    Cudd_RecursiveDeref(dd,res[0]);
	    break;	/* avoid infinite loop */
	}

	/* Compute the second factor by minimization. */
	res[1] = Cudd_bddLICompaction(dd,old[1],res[0]);
	if (res[1] == NULL) {
	    Cudd_RecursiveDeref(dd,old[0]);
	    Cudd_RecursiveDeref(dd,old[1]);
	    return(0);
	}
	cuddRef(res[1]);

	sizeNew = Cudd_SharingSize(res,2);
	if (sizeNew <= sizeOld) {
	    Cudd_RecursiveDeref(dd,old[0]);
	    old[0] = res[0];
	    Cudd_RecursiveDeref(dd,old[1]);
	    old[1] = res[1];
	    sizeOld = sizeNew;
	} else {
	    Cudd_RecursiveDeref(dd,res[0]);
	    Cudd_RecursiveDeref(dd,res[1]);
	    break;
	}

    } while (1);

    /* Refine the first factor by minimization. If h turns out to
    ** be f, this step guarantees that g will be 1. */
    superset1 = Cudd_bddLICompaction(dd,old[0],old[1]);
    if (superset1 == NULL) {
	Cudd_RecursiveDeref(dd,old[0]);
	Cudd_RecursiveDeref(dd,old[1]);
	return(0);
    }
    cuddRef(superset1);
    Cudd_RecursiveDeref(dd,old[0]);
    old[0] = superset1;

    if (old[0] != DD_ONE(dd)) {
	if (old[1] != DD_ONE(dd)) {
	    *conjuncts = ALLOC(DdNode *,2);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,old[0]);
		Cudd_RecursiveDeref(dd,old[1]);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = old[0];
	    (*conjuncts)[1] = old[1];
	    return(2);
	} else {
	    Cudd_RecursiveDeref(dd,old[1]);
	    *conjuncts = ALLOC(DdNode *,1);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,old[0]);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = old[0];
	    return(1);
	}
    } else {
	Cudd_RecursiveDeref(dd,old[0]);
	*conjuncts = ALLOC(DdNode *,1);
	if (*conjuncts == NULL) {
	    Cudd_RecursiveDeref(dd,old[1]);
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	(*conjuncts)[0] = old[1];
	return(1);
    }

} /* end of Cudd_bddIterConjDecomp */


/**
  @brief Performs two-way disjunctive decomposition of a %BDD.

  @details The disjuncts produced by this procedure tend to be
  imbalanced.

  @return the number of disjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddIterConjDecomp Cudd_bddApproxDisjDecomp
  Cudd_bddGenDisjDecomp Cudd_bddVarDisjDecomp

*/
int
Cudd_bddIterDisjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** disjuncts /**< address of the array of the disjuncts */)
{
    int result, i;

    result = Cudd_bddIterConjDecomp(dd,Cudd_Not(f),disjuncts);
    for (i = 0; i < result; i++) {
	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
    }
    return(result);

} /* end of Cudd_bddIterDisjDecomp */


/**
  @brief Performs two-way conjunctive decomposition of a %BDD.

  @details This procedure owes its name to the fact tht it generalizes
  the decomposition based on the cofactors with respect to one
  variable.  The conjuncts produced by this procedure tend to be
  balanced.

  @return the number of conjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The two factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddGenDisjDecomp Cudd_bddApproxConjDecomp
  Cudd_bddIterConjDecomp Cudd_bddVarConjDecomp

*/
int
Cudd_bddGenConjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** conjuncts /**< address of the array of conjuncts */)
{
    int result;
    DdNode *glocal, *hlocal;

    do {
	dd->reordered = 0;
	result = cuddConjunctsAux(dd, f, &glocal, &hlocal);
    } while (dd->reordered == 1);

    if (result == 0) {
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(0);
    }

    if (glocal != DD_ONE(dd)) {
	if (hlocal != DD_ONE(dd)) {
	    *conjuncts = ALLOC(DdNode *,2);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,glocal);
		Cudd_RecursiveDeref(dd,hlocal);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = glocal;
	    (*conjuncts)[1] = hlocal;
	    return(2);
	} else {
	    Cudd_RecursiveDeref(dd,hlocal);
	    *conjuncts = ALLOC(DdNode *,1);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,glocal);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = glocal;
	    return(1);
	}
    } else {
	Cudd_RecursiveDeref(dd,glocal);
	*conjuncts = ALLOC(DdNode *,1);
	if (*conjuncts == NULL) {
	    Cudd_RecursiveDeref(dd,hlocal);
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	(*conjuncts)[0] = hlocal;
	return(1);
    }

} /* end of Cudd_bddGenConjDecomp */


/**
  @brief Performs two-way disjunctive decomposition of a %BDD.

  @details The disjuncts produced by this procedure tend to be
  balanced.

  @return the number of disjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddGenConjDecomp Cudd_bddApproxDisjDecomp
  Cudd_bddIterDisjDecomp Cudd_bddVarDisjDecomp

*/
int
Cudd_bddGenDisjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** disjuncts /**< address of the array of the disjuncts */)
{
    int result, i;

    result = Cudd_bddGenConjDecomp(dd,Cudd_Not(f),disjuncts);
    for (i = 0; i < result; i++) {
	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
    }
    return(result);

} /* end of Cudd_bddGenDisjDecomp */


/**
  @brief Performs two-way conjunctive decomposition of a %BDD.

  @details Conjunctively decomposes one %BDD according to a
  variable.  If <code>f</code> is the function of the %BDD and
  <code>x</code> is the variable, the decomposition is
  <code>(f+x)(f+x')</code>.  The variable is chosen so as to balance
  the sizes of the two conjuncts and to keep them small.

  @return the number of conjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The two factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddVarDisjDecomp Cudd_bddGenConjDecomp
  Cudd_bddApproxConjDecomp Cudd_bddIterConjDecomp

*/
int
Cudd_bddVarConjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** conjuncts /**< address of the array of conjuncts */)
{
    int best;
    int min;
    DdNode *support, *scan, *var, *glocal, *hlocal;

    /* Find best cofactoring variable. */
    support = Cudd_Support(dd,f);
    if (support == NULL) return(0);
    if (Cudd_IsConstantInt(support)) {
	*conjuncts = ALLOC(DdNode *,1);
	if (*conjuncts == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	(*conjuncts)[0] = f;
	cuddRef((*conjuncts)[0]);
	return(1);
    }
    cuddRef(support);
    min = 1000000000;
    best = -1;
    scan = support;
    while (!Cudd_IsConstantInt(scan)) {
        int i, est1, est0, est;
	i = scan->index;
	est1 = Cudd_EstimateCofactor(dd,f,i,1);
        if (est1 == CUDD_OUT_OF_MEM) return(0);
	est0 = Cudd_EstimateCofactor(dd,f,i,0);
        if (est0 == CUDD_OUT_OF_MEM) return(0);
	/* Minimize the size of the larger of the two cofactors. */
	est = (est1 > est0) ? est1 : est0;
	if (est < min) {
	    min = est;
	    best = i;
	}
	scan = cuddT(scan);
    }
#ifdef DD_DEBUG
    assert(best >= 0 && best < dd->size);
#endif
    Cudd_RecursiveDeref(dd,support);

    var = Cudd_bddIthVar(dd,best);
    glocal = Cudd_bddOr(dd,f,var);
    if (glocal == NULL) {
	return(0);
    }
    cuddRef(glocal);
    hlocal = Cudd_bddOr(dd,f,Cudd_Not(var));
    if (hlocal == NULL) {
	Cudd_RecursiveDeref(dd,glocal);
	return(0);
    }
    cuddRef(hlocal);

    if (glocal != DD_ONE(dd)) {
	if (hlocal != DD_ONE(dd)) {
	    *conjuncts = ALLOC(DdNode *,2);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,glocal);
		Cudd_RecursiveDeref(dd,hlocal);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = glocal;
	    (*conjuncts)[1] = hlocal;
	    return(2);
	} else {
	    Cudd_RecursiveDeref(dd,hlocal);
	    *conjuncts = ALLOC(DdNode *,1);
	    if (*conjuncts == NULL) {
		Cudd_RecursiveDeref(dd,glocal);
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    (*conjuncts)[0] = glocal;
	    return(1);
	}
    } else {
	Cudd_RecursiveDeref(dd,glocal);
	*conjuncts = ALLOC(DdNode *,1);
	if (*conjuncts == NULL) {
	    Cudd_RecursiveDeref(dd,hlocal);
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	(*conjuncts)[0] = hlocal;
	return(1);
    }

} /* end of Cudd_bddVarConjDecomp */


/**
  @brief Performs two-way disjunctive decomposition of a %BDD.

  @details Performs two-way disjunctive decomposition of a %BDD
  according to a variable. If <code>f</code> is the function of the
  %BDD and <code>x</code> is the variable, the decomposition is
  <code>f*x + f*x'</code>.  The variable is chosen so as to balance
  the sizes of the two disjuncts and to keep them small.

  @return the number of disjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise.

  @sideeffect The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.

  @see Cudd_bddVarConjDecomp Cudd_bddApproxDisjDecomp
  Cudd_bddIterDisjDecomp Cudd_bddGenDisjDecomp

*/
int
Cudd_bddVarDisjDecomp(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be decomposed */,
  DdNode *** disjuncts /**< address of the array of the disjuncts */)
{
    int result, i;

    result = Cudd_bddVarConjDecomp(dd,Cudd_Not(f),disjuncts);
    for (i = 0; i < result; i++) {
	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
    }
    return(result);

} /* end of Cudd_bddVarDisjDecomp */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Get longest distance of node from constant.

  @return the distance of the root from the constant if successful;
  CUDD_OUT_OF_MEM otherwise.

  @sideeffect None

*/
static NodeStat *
CreateBotDist(
  DdNode * node,
  st_table * distanceTable)
{
    DdNode *N, *Nv, *Nnv;
    int distance, distanceNv, distanceNnv;
    NodeStat *nodeStat, *nodeStatNv, *nodeStatNnv;

#if 0
    if (Cudd_IsConstantInt(node)) {
	return(0);
    }
#endif
    
    /* Return the entry in the table if found. */
    N = Cudd_Regular(node);
    if (st_lookup(distanceTable, N, (void **) &nodeStat)) {
	nodeStat->localRef++;
	return(nodeStat);
    }

    Nv = cuddT(N);
    Nnv = cuddE(N);
    Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
    Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

    /* Recur on the children. */
    nodeStatNv = CreateBotDist(Nv, distanceTable);
    if (nodeStatNv == NULL) return(NULL);
    distanceNv = nodeStatNv->distance;

    nodeStatNnv = CreateBotDist(Nnv, distanceTable);
    if (nodeStatNnv == NULL) return(NULL);
    distanceNnv = nodeStatNnv->distance;
    /* Store max distance from constant; note sometimes this distance
    ** may be to 0.
    */
    distance = (distanceNv > distanceNnv) ? (distanceNv+1) : (distanceNnv + 1);

    nodeStat = ALLOC(NodeStat, 1);
    if (nodeStat == NULL) {
	return(0);
    }
    nodeStat->distance = distance;
    nodeStat->localRef = 1;
    
    if (st_insert(distanceTable, N, nodeStat) ==
	ST_OUT_OF_MEM) {
	return(0);

    }
    return(nodeStat);

} /* end of CreateBotDist */


/**
  @brief Count the number of minterms of each node ina a %BDD and
  store it in a hash table.

  @sideeffect None

*/
static double
CountMinterms(
  DdManager * dd,
  DdNode * node,
  double  max,
  st_table * mintermTable,
  FILE *fp)
{
    DdNode *N, *Nv, *Nnv;
    double min, minNv, minNnv;
    double *dummy;

    N = Cudd_Regular(node);

    if (cuddIsConstant(N)) {
        if (node == Cudd_Not(DD_ONE(dd))) {
	    return(0);
	} else {
	    return(max);
	}
    }

    /* Return the entry in the table if found. */
    if (st_lookup(mintermTable, node, (void **) &dummy)) {
        min = *dummy;
	return(min);
    }

    Nv = cuddT(N);
    Nnv = cuddE(N);
    Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
    Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

    /* Recur on the children. */
    minNv = CountMinterms(dd, Nv, max, mintermTable, fp);
    if (minNv == -1.0) return(-1.0);
    minNnv = CountMinterms(dd, Nnv, max, mintermTable, fp);
    if (minNnv == -1.0) return(-1.0);
    min = minNv / 2.0 + minNnv / 2.0;
    /* store 
     */

    dummy = ALLOC(double, 1);
    if (dummy == NULL) return(-1.0);
    *dummy = min;
    if (st_insert(mintermTable, node, dummy) == ST_OUT_OF_MEM) {
	(void) fprintf(fp, "st table insert failed\n");
    }
    return(min);

} /* end of CountMinterms */


/**
  @brief Free factors structure

  @sideeffect None

*/
static void
ConjunctsFree(
  DdManager * dd,
  Conjuncts * factors)
{
    Cudd_RecursiveDeref(dd, factors->g);
    Cudd_RecursiveDeref(dd, factors->h);
    FREE(factors);
    return;

} /* end of ConjunctsFree */


/**
  @brief Check whether the given pair is in the tables.

  @details gTable and hTable are combined.
  absence in both is indicated by 0,
  presence in gTable is indicated by 1,
  presence in hTable by 2 and
  presence in both by 3.
  The values returned by this function are PAIR_ST,
  PAIR_CR, G_ST, G_CR, H_ST, H_CR, BOTH_G, BOTH_H, NONE.
  PAIR_ST implies g in gTable and h in hTable
  PAIR_CR implies g in hTable and h in gTable
  G_ST implies g in gTable and h not in any table
  G_CR implies g in hTable and h not in any table
  H_ST implies h in hTable and g not in any table
  H_CR implies h in gTable and g not in any table
  BOTH_G implies both in gTable
  BOTH_H implies both in hTable
  NONE implies none in table; 

  @see CheckTablesCacheAndReturn CheckInTables

*/
static int
PairInTables(
  DdNode * g,
  DdNode * h,
  st_table * ghTable)
{
    int valueG, valueH, gPresent, hPresent;

    valueG = valueH = gPresent = hPresent = 0;
    
    gPresent = st_lookup_int(ghTable, Cudd_Regular(g), &valueG);
    hPresent = st_lookup_int(ghTable, Cudd_Regular(h), &valueH);

    if (!gPresent && !hPresent) return(NONE);

    if (!hPresent) {
	if (valueG & 1) return(G_ST);
	if (valueG & 2) return(G_CR);
    }
    if (!gPresent) {
	if (valueH & 1) return(H_CR);
	if (valueH & 2) return(H_ST);
    }
    /* both in tables */
    if ((valueG & 1) && (valueH & 2)) return(PAIR_ST);
    if ((valueG & 2) && (valueH & 1)) return(PAIR_CR);
    
    if (valueG & 1) {
	return(BOTH_G);
    } else {
	return(BOTH_H);
    }
    
} /* end of PairInTables */


/**
  @brief Check the tables for the existence of pair and return one
  combination, cache the result.

  @details The assumption is that one of the conjuncts is already in
  the tables.

  @sideeffect g and h referenced for the cache

  @see ZeroCase

*/
static Conjuncts *
CheckTablesCacheAndReturn(
  DdManager * manager,
  DdNode * node,
  DdNode * g,
  DdNode * h,
  st_table * ghTable,
  st_table * cacheTable)
{
    int pairValue;
    int value;
    Conjuncts *factors;
    
    value = 0;
    /* check tables */
    pairValue = PairInTables(g, h, ghTable);
    assert(pairValue != NONE);
    /* if both dont exist in table, we know one exists(either g or h).
     * Therefore store the other and proceed
     */
    factors = ALLOC(Conjuncts, 1);
    if (factors == NULL) return(NULL);
    if ((pairValue == BOTH_H) || (pairValue == H_ST)) {
	if (g != DD_ONE(manager)) {
	    value = 0;
	    if (st_lookup_int(ghTable, Cudd_Regular(g), &value)) {
		value |= 1;
	    } else {
		value = 1;
	    }
	    if (st_insert(ghTable, Cudd_Regular(g),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		return(NULL);
	    }
	}
	factors->g = g;
	factors->h = h;
    } else  if ((pairValue == BOTH_G) || (pairValue == G_ST)) {
	if (h != DD_ONE(manager)) {
	    value = 0;
	    if (st_lookup_int(ghTable, Cudd_Regular(h), &value)) {
		value |= 2;
	    } else {
		value = 2;
	    }
	    if (st_insert(ghTable, Cudd_Regular(h),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		return(NULL);
	    }
	}
	factors->g = g;
	factors->h = h;
    } else if (pairValue == H_CR) {
	if (g != DD_ONE(manager)) {
	    value = 2;
	    if (st_insert(ghTable, Cudd_Regular(g),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		return(NULL);
	    }
	}
	factors->g = h;
	factors->h = g;
    } else if (pairValue == G_CR) {
	if (h != DD_ONE(manager)) {
	    value = 1;
	    if (st_insert(ghTable, Cudd_Regular(h),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		return(NULL);
	    }
	}
	factors->g = h;
	factors->h = g;
    } else if (pairValue == PAIR_CR) {
    /* pair exists in table */
	factors->g = h;
	factors->h = g;
    } else if (pairValue == PAIR_ST) {
	factors->g = g;
	factors->h = h;
    }
	    
    /* cache the result for this node */
    if (st_insert(cacheTable, node, factors) == ST_OUT_OF_MEM) {
	FREE(factors);
	return(NULL);
    }

    return(factors);

} /* end of CheckTablesCacheAndReturn */
	
/**
  @brief Check the tables for the existence of pair and return one
  combination, store in cache.

  @details The pair that has more pointers to it is picked. An
  approximation of the number of local pointers is made by taking the
  reference count of the pairs sent.

  @see ZeroCase BuildConjuncts

*/
static Conjuncts *
PickOnePair(
  DdManager * manager,
  DdNode * node,
  DdNode * g1,
  DdNode * h1,
  DdNode * g2,
  DdNode * h2,
  st_table * ghTable,
  st_table * cacheTable)
{
    int value;
    Conjuncts *factors;
    int oneRef, twoRef;
    
    factors = ALLOC(Conjuncts, 1);
    if (factors == NULL) return(NULL);

    /* count the number of pointers to pair 2 */
    if (h2 == DD_ONE(manager)) {
	twoRef = (Cudd_Regular(g2))->ref;
    } else if (g2 == DD_ONE(manager)) {
	twoRef = (Cudd_Regular(h2))->ref;
    } else {
	twoRef = ((Cudd_Regular(g2))->ref + (Cudd_Regular(h2))->ref)/2;
    }

    /* count the number of pointers to pair 1 */
    if (h1 == DD_ONE(manager)) {
	oneRef  = (Cudd_Regular(g1))->ref;
    } else if (g1 == DD_ONE(manager)) {
	oneRef  = (Cudd_Regular(h1))->ref;
    } else {
	oneRef = ((Cudd_Regular(g1))->ref + (Cudd_Regular(h1))->ref)/2;
    }

    /* pick the pair with higher reference count */
    if (oneRef >= twoRef) {
	factors->g = g1;
	factors->h = h1;
    } else {
	factors->g = g2;
	factors->h = h2;
    }
    
    /*
     * Store computed factors in respective tables to encourage
     * recombination.
     */
    if (factors->g != DD_ONE(manager)) {
	/* insert g in htable */
	value = 0;
	if (st_lookup_int(ghTable, Cudd_Regular(factors->g), &value)) {
	    if (value == 2) {
		value |= 1;
		if (st_insert(ghTable, Cudd_Regular(factors->g),
			      (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		    FREE(factors);
		    return(NULL);
		}
	    }
	} else {
	    value = 1;
	    if (st_insert(ghTable, Cudd_Regular(factors->g),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		FREE(factors);
		return(NULL);
	    }
	}
    }

    if (factors->h != DD_ONE(manager)) {
	/* insert h in htable */
	value = 0;
	if (st_lookup_int(ghTable, Cudd_Regular(factors->h), &value)) {
	    if (value == 1) {
		value |= 2;
		if (st_insert(ghTable, Cudd_Regular(factors->h),
			      (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		    FREE(factors);
		    return(NULL);
		}
	    }	    
	} else {
	    value = 2;
	    if (st_insert(ghTable, Cudd_Regular(factors->h),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		FREE(factors);
		return(NULL);
	    }
	}
    }
    
    /* Store factors in cache table for later use. */
    if (st_insert(cacheTable, node, factors) ==
	    ST_OUT_OF_MEM) {
	FREE(factors);
	return(NULL);
    }

    return(factors);

} /* end of PickOnePair */


/**
  @brief Check if the two pairs exist in the table.

  @details If any of the conjuncts do exist, store in the cache and
  return the corresponding pair.

  @see ZeroCase BuildConjuncts

*/
static Conjuncts *
CheckInTables(
  DdManager * manager,
  DdNode * node,
  DdNode * g1,
  DdNode * h1,
  DdNode * g2,
  DdNode * h2,
  st_table * ghTable,
  st_table * cacheTable,
  int * outOfMem)
{
    int pairValue1,  pairValue2;
    Conjuncts *factors;
    int value;
    
    *outOfMem = 0;

    /* check existence of pair in table */
    pairValue1 = PairInTables(g1, h1, ghTable);
    pairValue2 = PairInTables(g2, h2, ghTable);

    /* if none of the 4 exist in the gh tables, return NULL */
    if ((pairValue1 == NONE) && (pairValue2 == NONE)) {
	return NULL;
    }
    
    factors = ALLOC(Conjuncts, 1);
    if (factors == NULL) {
	*outOfMem = 1;
	return NULL;
    }

    /* pairs that already exist in the table get preference. */
    if (pairValue1 == PAIR_ST) {
	factors->g = g1;
	factors->h = h1;
    } else if (pairValue2 == PAIR_ST) {
	factors->g = g2;
	factors->h = h2;
    } else if (pairValue1 == PAIR_CR) {
	factors->g = h1;
	factors->h = g1;
    } else if (pairValue2 == PAIR_CR) {
	factors->g = h2;
	factors->h = g2;
    } else if (pairValue1 == G_ST) {
	/* g exists in the table, h is not found in either table */
	factors->g = g1;
	factors->h = h1;
	if (h1 != DD_ONE(manager)) {
	    value = 2;
	    if (st_insert(ghTable, Cudd_Regular(h1),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue1 == BOTH_G) {
	/* g and h are  found in the g table */
	factors->g = g1;
	factors->h = h1;
	if (h1 != DD_ONE(manager)) {
	    value = 3;
	    if (st_insert(ghTable, Cudd_Regular(h1),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue1 == H_ST) {
	/* h exists in the table, g is not found in either table */
	factors->g = g1;
	factors->h = h1;
	if (g1 != DD_ONE(manager)) {
	    value = 1;
	    if (st_insert(ghTable, Cudd_Regular(g1),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue1 == BOTH_H) {
	/* g and h are  found in the h table */
	factors->g = g1;
	factors->h = h1;
	if (g1 != DD_ONE(manager)) {
	    value = 3;
	    if (st_insert(ghTable, Cudd_Regular(g1),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue2 == G_ST) {
	/* g exists in the table, h is not found in either table */
	factors->g = g2;
	factors->h = h2;
	if (h2 != DD_ONE(manager)) {
	    value = 2;
	    if (st_insert(ghTable, Cudd_Regular(h2),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if  (pairValue2 == BOTH_G) {
	/* g and h are  found in the g table */
	factors->g = g2;
	factors->h = h2;
	if (h2 != DD_ONE(manager)) {
	    value = 3;
	    if (st_insert(ghTable, Cudd_Regular(h2),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue2 == H_ST) { 
	/* h exists in the table, g is not found in either table */
	factors->g = g2;
	factors->h = h2;
	if (g2 != DD_ONE(manager)) {
	    value = 1;
	    if (st_insert(ghTable, Cudd_Regular(g2),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue2 == BOTH_H) {
	/* g and h are  found in the h table */
	factors->g = g2;
	factors->h = h2;
	if (g2 != DD_ONE(manager)) {
	    value = 3;
	    if (st_insert(ghTable, Cudd_Regular(g2),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue1 == G_CR) {
	/* g found in h table and h in none */
	factors->g = h1;
	factors->h = g1;
	if (h1 != DD_ONE(manager)) {
	    value = 1;
	    if (st_insert(ghTable, Cudd_Regular(h1),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue1 == H_CR) {
	/* h found in g table and g in none */
	factors->g = h1;
	factors->h = g1;
	if (g1 != DD_ONE(manager)) {
	    value = 2;
	    if (st_insert(ghTable, Cudd_Regular(g1),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue2 == G_CR) {
	/* g found in h table and h in none */
	factors->g = h2;
	factors->h = g2;
	if (h2 != DD_ONE(manager)) {
	    value = 1;
	    if (st_insert(ghTable, Cudd_Regular(h2),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    } else if (pairValue2 == H_CR) {
	/* h found in g table and g in none */
	factors->g = h2;
	factors->h = g2;
	if (g2 != DD_ONE(manager)) {
	    value = 2;
	    if (st_insert(ghTable, Cudd_Regular(g2),
			  (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		*outOfMem = 1;
		FREE(factors);
		return(NULL);
	    }
	}
    }
    
    /* Store factors in cache table for later use. */
    if (st_insert(cacheTable, node, factors) ==
	    ST_OUT_OF_MEM) {
	*outOfMem = 1;
	FREE(factors);
	return(NULL);
    }
    return factors;
} /* end of CheckInTables */



/**
  @brief If one child is zero, do explicitly what Restrict does or better

  @details First separate a variable and its child in the base
  case. In case of a cube times a function, separate the cube and
  function. As a last resort, look in tables.

  @sideeffect Frees the BDDs in factorsNv. factorsNv itself is not freed
  because it is freed above.

  @see BuildConjuncts

*/
static Conjuncts *
ZeroCase(
  DdManager * dd,
  DdNode * node,
  Conjuncts * factorsNv,
  st_table * ghTable,
  st_table * cacheTable,
  int switched)
{
    int topid;
    DdNode *g, *h, *g1, *g2, *h1, *h2, *x, *N, *G, *H, *Gv, *Gnv;
    DdNode *Hv, *Hnv;
    int value;
    int outOfMem;
    Conjuncts *factors;
    
    /* get var at this node */
    N = Cudd_Regular(node);
    topid = N->index;
    x = dd->vars[topid];
    x = (switched) ? Cudd_Not(x): x;
    cuddRef(x);

    /* Seprate variable and child */
    if (factorsNv->g == DD_ONE(dd)) {
	Cudd_RecursiveDeref(dd, factorsNv->g);
	factors = ALLOC(Conjuncts, 1);
	if (factors == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    Cudd_RecursiveDeref(dd, factorsNv->h);
	    Cudd_RecursiveDeref(dd, x);
	    return(NULL);
	}
	factors->g = x;
	factors->h = factorsNv->h;
	/* cache the result*/
	if (st_insert(cacheTable, node, factors) == ST_OUT_OF_MEM) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    Cudd_RecursiveDeref(dd, factorsNv->h); 
	    Cudd_RecursiveDeref(dd, x);
	    FREE(factors);
	    return NULL;
	}
	
	/* store  x in g table, the other node is already in the table */
	if (st_lookup_int(ghTable, Cudd_Regular(x), &value)) {
	    value |= 1;
	} else {
	    value = 1;
	}
	if (st_insert(ghTable, Cudd_Regular(x), (void *)(ptruint)value) == ST_OUT_OF_MEM) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return NULL;
	}
	return(factors);
    }
    
    /* Seprate variable and child */
    if (factorsNv->h == DD_ONE(dd)) {
	Cudd_RecursiveDeref(dd, factorsNv->h);
	factors = ALLOC(Conjuncts, 1);
	if (factors == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    Cudd_RecursiveDeref(dd, factorsNv->g);
	    Cudd_RecursiveDeref(dd, x);
	    return(NULL);
	}
	factors->g = factorsNv->g;
	factors->h = x;
	/* cache the result. */
 	if (st_insert(cacheTable, node, factors) == ST_OUT_OF_MEM) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    Cudd_RecursiveDeref(dd, factorsNv->g);
	    Cudd_RecursiveDeref(dd, x);
	    FREE(factors);
	    return(NULL);
	}
	/* store x in h table,  the other node is already in the table */
	if (st_lookup_int(ghTable, Cudd_Regular(x), &value)) {
	    value |= 2;
	} else {
	    value = 2;
	}
	if (st_insert(ghTable, Cudd_Regular(x), (void *)(ptruint)value) == ST_OUT_OF_MEM) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return NULL;
	}
	return(factors);
    }

    G = Cudd_Regular(factorsNv->g);
    Gv = cuddT(G);
    Gnv = cuddE(G);
    Gv = Cudd_NotCond(Gv, Cudd_IsComplement(node));
    Gnv = Cudd_NotCond(Gnv, Cudd_IsComplement(node));
    /* if the child below is a variable */
    if ((Gv == Cudd_Not(DD_ONE(dd))) || (Gnv == Cudd_Not(DD_ONE(dd)))) {
	h = factorsNv->h;
	g = cuddBddAndRecur(dd, x, factorsNv->g);
	if (g != NULL) 	cuddRef(g);
	Cudd_RecursiveDeref(dd, factorsNv->g); 
	Cudd_RecursiveDeref(dd, x);
	if (g == NULL) {
	    Cudd_RecursiveDeref(dd, factorsNv->h); 
	    return NULL;
	}
	/* CheckTablesCacheAndReturn responsible for allocating
	 * factors structure., g,h referenced for cache store  the
	 */
	factors = CheckTablesCacheAndReturn(dd,
					    node,
					    g,
					    h,
					    ghTable,
					    cacheTable);
	if (factors == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    Cudd_RecursiveDeref(dd, g);
	    Cudd_RecursiveDeref(dd, h);
	}
	return(factors); 
    }

    H = Cudd_Regular(factorsNv->h);
    Hv = cuddT(H);
    Hnv = cuddE(H);
    Hv = Cudd_NotCond(Hv, Cudd_IsComplement(node));
    Hnv = Cudd_NotCond(Hnv, Cudd_IsComplement(node));
    /* if the child below is a variable */
    if ((Hv == Cudd_Not(DD_ONE(dd))) || (Hnv == Cudd_Not(DD_ONE(dd)))) {
	g = factorsNv->g;
	h = cuddBddAndRecur(dd, x, factorsNv->h);
	if (h!= NULL) cuddRef(h);
	Cudd_RecursiveDeref(dd, factorsNv->h);
	Cudd_RecursiveDeref(dd, x);
	if (h == NULL) {
	    Cudd_RecursiveDeref(dd, factorsNv->g);
	    return NULL;
	}
	/* CheckTablesCacheAndReturn responsible for allocating
	 * factors structure.g,h referenced for table store 
	 */
	factors = CheckTablesCacheAndReturn(dd,
					    node,
					    g,
					    h,
					    ghTable,
					    cacheTable);
	if (factors == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    Cudd_RecursiveDeref(dd, g);
	    Cudd_RecursiveDeref(dd, h);
	}
	return(factors); 
    }

    /* build g1 = x*g; h1 = h */
    /* build g2 = g; h2 = x*h */
    Cudd_RecursiveDeref(dd, x);
    h1 = factorsNv->h;
    g1 = cuddBddAndRecur(dd, x, factorsNv->g);
    if (g1 != NULL) cuddRef(g1);
    if (g1 == NULL) {
	Cudd_RecursiveDeref(dd, factorsNv->g); 
	Cudd_RecursiveDeref(dd, factorsNv->h);
	return NULL;
    }
    
    g2 = factorsNv->g;
    h2 = cuddBddAndRecur(dd, x, factorsNv->h);
    if (h2 != NULL) cuddRef(h2);
    if (h2 == NULL) {
	Cudd_RecursiveDeref(dd, factorsNv->h);
	Cudd_RecursiveDeref(dd, factorsNv->g);
	return NULL;
    }

    /* check whether any pair is in tables */
    factors = CheckInTables(dd, node, g1, h1, g2, h2, ghTable, cacheTable, &outOfMem);
    if (outOfMem) {
	dd->errorCode = CUDD_MEMORY_OUT;
	Cudd_RecursiveDeref(dd, g1);
	Cudd_RecursiveDeref(dd, h1);
	Cudd_RecursiveDeref(dd, g2);
	Cudd_RecursiveDeref(dd, h2);
	return NULL;
    }
    if (factors != NULL) {
	if ((factors->g == g1) || (factors->g == h1)) {
	    Cudd_RecursiveDeref(dd, g2);
	    Cudd_RecursiveDeref(dd, h2);
	} else {
	    Cudd_RecursiveDeref(dd, g1);
	    Cudd_RecursiveDeref(dd, h1);
	}
	return factors;
    }

    /* check for each pair in tables and choose one */
    factors = PickOnePair(dd, node,g1, h1, g2, h2, ghTable, cacheTable);
    if (factors == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	Cudd_RecursiveDeref(dd, g1);
	Cudd_RecursiveDeref(dd, h1);
	Cudd_RecursiveDeref(dd, g2);
	Cudd_RecursiveDeref(dd, h2);
    } else {
	/* now free what was created and not used */
	if ((factors->g == g1) || (factors->g == h1)) {
	    Cudd_RecursiveDeref(dd, g2);
	    Cudd_RecursiveDeref(dd, h2);
	} else {
	    Cudd_RecursiveDeref(dd, g1);
	    Cudd_RecursiveDeref(dd, h1);
	}
    }
	
    return(factors);
} /* end of ZeroCase */


/**
  @brief Builds the conjuncts recursively, bottom up.

  @details Constants are returned as (f, f). The cache is checked for
  previously computed result. The decomposition points are determined
  by the local reference count of this node and the longest distance
  from the constant. At the decomposition point, the factors returned
  are (f, 1). Recur on the two children. The order is determined by
  the heavier branch. Combine the factors of the two children and pick
  the one that already occurs in the gh table. Occurence in g is
  indicated by value 1, occurence in h by 2, occurence in both by 3.

  @see cuddConjunctsAux

*/
static Conjuncts *
BuildConjuncts(
  DdManager * dd,
  DdNode * node,
  st_table * distanceTable,
  st_table * cacheTable,
  int approxDistance,
  int maxLocalRef,
  st_table * ghTable,
  st_table * mintermTable,
  int32_t *lastTimeG)
{
    int topid, distance;
    Conjuncts *factorsNv = NULL, *factorsNnv = NULL, *factors;
    void *dummy;
    DdNode *N, *Nv, *Nnv, *temp, *g1, *g2, *h1, *h2, *topv;
    double minNv = 0.0, minNnv = 0.0;
    double *doubleDummy;
    int switched =0;
    int outOfMem;
    int freeNv = 0, freeNnv = 0, freeTemp;
    NodeStat *nodeStat;
    int value;
    DdNode * const one = DD_ONE(dd);
    DdNode * const zero = Cudd_Not(one);

    /* if f is constant, return (f,f) */
    if (Cudd_IsConstantInt(node)) {
	factors = ALLOC(Conjuncts, 1);
	if (factors == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(NULL);
	}
	factors->g = node;
	factors->h = node;
	return(FactorsComplement(factors));
    }

    /* If result (a pair of conjuncts) in cache, return the factors. */
    if (st_lookup(cacheTable, node, &dummy)) {
        factors = (Conjuncts *) dummy;
	return(factors);
    }

    /* check distance and local reference count of this node */
    N = Cudd_Regular(node);
    if (!st_lookup(distanceTable, N, (void **) &nodeStat)) {
	(void) fprintf(dd->err, "Not in table, Something wrong\n");
	dd->errorCode = CUDD_INTERNAL_ERROR;
	return(NULL);
    }
    distance = nodeStat->distance;

    /* at or below decomposition point, return (f, 1) */
    if (((nodeStat->localRef > maxLocalRef*2/3) &&
	 (distance < approxDistance*2/3)) ||
	    (distance <= approxDistance/4)) {
	factors = ALLOC(Conjuncts, 1);
	if (factors == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(NULL);
	}
	/* alternate assigning (f,1) */
	value = 0;
	if (st_lookup_int(ghTable, Cudd_Regular(node), &value)) {
	    if (value == 3) {
		if (!*lastTimeG) {
		    factors->g = node;
		    factors->h = one;
		    *lastTimeG = 1;
		} else {
		    factors->g = one;
		    factors->h = node;
		    *lastTimeG = 0; 
		}
	    } else if (value == 1) {
		factors->g = node;
		factors->h = one;
	    } else {
		factors->g = one;
		factors->h = node;
	    }
	} else if (!*lastTimeG) {
	    factors->g = node;
	    factors->h = one;
	    *lastTimeG = 1;
	    value = 1;
	    if (st_insert(ghTable, Cudd_Regular(node), (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		dd->errorCode = CUDD_MEMORY_OUT;
		FREE(factors);
		return NULL;
	    }
	} else {
	    factors->g = one;
	    factors->h = node;
	    *lastTimeG = 0;
	    value = 2;
	    if (st_insert(ghTable, Cudd_Regular(node), (void *)(ptruint)value) == ST_OUT_OF_MEM) {
		dd->errorCode = CUDD_MEMORY_OUT;
		FREE(factors);
		return NULL;
	    }
	}
	return(FactorsComplement(factors));
    }

    /* get the children and recur */
    Nv = cuddT(N);
    Nnv = cuddE(N);
    Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
    Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

    /* Choose which subproblem to solve first based on the number of
     * minterms. We go first where there are more minterms.
     */
    if (!Cudd_IsConstantInt(Nv)) {
	if (!st_lookup(mintermTable, Nv, (void **) &doubleDummy)) {
	    (void) fprintf(dd->err, "Not in table: Something wrong\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    return(NULL);
	}
	minNv = *doubleDummy;
    }

    if (!Cudd_IsConstantInt(Nnv)) {
	if (!st_lookup(mintermTable, Nnv, (void **) &doubleDummy)) {
	    (void) fprintf(dd->err, "Not in table: Something wrong\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    return(NULL);
	}
	minNnv = *doubleDummy;
    }

    if (minNv < minNnv) {
	temp = Nv;
	Nv = Nnv;
	Nnv = temp;
	switched = 1;
    }

    /* build gt, ht recursively */
    if (Nv != zero) {
	factorsNv = BuildConjuncts(dd, Nv, distanceTable,
				   cacheTable, approxDistance, maxLocalRef, 
				   ghTable, mintermTable, lastTimeG);
	if (factorsNv == NULL) return(NULL);
	freeNv = FactorsNotStored(factorsNv);
	factorsNv = (freeNv) ? FactorsUncomplement(factorsNv) : factorsNv;
	cuddRef(factorsNv->g);
	cuddRef(factorsNv->h);

	/* Deal with the zero case */
	if (Nnv == zero) {
	    /* is responsible for freeing factorsNv */
	    factors = ZeroCase(dd, node, factorsNv, ghTable,
			       cacheTable, switched);
	    if (freeNv) FREE(factorsNv);
	    return(factors);
	}
    }

    /* build ge, he recursively */
    if (Nnv != zero) {
	factorsNnv = BuildConjuncts(dd, Nnv, distanceTable,
				    cacheTable, approxDistance, maxLocalRef,
				    ghTable, mintermTable, lastTimeG);
	if (factorsNnv == NULL) {
            if (factorsNv != NULL) {
                Cudd_RecursiveDeref(dd, factorsNv->g);
                Cudd_RecursiveDeref(dd, factorsNv->h);
                if (freeNv) FREE(factorsNv);
            }
	    return(NULL);
	}
	freeNnv = FactorsNotStored(factorsNnv);
	factorsNnv = (freeNnv) ? FactorsUncomplement(factorsNnv) : factorsNnv;
	cuddRef(factorsNnv->g);
	cuddRef(factorsNnv->h);
	
	/* Deal with the zero case */
	if (Nv == zero) {
	    /* is responsible for freeing factorsNv */
	    factors = ZeroCase(dd, node, factorsNnv, ghTable,
			       cacheTable, switched);
	    if (freeNnv) FREE(factorsNnv);
	    return(factors);
	}
    }

    /* construct the 2 pairs */
    /* g1 = x*gt + x'*ge; h1 = x*ht + x'*he; */
    /* g2 = x*gt + x'*he; h2 = x*ht + x'*ge */
    if (switched) {
	factors = factorsNnv;
	factorsNnv = factorsNv;
	factorsNv = factors;
	freeTemp = freeNv;
	freeNv = freeNnv;
	freeNnv = freeTemp;
    }

    /* Build the factors for this node. */
    topid = N->index;
    topv = dd->vars[topid];

    g1 = cuddBddIteRecur(dd, topv, factorsNv->g, factorsNnv->g);
    if (g1 == NULL) {
	Cudd_RecursiveDeref(dd, factorsNv->g);
	Cudd_RecursiveDeref(dd, factorsNv->h);
	Cudd_RecursiveDeref(dd, factorsNnv->g);
	Cudd_RecursiveDeref(dd, factorsNnv->h);
	if (freeNv) FREE(factorsNv);
	if (freeNnv) FREE(factorsNnv);
	return(NULL);
    }

    cuddRef(g1);

    h1 = cuddBddIteRecur(dd, topv, factorsNv->h, factorsNnv->h);
    if (h1 == NULL) {
	Cudd_RecursiveDeref(dd, factorsNv->g);
	Cudd_RecursiveDeref(dd, factorsNv->h);
	Cudd_RecursiveDeref(dd, factorsNnv->g);
	Cudd_RecursiveDeref(dd, factorsNnv->h);
	Cudd_RecursiveDeref(dd, g1);
	if (freeNv) FREE(factorsNv);
	if (freeNnv) FREE(factorsNnv);
	return(NULL);
    }

    cuddRef(h1);

    g2 = cuddBddIteRecur(dd, topv, factorsNv->g, factorsNnv->h);
    if (g2 == NULL) {
	Cudd_RecursiveDeref(dd, factorsNv->h);
	Cudd_RecursiveDeref(dd, factorsNv->g);
	Cudd_RecursiveDeref(dd, factorsNnv->g);
	Cudd_RecursiveDeref(dd, factorsNnv->h);
	Cudd_RecursiveDeref(dd, g1);
	Cudd_RecursiveDeref(dd, h1);
	if (freeNv) FREE(factorsNv);
	if (freeNnv) FREE(factorsNnv);
	return(NULL);
    }
    cuddRef(g2);
    Cudd_RecursiveDeref(dd, factorsNv->g);
    Cudd_RecursiveDeref(dd, factorsNnv->h);

    h2 = cuddBddIteRecur(dd, topv, factorsNv->h, factorsNnv->g);
    if (h2 == NULL) {
	Cudd_RecursiveDeref(dd, factorsNv->g);
	Cudd_RecursiveDeref(dd, factorsNv->h);
	Cudd_RecursiveDeref(dd, factorsNnv->g);
	Cudd_RecursiveDeref(dd, factorsNnv->h);
	Cudd_RecursiveDeref(dd, g1);
	Cudd_RecursiveDeref(dd, h1);
	Cudd_RecursiveDeref(dd, g2);
	if (freeNv) FREE(factorsNv);
	if (freeNnv) FREE(factorsNnv);
	return(NULL);
    }
    cuddRef(h2);
    Cudd_RecursiveDeref(dd, factorsNv->h);
    Cudd_RecursiveDeref(dd, factorsNnv->g);
    if (freeNv) FREE(factorsNv);
    if (freeNnv) FREE(factorsNnv);

    /* check for each pair in tables and choose one */
    factors = CheckInTables(dd, node, g1, h1, g2, h2, ghTable, cacheTable, &outOfMem);
    if (outOfMem) {
	dd->errorCode = CUDD_MEMORY_OUT;
	Cudd_RecursiveDeref(dd, g1);
	Cudd_RecursiveDeref(dd, h1);
	Cudd_RecursiveDeref(dd, g2);
	Cudd_RecursiveDeref(dd, h2);
	return(NULL);
    }
    if (factors != NULL) {
	if ((factors->g == g1) || (factors->g == h1)) {
	    Cudd_RecursiveDeref(dd, g2);
	    Cudd_RecursiveDeref(dd, h2);
	} else {
	    Cudd_RecursiveDeref(dd, g1);
	    Cudd_RecursiveDeref(dd, h1);
	}
	return(factors);
    }

    /* if not in tables, pick one pair */
    factors = PickOnePair(dd, node, g1, h1, g2, h2, ghTable, cacheTable);
    if (factors == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	Cudd_RecursiveDeref(dd, g1);
	Cudd_RecursiveDeref(dd, h1);
	Cudd_RecursiveDeref(dd, g2);
	Cudd_RecursiveDeref(dd, h2);
    } else {
	/* now free what was created and not used */
	if ((factors->g == g1) || (factors->g == h1)) {
	    Cudd_RecursiveDeref(dd, g2);
	    Cudd_RecursiveDeref(dd, h2);
	} else {
	    Cudd_RecursiveDeref(dd, g1);
	    Cudd_RecursiveDeref(dd, h1);
	}
    }

    return(factors);

} /* end of BuildConjuncts */


/**
  @brief Computes two conjunctive factors of f and places them in *c1 and *c2.

  @details Sets up the required data - table of distances from the
  constant and local reference count. Also minterm table.

*/
static int
cuddConjunctsAux(
  DdManager * dd,
  DdNode * f,
  DdNode ** c1,
  DdNode ** c2)
{
    st_table *distanceTable = NULL;
    st_table *cacheTable = NULL;
    st_table *mintermTable = NULL;
    st_table *ghTable = NULL;
    st_generator *stGen;
    char *key, *value;
    Conjuncts *factors;
    int distance, approxDistance;
    double max, minterms;
    int freeFactors;
    NodeStat *nodeStat;
    int maxLocalRef;
    int32_t lastTimeG;

    /* initialize */
    *c1 = NULL;
    *c2 = NULL;

    /* initialize distances table */
    distanceTable = st_init_table(st_ptrcmp,st_ptrhash);
    if (distanceTable == NULL) goto outOfMem;
    
    /* make the entry for the constant */
    nodeStat = ALLOC(NodeStat, 1);
    if (nodeStat == NULL) goto outOfMem;
    nodeStat->distance = 0;
    nodeStat->localRef = 1;
    if (st_insert(distanceTable, DD_ONE(dd), nodeStat) == ST_OUT_OF_MEM) {
	goto outOfMem;
    }

    /* Count node distances from constant. */
    nodeStat = CreateBotDist(f, distanceTable);
    if (nodeStat == NULL) goto outOfMem;

    /* set the distance for the decomposition points */
    approxDistance = (DEPTH < nodeStat->distance) ? nodeStat->distance : DEPTH;
    distance = nodeStat->distance;

    if (distance < approxDistance) {
	/* Too small to bother. */
	*c1 = f;
	*c2 = DD_ONE(dd);
	cuddRef(*c1); cuddRef(*c2);
	stGen = st_init_gen(distanceTable);
	if (stGen == NULL) goto outOfMem;
	while(st_gen(stGen, (void **)&key, (void **)&value)) {
	    FREE(value);
	}
	st_free_gen(stGen); stGen = NULL;
	st_free_table(distanceTable);
	return(1);
    }

    /* record the maximum local reference count */
    maxLocalRef = 0;
    stGen = st_init_gen(distanceTable);
    if (stGen == NULL) goto outOfMem;
    while(st_gen(stGen, (void **)&key, (void **)&value)) {
	nodeStat = (NodeStat *)value;
	maxLocalRef = (nodeStat->localRef > maxLocalRef) ?
	    nodeStat->localRef : maxLocalRef;
    }
    st_free_gen(stGen); stGen = NULL;


    /* Count minterms for each node. */
    max = pow(2.0, (double)Cudd_SupportSize(dd,f)); /* potential overflow */
    mintermTable = st_init_table(st_ptrcmp,st_ptrhash);
    if (mintermTable == NULL) goto outOfMem;
    minterms = CountMinterms(dd, f, max, mintermTable, dd->err);
    if (minterms == -1.0) goto outOfMem;
    
    lastTimeG = Cudd_Random(dd) & 1;
    cacheTable = st_init_table(st_ptrcmp, st_ptrhash);
    if (cacheTable == NULL) goto outOfMem;
    ghTable = st_init_table(st_ptrcmp, st_ptrhash);
    if (ghTable == NULL) goto outOfMem;

    /* Build conjuncts. */
    factors = BuildConjuncts(dd, f, distanceTable, cacheTable,
			     approxDistance, maxLocalRef, ghTable,
                             mintermTable, &lastTimeG);
    if (factors == NULL) goto outOfMem;

    /* free up tables */
    stGen = st_init_gen(distanceTable);
    if (stGen == NULL) goto outOfMem;
    while(st_gen(stGen, (void **)&key, (void **)&value)) {
	FREE(value);
    }
    st_free_gen(stGen); stGen = NULL;
    st_free_table(distanceTable); distanceTable = NULL;
    st_free_table(ghTable); ghTable = NULL;
    
    stGen = st_init_gen(mintermTable);
    if (stGen == NULL) goto outOfMem;
    while(st_gen(stGen, (void **)&key, (void **)&value)) {
	FREE(value);
    }
    st_free_gen(stGen); stGen = NULL;
    st_free_table(mintermTable); mintermTable = NULL;

    freeFactors = FactorsNotStored(factors);
    factors = (freeFactors) ? FactorsUncomplement(factors) : factors;
    if (factors != NULL) {
	*c1 = factors->g;
	*c2 = factors->h;
	cuddRef(*c1);
	cuddRef(*c2);
	if (freeFactors) FREE(factors);
	
#if 0    
	if ((*c1 == f) && (!Cudd_IsConstantInt(f))) {
	    assert(*c2 == DD_ONE(manager));
	}
	if ((*c2 == f) && (!Cudd_IsConstantInt(f))) {
	    assert(*c1 == DD_ONE(manager));
	}
	
	if ((*c1 != DD_ONE(manager)) && (!Cudd_IsConstantInt(f))) {
	    assert(!Cudd_bddLeq(dd, *c2, *c1));
	}
	if ((*c2 != DD_ONE(manager)) && (!Cudd_IsConstantInt(f))) {
	    assert(!Cudd_bddLeq(dd, *c1, *c2));
	}
#endif
    }

    stGen = st_init_gen(cacheTable);
    if (stGen == NULL) goto outOfMem;
    while(st_gen(stGen, (void **)&key, (void **)&value)) {
	ConjunctsFree(dd, (Conjuncts *)value);
    }
    st_free_gen(stGen); stGen = NULL;

    st_free_table(cacheTable); cacheTable = NULL;

    return(1);

outOfMem:
    if (distanceTable != NULL) {
	stGen = st_init_gen(distanceTable);
	if (stGen == NULL) goto outOfMem;
	while(st_gen(stGen, (void **)&key, (void **)&value)) {
	    FREE(value);
	}
	st_free_gen(stGen); stGen = NULL;
	st_free_table(distanceTable); distanceTable = NULL;
    }
    if (mintermTable != NULL) {
	stGen = st_init_gen(mintermTable);
	if (stGen == NULL) goto outOfMem;
	while(st_gen(stGen, (void **)&key, (void **)&value)) {
	    FREE(value);
	}
	st_free_gen(stGen); stGen = NULL;
	st_free_table(mintermTable); mintermTable = NULL;
    }
    if (ghTable != NULL) st_free_table(ghTable);
    if (cacheTable != NULL) {
	stGen = st_init_gen(cacheTable);
	if (stGen == NULL) goto outOfMem;
	while(st_gen(stGen, (void **)&key, (void **)&value)) {
	    ConjunctsFree(dd, (Conjuncts *)value);
	}
	st_free_gen(stGen); stGen = NULL;
	st_free_table(cacheTable); cacheTable = NULL;
    }
    dd->errorCode = CUDD_MEMORY_OUT;
    return(0);

} /* end of cuddConjunctsAux */

cuddEssent.c
40003
/**
  @file

  @ingroup cudd

  @brief Functions for the detection of essential variables.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* These definitions are for the bit vectors. */
#if SIZEOF_VOID_P == 8
#define BPL 64
#define LOGBPL 6
#else
#define BPL 32
#define LOGBPL 5
#endif

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
** @brief This structure holds the set of clauses for a node.
** @details Each clause consists of two literals.
** For one-literal clauses, the second literal is FALSE.
** Each literal is composed of a variable and a phase.  A variable is a node
** index, and requires sizeof(DdHalfWord) bytes.  The constant literals use
** CUDD_MAXINDEX as variable indicator.  Each phase is a bit: 0 for positive
** phase, and 1 for negative phase.
** Variables and phases are stored separately for the sake of compactness.
** The variables are stored in an array of DdHalfWord's terminated by a
** sentinel (a pair of zeroes).  The phases are stored in a bit vector.
** The cnt field holds, at the end, the number of clauses.
** The clauses of the set are kept sorted.  For each clause, the first literal
** is the one of least index.  So, the clause with literals +2 and -4 is stored
** as (+2,-4).  A one-literal clause with literal +3 is stored as
** (+3,-CUDD_MAXINDEX).  Clauses are sorted in decreasing order as follows:
** <ul>
** <li> (+5,-7)
** <li> (+5,+6)
** <li> (-5,+7)
** <li> (-4,FALSE)
** <li> (-4,+8)
** <li> ...
** </ul>
** That is, one first looks at the variable of the first literal, then at the
** phase of the first literal, then at the variable of the second literal,
** and finally at the phase of the second literal.
*/
struct DdTlcInfo {
    DdHalfWord *vars;
    ptruint *phases;
    DdHalfWord cnt;
};

/**
** @brief This structure is for temporary representation of sets of clauses.
** @details It is meant to be used in linked lists, when the number of clauses
** is not yet known.  The encoding of a clause is the same as in DdTlcInfo,
** though the phase information is not stored in a bit array.
*/
struct TlClause {
    DdHalfWord v1, v2;
    short p1, p2;
    struct TlClause *next;
};

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef ptruint BitVector;
typedef struct TlClause TlClause;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * ddFindEssentialRecur (DdManager *dd, DdNode *f);
static DdTlcInfo * ddFindTwoLiteralClausesRecur (DdManager * dd, DdNode * f, st_table *table, BitVector *Tolv, BitVector *Tolp, BitVector *Eolv, BitVector *Eolp);
static DdTlcInfo * computeClauses (DdTlcInfo *Tres, DdTlcInfo *Eres, DdHalfWord label, int size, BitVector *Tolv, BitVector *Tolp, BitVector *Eolv, BitVector *Eolp);
static DdTlcInfo * computeClausesWithUniverse (DdTlcInfo *Cres, DdHalfWord label, short phase);
static DdTlcInfo * emptyClauseSet (void);
static int sentinelp (DdHalfWord var1, DdHalfWord var2);
static int equalp (DdHalfWord var1a, short phase1a, DdHalfWord var1b, short phase1b, DdHalfWord var2a, short phase2a, DdHalfWord var2b, short phase2b);
static int beforep (DdHalfWord var1a, short phase1a, DdHalfWord var1b, short phase1b, DdHalfWord var2a, short phase2a, DdHalfWord var2b, short phase2b);
static int oneliteralp (DdHalfWord var);
static int impliedp (DdHalfWord var1, short phase1, DdHalfWord var2, short phase2, BitVector *olv, BitVector *olp);
static BitVector * bitVectorAlloc (int size);
static void bitVectorClear (BitVector *vector, int size);
static void bitVectorFree (BitVector *vector);
static short bitVectorRead (BitVector *vector, int i);
static void bitVectorSet (BitVector * vector, int i, short val);
static DdTlcInfo * tlcInfoAlloc (void);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Finds the essential variables of a %DD.

  @details Returns the cube of the essential variables. A positive
  literal means that the variable must be set to 1 for the function to be
  1. A negative literal means that the variable must be set to 0 for the
  function to be 1.

  @return a pointer to the cube %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddIsVarEssential

*/
DdNode *
Cudd_FindEssential(
  DdManager * dd,
  DdNode * f)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = ddFindEssentialRecur(dd,f);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_FindEssential */


/**
  @brief Determines whether a given variable is essential with a
  given phase in a %BDD.

  @details Uses Cudd_bddIteConstant. Returns 1 if phase == 1 and
  f-->x_id, or if phase == 0 and f-->x_id'.

  @sideeffect None

  @see Cudd_FindEssential

*/
int
Cudd_bddIsVarEssential(
  DdManager * manager,
  DdNode * f,
  int  id,
  int  phase)
{
    DdNode	*var;
    int		res;

    var = Cudd_bddIthVar(manager, id);

    var = Cudd_NotCond(var,phase == 0);

    res = Cudd_bddLeq(manager, f, var);

    return(res);

} /* end of Cudd_bddIsVarEssential */


/**
  @brief Finds the two literal clauses of a %DD.

  @details Returns the one- and two-literal clauses of a %DD.  For a
  constant %DD, the empty set of clauses is returned.  This is
  obviously correct for a non-zero constant.  For the constant zero,
  it is based on the assumption that only those clauses containing
  variables in the support of the function are considered.  Since the
  support of a constant function is empty, no clauses are returned.

  @return a pointer to the structure holding the clauses if
  successful; NULL otherwise.

  @sideeffect None

  @see Cudd_FindEssential

*/
DdTlcInfo *
Cudd_FindTwoLiteralClauses(
  DdManager * dd,
  DdNode * f)
{
    DdTlcInfo *res;
    st_table *table;
    st_generator *gen;
    DdTlcInfo *tlc;
    DdNode *node;
    int size = dd->size;
    BitVector *Tolv, *Tolp, *Eolv, *Eolp;

    if (Cudd_IsConstantInt(f)) {
	res = emptyClauseSet();
	return(res);
    }
    table = st_init_table(st_ptrcmp,st_ptrhash);
    if (table == NULL) return(NULL);
    Tolv = bitVectorAlloc(size);
    if (Tolv == NULL) {
	st_free_table(table);
	return(NULL);
    }
    Tolp = bitVectorAlloc(size);
    if (Tolp == NULL) {
	st_free_table(table);
	bitVectorFree(Tolv);
	return(NULL);
    }
    Eolv = bitVectorAlloc(size);
    if (Eolv == NULL) {
	st_free_table(table);
	bitVectorFree(Tolv);
	bitVectorFree(Tolp);
	return(NULL);
    }
    Eolp = bitVectorAlloc(size);
    if (Eolp == NULL) {
	st_free_table(table);
	bitVectorFree(Tolv);
	bitVectorFree(Tolp);
	bitVectorFree(Eolv);
	return(NULL);
    }

    res = ddFindTwoLiteralClausesRecur(dd,f,table,Tolv,Tolp,Eolv,Eolp);
    /* Dispose of table contents and free table. */
    st_foreach_item(table, gen, (void **) &node, (void **) &tlc) {
	if (node != f) {
	    Cudd_tlcInfoFree(tlc);
	}
    }
    st_free_table(table);
    bitVectorFree(Tolv);
    bitVectorFree(Tolp);
    bitVectorFree(Eolv);
    bitVectorFree(Eolp);

    if (res != NULL) {
	int i;
	for (i = 0; !sentinelp(res->vars[i], res->vars[i+1]); i += 2);
	res->cnt = i >> 1;
    }

    return(res);

} /* end of Cudd_FindTwoLiteralClauses */


/**
  @brief Accesses the i-th clause of a %DD.

  @details Accesses the i-th clause of a %DD given the clause set which
  must be already computed.

  @return 1 if successful; 0 if i is out of range, or in case of
  error.

  @sideeffect the four components of a clause are returned as side effects.

  @see Cudd_FindTwoLiteralClauses

*/
int
Cudd_ReadIthClause(
  DdTlcInfo * tlc,
  int i,
  unsigned *var1,
  unsigned *var2,
  int *phase1,
  int *phase2)
{
    if (tlc == NULL) return(0);
    if (tlc->vars == NULL || tlc->phases == NULL) return(0);
    if (i < 0 || (unsigned) i >= tlc->cnt) return(0);
    *var1 = (unsigned) tlc->vars[2*i];
    *var2 = (unsigned) tlc->vars[2*i+1];
    *phase1 = (int) bitVectorRead(tlc->phases, 2*i);
    *phase2 = (int) bitVectorRead(tlc->phases, 2*i+1);
    return(1);

} /* end of Cudd_ReadIthClause */


/**
  @brief Prints the one- and two-literal clauses of a %DD.

  @details The argument "names" can be NULL, in which case the
  variable indices are printed.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_FindTwoLiteralClauses

*/
int
Cudd_PrintTwoLiteralClauses(
  DdManager * dd,
  DdNode * f,
  char **names,
  FILE *fp)
{
    DdHalfWord *vars;
    BitVector *phases;
    int i;
    DdTlcInfo *res = Cudd_FindTwoLiteralClauses(dd, f);
    FILE *ifp = fp == NULL ? dd->out : fp;

    if (res == NULL) return(0);
    vars = res->vars;
    phases = res->phases;
    for (i = 0; !sentinelp(vars[i], vars[i+1]); i += 2) {
	if (names != NULL) {
	    if (vars[i+1] == CUDD_MAXINDEX) {
		(void) fprintf(ifp, "%s%s\n",
			       bitVectorRead(phases, i) ? "~" : " ",
			       names[vars[i]]);
	    } else {
		(void) fprintf(ifp, "%s%s | %s%s\n",
			       bitVectorRead(phases, i) ? "~" : " ",
			       names[vars[i]],
			       bitVectorRead(phases, i+1) ? "~" : " ",
			       names[vars[i+1]]);
	    }
	} else {
	    if (vars[i+1] == CUDD_MAXINDEX) {
		(void) fprintf(ifp, "%s%d\n",
			       bitVectorRead(phases, i) ? "~" : " ",
			       (int) vars[i]);
	    } else {
		(void) fprintf(ifp, "%s%d | %s%d\n",
			       bitVectorRead(phases, i) ? "~" : " ",
			       (int) vars[i],
			       bitVectorRead(phases, i+1) ? "~" : " ",
			       (int) vars[i+1]);
	    }
	}
    }
    Cudd_tlcInfoFree(res);

    return(1);

} /* end of Cudd_PrintTwoLiteralClauses */


/**
  @brief Frees a DdTlcInfo Structure.

  @details Also frees the memory pointed by it.

  @sideeffect None

*/
void
Cudd_tlcInfoFree(
  DdTlcInfo * t)
{
    if (t->vars != NULL) FREE(t->vars);
    if (t->phases != NULL) FREE(t->phases);
    FREE(t);

} /* end of Cudd_tlcInfoFree */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_FindEssential.

  @return a pointer to the cube %BDD if successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
ddFindEssentialRecur(
  DdManager * dd,
  DdNode * f)
{
    DdNode	*T, *E, *F;
    DdNode	*essT, *essE, *res;
    unsigned	index;
    DdNode	*one, *lzero, *azero;

    one = DD_ONE(dd);
    F = Cudd_Regular(f);
    /* If f is constant the set of essential variables is empty. */
    if (cuddIsConstant(F)) return(one);

    res = cuddCacheLookup1(dd,Cudd_FindEssential,f);
    if (res != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(dd);

    lzero = Cudd_Not(one);
    azero = DD_ZERO(dd);
    /* Find cofactors: here f is non-constant. */
    T = cuddT(F);
    E = cuddE(F);
    if (Cudd_IsComplement(f)) {
	T = Cudd_Not(T); E = Cudd_Not(E);
    }

    index = F->index;
    if (Cudd_IsConstantInt(T) && T != lzero && T != azero) {
	/* if E is zero, index is essential, otherwise there are no
	** essentials, because index is not essential and no other variable
	** can be, since setting index = 1 makes the function constant and
	** different from 0.
	*/
	if (E == lzero || E == azero) {
	    res = dd->vars[index];
	} else {
	    res = one;
	}
    } else if (T == lzero || T == azero) {
	if (Cudd_IsConstantInt(E)) { /* E cannot be zero here */
	    res = Cudd_Not(dd->vars[index]);
	} else { /* E == non-constant */
	    /* find essentials in the else branch */
	    essE = ddFindEssentialRecur(dd,E);
	    if (essE == NULL) {
		return(NULL);
	    }
	    cuddRef(essE);

	    /* add index to the set with negative phase */
	    res = cuddUniqueInter(dd,index,one,Cudd_Not(essE));
	    if (res == NULL) {
		Cudd_RecursiveDeref(dd,essE);
		return(NULL);
	    }
	    res = Cudd_Not(res);
	    cuddDeref(essE);
	}
    } else { /* T == non-const */
	if (E == lzero || E == azero) {
	    /* find essentials in the then branch */
	    essT = ddFindEssentialRecur(dd,T);
	    if (essT == NULL) {
		return(NULL);
	    }
	    cuddRef(essT);

	    /* add index to the set with positive phase */
	    /* use And because essT may be complemented */
	    res = cuddBddAndRecur(dd,dd->vars[index],essT);
	    if (res == NULL) {
		Cudd_RecursiveDeref(dd,essT);
		return(NULL);
	    }
	    cuddDeref(essT);
	} else if (!Cudd_IsConstantInt(E)) {
	    /* if E is a non-zero constant there are no essentials
	    ** because T is non-constant.
	    */
	    essT = ddFindEssentialRecur(dd,T);
	    if (essT == NULL) {
		return(NULL);
	    }
	    if (essT == one) {
		res = one;
	    } else {
		cuddRef(essT);
		essE = ddFindEssentialRecur(dd,E);
		if (essE == NULL) {
		    Cudd_RecursiveDeref(dd,essT);
		    return(NULL);
		}
		cuddRef(essE);

		/* res = intersection(essT, essE) */
		res = cuddBddLiteralSetIntersectionRecur(dd,essT,essE);
		if (res == NULL) {
		    Cudd_RecursiveDeref(dd,essT);
		    Cudd_RecursiveDeref(dd,essE);
		    return(NULL);
		}
		cuddRef(res);
		Cudd_RecursiveDeref(dd,essT);
		Cudd_RecursiveDeref(dd,essE);
		cuddDeref(res);
	    }
	} else {	/* E is a non-zero constant */
	    res = one;
	}
    }

    cuddCacheInsert1(dd,Cudd_FindEssential, f, res);
    return(res);

} /* end of ddFindEssentialRecur */


/**
  @brief Implements the recursive step of Cudd_FindTwoLiteralClauses.

  @details The %DD node is assumed to be not constant.

  @return a pointer to a set of clauses if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_FindTwoLiteralClauses

*/
static DdTlcInfo *
ddFindTwoLiteralClausesRecur(
  DdManager * dd,
  DdNode * f,
  st_table *table,
  BitVector *Tolv,
  BitVector *Tolp,
  BitVector *Eolv,
  BitVector *Eolp)
{
    DdNode *T, *E, *F;
    DdNode *one, *lzero, *azero;
    DdTlcInfo *res, *Tres, *Eres;
    DdHalfWord index;

    F = Cudd_Regular(f);

    assert(!cuddIsConstant(F));

    /* Check computed table.  Separate entries are necessary for
    ** a node and its complement.  We should update the counter here. */
    if (st_lookup(table, f, (void **) &res)) {
	return(res);
    }

    /* Easy access to the constants for BDDs and ADDs. */
    one = DD_ONE(dd);
    lzero = Cudd_Not(one);
    azero = DD_ZERO(dd);

    /* Find cofactors and variable labeling the top node. */
    T = cuddT(F); E = cuddE(F);
    if (Cudd_IsComplement(f)) {
	T = Cudd_Not(T); E = Cudd_Not(E);
    }
    index = F->index;

    if (Cudd_IsConstantInt(T) && T != lzero && T != azero) {
	/* T is a non-zero constant.  If E is zero, then this node's index
	** is a one-literal clause.  Otherwise, if E is a non-zero
	** constant, there are no clauses for this node.  Finally,
	** if E is not constant, we recursively compute its clauses, and then
	** merge using the empty set for T. */
	if (E == lzero || E == azero) {
	    /* Create the clause (index + 0). */
	    res = tlcInfoAlloc();
	    if (res == NULL) return(NULL);
	    res->vars = ALLOC(DdHalfWord,4);
	    if (res->vars == NULL) {
		FREE(res);
		return(NULL);
	    }
	    res->phases = bitVectorAlloc(2);
	    if (res->phases == NULL) {
		FREE(res->vars);
		FREE(res);
		return(NULL);
	    }
	    res->vars[0] = index;
	    res->vars[1] = CUDD_MAXINDEX;
	    res->vars[2] = 0;
	    res->vars[3] = 0;
	    bitVectorSet(res->phases, 0, 0); /* positive phase */
	    bitVectorSet(res->phases, 1, 1); /* negative phase */
	} else if (Cudd_IsConstantInt(E)) {
	    /* If E is a non-zero constant, no clauses. */
	    res = emptyClauseSet();
	} else {
	    /* E is non-constant */
	    Tres = emptyClauseSet();
	    if (Tres == NULL) return(NULL);
	    Eres = ddFindTwoLiteralClausesRecur(dd, E, table,
                                                Tolv, Tolp, Eolv, Eolp);
	    if (Eres == NULL) {
		Cudd_tlcInfoFree(Tres);
		return(NULL);
	    }
	    res = computeClauses(Tres, Eres, index, dd->size,
                                 Tolv, Tolp, Eolv, Eolp);
	    Cudd_tlcInfoFree(Tres);
	}
    } else if (T == lzero || T == azero) {
	/* T is zero.  If E is a non-zero constant, then the
	** complement of this node's index is a one-literal clause.
	** Otherwise, if E is not constant, we recursively compute its
	** clauses, and then merge using the universal set for T. */
	if (Cudd_IsConstantInt(E)) { /* E cannot be zero here */
	    /* Create the clause (!index + 0). */
	    res = tlcInfoAlloc();
	    if (res == NULL) return(NULL);
	    res->vars = ALLOC(DdHalfWord,4);
	    if (res->vars == NULL) {
		FREE(res);
		return(NULL);
	    }
	    res->phases = bitVectorAlloc(2);
	    if (res->phases == NULL) {
		FREE(res->vars);
		FREE(res);
		return(NULL);
	    }
	    res->vars[0] = index;
	    res->vars[1] = CUDD_MAXINDEX;
	    res->vars[2] = 0;
	    res->vars[3] = 0;
	    bitVectorSet(res->phases, 0, 1); /* negative phase */
	    bitVectorSet(res->phases, 1, 1); /* negative phase */
	} else { /* E == non-constant */
	    Eres = ddFindTwoLiteralClausesRecur(dd, E, table,
                                                Tolv, Tolp, Eolv, Eolp);
	    if (Eres == NULL) return(NULL);
	    res = computeClausesWithUniverse(Eres, index, 1);
	}
    } else { /* T == non-const */
	Tres = ddFindTwoLiteralClausesRecur(dd, T, table,
                                            Tolv, Tolp, Eolv, Eolp);
	if (Tres == NULL) return(NULL);
	if (Cudd_IsConstantInt(E)) {
	    if (E == lzero || E == azero) {
		res = computeClausesWithUniverse(Tres, index, 0);
	    } else {
		Eres = emptyClauseSet();
		if (Eres == NULL) return(NULL);
		res = computeClauses(Tres, Eres, index, dd->size,
                                     Tolv, Tolp, Eolv, Eolp);
		Cudd_tlcInfoFree(Eres);
	    }
	} else {
	    Eres = ddFindTwoLiteralClausesRecur(dd, E, table,
                                                Tolv, Tolp, Eolv, Eolp);
	    if (Eres == NULL) return(NULL);
	    res = computeClauses(Tres, Eres, index, dd->size,
                                 Tolv, Tolp, Eolv, Eolp);
	}
    }

    /* Cache results. */
    if (st_add_direct(table, f, res) == ST_OUT_OF_MEM) {
	FREE(res);
	return(NULL);
    }
    return(res);

} /* end of ddFindTwoLiteralClausesRecur */


/**
  @brief Computes the two-literal clauses for a node.

  @details Computes the two-literal clauses for a node given the
  clauses for its children and the label of the node.

  @return a pointer to a TclInfo structure if successful; NULL
  otherwise.

  @sideeffect None

  @see computeClausesWithUniverse

*/
static DdTlcInfo *
computeClauses(
  DdTlcInfo *Tres /**< list of clauses for T child */,
  DdTlcInfo *Eres /**< list of clauses for E child */,
  DdHalfWord label /**< variable labeling the current node */,
  int size /**< number of variables in the manager */,
  BitVector *Tolv /**< variable bit vector for T child */,
  BitVector *Tolp /**< phase bit vector for T child */,
  BitVector *Eolv /**< variable bit vector for E child */,
  BitVector *Eolp /**< phase bit vector for E child */)
{
    DdHalfWord *Tcv = Tres->vars; /* variables of clauses for the T child */
    BitVector *Tcp = Tres->phases; /* phases of clauses for the T child */
    DdHalfWord *Ecv = Eres->vars; /* variables of clauses for the E child */
    BitVector *Ecp = Eres->phases; /* phases of clauses for the E child */
    DdHalfWord *Vcv = NULL; /* pointer to variables of the clauses for v */
    BitVector *Vcp = NULL; /* pointer to phases of the clauses for v */
    DdTlcInfo *res = NULL; /* the set of clauses to be returned */
    int pt = 0; /* index in the list of clauses of T */
    int pe = 0; /* index in the list of clauses of E */
    int cv = 0; /* counter of the clauses for this node */
    TlClause *iclauses = NULL; /* list of inherited clauses */
    TlClause *tclauses = NULL; /* list of 1-literal clauses of T */
    TlClause *eclauses = NULL; /* list of 1-literal clauses of E */
    TlClause *nclauses = NULL; /* list of new (non-inherited) clauses */
    TlClause *lnclause = NULL; /* pointer to last new clause */
    TlClause *newclause; /* temporary pointer to new clauses */

    /* Initialize sets of one-literal clauses.  The one-literal clauses
    ** are stored redundantly.  These sets allow constant-time lookup, which
    ** we need when we check for implication of a two-literal clause by a
    ** one-literal clause.  The linked lists allow fast sequential
    ** processing. */
    bitVectorClear(Tolv, size);
    bitVectorClear(Tolp, size);
    bitVectorClear(Eolv, size);
    bitVectorClear(Eolp, size);

    /* Initialize result structure. */
    res = tlcInfoAlloc();
    if (res == NULL) goto cleanup;

    /* Scan the two input list.  Extract inherited two-literal clauses
    ** and set aside one-literal clauses from each list.  The incoming lists
    ** are sorted in the order defined by beforep.  The three linked list
    ** produced by this loop are sorted in the reverse order because we
    ** always append to the front of the lists.
    ** The inherited clauses are those clauses (both one- and two-literal)
    ** that are common to both children; and the two-literal clauses of
    ** one child that are implied by a one-literal clause of the other
    ** child. */
    while (!sentinelp(Tcv[pt], Tcv[pt+1]) || !sentinelp(Ecv[pe], Ecv[pe+1])) {
	if (equalp(Tcv[pt], bitVectorRead(Tcp, pt),
		   Tcv[pt+1], bitVectorRead(Tcp, pt+1),
		   Ecv[pe], bitVectorRead(Ecp, pe),
		   Ecv[pe+1], bitVectorRead(Ecp, pe+1))) {
	    /* Add clause to inherited list. */
	    newclause = ALLOC(TlClause,1);
	    if (newclause == NULL) goto cleanup;
	    newclause->v1 = Tcv[pt];
	    newclause->v2 = Tcv[pt+1];
	    newclause->p1 = bitVectorRead(Tcp, pt);
	    newclause->p2 = bitVectorRead(Tcp, pt+1);
	    newclause->next = iclauses;
	    iclauses = newclause;
	    pt += 2; pe += 2; cv++;
	} else if (beforep(Tcv[pt], bitVectorRead(Tcp, pt),
		   Tcv[pt+1], bitVectorRead(Tcp, pt+1),
		   Ecv[pe], bitVectorRead(Ecp, pe),
		   Ecv[pe+1], bitVectorRead(Ecp, pe+1))) {
	    if (oneliteralp(Tcv[pt+1])) {
		/* Add this one-literal clause to the T set. */
		newclause = ALLOC(TlClause,1);
		if (newclause == NULL) goto cleanup;
		newclause->v1 = Tcv[pt];
		newclause->v2 = CUDD_MAXINDEX;
		newclause->p1 = bitVectorRead(Tcp, pt);
		newclause->p2 = 1;
		newclause->next = tclauses;
		tclauses = newclause;
		bitVectorSet(Tolv, Tcv[pt], 1);
		bitVectorSet(Tolp, Tcv[pt], bitVectorRead(Tcp, pt));
	    } else {
		if (impliedp(Tcv[pt], bitVectorRead(Tcp, pt),
			     Tcv[pt+1], bitVectorRead(Tcp, pt+1),
			     Eolv, Eolp)) {
		    /* Add clause to inherited list. */
		    newclause = ALLOC(TlClause,1);
		    if (newclause == NULL) goto cleanup;
		    newclause->v1 = Tcv[pt];
		    newclause->v2 = Tcv[pt+1];
		    newclause->p1 = bitVectorRead(Tcp, pt);
		    newclause->p2 = bitVectorRead(Tcp, pt+1);
		    newclause->next = iclauses;
		    iclauses = newclause;
		    cv++;
		}
	    }
	    pt += 2;
	} else { /* !beforep() */
	    if (oneliteralp(Ecv[pe+1])) {
		/* Add this one-literal clause to the E set. */
		newclause = ALLOC(TlClause,1);
		if (newclause == NULL) goto cleanup;
		newclause->v1 = Ecv[pe];
		newclause->v2 = CUDD_MAXINDEX;
		newclause->p1 = bitVectorRead(Ecp, pe);
		newclause->p2 = 1;
		newclause->next = eclauses;
		eclauses = newclause;
		bitVectorSet(Eolv, Ecv[pe], 1);
		bitVectorSet(Eolp, Ecv[pe], bitVectorRead(Ecp, pe));
	    } else {
		if (impliedp(Ecv[pe], bitVectorRead(Ecp, pe),
			     Ecv[pe+1], bitVectorRead(Ecp, pe+1),
			     Tolv, Tolp)) {
		    /* Add clause to inherited list. */
		    newclause = ALLOC(TlClause,1);
		    if (newclause == NULL) goto cleanup;
		    newclause->v1 = Ecv[pe];
		    newclause->v2 = Ecv[pe+1];
		    newclause->p1 = bitVectorRead(Ecp, pe);
		    newclause->p2 = bitVectorRead(Ecp, pe+1);
		    newclause->next = iclauses;
		    iclauses = newclause;
		    cv++;
		}
	    }
	    pe += 2;
	}
    }

    /* Add one-literal clauses for the label variable to the front of
    ** the two lists. */
    newclause = ALLOC(TlClause,1);
    if (newclause == NULL) goto cleanup;
    newclause->v1 = label;
    newclause->v2 = CUDD_MAXINDEX;
    newclause->p1 = 0;
    newclause->p2 = 1;
    newclause->next = tclauses;
    tclauses = newclause;
    newclause = ALLOC(TlClause,1);
    if (newclause == NULL) goto cleanup;
    newclause->v1 = label;
    newclause->v2 = CUDD_MAXINDEX;
    newclause->p1 = 1;
    newclause->p2 = 1;
    newclause->next = eclauses;
    eclauses = newclause;

    /* Produce the non-inherited clauses.  We preserve the "reverse"
    ** order of the two input lists by appending to the end of the
    ** list.  In this way, iclauses and nclauses are consistent. */
    while (tclauses != NULL && eclauses != NULL) {
	if (beforep(eclauses->v1, eclauses->p1, eclauses->v2, eclauses->p2,
		    tclauses->v1, tclauses->p1, tclauses->v2, tclauses->p2)) {
	    TlClause *nextclause = tclauses->next;
	    TlClause *otherclauses = eclauses;
	    while (otherclauses != NULL) {
		if (tclauses->v1 != otherclauses->v1) {
		    newclause = ALLOC(TlClause,1);
		    if (newclause == NULL) goto cleanup;
		    newclause->v1 = tclauses->v1;
		    newclause->v2 = otherclauses->v1;
		    newclause->p1 = tclauses->p1;
		    newclause->p2 = otherclauses->p1;
		    newclause->next = NULL;
		    if (nclauses == NULL) {
			nclauses = newclause;
			lnclause = newclause;
		    } else {
			lnclause->next = newclause;
			lnclause = newclause;
		    }
		    cv++;
		}
		otherclauses = otherclauses->next;
	    }
	    FREE(tclauses);
	    tclauses = nextclause;
	} else {
	    TlClause *nextclause = eclauses->next;
	    TlClause *otherclauses = tclauses;
	    while (otherclauses != NULL) {
		if (eclauses->v1 != otherclauses->v1) {
		    newclause = ALLOC(TlClause,1);
		    if (newclause == NULL) goto cleanup;
		    newclause->v1 = eclauses->v1;
		    newclause->v2 = otherclauses->v1;
		    newclause->p1 = eclauses->p1;
		    newclause->p2 = otherclauses->p1;
		    newclause->next = NULL;
		    if (nclauses == NULL) {
			nclauses = newclause;
			lnclause = newclause;
		    } else {
			lnclause->next = newclause;
			lnclause = newclause;
		    }
		    cv++;
		}
		otherclauses = otherclauses->next;
	    }
	    FREE(eclauses);
	    eclauses = nextclause;
	}
    }
    while (tclauses != NULL) {
	TlClause *nextclause = tclauses->next;
	FREE(tclauses);
	tclauses = nextclause;
    }
    while (eclauses != NULL) {
	TlClause *nextclause = eclauses->next;
	FREE(eclauses);
	eclauses = nextclause;
    }

    /* Merge inherited and non-inherited clauses.  Now that we know the
    ** total number, we allocate the arrays, and we fill them bottom-up
    ** to restore the proper ordering. */
    Vcv = ALLOC(DdHalfWord, 2*(cv+1));
    if (Vcv == NULL) goto cleanup;
    if (cv > 0) {
	Vcp = bitVectorAlloc(2*cv);
	if (Vcp == NULL) goto cleanup;
    } else {
	Vcp = NULL;
    }
    res->vars = Vcv;
    res->phases = Vcp;
    /* Add sentinel. */
    Vcv[2*cv] = 0;
    Vcv[2*cv+1] = 0;
    while (iclauses != NULL || nclauses != NULL) {
	TlClause *nextclause;
	cv--;
	if (nclauses == NULL || (iclauses != NULL &&
	    beforep(nclauses->v1, nclauses->p1, nclauses->v2, nclauses->p2,
		    iclauses->v1, iclauses->p1, iclauses->v2, iclauses->p2))) {
	    Vcv[2*cv] = iclauses->v1;
	    Vcv[2*cv+1] = iclauses->v2;
	    bitVectorSet(Vcp, 2*cv, iclauses->p1);
	    bitVectorSet(Vcp, 2*cv+1, iclauses->p2);
	    nextclause = iclauses->next;
	    FREE(iclauses);
	    iclauses = nextclause;
	} else {
	    Vcv[2*cv] = nclauses->v1;
	    Vcv[2*cv+1] = nclauses->v2;
	    bitVectorSet(Vcp, 2*cv, nclauses->p1);
	    bitVectorSet(Vcp, 2*cv+1, nclauses->p2);
	    nextclause = nclauses->next;
	    FREE(nclauses);
	    nclauses = nextclause;
	}
    }
    assert(cv == 0);

    return(res);

 cleanup:
    if (res != NULL) Cudd_tlcInfoFree(res);
    while (iclauses != NULL) {
	TlClause *nextclause = iclauses->next;
	FREE(iclauses);
	iclauses = nextclause;
    }
    while (nclauses != NULL) {
	TlClause *nextclause = nclauses->next;
	FREE(nclauses);
	nclauses = nextclause;
    }
    while (tclauses != NULL) {
	TlClause *nextclause = tclauses->next;
	FREE(tclauses);
	tclauses = nextclause;
    }
    while (eclauses != NULL) {
	TlClause *nextclause = eclauses->next;
	FREE(eclauses);
	eclauses = nextclause;
    }

    return(NULL);

} /* end of computeClauses */


/**
  @brief Computes the two-literal clauses for a node.

  @details Computes the two-literal clauses for a node with a zero
  child, given the clauses for its other child and the label of the
  node.

  @return a pointer to a TclInfo structure if successful; NULL
  otherwise.

  @sideeffect None

  @see computeClauses

*/
static DdTlcInfo *
computeClausesWithUniverse(
  DdTlcInfo *Cres /* list of clauses for child */,
  DdHalfWord label /* variable labeling the current node */,
  short phase /* 0 if E child is zero; 1 if T child is zero */)
{
    DdHalfWord *Ccv = Cres->vars; /* variables of clauses for child */
    BitVector *Ccp = Cres->phases; /* phases of clauses for child */
    DdHalfWord *Vcv = NULL; /* pointer to the variables of the clauses for v */
    BitVector *Vcp = NULL; /* pointer to the phases of the clauses for v */
    DdTlcInfo *res = NULL; /* the set of clauses to be returned */
    int i;

    /* Initialize result. */
    res = tlcInfoAlloc();
    if (res == NULL) goto cleanup;
    /* Count entries for new list and allocate accordingly. */
    for (i = 0; !sentinelp(Ccv[i], Ccv[i+1]); i += 2);
    /* At this point, i is twice the number of clauses in the child's
    ** list.  We need four more entries for this node: 2 for the one-literal
    ** clause for the label, and 2 for the sentinel. */
    Vcv = ALLOC(DdHalfWord,i+4);
    if (Vcv == NULL) goto cleanup;
    Vcp = bitVectorAlloc(i+4);
    if (Vcp == NULL) goto cleanup;
    res->vars = Vcv;
    res->phases = Vcp;
    /* Copy old list into new. */
    for (i = 0; !sentinelp(Ccv[i], Ccv[i+1]); i += 2) {
	Vcv[i] = Ccv[i];
	Vcv[i+1] = Ccv[i+1];
	bitVectorSet(Vcp, i, bitVectorRead(Ccp, i));
	bitVectorSet(Vcp, i+1, bitVectorRead(Ccp, i+1));
    }
    /* Add clause corresponding to label. */
    Vcv[i] = label;
    bitVectorSet(Vcp, i, phase);
    i++;
    Vcv[i] = CUDD_MAXINDEX;
    bitVectorSet(Vcp, i, 1);
    i++;
    /* Add sentinel. */
    Vcv[i] = 0;
    Vcv[i+1] = 0;
    bitVectorSet(Vcp, i, 0);
    bitVectorSet(Vcp, i+1, 0);

    return(res);

 cleanup:
    /* Vcp is guaranteed to be NULL here.  Hence, we do not try to free it. */
    if (Vcv != NULL) FREE(Vcv);
    if (res != NULL) Cudd_tlcInfoFree(res);

    return(NULL);

} /* end of computeClausesWithUniverse */


/**
  @brief Returns an enpty set of clauses.

  @details No bit vector for the phases is allocated.

  @return a pointer to an empty set of clauses if successful; NULL
  otherwise.

  @sideeffect None

*/
static DdTlcInfo *
emptyClauseSet(void)
{
    DdTlcInfo *eset;

    eset = ALLOC(DdTlcInfo,1);
    if (eset == NULL) return(NULL);
    eset->vars = ALLOC(DdHalfWord,2);
    if (eset->vars == NULL) {
	FREE(eset);
	return(NULL);
    }
    /* Sentinel */
    eset->vars[0] = 0;
    eset->vars[1] = 0;
    eset->phases = NULL; /* does not matter */
    eset->cnt = 0;
    return(eset);

} /* end of emptyClauseSet */


/**
  @brief Returns true iff the argument is the sentinel clause.

  @details A sentinel clause has both variables equal to 0.

  @sideeffect None

*/
static int
sentinelp(
  DdHalfWord var1,
  DdHalfWord var2)
{
    return(var1 == 0 && var2 == 0);

} /* end of sentinelp */


/**
  @brief Returns true iff the two arguments are identical clauses.

  @details Since literals are sorted, we only need to compare literals
  in the same position.

  @sideeffect None

  @see beforep

*/
static int
equalp(
  DdHalfWord var1a,
  short phase1a,
  DdHalfWord var1b,
  short phase1b,
  DdHalfWord var2a,
  short phase2a,
  DdHalfWord var2b,
  short phase2b)
{
    return(var1a == var2a && phase1a == phase2a &&
	   var1b == var2b && phase1b == phase2b);

} /* end of equalp */


/**
  @brief Returns true iff the first argument precedes the second in
  the clause order.

  @details A clause precedes another if its first lieral
  precedes the first literal of the other, or if the first literals
  are the same, and its second literal precedes the second literal of
  the other clause.  A literal precedes another if it has a higher
  index, of if it has the same index, but it has lower phase.  Phase 0
  is the positive phase, and it is lower than Phase 1 (negative
  phase).

  @sideeffect None

  @see equalp

*/
static int
beforep(
  DdHalfWord var1a,
  short phase1a,
  DdHalfWord var1b,
  short phase1b,
  DdHalfWord var2a,
  short phase2a,
  DdHalfWord var2b,
  short phase2b)
{
    return(var1a > var2a || (var1a == var2a &&
	   (phase1a < phase2a || (phase1a == phase2a &&
	    (var1b > var2b || (var1b == var2b && phase1b < phase2b))))));

} /* end of beforep */


/**
  @brief Returns true iff the argument is a one-literal clause.

  @details A one-litaral clause has the constant FALSE as second
  literal.  Since the constant TRUE is never used, it is sufficient to
  test for a constant.

  @sideeffect None

*/
static int
oneliteralp(
  DdHalfWord var)
{
    return(var == CUDD_MAXINDEX);

} /* end of oneliteralp */


/**
  @brief Returns true iff either literal of a clause is in a set of
  literals.

  @details The first four arguments specify the clause.  The remaining
  two arguments specify the literal set.

  @sideeffect None

*/
static int
impliedp(
  DdHalfWord var1,
  short phase1,
  DdHalfWord var2,
  short phase2,
  BitVector *olv,
  BitVector *olp)
{
    return((bitVectorRead(olv, var1) &&
	    bitVectorRead(olp, var1) == phase1) ||
	   (bitVectorRead(olv, var2) &&
	    bitVectorRead(olp, var2) == phase2));

} /* end of impliedp */


/**
  @brief Allocates a bit vector.

  @details The parameter size gives the number of bits.  This
  procedure allocates enough words to hold the specified number of
  bits.

  @return a pointer to the allocated vector if successful; NULL
  otherwise.

  @sideeffect None

  @see bitVectorClear bitVectorFree

*/
static BitVector *
bitVectorAlloc(
  int size)
{
    int allocSize;
    BitVector *vector;

    /* Find out how many words we need.
    ** There are sizeof(ptruint) * 8 bits in a ptruint.
    ** The ceiling of the ratio of two integers m and n is given
    ** by ((n-1)/m)+1.  Putting all this together, we get... */
    allocSize = ((size - 1) / (sizeof(BitVector) * 8)) + 1;
    vector = ALLOC(BitVector, allocSize);
    if (vector == NULL) return(NULL);
    /* Clear the whole array. */
    (void) memset(vector, 0, allocSize * sizeof(BitVector));
    return(vector);

} /* end of bitVectorAlloc */


/**
  @brief Clears a bit vector.

  @details The parameter size gives the number of bits.

  @sideeffect None

  @see bitVectorAlloc

*/
static void
bitVectorClear(
  BitVector *vector,
  int size)
{
    int allocSize;

    /* Find out how many words we need.
    ** There are sizeof(ptruint) * 8 bits in a ptruint.
    ** The ceiling of the ratio of two integers m and n is given
    ** by ((n-1)/m)+1.  Putting all this together, we get... */
    allocSize = ((size - 1) / (sizeof(BitVector) * 8)) + 1;
    /* Clear the whole array. */
    (void) memset(vector, 0, allocSize * sizeof(BitVector));
    return;

} /* end of bitVectorClear */


/**
  @brief Frees a bit vector.

  @sideeffect None

  @see bitVectorAlloc

*/
static void
bitVectorFree(
  BitVector *vector)
{
    FREE(vector);

} /* end of bitVectorFree */


/**
  @brief Returns the i-th entry of a bit vector.

  @sideeffect None

  @see bitVectorSet

*/
static short
bitVectorRead(
  BitVector *vector,
  int i)
{
    int word, bit;
    short result;

    if (vector == NULL) return((short) 0);

    word = i >> LOGBPL;
    bit = i & (BPL - 1);
    result = (short) ((vector[word] >> bit) & (ptruint) 1);
    return(result);

} /* end of bitVectorRead */


/**
  @brief Sets the i-th entry of a bit vector to a value.

  @sideeffect None

  @see bitVectorRead

*/
static void
bitVectorSet(
  BitVector * vector,
  int i,
  short val)
{
    int word, bit;

    word = i >> LOGBPL;
    bit = i & (BPL - 1);
    vector[word] &= ~((ptruint) 1 << bit);
    vector[word] |= (((ptruint) val) << bit);

} /* end of bitVectorSet */


/**
  @brief Allocates a DdTlcInfo Structure.

  @return a pointer to a DdTlcInfo Structure if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_tlcInfoFree

*/
static DdTlcInfo *
tlcInfoAlloc(void)
{
    DdTlcInfo *res = ALLOC(DdTlcInfo,1);
    if (res == NULL) return(NULL);
    res->vars = NULL;
    res->phases = NULL;
    res->cnt = 0;
    return(res);

} /* end of tlcInfoAlloc */

cuddExact.c
24861
/**
  @file

  @ingroup cudd

  @brief Functions for exact variable reordering.

  @author Cheng Hua, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int getMaxBinomial (int n);
static DdHalfWord ** getMatrix (int rows, int cols);
static void freeMatrix (DdHalfWord **matrix);
static int getLevelKeys (DdManager *table, int l);
static int ddShuffle (DdManager *table, DdHalfWord *permutation, int lower, int upper);
static int ddSiftUp (DdManager *table, int x, int xLow);
static int updateUB (DdManager *table, int oldBound, DdHalfWord *bestOrder, int lower, int upper);
static int ddCountRoots (DdManager *table, int lower, int upper);
static void ddClearGlobal (DdManager *table, int lower, int maxlevel);
static int computeLB (DdManager *table, DdHalfWord *order, int roots, int cost, int lower, int upper, int level);
static int updateEntry (DdManager *table, DdHalfWord *order, int level, int cost, DdHalfWord **orders, int *costs, int subsets, char *mask, int lower, int upper);
static void pushDown (DdHalfWord *order, int j, int level);
static DdHalfWord * initSymmInfo (DdManager *table, int lower, int upper);
static int checkSymmInfo (DdManager *table, DdHalfWord *symmInfo, int index, int level);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Exact variable ordering algorithm.

  @details Finds an optimum order for the variables between lower and
  upper.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddExact(
  DdManager * table,
  int  lower,
  int  upper)
{
    int k, i, j;
    int maxBinomial, oldSubsets, newSubsets;
    int subsetCost;
    int size;			/* number of variables to be reordered */
    int unused, nvars, level, result;
    int upperBound, lowerBound, cost;
    int roots;
    char *mask = NULL;
    DdHalfWord  *symmInfo = NULL;
    DdHalfWord **newOrder = NULL;
    DdHalfWord **oldOrder = NULL;
    int *newCost = NULL;
    int *oldCost = NULL;
    DdHalfWord **tmpOrder;
    int *tmpCost;
    DdHalfWord *bestOrder = NULL;
    DdHalfWord *order;
#ifdef DD_STATS
    int  ddTotalSubsets;
#endif

    /* Restrict the range to be reordered by excluding unused variables
    ** at the two ends. */
    while (table->subtables[lower].keys == 1 &&
	   table->vars[table->invperm[lower]]->ref == 1 &&
	   lower < upper)
	lower++;
    while (table->subtables[upper].keys == 1 &&
	   table->vars[table->invperm[upper]]->ref == 1 &&
	   lower < upper)
	upper--;
    if (lower == upper) return(1); /* trivial problem */

    /* Apply symmetric sifting to get a good upper bound and to extract
    ** symmetry information. */
    result = cuddSymmSiftingConv(table,lower,upper);
    if (result == 0) goto cuddExactOutOfMem;

#ifdef DD_STATS
    (void) fprintf(table->out,"\n");
    table->totalShuffles = 0;
    ddTotalSubsets = 0;
#endif

    /* Initialization. */
    nvars = table->size;
    size = upper - lower + 1;
    /* Count unused variable among those to be reordered.  This is only
    ** used to compute maxBinomial. */
    unused = 0;
    for (i = lower + 1; i < upper; i++) {
	if (table->subtables[i].keys == 1 &&
	    table->vars[table->invperm[i]]->ref == 1)
	    unused++;
    }

    /* Find the maximum number of subsets we may have to store. */
    maxBinomial = getMaxBinomial(size - unused);
    if (maxBinomial == -1) goto cuddExactOutOfMem;

    newOrder = getMatrix(maxBinomial, size);
    if (newOrder == NULL) goto cuddExactOutOfMem;

    newCost = ALLOC(int, maxBinomial);
    if (newCost == NULL) goto cuddExactOutOfMem;

    oldOrder = getMatrix(maxBinomial, size);
    if (oldOrder == NULL) goto cuddExactOutOfMem;

    oldCost = ALLOC(int, maxBinomial);
    if (oldCost == NULL) goto cuddExactOutOfMem;

    bestOrder = ALLOC(DdHalfWord, size);
    if (bestOrder == NULL) goto cuddExactOutOfMem;

    mask = ALLOC(char, nvars);
    if (mask == NULL) goto cuddExactOutOfMem;

    symmInfo = initSymmInfo(table, lower, upper);
    if (symmInfo == NULL) goto cuddExactOutOfMem;

    roots = ddCountRoots(table, lower, upper);

    /* Initialize the old order matrix for the empty subset and the best
    ** order to the current order. The cost for the empty subset includes
    ** the cost of the levels between upper and the constants. These levels
    ** are not going to change. Hence, we count them only once.
    */
    oldSubsets = 1;
    for (i = 0; i < size; i++) {
	oldOrder[0][i] = bestOrder[i] = (DdHalfWord) table->invperm[i+lower];
    }
    subsetCost = (int) table->constants.keys;
    for (i = upper + 1; i < nvars; i++)
	subsetCost += getLevelKeys(table,i);
    oldCost[0] = subsetCost;
    /* The upper bound is initialized to the current size of the BDDs. */
    upperBound = (int) (table->keys - table->isolated);

    /* Now consider subsets of increasing size. */
    for (k = 1; k <= size; k++) {
#ifdef DD_STATS
	(void) fprintf(table->out,"Processing subsets of size %d\n", k);
	fflush(table->out);
#endif
	newSubsets = 0;
	level = size - k;		/* offset of first bottom variable */

	for (i = 0; i < oldSubsets; i++) { /* for each subset of size k-1 */
	    order = oldOrder[i];
	    cost = oldCost[i];
	    lowerBound = computeLB(table, order, roots, cost, lower, upper,
				   level);
	    if (lowerBound >= upperBound)
		continue;
	    /* Impose new order. */
	    result = ddShuffle(table, order, lower, upper);
	    if (result == 0) goto cuddExactOutOfMem;
	    upperBound = updateUB(table,upperBound,bestOrder,lower,upper);
	    /* For each top bottom variable. */
	    for (j = level; j >= 0; j--) {
		/* Skip unused variables. */
		if (table->subtables[j+lower-1].keys == 1 &&
		    table->vars[table->invperm[j+lower-1]]->ref == 1) continue;
		/* Find cost under this order. */
		subsetCost = cost + getLevelKeys(table, lower + level);
		newSubsets = updateEntry(table, order, level, subsetCost,
					 newOrder, newCost, newSubsets, mask,
					 lower, upper);
		if (j == 0)
		    break;
		if (checkSymmInfo(table, symmInfo, (int) order[j-1], level) == 0)
		    continue;
		pushDown(order,j-1,level);
		/* Impose new order. */
		result = ddShuffle(table, order, lower, upper);
		if (result == 0) goto cuddExactOutOfMem;
		upperBound = updateUB(table,upperBound,bestOrder,lower,upper);
	    } /* for each bottom variable */
	} /* for each subset of size k */

	/* New orders become old orders in preparation for next iteration. */
	tmpOrder = oldOrder; tmpCost = oldCost;
	oldOrder = newOrder; oldCost = newCost;
	newOrder = tmpOrder; newCost = tmpCost;
#ifdef DD_STATS
	ddTotalSubsets += newSubsets;
#endif
	oldSubsets = newSubsets;
    }
    result = ddShuffle(table, bestOrder, lower, upper);
    if (result == 0) goto cuddExactOutOfMem;
#ifdef DD_STATS
#ifdef DD_VERBOSE
    (void) fprintf(table->out,"\n");
#endif
    (void) fprintf(table->out,"#:S_EXACT   %8d: total subsets\n",
		   ddTotalSubsets);
    (void) fprintf(table->out,"#:H_EXACT   %8d: total shuffles",
		   table->totalShuffles);
#endif

    freeMatrix(newOrder);
    freeMatrix(oldOrder);
    FREE(bestOrder);
    FREE(oldCost);
    FREE(newCost);
    FREE(symmInfo);
    FREE(mask);
    return(1);

cuddExactOutOfMem:

    if (newOrder != NULL) freeMatrix(newOrder);
    if (oldOrder != NULL) freeMatrix(oldOrder);
    if (bestOrder != NULL) FREE(bestOrder);
    if (oldCost != NULL) FREE(oldCost);
    if (newCost != NULL) FREE(newCost);
    if (symmInfo != NULL) FREE(symmInfo);
    if (mask != NULL) FREE(mask);
    table->errorCode = CUDD_MEMORY_OUT;
    return(0);

} /* end of cuddExact */


/**
  @brief Returns the maximum value of `(n choose k)` for a given `n`.

  @details Computes the maximum value of `(n choose k)` for a given
  `n`.  The maximum value occurs for `k = n/2` when `n` is even, or `k =
  (n-1)/2` when `n` is odd.  The algorithm used in this procedure avoids
  intermediate overflow problems.  It is based on the identity

      binomial(n,k) = n/k * binomial(n-1,k-1).

  @return the computed value if successful; -1 if out of range.

  @sideeffect None

*/
static int
getMaxBinomial(
  int n)
{
    double i, j, result;

    if (n < 0 || n > 33) return(-1); /* error */
    if (n < 2) return(1);

    for (result = (double)((n+3)/2), i = result+1, j=2; i <= n; i++, j++) {
	result *= i;
	result /= j;
    }

    return((int)result);

} /* end of getMaxBinomial */


#if 0
/**
  @brief Returns the gcd of two integers.

  @details Uses the binary GCD algorithm described in Cormen,
  Leiserson, and Rivest.

  @sideeffect None

*/
static int
gcd(
  int  x,
  int  y)
{
    int a;
    int b;
    int lsbMask;

    /* GCD(n,0) = n. */
    if (x == 0) return(y);
    if (y == 0) return(x);

    a = x; b = y; lsbMask = 1;

    /* Here both a and b are != 0. The iteration maintains this invariant.
    ** Hence, we only need to check for when they become equal.
    */
    while (a != b) {
	if (a & lsbMask) {
	    if (b & lsbMask) {	/* both odd */
		if (a < b) {
		    b = (b - a) >> 1;
		} else {
		    a = (a - b) >> 1;
		}
	    } else {		/* a odd, b even */
		b >>= 1;
	    }
	} else {
	    if (b & lsbMask) {	/* a even, b odd */
		a >>= 1;
	    } else {		/* both even */
		lsbMask <<= 1;
	    }
	}
    }

    return(a);

} /* end of gcd */
#endif


/**
  @brief Allocates a two-dimensional matrix of ints.

  @return the pointer to the matrix if successful; NULL otherwise.

  @sideeffect None

  @see freeMatrix

*/
static DdHalfWord **
getMatrix(
  int  rows /* number of rows */,
  int  cols /* number of columns */)
{
    DdHalfWord **matrix;
    int i;

    if (cols*rows == 0) return(NULL);
    matrix = ALLOC(DdHalfWord *, rows);
    if (matrix == NULL) return(NULL);
    matrix[0] = ALLOC(DdHalfWord, cols*rows);
    if (matrix[0] == NULL) {
	FREE(matrix);
	return(NULL);
    }
    for (i = 1; i < rows; i++) {
	matrix[i] = matrix[i-1] + cols;
    }
    return(matrix);

} /* end of getMatrix */


/**
  @brief Frees a two-dimensional matrix allocated by getMatrix.

  @sideeffect None

  @see getMatrix

*/
static void
freeMatrix(
  DdHalfWord ** matrix)
{
    FREE(matrix[0]);
    FREE(matrix);
    return;

} /* end of freeMatrix */


/**
  @brief Returns the number of nodes at one level of a unique table.

  @details The projection function, if isolated, is not counted.

  @sideeffect None

*/
static int
getLevelKeys(
  DdManager * table,
  int  l)
{
    int isolated;
    int x;        /* x is an index */

    x = table->invperm[l];
    isolated = table->vars[x]->ref == 1;

    return((int) table->subtables[l].keys - isolated);

} /* end of getLevelKeys */


/**
  @brief Reorders variables according to a given permutation.

  @details The i-th permutation array contains the index of the
  variable that should be brought to the i-th level. ddShuffle assumes
  that no dead nodes are present and that the interaction matrix is
  properly initialized.  The reordering is achieved by a series of
  upward sifts.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddShuffle(
  DdManager * table,
  DdHalfWord * permutation,
  int  lower,
  int  upper)
{
    DdHalfWord	index;
    int		level;
    int		position;
#if 0
    int		numvars;
#endif
    int		result;
#if defined(DD_STATS) && defined(DD_VERBOSE)
    int		initialSize;
    int		finalSize;
#endif

#if defined(DD_STATS) && defined(DD_VERBOSE)
    initialSize = (int) (table->keys - table->isolated);
#endif

#if 0
    numvars = table->size;

    (void) fprintf(table->out,"%d:", table->totalShuffles);
    for (level = 0; level < numvars; level++) {
	(void) fprintf(table->out," %d", table->invperm[level]);
    }
    (void) fprintf(table->out,"\n");
#endif

    for (level = 0; level <= upper - lower; level++) {
	index = permutation[level];
	position = table->perm[index];
	result = ddSiftUp(table,position,level+lower);
	if (!result) return(0);
    }

#ifdef DD_STATS
    table->totalShuffles++;
#ifdef DD_VERBOSE
    finalSize = (int) (table->keys - table->isolated);
    if (finalSize < initialSize) {
	(void) fprintf(table->out,"-");
    } else if (finalSize > initialSize) {
	(void) fprintf(table->out,"+");
    } else {
	(void) fprintf(table->out,"=");
    }
    if ((table->totalShuffles & 63) == 0) (void) fprintf(table->out,"\n");
    fflush(table->out);
#endif
#endif

    return(1);

} /* end of ddShuffle */


/**
  @brief Moves one variable up.

  @details Takes a variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.

  @return 1 if successful; 0 otherwise

  @sideeffect None

*/
static int
ddSiftUp(
  DdManager * table,
  int  x,
  int  xLow)
{
    int        y;
    int        size;

    y = cuddNextLow(table,x);
    while (y >= xLow) {
	size = cuddSwapInPlace(table,y,x);
	if (size == 0) {
	    return(0);
	}
	x = y;
	y = cuddNextLow(table,x);
    }
    return(1);

} /* end of ddSiftUp */


/**
  @brief Updates the upper bound and saves the best order seen so far.

  @return the current value of the upper bound.

  @sideeffect None

*/
static int
updateUB(
  DdManager * table,
  int  oldBound,
  DdHalfWord * bestOrder,
  int  lower,
  int  upper)
{
    int i;
    int newBound = (int) (table->keys - table->isolated);

    if (newBound < oldBound) {
#ifdef DD_STATS
	(void) fprintf(table->out,"New upper bound = %d\n", newBound);
	fflush(table->out);
#endif
	for (i = lower; i <= upper; i++)
	    bestOrder[i-lower] = (DdHalfWord) table->invperm[i];
	return(newBound);
    } else {
	return(oldBound);
    }

} /* end of updateUB */


/**
  @brief Counts the number of roots.

  @details Counts the number of roots at the levels between lower and
  upper.  The computation is based on breadth-first search.  A node is
  a root if it is not reachable from any previously visited node.
  (All the nodes at level lower are therefore considered roots.)  The
  roots that are constant nodes are always ignored.  The visited flag
  uses the LSB of the next pointer.

  @return the root count.

  @sideeffect None

  @see ddClearGlobal

*/
static int
ddCountRoots(
  DdManager * table,
  int  lower,
  int  upper)
{
    int i,j;
    DdNode *f;
    DdNodePtr *nodelist;
    DdNode *sentinel = &(table->sentinel);
    int slots;
    int roots = 0;
    int maxlevel = lower;

    for (i = lower; i <= upper; i++) {
	nodelist = table->subtables[i].nodelist;
	slots = (int) table->subtables[i].slots;
	for (j = 0; j < slots; j++) {
	    f = nodelist[j];
	    while (f != sentinel) {
		/* A node is a root of the DAG if it cannot be
		** reached by nodes above it. If a node was never
		** reached during the previous depth-first searches,
		** then it is a root, and we start a new depth-first
		** search from it.
		*/
		if (!Cudd_IsComplement(f->next)) {
		    if (f != table->vars[f->index]) {
			roots++;
		    }
		}
		if (!cuddIsConstant(cuddT(f))) {
		    cuddT(f)->next = Cudd_Complement(cuddT(f)->next);
		    if (table->perm[cuddT(f)->index] > maxlevel)
			maxlevel = table->perm[cuddT(f)->index];
		}
		if (!Cudd_IsConstantInt(cuddE(f))) {
		    Cudd_Regular(cuddE(f))->next =
			Cudd_Complement(Cudd_Regular(cuddE(f))->next);
		    if (table->perm[Cudd_Regular(cuddE(f))->index] > maxlevel)
			maxlevel = table->perm[Cudd_Regular(cuddE(f))->index];
		}
		f = Cudd_Regular(f->next);
	    }
	}
    }
    ddClearGlobal(table, lower, maxlevel);

    return(roots);

} /* end of ddCountRoots */


/**
  @brief Scans the %DD and clears the LSB of the next pointers.

  @details The LSB of the next pointers are used as markers to tell
  whether a node was reached. Once the roots are counted, these flags
  are reset.

  @sideeffect None

  @see ddCountRoots

*/
static void
ddClearGlobal(
  DdManager * table,
  int  lower,
  int  maxlevel)
{
    int i,j;
    DdNode *f;
    DdNodePtr *nodelist;
    DdNode *sentinel = &(table->sentinel);
    int slots;

    for (i = lower; i <= maxlevel; i++) {
	nodelist = table->subtables[i].nodelist;
	slots = (int) table->subtables[i].slots;
	for (j = 0; j < slots; j++) {
	    f = nodelist[j];
	    while (f != sentinel) {
		f->next = Cudd_Regular(f->next);
		f = f->next;
	    }
	}
    }

} /* end of ddClearGlobal */


/**
  @brief Computes a lower bound on the size of a %BDD.

  @details The lower bound depends on the following factors:
  <ul>
  <li> size of the lower part of it;
  <li> size of the part of the upper part not subjected to reordering;
  <li> number of roots in the part of the %BDD subjected to reordering;
  <li> variable in the support of the roots in the upper part of the
       %BDD subjected to reordering.
  </ul>

  @sideeffect None

*/
static int
computeLB(
  DdManager * table		/**< manager */,
  DdHalfWord * order		/**< optimal order for the subset */,
  int  roots			/**< roots between lower and upper */,
  int  cost			/**< minimum cost for the subset */,
  int  lower			/**< lower level to be reordered */,
  int  upper			/**< upper level to be reordered */,
  int  level			/**< offset for the current top bottom var */
  )
{
    int i;
    int lb = cost;
    int lb1 = 0;
    int lb2;
    int support;
    DdHalfWord ref;

    /* The levels not involved in reordering are not going to change.
    ** Add their sizes to the lower bound.
    */
    for (i = 0; i < lower; i++) {
	lb += getLevelKeys(table,i);
    }
    /* If a variable is in the support, then there is going
    ** to be at least one node labeled by that variable.
    */
    for (i = lower; i <= lower+level; i++) {
	support = table->subtables[i].keys > 1 ||
	    table->vars[order[i-lower]]->ref > 1;
	lb1 += support;
    }

    /* Estimate the number of nodes required to connect the roots to
    ** the nodes in the bottom part. */
    if (lower+level+1 < table->size) {
	if (lower+level < upper)
	    ref = table->vars[order[level+1]]->ref;
	else
	    ref = table->vars[table->invperm[upper+1]]->ref;
	lb2 = (int) table->subtables[lower+level+1].keys -
            (ref > (DdHalfWord) 1) - roots;
    } else {
	lb2 = 0;
    }

    lb += lb1 > lb2 ? lb1 : lb2;

    return(lb);

} /* end of computeLB */


/**
  @brief Updates entry for a subset.

  @details Finds the subset, if it exists.  If the new order for the
  subset has lower cost, or if the subset did not exist, it stores the
  new order and cost.

  @return the number of subsets currently in the table.

  @sideeffect None

*/
static int
updateEntry(
  DdManager * table,
  DdHalfWord * order,
  int  level,
  int  cost,
  DdHalfWord ** orders,
  int * costs,
  int  subsets,
  char * mask,
  int  lower,
  int  upper)
{
    int i, j;
    int size = upper - lower + 1;

    /* Build a mask that says what variables are in this subset. */
    for (i = lower; i <= upper; i++)
	mask[table->invperm[i]] = 0;
    for (i = level; i < size; i++)
	mask[order[i]] = 1;

    /* Check each subset until a match is found or all subsets are examined. */
    for (i = 0; i < subsets; i++) {
	DdHalfWord *subset = orders[i];
	for (j = level; j < size; j++) {
	    if (mask[subset[j]] == 0)
		break;
	}
	if (j == size)		/* no mismatches: success */
	    break;
    }
    if (i == subsets || cost < costs[i]) {		/* add or replace */
	for (j = 0; j < size; j++)
	    orders[i][j] = order[j];
	costs[i] = cost;
	subsets += (i == subsets);
    }
    return(subsets);

} /* end of updateEntry */


/**
  @brief Pushes a variable in the order down to position "level."

  @sideeffect None

*/
static void
pushDown(
  DdHalfWord * order,
  int  j,
  int  level)
{
    int i;
    DdHalfWord tmp;

    tmp = order[j];
    for (i = j; i < level; i++) {
	order[i] = order[i+1];
    }
    order[level] = tmp;
    return;

} /* end of pushDown */


/**
  @brief Gathers symmetry information.

  @details Translates the symmetry information stored in the next
  field of each subtable from level to indices. This procedure is called
  immediately after symmetric sifting, so that the next fields are correct.
  By translating this informaton in terms of indices, we make it independent
  of subsequent reorderings. The format used is that of the next fields:
  a circular list where each variable points to the next variable in the
  same symmetry group. Only the entries between lower and upper are
  considered.  The procedure returns a pointer to an array
  holding the symmetry information if successful; NULL otherwise.

  @sideeffect None

  @see checkSymmInfo

*/
static DdHalfWord *
initSymmInfo(
  DdManager * table,
  int  lower,
  int  upper)
{
    int level, index, next, nextindex;
    DdHalfWord *symmInfo;

    symmInfo =  ALLOC(DdHalfWord, table->size);
    if (symmInfo == NULL) return(NULL);

    for (level = lower; level <= upper; level++) {
	index = table->invperm[level];
	next =  (int) table->subtables[level].next;
	nextindex = table->invperm[next];
	symmInfo[index] = (DdHalfWord) nextindex;
    }
    return(symmInfo);

} /* end of initSymmInfo */


/**
  @brief Check symmetry condition.

  @details Returns 1 if a variable is the one with the highest index
  among those belonging to a symmetry group that are in the top part of
  the %BDD.  The top part is given by level.

  @sideeffect None

  @see initSymmInfo

*/
static int
checkSymmInfo(
  DdManager * table,
  DdHalfWord * symmInfo,
  int  index,
  int  level)
{
    int i;

    i = (int) symmInfo[index];
    while (i != index) {
	if (index < i && table->perm[i] <= level)
	    return(0);
	i = (int) symmInfo[i];
    }
    return(1);

} /* end of checkSymmInfo */

cuddExport.c
46041
/**
  @file

  @ingroup cudd

  @brief Export functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cstringstream.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int ddDoDumpBlif (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char const * const *names, int mv);
static int ddDoDumpDaVinci (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char const * const *names, ptruint mask);
static int ddDoDumpDDcal (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char const * const *names, ptruint mask);
static int ddDoDumpFactoredForm (DdManager *dd, DdNode *f, FILE *fp, char const * const *names);
static int ddDoFactoredFormString(DdManager * dd, DdNode *f, cstringstream stream, char const * const * names);
/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Writes a blif file representing the argument BDDs.

  @details Each %BDD is written as a network of multiplexers.
  Cudd_DumpBlif does not close the file: This is the caller
  responsibility. Cudd_DumpBlif uses a minimal unique subset of the
  hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames.

  @return 1 in case of success; 0 otherwise (e.g., out-of-memory, file
  system full, or an %ADD with constants different from 0 and 1).

  @sideeffect None

  @see Cudd_DumpBlifBody Cudd_DumpDot Cudd_PrintDebug Cudd_DumpDDcal
  Cudd_DumpDaVinci Cudd_DumpFactoredForm

*/
int
Cudd_DumpBlif(
  DdManager * dd /**< manager */,
  int  n /**< number of output nodes to be dumped */,
  DdNode ** f /**< array of output nodes to be dumped */,
  char const * const * inames /**< array of input names (or NULL) */,
  char const * const * onames /**< array of output names (or NULL) */,
  char * mname /**< model name (or NULL) */,
  FILE * fp /**< pointer to the dump file */,
  int mv /**< 0: blif, 1: blif-MV */)
{
    DdNode	*support = NULL;
    DdNode	*scan;
    int		*sorted = NULL;
    int		nvars = dd->size;
    int		retval;
    int		i;

    /* Build a bit array with the support of f. */
    sorted = ALLOC(int,nvars);
    if (sorted == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	goto failure;
    }
    for (i = 0; i < nvars; i++) sorted[i] = 0;

    /* Take the union of the supports of each output function. */
    support = Cudd_VectorSupport(dd,f,n);
    if (support == NULL) goto failure;
    cuddRef(support);
    scan = support;
    while (!cuddIsConstant(scan)) {
	sorted[scan->index] = 1;
	scan = cuddT(scan);
    }
    Cudd_RecursiveDeref(dd,support);
    support = NULL; /* so that we do not try to free it in case of failure */

    /* Write the header (.model .inputs .outputs). */
    if (mname == NULL) {
	retval = fprintf(fp,".model DD\n.inputs");
    } else {
	retval = fprintf(fp,".model %s\n.inputs",mname);
    }
    if (retval == EOF) {
	FREE(sorted);
	return(0);
    }

    /* Write the input list by scanning the support array. */
    for (i = 0; i < nvars; i++) {
	if (sorted[i]) {
	    if (inames == NULL) {
		retval = fprintf(fp," %d", i);
	    } else {
		retval = fprintf(fp," %s", inames[i]);
	    }
	    if (retval == EOF) goto failure;
	}
    }
    FREE(sorted);
    sorted = NULL;

    /* Write the .output line. */
    retval = fprintf(fp,"\n.outputs");
    if (retval == EOF) goto failure;
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp," f%d", i);
	} else {
	    retval = fprintf(fp," %s", onames[i]);
	}
	if (retval == EOF) goto failure;
    }
    retval = fprintf(fp,"\n");
    if (retval == EOF) goto failure;

    retval = Cudd_DumpBlifBody(dd, n, f, inames, onames, fp, mv);
    if (retval == 0) goto failure;

    /* Write trailer and return. */
    retval = fprintf(fp,".end\n");
    if (retval == EOF) goto failure;

    return(1);

 failure:
    if (sorted != NULL) FREE(sorted);
    if (support != NULL) Cudd_RecursiveDeref(dd,support);
    return(0);

} /* end of Cudd_DumpBlif */


/**
  @brief Writes a blif body representing the argument BDDs.

  @details Each %BDD is written as a network of multiplexers.  No
  header (.model, .inputs, and .outputs) and footer (.end) are
  produced by this function.  One multiplexer is written for each %BDD
  node.  Cudd_DumpBlifBody does not close the file: This is the caller
  responsibility. Cudd_DumpBlifBody uses a minimal unique subset of
  the hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames. This function prints out only
  .names part.

  @return 1 in case of success; 0 otherwise (e.g., out-of-memory, file
  system full, or an %ADD with constants different from 0 and 1).

  @sideeffect None

  @see Cudd_DumpBlif Cudd_DumpDot Cudd_PrintDebug Cudd_DumpDDcal
  Cudd_DumpDaVinci Cudd_DumpFactoredForm

*/
int
Cudd_DumpBlifBody(
  DdManager * dd /**< manager */,
  int  n /**< number of output nodes to be dumped */,
  DdNode ** f /**< array of output nodes to be dumped */,
  char const * const * inames /**< array of input names (or NULL) */,
  char const * const * onames /**< array of output names (or NULL) */,
  FILE * fp /**< pointer to the dump file */,
  int mv /**< 0: blif, 1: blif-MV */)
{
    st_table	*visited = NULL;
    int		retval;
    int		i;

    /* Initialize symbol table for visited nodes. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);
    if (visited == NULL) goto failure;

    /* Call the function that really gets the job done. */
    for (i = 0; i < n; i++) {
	retval = ddDoDumpBlif(dd,Cudd_Regular(f[i]),fp,visited,inames,mv);
	if (retval == 0) goto failure;
    }

    /* To account for the possible complement on the root,
    ** we put either a buffer or an inverter at the output of
    ** the multiplexer representing the top node.
    */
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp, ".names %" PRIxPTR " f%d\n",
                (ptruint) f[i] / (ptruint) sizeof(DdNode), i);
	} else {
	    retval = fprintf(fp, ".names %" PRIxPTR " %s\n",
                (ptruint) f[i] / (ptruint) sizeof(DdNode), onames[i]);
	}
	if (retval == EOF) goto failure;
	if (Cudd_IsComplement(f[i])) {
	    retval = fprintf(fp,"%s0 1\n", mv ? ".def 0\n" : "");
	} else {
	    retval = fprintf(fp,"%s1 1\n", mv ? ".def 0\n" : "");
	}
	if (retval == EOF) goto failure;
    }

    st_free_table(visited);
    return(1);

 failure:
    if (visited != NULL) st_free_table(visited);
    return(0);

} /* end of Cudd_DumpBlifBody */


/**
  @brief Writes a dot file representing the argument DDs.

  @details Writes a file representing the argument DDs in a format
  suitable for the graph drawing program dot.
  Cudd_DumpDot does not close the file: This is the caller
  responsibility. Cudd_DumpDot uses a minimal unique subset of the
  hexadecimal address of a node as name for it.
  If the argument inames is non-null, it is assumed to hold the pointers
  to the names of the inputs. Similarly for onames.
  Cudd_DumpDot uses the following convention to draw arcs:
    <ul>
    <li> solid line: THEN arcs;
    <li> dotted line: complement arcs;
    <li> dashed line: regular ELSE arcs.
    </ul>
  The dot options are chosen so that the drawing fits on a letter-size
  sheet.

  @return 1 in case of success; 0 otherwise (e.g., out-of-memory, file
  system full).

  @sideeffect None

  @see Cudd_DumpBlif Cudd_PrintDebug Cudd_DumpDDcal
  Cudd_DumpDaVinci Cudd_DumpFactoredForm

*/
int
Cudd_DumpDot(
  DdManager * dd /**< manager */,
  int  n /**< number of output nodes to be dumped */,
  DdNode ** f /**< array of output nodes to be dumped */,
  char const * const * inames /**< array of input names (or NULL) */,
  char const * const * onames /**< array of output names (or NULL) */,
  FILE * fp /**< pointer to the dump file */)
{
    DdNode	*support = NULL;
    DdNode	*scan;
    int		*sorted = NULL;
    int		nvars = dd->size;
    st_table	*visited = NULL;
    st_generator *gen = NULL;
    int		retval;
    int		i, j;
    int		slots;
    DdNodePtr	*nodelist;
    ptruint	refAddr, diff, mask = 0;

    /* Build a bit array with the support of f. */
    sorted = ALLOC(int,nvars);
    if (sorted == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	goto failure;
    }
    for (i = 0; i < nvars; i++) sorted[i] = 0;

    /* Take the union of the supports of each output function. */
    support = Cudd_VectorSupport(dd,f,n);
    if (support == NULL) goto failure;
    cuddRef(support);
    scan = support;
    while (!cuddIsConstant(scan)) {
	sorted[scan->index] = 1;
	scan = cuddT(scan);
    }
    Cudd_RecursiveDeref(dd,support);
    support = NULL; /* so that we do not try to free it in case of failure */

    /* Initialize symbol table for visited nodes. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);
    if (visited == NULL) goto failure;

    /* Collect all the nodes of this DD in the symbol table. */
    for (i = 0; i < n; i++) {
	retval = cuddCollectNodes(Cudd_Regular(f[i]),visited);
	if (retval == 0) goto failure;
    }

    /* Find how many most significant hex digits are identical
    ** in the addresses of all the nodes. Build a mask based
    ** on this knowledge, so that digits that carry no information
    ** will not be printed. This is done in two steps.
    **  1. We scan the symbol table to find the bits that differ
    **     in at least 2 addresses.
    **  2. We choose one of the possible masks. There are 8 possible
    **     masks for 32-bit integer, and 16 possible masks for 64-bit
    **     integers.
    */

    /* Find the bits that are different. */
    refAddr = (ptruint) Cudd_Regular(f[0]);
    diff = 0;
    gen = st_init_gen(visited);
    if (gen == NULL) goto failure;
    while (st_gen(gen, (void **) &scan, NULL)) {
	diff |= refAddr ^ (ptruint) scan;
    }
    st_free_gen(gen); gen = NULL;

    /* Choose the mask. */
    for (i = 0; (unsigned) i < 8 * sizeof(ptruint); i += 4) {
        mask = ((ptruint) 1 << i) - 1;
	if (diff <= mask) break;
    }

    /* Write the header and the global attributes. */
    retval = fprintf(fp,"digraph \"DD\" {\n");
    if (retval == EOF) return(0);
    retval = fprintf(fp,
	"size = \"7.5,10\"\ncenter = true;\nedge [dir = none];\n");
    if (retval == EOF) return(0);

    /* Write the input name subgraph by scanning the support array. */
    retval = fprintf(fp,"{ node [shape = plaintext];\n");
    if (retval == EOF) goto failure;
    retval = fprintf(fp,"  edge [style = invis];\n");
    if (retval == EOF) goto failure;
    /* We use a name ("CONST NODES") with an embedded blank, because
    ** it is unlikely to appear as an input name.
    */
    retval = fprintf(fp,"  \"CONST NODES\" [style = invis];\n");
    if (retval == EOF) goto failure;
    for (i = 0; i < nvars; i++) {
	if (sorted[dd->invperm[i]]) {
	    if (inames == NULL || inames[dd->invperm[i]] == NULL) {
		retval = fprintf(fp,"\" %d \" -> ", dd->invperm[i]);
	    } else {
		retval = fprintf(fp,"\" %s \" -> ", inames[dd->invperm[i]]);
	    }
	    if (retval == EOF) goto failure;
	}
    }
    retval = fprintf(fp,"\"CONST NODES\"; \n}\n");
    if (retval == EOF) goto failure;

    /* Write the output node subgraph. */
    retval = fprintf(fp,"{ rank = same; node [shape = box]; edge [style = invis];\n");
    if (retval == EOF) goto failure;
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp,"\"F%d\"", i);
	} else {
	    retval = fprintf(fp,"\"  %s  \"", onames[i]);
	}
	if (retval == EOF) goto failure;
	if (i == n - 1) {
	    retval = fprintf(fp,"; }\n");
	} else {
	    retval = fprintf(fp," -> ");
	}
	if (retval == EOF) goto failure;
    }

    /* Write rank info: All nodes with the same index have the same rank. */
    for (i = 0; i < nvars; i++) {
	if (sorted[dd->invperm[i]]) {
	    retval = fprintf(fp,"{ rank = same; ");
	    if (retval == EOF) goto failure;
	    if (inames == NULL || inames[dd->invperm[i]] == NULL) {
		retval = fprintf(fp,"\" %d \";\n", dd->invperm[i]);
	    } else {
		retval = fprintf(fp,"\" %s \";\n", inames[dd->invperm[i]]);
	    }
	    if (retval == EOF) goto failure;
	    nodelist = dd->subtables[i].nodelist;
	    slots = dd->subtables[i].slots;
	    for (j = 0; j < slots; j++) {
		scan = nodelist[j];
		while (scan != NULL) {
		    if (st_is_member(visited,scan)) {
			retval = fprintf(fp,"\"%#" PRIxPTR "\";\n",
			    ((mask & (ptruint) scan) / sizeof(DdNode)));
			if (retval == EOF) goto failure;
		    }
		    scan = scan->next;
		}
	    }
	    retval = fprintf(fp,"}\n");
	    if (retval == EOF) goto failure;
	}
    }

    /* All constants have the same rank. */
    retval = fprintf(fp,
	"{ rank = same; \"CONST NODES\";\n{ node [shape = box]; ");
    if (retval == EOF) goto failure;
    nodelist = dd->constants.nodelist;
    slots = dd->constants.slots;
    for (j = 0; j < slots; j++) {
	scan = nodelist[j];
	while (scan != NULL) {
	    if (st_is_member(visited,scan)) {
		retval = fprintf(fp,"\"%#" PRIxPTR "\";\n",
		    ((mask & (ptruint) scan) / sizeof(DdNode)));
		if (retval == EOF) goto failure;
	    }
	    scan = scan->next;
	}
    }
    retval = fprintf(fp,"}\n}\n");
    if (retval == EOF) goto failure;

    /* Write edge info. */
    /* Edges from the output nodes. */
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp,"\"F%d\"", i);
	} else {
	    retval = fprintf(fp,"\"  %s  \"", onames[i]);
	}
	if (retval == EOF) goto failure;
	/* Account for the possible complement on the root. */
	if (Cudd_IsComplement(f[i])) {
	    retval = fprintf(fp," -> \"%#" PRIxPTR "\" [style = dotted];\n",
		((mask & (ptruint) f[i]) / sizeof(DdNode)));
	} else {
	    retval = fprintf(fp," -> \"%#" PRIxPTR "\" [style = solid];\n",
		((mask & (ptruint) f[i]) / sizeof(DdNode)));
	}
	if (retval == EOF) goto failure;
    }

    /* Edges from internal nodes. */
    for (i = 0; i < nvars; i++) {
	if (sorted[dd->invperm[i]]) {
	    nodelist = dd->subtables[i].nodelist;
	    slots = dd->subtables[i].slots;
	    for (j = 0; j < slots; j++) {
		scan = nodelist[j];
		while (scan != NULL) {
		    if (st_is_member(visited,scan)) {
			retval = fprintf(fp,
			    "\"%#" PRIxPTR "\" -> \"%#" PRIxPTR "\";\n",
			    ((mask & (ptruint) scan) / sizeof(DdNode)),
			    ((mask & (ptruint) cuddT(scan)) / sizeof(DdNode)));
			if (retval == EOF) goto failure;
			if (Cudd_IsComplement(cuddE(scan))) {
			    retval = fprintf(fp,
				"\"%#" PRIxPTR "\" -> \"%#" PRIxPTR
                                             "\" [style = dotted];\n",
				((mask & (ptruint) scan) / sizeof(DdNode)),
				((mask & (ptruint) cuddE(scan)) /
				sizeof(DdNode)));
			} else {
			    retval = fprintf(fp,
				"\"%#" PRIxPTR "\" -> \"%#" PRIxPTR
                                             "\" [style = dashed];\n",
				((mask & (ptruint) scan) / sizeof(DdNode)),
				((mask & (ptruint) cuddE(scan)) /
				sizeof(DdNode)));
			}
			if (retval == EOF) goto failure;
		    }
		    scan = scan->next;
		}
	    }
	}
    }

    /* Write constant labels. */
    nodelist = dd->constants.nodelist;
    slots = dd->constants.slots;
    for (j = 0; j < slots; j++) {
	scan = nodelist[j];
	while (scan != NULL) {
	    if (st_is_member(visited,scan)) {
		retval = fprintf(fp,"\"%#" PRIxPTR "\" [label = \"%g\"];\n",
		    ((mask & (ptruint) scan) / sizeof(DdNode)), cuddV(scan));
		if (retval == EOF) goto failure;
	    }
	    scan = scan->next;
	}
    }

    /* Write trailer and return. */
    retval = fprintf(fp,"}\n");
    if (retval == EOF) goto failure;

    st_free_table(visited);
    FREE(sorted);
    return(1);

 failure:
    if (sorted != NULL) FREE(sorted);
    if (support != NULL) Cudd_RecursiveDeref(dd,support);
    if (visited != NULL) st_free_table(visited);
    return(0);

} /* end of Cudd_DumpDot */


/**
  @brief Writes a daVinci file representing the argument BDDs.

  @details Writes a daVinci file representing the argument BDDs.
  Cudd_DumpDaVinci does not close the file: This is the caller
  responsibility. Cudd_DumpDaVinci uses a minimal unique subset of the
  hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames.

  @return 1 in case of success; 0 otherwise (e.g., out-of-memory or
  file system full).

  @sideeffect None

  @see Cudd_DumpDot Cudd_PrintDebug Cudd_DumpBlif Cudd_DumpDDcal
  Cudd_DumpFactoredForm

*/
int
Cudd_DumpDaVinci(
  DdManager * dd /**< manager */,
  int  n /**< number of output nodes to be dumped */,
  DdNode ** f /**< array of output nodes to be dumped */,
  char const * const * inames /**< array of input names (or NULL) */,
  char const * const * onames /**< array of output names (or NULL) */,
  FILE * fp /**< pointer to the dump file */)
{
    DdNode	  *support = NULL;
    DdNode	  *scan;
    st_table	  *visited = NULL;
    int		  retval;
    int		  i;
    st_generator  *gen;
    ptruint       refAddr, diff, mask = 0;

    /* Initialize symbol table for visited nodes. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);
    if (visited == NULL) goto failure;

    /* Collect all the nodes of this DD in the symbol table. */
    for (i = 0; i < n; i++) {
	retval = cuddCollectNodes(Cudd_Regular(f[i]),visited);
	if (retval == 0) goto failure;
    }

    /* Find how many most significant hex digits are identical
    ** in the addresses of all the nodes. Build a mask based
    ** on this knowledge, so that digits that carry no information
    ** will not be printed. This is done in two steps.
    **  1. We scan the symbol table to find the bits that differ
    **     in at least 2 addresses.
    **  2. We choose one of the possible masks. There are 8 possible
    **     masks for 32-bit integer, and 16 possible masks for 64-bit
    **     integers.
    */

    /* Find the bits that are different. */
    refAddr = (ptruint) Cudd_Regular(f[0]);
    diff = 0;
    gen = st_init_gen(visited);
    while (st_gen(gen, (void **) &scan, NULL)) {
	diff |= refAddr ^ (ptruint) scan;
    }
    st_free_gen(gen);

    /* Choose the mask. */
    for (i = 0; (unsigned) i < 8 * sizeof(ptruint); i += 4) {
	mask = ((ptruint) 1 << i) - 1;
	if (diff <= mask) break;
    }
    st_free_table(visited);

    /* Initialize symbol table for visited nodes. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);
    if (visited == NULL) goto failure;

    retval = fprintf(fp, "[");
    if (retval == EOF) goto failure;
    /* Call the function that really gets the job done. */
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp,
			     "l(\"f%d\",n(\"root\",[a(\"OBJECT\",\"f%d\")],",
			     i,i);
	} else {
	    retval = fprintf(fp,
			     "l(\"%s\",n(\"root\",[a(\"OBJECT\",\"%s\")],",
			     onames[i], onames[i]);
	}
	if (retval == EOF) goto failure;
	retval = fprintf(fp, "[e(\"edge\",[a(\"EDGECOLOR\",\"%s\"),a(\"_DIR\",\"none\")],",
			 Cudd_IsComplement(f[i]) ? "red" : "blue");
	if (retval == EOF) goto failure;
	retval = ddDoDumpDaVinci(dd,Cudd_Regular(f[i]),fp,visited,inames,mask);
	if (retval == 0) goto failure;
	retval = fprintf(fp, ")]))%s", i == n-1 ? "" : ",");
	if (retval == EOF) goto failure;
    }

    /* Write trailer and return. */
    retval = fprintf(fp, "]\n");
    if (retval == EOF) goto failure;

    st_free_table(visited);
    return(1);

failure:
    if (support != NULL) Cudd_RecursiveDeref(dd,support);
    if (visited != NULL) st_free_table(visited);
    return(0);

} /* end of Cudd_DumpDaVinci */


/**
  @brief Writes a DDcal file representing the argument BDDs.

  @details Writes a DDcal file representing the argument BDDs.
  Cudd_DumpDDcal does not close the file: This is the caller
  responsibility. Cudd_DumpDDcal uses a minimal unique subset of the
  hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames.

  @return 1 in case of success; 0 otherwise (e.g., out-of-memory or
  file system full).

  @sideeffect None

  @see Cudd_DumpDot Cudd_PrintDebug Cudd_DumpBlif Cudd_DumpDaVinci
  Cudd_DumpFactoredForm

*/
int
Cudd_DumpDDcal(
  DdManager * dd /**< manager */,
  int  n /**< number of output nodes to be dumped */,
  DdNode ** f /**< array of output nodes to be dumped */,
  char const * const * inames /**< array of input names (or NULL) */,
  char const * const * onames /**< array of output names (or NULL) */,
  FILE * fp /**< pointer to the dump file */)
{
    DdNode	  *support = NULL;
    DdNode	  *scan;
    int		  *sorted = NULL;
    int		  nvars = dd->size;
    st_table	  *visited = NULL;
    int		  retval;
    int		  i;
    st_generator  *gen;
    ptruint       refAddr, diff, mask = 0;

    /* Initialize symbol table for visited nodes. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);
    if (visited == NULL) goto failure;

    /* Collect all the nodes of this DD in the symbol table. */
    for (i = 0; i < n; i++) {
	retval = cuddCollectNodes(Cudd_Regular(f[i]),visited);
	if (retval == 0) goto failure;
    }

    /* Find how many most significant hex digits are identical
    ** in the addresses of all the nodes. Build a mask based
    ** on this knowledge, so that digits that carry no information
    ** will not be printed. This is done in two steps.
    **  1. We scan the symbol table to find the bits that differ
    **     in at least 2 addresses.
    **  2. We choose one of the possible masks. There are 8 possible
    **     masks for 32-bit integer, and 16 possible masks for 64-bit
    **     integers.
    */

    /* Find the bits that are different. */
    refAddr = (ptruint) Cudd_Regular(f[0]);
    diff = 0;
    gen = st_init_gen(visited);
    while (st_gen(gen, (void **) &scan, NULL)) {
	diff |= refAddr ^ (ptruint) scan;
    }
    st_free_gen(gen);

    /* Choose the mask. */
    for (i = 0; (unsigned) i < 8 * sizeof(ptruint); i += 4) {
	mask = ((ptruint) 1 << i) - 1;
	if (diff <= mask) break;
    }
    st_free_table(visited);

    /* Build a bit array with the support of f. */
    sorted = ALLOC(int,nvars);
    if (sorted == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	goto failure;
    }
    for (i = 0; i < nvars; i++) sorted[i] = 0;

    /* Take the union of the supports of each output function. */
    support = Cudd_VectorSupport(dd,f,n);
    if (support == NULL) goto failure;
    cuddRef(support);
    scan = support;
    while (!cuddIsConstant(scan)) {
	sorted[scan->index] = 1;
	scan = cuddT(scan);
    }
    Cudd_RecursiveDeref(dd,support);
    support = NULL; /* so that we do not try to free it in case of failure */
    for (i = 0; i < nvars; i++) {
	if (sorted[dd->invperm[i]]) {
	    if (inames == NULL || inames[dd->invperm[i]] == NULL) {
		retval = fprintf(fp,"v%d", dd->invperm[i]);
	    } else {
		retval = fprintf(fp,"%s", inames[dd->invperm[i]]);
	    }
	    if (retval == EOF) goto failure;
	}
	retval = fprintf(fp,"%s", i == nvars - 1 ? "\n" : " * ");
	if (retval == EOF) goto failure;
    }
    FREE(sorted);
    sorted = NULL;

    /* Initialize symbol table for visited nodes. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);
    if (visited == NULL) goto failure;

    /* Call the function that really gets the job done. */
    for (i = 0; i < n; i++) {
	retval = ddDoDumpDDcal(dd,Cudd_Regular(f[i]),fp,visited,inames,mask);
	if (retval == 0) goto failure;
	if (onames == NULL) {
	    retval = fprintf(fp, "f%d = ", i);
	} else {
	    retval = fprintf(fp, "%s = ", onames[i]);
	}
	if (retval == EOF) goto failure;
	retval = fprintf(fp, "n%#" PRIxPTR "%s\n",
			 (((ptruint) f[i] & mask) / sizeof(DdNode)),
			 Cudd_IsComplement(f[i]) ? "'" : "");
	if (retval == EOF) goto failure;
    }

    /* Write trailer and return. */
    retval = fprintf(fp, "[");
    if (retval == EOF) goto failure;
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp, "f%d", i);
	} else {
	    retval = fprintf(fp, "%s", onames[i]);
	}
	if (retval == EOF) goto failure;
	retval = fprintf(fp, "%s", i == n-1 ? "" : " ");
	if (retval == EOF) goto failure;
    }
    retval = fprintf(fp, "]\n");
    if (retval == EOF) goto failure;

    st_free_table(visited);
    return(1);

failure:
    if (sorted != NULL) FREE(sorted);
    if (support != NULL) Cudd_RecursiveDeref(dd,support);
    if (visited != NULL) st_free_table(visited);
    return(0);

} /* end of Cudd_DumpDDcal */


/**
  @brief Writes factored forms representing the argument BDDs.

  @details Writes factored forms representing the argument BDDs.  The
  format of the factored form is the one used in the genlib files for
  technology mapping in sis.  Cudd_DumpFactoredForm does not close the
  file: This is the caller responsibility. Caution must be exercised
  because a factored form may be exponentially larger than the
  argument %BDD.  If the argument inames is non-null, it is assumed to
  hold the pointers to the names of the inputs. Similarly for onames.
  If the number of output nodes is 0, it is interpreted as 1, but no
  output name followed by equal sign is printed before the factored
  form.

  @return 1 in case of success; 0 otherwise (e.g., file system full).

  @sideeffect None

  @see Cudd_DumpDot Cudd_PrintDebug Cudd_DumpBlif Cudd_DumpDaVinci
  Cudd_DumpDDcal

*/
int
Cudd_DumpFactoredForm(
  DdManager * dd /**< manager */,
  int  n /**< number of output nodes to be dumped */,
  DdNode ** f /**< array of output nodes to be dumped */,
  char const * const * inames /**< array of input names (or NULL) */,
  char const * const * onames /**< array of output names (or NULL) */,
  FILE * fp /**< pointer to the dump file */)
{
    int		retval = 0;
    int		i;
    int		printName = n != 0;

    if (!printName) n = 1;

    /* Call the function that really gets the job done. */
    for (i = 0; i < n; i++) {
        if (printName) {
            if (onames == NULL) {
		retval = fprintf(fp, "f%d = ", i);
            } else {
		retval = fprintf(fp, "%s = ", onames[i]);
            }
        }
	if (retval == EOF) return(0);
	if (f[i] == DD_ONE(dd)) {
	    retval = fprintf(fp, "CONST1");
	    if (retval == EOF) return(0);
	} else if (f[i] == Cudd_Not(DD_ONE(dd)) || f[i] == DD_ZERO(dd)) {
	    retval = fprintf(fp, "CONST0");
	    if (retval == EOF) return(0);
	} else {
	    retval = fprintf(fp, "%s", Cudd_IsComplement(f[i]) ? (Cudd_bddIsVar(dd, Cudd_Regular(f[i])) ? "!" : "!(") : "");
	    if (retval == EOF) return(0);
	    retval = ddDoDumpFactoredForm(dd,Cudd_Regular(f[i]),fp,inames);
	    if (retval == 0) return(0);
	    retval = fprintf(fp, "%s", Cudd_IsComplement(f[i]) && !Cudd_bddIsVar(dd, Cudd_Regular(f[i])) ? ")" : "");
	    if (retval == EOF) return(0);
	}
	retval = fprintf(fp, "%s", i == n-1 ? "" : "\n");
	if (retval == EOF) return(0);
    }

    return(1);

} /* end of Cudd_DumpFactoredForm */


/**
  @brief Returns a string with the factored form of the argument BDDs

  @details The factored form uses & for conjunction, | for disjunction
  and ! for negation.  Caution must be exercised because a factored
  form may be exponentially larger than the argument %BDD.  If the
  argument inames is non-null, it is assumed to hold the pointers to
  the names of the inputs.

  @return a string in case of success; NULL otherwise.

  @sideeffect None

  @see Cudd_DumpDot Cudd_PrintDebug Cudd_DumpBlif Cudd_DumpDaVinci
  Cudd_DumpDDcal Cudd_DumpFactoredForm

*/
char *
Cudd_FactoredFormString(
  DdManager *dd,
  DdNode *f,
  char const * const * inames)
{
    cstringstream stream = newStringStream();
    int err, retval;
    char * str;

    if (!stream) {
        return(0);
    }
    /* Call the function that really gets the job done. */
    if (f == DD_ONE(dd)) {
        err = appendStringStringStream(stream, "true");
        if (err) {
            deleteStringStream(stream);
            return(0);
        }
    } else if (f == Cudd_Not(DD_ONE(dd)) || f == DD_ZERO(dd)) {
        err = appendStringStringStream(stream, "false");
        if (err) {
            deleteStringStream(stream);
            return(0);
        }
    } else {
        err = appendStringStringStream(
          stream, Cudd_IsComplement(f) ?
          (Cudd_bddIsVar(dd, Cudd_Regular(f)) ? "!" : "!(") : "");
        if (err) {
            deleteStringStream(stream);
            return(0);
        }
        retval = ddDoFactoredFormString(dd,Cudd_Regular(f),stream,inames);
        if (retval == 0) {
            deleteStringStream(stream);
            return(0);
        }
        err = appendStringStringStream(
          stream, Cudd_IsComplement(f) &&
          !Cudd_bddIsVar(dd, Cudd_Regular(f)) ? ")" : "");
        if (err) {
            deleteStringStream(stream);
            return(0);
        }
    }
    str = stringFromStringStream(stream);
    deleteStringStream(stream);
    return(str);

} /* end of Cudd_FactoredFormString */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_DumpBlif.

  @details Traverses the %BDD f and writes a multiplexer-network
  description to the file pointed by fp in blif format. f is assumed
  to be a regular pointer and ddDoDumpBlif guarantees this assumption
  in the recursive calls.

  @sideeffect None

*/
static int
ddDoDumpBlif(
  DdManager * dd,
  DdNode * f,
  FILE * fp,
  st_table * visited,
  char const * const * names,
  int mv)
{
    DdNode	*T, *E;
    int		retval;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(f));
#endif

    /* If already visited, nothing to do. */
    if (st_is_member(visited, f) == 1)
	return(1);

    /* Check for abnormal condition that should never happen. */
    if (f == NULL)
	return(0);

    /* Mark node as visited. */
    if (st_insert(visited, f, NULL) == ST_OUT_OF_MEM)
	return(0);

    /* Check for special case: If constant node, generate constant 1. */
    if (f == DD_ONE(dd)) {
	retval = fprintf(fp, ".names %" PRIxPTR "\n1\n",(ptruint) f / (ptruint) sizeof(DdNode));
	if (retval == EOF) {
	    return(0);
	} else {
	    return(1);
	}
    }

    /* Check whether this is an ADD. We deal with 0-1 ADDs, but not
    ** with the general case.
    */
    if (f == DD_ZERO(dd)) {
	retval = fprintf(fp, ".names %" PRIxPTR "\n%s",
			 (ptruint) f / (ptruint) sizeof(DdNode),
			 mv ? "0\n" : "");
	if (retval == EOF) {
	    return(0);
	} else {
	    return(1);
	}
    }
    if (cuddIsConstant(f))
	return(0);

    /* Recursive calls. */
    T = cuddT(f);
    retval = ddDoDumpBlif(dd,T,fp,visited,names,mv);
    if (retval != 1) return(retval);
    E = Cudd_Regular(cuddE(f));
    retval = ddDoDumpBlif(dd,E,fp,visited,names,mv);
    if (retval != 1) return(retval);

    /* Write multiplexer taking complement arc into account. */
    if (names != NULL) {
	retval = fprintf(fp,".names %s", names[f->index]);
    } else {
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
	retval = fprintf(fp,".names %u", f->index);
#else
	retval = fprintf(fp,".names %hu", f->index);
#endif
    }
    if (retval == EOF)
	return(0);

    if (mv) {
	if (Cudd_IsComplement(cuddE(f))) {
	    retval = fprintf(fp," %" PRIxPTR " %" PRIxPTR " %" PRIxPTR "\n.def 0\n1 1 - 1\n0 - 0 1\n",
		(ptruint) T / (ptruint) sizeof(DdNode),
		(ptruint) E / (ptruint) sizeof(DdNode),
		(ptruint) f / (ptruint) sizeof(DdNode));
	} else {
	    retval = fprintf(fp," %" PRIxPTR " %" PRIxPTR " %" PRIxPTR "\n.def 0\n1 1 - 1\n0 - 1 1\n",
		(ptruint) T / (ptruint) sizeof(DdNode),
		(ptruint) E / (ptruint) sizeof(DdNode),
		(ptruint) f / (ptruint) sizeof(DdNode));
	}
    } else {
	if (Cudd_IsComplement(cuddE(f))) {
	    retval = fprintf(fp," %" PRIxPTR " %" PRIxPTR " %" PRIxPTR "\n11- 1\n0-0 1\n",
		(ptruint) T / (ptruint) sizeof(DdNode),
		(ptruint) E / (ptruint) sizeof(DdNode),
		(ptruint) f / (ptruint) sizeof(DdNode));
	} else {
	    retval = fprintf(fp," %" PRIxPTR " %" PRIxPTR " %" PRIxPTR "\n11- 1\n0-1 1\n",
		(ptruint) T / (ptruint) sizeof(DdNode),
		(ptruint) E / (ptruint) sizeof(DdNode),
		(ptruint) f / (ptruint) sizeof(DdNode));
	}
    }
    if (retval == EOF) {
	return(0);
    } else {
	return(1);
    }

} /* end of ddDoDumpBlif */


/**
  @brief Performs the recursive step of Cudd_DumpDaVinci.

  @details Traverses the %BDD f and writes a term expression to the
  file pointed by fp in daVinci format. f is assumed to be a regular
  pointer and ddDoDumpDaVinci guarantees this assumption in the
  recursive calls.

  @sideeffect None

*/
static int
ddDoDumpDaVinci(
  DdManager * dd,
  DdNode * f,
  FILE * fp,
  st_table * visited,
  char const * const * names,
  ptruint mask)
{
    DdNode  *T, *E;
    int	    retval;
    ptruint id;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(f));
#endif

    id = ((ptruint) f & mask) / sizeof(DdNode);

    /* If already visited, insert a reference. */
    if (st_is_member(visited, f) == 1) {
	retval = fprintf(fp,"r(\"%#" PRIxPTR "\")", id);
	if (retval == EOF) {
	    return(0);
	} else {
	    return(1);
	}
    }

    /* Check for abnormal condition that should never happen. */
    if (f == NULL)
	return(0);

    /* Mark node as visited. */
    if (st_insert(visited, f, NULL) == ST_OUT_OF_MEM)
	return(0);

    /* Check for special case: If constant node, generate constant 1. */
    if (Cudd_IsConstantInt(f)) {
	retval = fprintf(fp,
			 "l(\"%#" PRIxPTR
                         "\",n(\"constant\",[a(\"OBJECT\",\"%g\")],[]))",
			 id, cuddV(f));
	if (retval == EOF) {
	    return(0);
	} else {
	    return(1);
	}
    }

    /* Recursive calls. */
    if (names != NULL) {
	retval = fprintf(fp, "l(\"%#" PRIxPTR
                         "\",n(\"internal\",[a(\"OBJECT\",\"%s\"),",
			 id, names[f->index]);
    } else {
#if SIZEOF_VOID_P == 8
	retval = fprintf(fp, "l(\"%#" PRIxPTR
                         "\",n(\"internal\",[a(\"OBJECT\",\"%u\"),",
			 id, f->index);
#else
	retval = fprintf(fp, "l(\"%#"PRIxPTR
                         "\",n(\"internal\",[a(\"OBJECT\",\"%hu\"),",
			 id, f->index);
#endif
    }
    if (retval == EOF) return(0);
    retval = fprintf(fp, "a(\"_GO\",\"ellipse\")],[e(\"then\",[a(\"EDGECOLOR\",\"blue\"),a(\"_DIR\",\"none\")],");
    if (retval == EOF) return(0);
    T = cuddT(f);
    retval = ddDoDumpDaVinci(dd,T,fp,visited,names,mask);
    if (retval != 1) return(retval);
    retval = fprintf(fp, "),e(\"else\",[a(\"EDGECOLOR\",\"%s\"),a(\"_DIR\",\"none\")],",
		     Cudd_IsComplement(cuddE(f)) ? "red" : "green");
    if (retval == EOF) return(0);
    E = Cudd_Regular(cuddE(f));
    retval = ddDoDumpDaVinci(dd,E,fp,visited,names,mask);
    if (retval != 1) return(retval);

    retval = fprintf(fp,")]))");
    if (retval == EOF) {
	return(0);
    } else {
	return(1);
    }

} /* end of ddDoDumpDaVinci */


/**
  @brief Performs the recursive step of Cudd_DumpDDcal.

  @details Traverses the %BDD f and writes a line for each node to the
  file pointed by fp in DDcal format. f is assumed to be a regular
  pointer and ddDoDumpDDcal guarantees this assumption in the
  recursive calls.

  @sideeffect None

*/
static int
ddDoDumpDDcal(
  DdManager * dd,
  DdNode * f,
  FILE * fp,
  st_table * visited,
  char const * const * names,
  ptruint mask)
{
    DdNode  *T, *E;
    int	    retval;
    ptruint id, idT, idE;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(f));
#endif

    id = ((ptruint) f & mask) / sizeof(DdNode);

    /* If already visited, do nothing. */
    if (st_is_member(visited, f) == 1) {
	return(1);
    }

    /* Check for abnormal condition that should never happen. */
    if (f == NULL)
	return(0);

    /* Mark node as visited. */
    if (st_insert(visited, f, NULL) == ST_OUT_OF_MEM)
	return(0);

    /* Check for special case: If constant node, assign constant. */
    if (Cudd_IsConstantInt(f)) {
	if (f != DD_ONE(dd) && f != DD_ZERO(dd))
	    return(0);
	retval = fprintf(fp, "n%#" PRIxPTR" = %g\n", id, cuddV(f));
	if (retval == EOF) {
	    return(0);
	} else {
	    return(1);
	}
    }

    /* Recursive calls. */
    T = cuddT(f);
    retval = ddDoDumpDDcal(dd,T,fp,visited,names,mask);
    if (retval != 1) return(retval);
    E = Cudd_Regular(cuddE(f));
    retval = ddDoDumpDDcal(dd,E,fp,visited,names,mask);
    if (retval != 1) return(retval);
    idT = ((ptruint) T & mask) / sizeof(DdNode);
    idE = ((ptruint) E & mask) / sizeof(DdNode);
    if (names != NULL) {
	retval = fprintf(fp, "n%#" PRIxPTR " = %s * n%#" PRIxPTR
                         " + %s' * n%#" PRIxPTR "%s\n",
			 id, names[f->index], idT, names[f->index],
			 idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
    } else {
#if SIZEOF_VOID_P == 8
	retval = fprintf(fp, "n%#" PRIxPTR " = v%u * n%#" PRIxPTR
                         " + v%u' * n%#" PRIxPTR "%s\n",
			 id, f->index, idT, f->index,
			 idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
#else
	retval = fprintf(fp, "n%#"PRIxPTR" = v%hu * n%#"PRIxPTR
                         " + v%hu' * n%#"PRIxPTR"%s\n",
			 id, f->index, idT, f->index,
			 idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
#endif
    }
    if (retval == EOF) {
	return(0);
    } else {
	return(1);
    }

} /* end of ddDoDumpDDcal */


/**
  @brief Performs the recursive step of Cudd_DumpFactoredForm.

  @details Traverses the %BDD f and writes a factored form for each
  node to the file pointed by fp in terms of the factored forms of the
  children. Constants are propagated, and absorption is applied.  f is
  assumed to be a regular pointer and ddDoDumpFActoredForm guarantees
  this assumption in the recursive calls.

  @sideeffect None

  @see Cudd_DumpFactoredForm

*/
static int
ddDoDumpFactoredForm(
  DdManager * dd,
  DdNode * f,
  FILE * fp,
  char const * const * names)
{
    DdNode	*T, *E;
    int		retval;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(f));
    assert(!cuddIsConstant(f));
#endif

    /* Check for abnormal condition that should never happen. */
    if (f == NULL)
	return(0);

    /* Recursive calls. */
    T = cuddT(f);
    E = cuddE(f);
    if (T != DD_ZERO(dd)) {
	if (E != DD_ONE(dd)) {
	    if (names != NULL) {
		retval = fprintf(fp, "%s", names[f->index]);
	    } else {
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
		retval = fprintf(fp, "x%u", f->index);
#else
		retval = fprintf(fp, "x%hu", f->index);
#endif
	    }
	    if (retval == EOF) return(0);
	}
	if (T != DD_ONE(dd)) {
            //	    retval = fprintf(fp, "%s(", E != DD_ONE(dd) ? " * " : "");
            retval = fprintf(fp, "%s%s", E != DD_ONE(dd) ? " * " : "", Cudd_bddIsVar(dd, T) ? "" : "(");
	    if (retval == EOF) return(0);
	    retval = ddDoDumpFactoredForm(dd,T,fp,names);
	    if (retval != 1) return(retval);
	    retval = fprintf(fp, "%s", Cudd_bddIsVar(dd, T) ? "" : ")");
	    if (retval == EOF) return(0);
	}
	if (E == Cudd_Not(DD_ONE(dd)) || E == DD_ZERO(dd)) return(1);
	retval = fprintf(fp, " + ");
	if (retval == EOF) return(0);
    }
    E = Cudd_Regular(E);
    if (T != DD_ONE(dd)) {
	if (names != NULL) {
	    retval = fprintf(fp, "!%s", names[f->index]);
	} else {
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
	    retval = fprintf(fp, "!x%u", f->index);
#else
	    retval = fprintf(fp, "!x%hu", f->index);
#endif
	}
	if (retval == EOF) return(0);
    }
    if (E != DD_ONE(dd)) {
	retval = fprintf(fp, "%s%s%s", T != DD_ONE(dd) ? " * " : "",
			 E != cuddE(f) ? "!" : "", Cudd_bddIsVar(dd, E) ? "" : "(");
	if (retval == EOF) return(0);
	retval = ddDoDumpFactoredForm(dd,E,fp,names);
	if (retval != 1) return(retval);
	retval = fprintf(fp, "%s", Cudd_bddIsVar(dd, E) ? "" : "(");
	if (retval == EOF) return(0);
    }
    return(1);

} /* end of ddDoDumpFactoredForm */


/**
  @brief Performs the recursive step of Cudd_DumpFactoredForm.

  @details Traverses the %BDD f and writes a factored form for each
  node to the file pointed by fp in terms of the factored forms of the
  children. Constants are propagated, and absorption is applied.  f is
  assumed to be a regular pointer and ddDoDumpFActoredForm guarantees
  this assumption in the recursive calls.

  @sideeffect None

  @see Cudd_DumpFactoredForm

*/
static int
ddDoFactoredFormString(
  DdManager * dd,
  DdNode * f,
  cstringstream stream,
  char const * const * names)
{
    DdNode	*T, *E;
    int		retval, err;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(f));
    assert(!cuddIsConstant(f));
#endif

    /* Check for abnormal condition that should never happen. */
    if (f == NULL)
	return(0);

    /* Recursive calls. */
    T = cuddT(f);
    E = cuddE(f);
    if (T != DD_ZERO(dd)) {
	if (E != DD_ONE(dd)) {
	    if (names != NULL) {
                err = appendStringStringStream(stream, names[f->index]);
	    } else {
                err = appendCharStringStream(stream, 'x');
                if (err) return(0);
                err = appendUnsignedStringStream(stream, (unsigned) f->index);
	    }
	    if (err) return(0);
	}
	if (T != DD_ONE(dd)) {
            err = appendStringStringStream(stream, E != DD_ONE(dd) ? " & " : "");
            if (err) return(0);
            err = appendStringStringStream(stream, Cudd_bddIsVar(dd, T) ? "" : "(");
	    if (err) return(0);
	    retval = ddDoFactoredFormString(dd,T,stream,names);
	    if (retval != 1) return(retval);
            err = appendStringStringStream(stream, Cudd_bddIsVar(dd, T) ? "" : ")");
	    if (err) return(0);
	}
	if (E == Cudd_Not(DD_ONE(dd)) || E == DD_ZERO(dd)) return(1);
        err = appendStringStringStream(stream,  " | ");
	if (err) return(0);
    }
    E = Cudd_Regular(E);
    if (T != DD_ONE(dd)) {
        err = appendCharStringStream(stream, '!');
        if (err) return(0);
	if (names != NULL) {
            err = appendStringStringStream(stream, names[f->index]);
	} else {
            err = appendCharStringStream(stream, 'x');
            if (err) return(0);
            err = appendUnsignedStringStream(stream, (unsigned) f->index);
	}
	if (err) return(0);
    }
    if (E != DD_ONE(dd)) {
        err = appendStringStringStream(stream, T != DD_ONE(dd) ? " & " : "");
        if (err) return(0);
        err = appendStringStringStream(stream, E != cuddE(f) ? "!" : "");
        if (err) return(0);
        err = appendStringStringStream(stream, Cudd_bddIsVar(dd, E) ? "" : "(");
        if (err) return(0);
	retval = ddDoFactoredFormString(dd,E,stream,names);
	if (retval != 1) return(retval);
        err = appendStringStringStream(stream, Cudd_bddIsVar(dd, E) ? "" : ")");
	if (err) return(0);
    }
    return(1);

} /* end of ddDoFactoredFormString */

cuddGenCof.c
57084
/**
  @file

  @ingroup cudd

  @brief Generalized cofactors for BDDs and ADDs.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* Codes for edge markings in Cudd_bddLICompaction.  The codes are defined
** so that they can be bitwise ORed to implement the code priority scheme.
*/
#define DD_LIC_DC 0
#define DD_LIC_1  1
#define DD_LIC_0  2
#define DD_LIC_NL 3

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/** Key for the cache used in the edge marking phase. */
typedef struct MarkCacheKey {
    DdNode *f;
    DdNode *c;
} MarkCacheKey;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int cuddBddConstrainDecomp (DdManager *dd, DdNode *f, DdNode **decomp);
static DdNode * cuddBddCharToVect (DdManager *dd, DdNode *f, DdNode *x);
static int cuddBddLICMarkEdges (DdManager *dd, DdNode *f, DdNode *c, st_table *table, st_table *cache);
static DdNode * cuddBddLICBuildResult (DdManager *dd, DdNode *f, st_table *cache, st_table *table);
static int MarkCacheHash (void const *ptr, int modulus);
static int MarkCacheCompare (const void *ptr1, const void *ptr2);
static enum st_retval MarkCacheCleanUp (void *key, void *value, void *arg);
static DdNode * cuddBddSqueeze (DdManager *dd, DdNode *l, DdNode *u);
static DdNode * cuddBddInterpolate (DdManager * dd, DdNode * l, DdNode * u);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes f constrain c.

  @details Computes f constrain c (f @ c).
  Uses a canonical form: (f' @ c) = (f @ c)'.  (Note: this is not true
  for c.)  List of special cases:
    <ul>
    <li> f @ 0 = 0
    <li> f @ 1 = f
    <li> 0 @ c = 0
    <li> 1 @ c = 1
    <li> f @ f = 1
    <li> f @ f'= 0
    </ul>
  Note that if F=(f1,...,fn) and reordering takes place while computing F @ c,
  then the image restriction property (Img(F,c) = Img(F @ c)) is lost.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddRestrict Cudd_addConstrain

*/
DdNode *
Cudd_bddConstrain(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddConstrainRecur(dd,f,c);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddConstrain */


/**
  @brief %BDD restrict according to Coudert and Madre's algorithm
  (ICCAD90).

  @details If application of restrict results in a %BDD larger than the
  input %BDD, the input %BDD is returned.

  @return the restricted %BDD if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_bddConstrain Cudd_addRestrict

*/
DdNode *
Cudd_bddRestrict(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode *suppF, *suppC, *commonSupport;
    DdNode *cplus, *res;
    int retval;
    int sizeF, sizeRes;

    /* Check terminal cases here to avoid computing supports in trivial cases.
    ** This also allows us notto check later for the case c == 0, in which
    ** there is no common support. */
    if (c == Cudd_Not(DD_ONE(dd))) return(Cudd_Not(DD_ONE(dd)));
    if (Cudd_IsConstantInt(f)) return(f);
    if (f == c) return(DD_ONE(dd));
    if (f == Cudd_Not(c)) return(Cudd_Not(DD_ONE(dd)));

    /* Check if supports intersect. */
    retval = Cudd_ClassifySupport(dd,f,c,&commonSupport,&suppF,&suppC);
    if (retval == 0) {
	return(NULL);
    }
    cuddRef(commonSupport); cuddRef(suppF); cuddRef(suppC);
    Cudd_IterDerefBdd(dd,suppF);

    if (commonSupport == DD_ONE(dd)) {
	Cudd_IterDerefBdd(dd,commonSupport);
	Cudd_IterDerefBdd(dd,suppC);
	return(f);
    }
    Cudd_IterDerefBdd(dd,commonSupport);

    /* Abstract from c the variables that do not appear in f. */
    cplus = Cudd_bddExistAbstract(dd, c, suppC);
    if (cplus == NULL) {
	Cudd_IterDerefBdd(dd,suppC);
	return(NULL);
    }
    cuddRef(cplus);
    Cudd_IterDerefBdd(dd,suppC);

    do {
	dd->reordered = 0;
	res = cuddBddRestrictRecur(dd, f, cplus);
    } while (dd->reordered == 1);
    if (res == NULL) {
	Cudd_IterDerefBdd(dd,cplus);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
          dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_IterDerefBdd(dd,cplus);
    /* Make restric safe by returning the smaller of the input and the
    ** result. */
    sizeF = Cudd_DagSize(f);
    sizeRes = Cudd_DagSize(res);
    if (sizeF <= sizeRes) {
	Cudd_IterDerefBdd(dd, res);
	return(f);
    } else {
	cuddDeref(res);
	return(res);
    }

} /* end of Cudd_bddRestrict */


/**
  @brief Computes f non-polluting-and g.

  @details The non-polluting AND of f and g is a hybrid of AND and
  Restrict.  From Restrict, this operation takes the idea of
  existentially quantifying the top variable of the second operand if
  it does not appear in the first.  Therefore, the variables that
  appear in the result also appear in f.  For the rest, the function
  behaves like AND.  Since the two operands play different roles,
  non-polluting AND is not commutative.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddConstrain Cudd_bddRestrict

*/
DdNode *
Cudd_bddNPAnd(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddNPAndRecur(dd,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddNPAnd */


/**
  @brief Computes f constrain c for ADDs.

  @details Computes f constrain c (f @ c), for f an %ADD and c a 0-1
  %ADD.  List of special cases:
  <ul>
  <li> F @ 0 = 0
  <li> F @ 1 = F
  <li> 0 @ c = 0
  <li> 1 @ c = 1
  <li> F @ F = 1
  </ul>

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddConstrain

*/
DdNode *
Cudd_addConstrain(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddAddConstrainRecur(dd,f,c);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addConstrain */


/**
  @brief %BDD conjunctive decomposition as in McMillan's CAV96 paper.

  @details The decomposition is canonical only for a given variable
  order. If canonicity is required, variable ordering must be disabled
  after the decomposition has been computed.  The components of the
  solution have their reference counts already incremented (unlike the
  results of most other functions in the package).

  @return an array with one entry for each %BDD variable in the manager
  if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_bddConstrain Cudd_bddExistAbstract

*/
DdNode **
Cudd_bddConstrainDecomp(
  DdManager * dd,
  DdNode * f)
{
    DdNode **decomp;
    int res;
    int i;

    /* Create an initialize decomposition array. */
    decomp = ALLOC(DdNode *,dd->size);
    if (decomp == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < dd->size; i++) {
	decomp[i] = NULL;
    }
    do {
	dd->reordered = 0;
	/* Clean up the decomposition array in case reordering took place. */
	for (i = 0; i < dd->size; i++) {
	    if (decomp[i] != NULL) {
		Cudd_IterDerefBdd(dd, decomp[i]);
		decomp[i] = NULL;
	    }
	}
	res = cuddBddConstrainDecomp(dd,f,decomp);
    } while (dd->reordered == 1);
    if (res == 0) {
	FREE(decomp);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
          dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    /* Missing components are constant ones. */
    for (i = 0; i < dd->size; i++) {
	if (decomp[i] == NULL) {
	    decomp[i] = DD_ONE(dd);
	    cuddRef(decomp[i]);
	}
    }
    return(decomp);

} /* end of Cudd_bddConstrainDecomp */


/**
  @brief %ADD restrict according to Coudert and Madre's algorithm
  (ICCAD90).

  @details If application of restrict results in an %ADD larger than
  the input %ADD, the input %ADD is returned.

  @return the restricted %ADD if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_addConstrain Cudd_bddRestrict

*/
DdNode *
Cudd_addRestrict(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode *supp_f, *supp_c;
    DdNode *res, *commonSupport;
    int intersection;
    int sizeF, sizeRes;

    /* Check if supports intersect. */
    supp_f = Cudd_Support(dd, f);
    if (supp_f == NULL) {
	return(NULL);
    }
    cuddRef(supp_f);
    supp_c = Cudd_Support(dd, c);
    if (supp_c == NULL) {
	Cudd_RecursiveDeref(dd,supp_f);
	return(NULL);
    }
    cuddRef(supp_c);
    commonSupport = Cudd_bddLiteralSetIntersection(dd, supp_f, supp_c);
    if (commonSupport == NULL) {
	Cudd_RecursiveDeref(dd,supp_f);
	Cudd_RecursiveDeref(dd,supp_c);
	return(NULL);
    }
    cuddRef(commonSupport);
    Cudd_RecursiveDeref(dd,supp_f);
    Cudd_RecursiveDeref(dd,supp_c);
    intersection = commonSupport != DD_ONE(dd);
    Cudd_RecursiveDeref(dd,commonSupport);

    if (intersection) {
	do {
	    dd->reordered = 0;
	    res = cuddAddRestrictRecur(dd, f, c);
	} while (dd->reordered == 1);
        if (res == 0) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(f);
        }
	sizeF = Cudd_DagSize(f);
	sizeRes = Cudd_DagSize(res);
	if (sizeF <= sizeRes) {
	    cuddRef(res);
	    Cudd_RecursiveDeref(dd, res);
	    return(f);
	} else {
	    return(res);
	}
    } else {
	return(f);
    }

} /* end of Cudd_addRestrict */


/**
  @brief Computes a vector of BDDs whose image equals a non-zero function.

  @details 
  The result depends on the variable order. The i-th component of the vector
  depends only on the first i variables in the order.  Each %BDD in the vector
  is not larger than the %BDD of the given characteristic function.  This
  function is based on the description of char-to-vect in "Verification of
  Sequential Machines Using Boolean Functional Vectors" by O. Coudert, C.
  Berthet and J. C. Madre.

  @return a pointer to an array containing the result if successful;
  NULL otherwise.  The size of the array equals the number of
  variables in the manager. The components of the solution have their
  reference counts already incremented (unlike the results of most
  other functions in the package).

  @sideeffect None

  @see Cudd_bddConstrain

*/
DdNode **
Cudd_bddCharToVect(
  DdManager * dd,
  DdNode * f)
{
    int i, j;
    DdNode **vect;
    DdNode *res = NULL;

    if (f == Cudd_Not(DD_ONE(dd))) return(NULL);

    vect = ALLOC(DdNode *, dd->size);
    if (vect == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    do {
	dd->reordered = 0;
	for (i = 0; i < dd->size; i++) {
	    res = cuddBddCharToVect(dd,f,dd->vars[dd->invperm[i]]);
	    if (res == NULL) {
		/* Clean up the vector array in case reordering took place. */
		for (j = 0; j < i; j++) {
		    Cudd_IterDerefBdd(dd, vect[dd->invperm[j]]);
		}
		break;
	    }
	    cuddRef(res);
	    vect[dd->invperm[i]] = res;
	}
    } while (dd->reordered == 1);
    if (res == NULL) {
	FREE(vect);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    return(vect);

} /* end of Cudd_bddCharToVect */


/**
  @brief Performs safe minimization of a %BDD.

  @details Given the %BDD `f` of a function to be minimized and a %BDD
  `c` representing the care set, Cudd_bddLICompaction produces the
  %BDD of a function that agrees with `f` wherever `c` is 1.  Safe
  minimization means that the size of the result is guaranteed not to
  exceed the size of `f`. This function is based on the DAC97 paper by
  Hong et al..

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddRestrict

*/
DdNode *
Cudd_bddLICompaction(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be minimized */,
  DdNode * c /**< constraint (care set) */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddLICompaction(dd,f,c);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddLICompaction */


/**
  @brief Finds a small %BDD in a function interval.

  @details Given BDDs `l` and `u`, representing the lower bound and
  upper bound of a function interval, Cudd_bddSqueeze produces the
  %BDD of a function within the interval with a small %BDD.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddRestrict Cudd_bddLICompaction

*/
DdNode *
Cudd_bddSqueeze(
  DdManager * dd /**< manager */,
  DdNode * l /**< lower bound */,
  DdNode * u /**< upper bound */)
{
    DdNode *res;
    int sizeRes, sizeL, sizeU;

    do {
	dd->reordered = 0;
	res = cuddBddSqueeze(dd,l,u);
    } while (dd->reordered == 1);
    if (res == NULL) {
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
        return(NULL);
    }
    /* We now compare the result with the bounds and return the smallest.
    ** We first compare to u, so that in case l == 0 and u == 1, we return
    ** 0 as in other minimization algorithms. */
    sizeRes = Cudd_DagSize(res);
    sizeU = Cudd_DagSize(u);
    if (sizeU <= sizeRes) {
	cuddRef(res);
	Cudd_IterDerefBdd(dd,res);
	res = u;
	sizeRes = sizeU;
    }
    sizeL = Cudd_DagSize(l);
    if (sizeL <= sizeRes) {
	cuddRef(res);
	Cudd_IterDerefBdd(dd,res);
	res = l;
    }
    return(res);

} /* end of Cudd_bddSqueeze */


/**
  @brief Finds an interpolant of two functions.

  @details Given BDDs `l` and `u`, representing the lower bound and
  upper bound of a function interval, Cudd_bddInterpolate produces the
  %BDD of a function within the interval that only depends on the
  variables common to `l` and `u`.

  The approach is based on quantification as in Cudd_bddRestrict().
  The function assumes that `l` implies `u`, but does not check whether
  that's true.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddRestrict Cudd_bddSqueeze

*/
DdNode *
Cudd_bddInterpolate(
  DdManager * dd /**< manager */,
  DdNode * l /**< lower bound */,
  DdNode * u /**< upper bound */)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddInterpolate(dd,l,u);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddInterpolate */


/**
  @brief Finds a small %BDD that agrees with `f` over `c`.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddRestrict Cudd_bddLICompaction Cudd_bddSqueeze

*/
DdNode *
Cudd_bddMinimize(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode *cplus, *res;

    if (c == Cudd_Not(DD_ONE(dd))) return(c);
    if (Cudd_IsConstantInt(f)) return(f);
    if (f == c) return(DD_ONE(dd));
    if (f == Cudd_Not(c)) return(Cudd_Not(DD_ONE(dd)));

    cplus = Cudd_RemapOverApprox(dd,c,0,0,1.0);
    if (cplus == NULL) return(NULL);
    cuddRef(cplus);
    res = Cudd_bddLICompaction(dd,f,cplus);
    if (res == NULL) {
	Cudd_IterDerefBdd(dd,cplus);
	return(NULL);
    }
    cuddRef(res);
    Cudd_IterDerefBdd(dd,cplus);
    cuddDeref(res);
    return(res);

} /* end of Cudd_bddMinimize */


/**
  @brief Find a dense subset of %BDD `f`.

  @details Density is the ratio of number of minterms to number of
  nodes.  Uses several techniques in series. It is more expensive than
  other subsetting procedures, but often produces better results. See
  Cudd_SubsetShortPaths for a description of the threshold and nvars
  parameters.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_RemapUnderApprox Cudd_SubsetShortPaths
  Cudd_SubsetHeavyBranch Cudd_bddSqueeze

*/
DdNode *
Cudd_SubsetCompress(
  DdManager * dd /**< manager */,
  DdNode * f /**< %BDD whose subset is sought */,
  int  nvars /**< number of variables in the support of f */,
  int  threshold /**< maximum number of nodes in the subset */)
{
    DdNode *res, *tmp1, *tmp2;

    tmp1 = Cudd_SubsetShortPaths(dd, f, nvars, threshold, 0);
    if (tmp1 == NULL) return(NULL);
    cuddRef(tmp1);
    tmp2 = Cudd_RemapUnderApprox(dd,tmp1,nvars,0,0.95);
    if (tmp2 == NULL) {
	Cudd_IterDerefBdd(dd,tmp1);
	return(NULL);
    }
    cuddRef(tmp2);
    Cudd_IterDerefBdd(dd,tmp1);
    res = Cudd_bddSqueeze(dd,tmp2,f);
    if (res == NULL) {
	Cudd_IterDerefBdd(dd,tmp2);
	return(NULL);
    }
    cuddRef(res);
    Cudd_IterDerefBdd(dd,tmp2);
    cuddDeref(res);
    return(res);

} /* end of Cudd_SubsetCompress */


/**
  @brief Find a dense superset of %BDD `f`.

  @details Density is the ratio of number of minterms to number of
  nodes.  Uses several techniques in series. It is more expensive than
  other supersetting procedures, but often produces better
  results. See Cudd_SupersetShortPaths for a description of the
  threshold and nvars parameters.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_SubsetCompress Cudd_SupersetRemap Cudd_SupersetShortPaths
  Cudd_SupersetHeavyBranch Cudd_bddSqueeze

*/
DdNode *
Cudd_SupersetCompress(
  DdManager * dd /**< manager */,
  DdNode * f /**< %BDD whose superset is sought */,
  int  nvars /**< number of variables in the support of f */,
  int  threshold /**< maximum number of nodes in the superset */)
{
    DdNode *subset;

    subset = Cudd_SubsetCompress(dd, Cudd_Not(f),nvars,threshold);

    return(Cudd_NotCond(subset, (subset != NULL)));

} /* end of Cudd_SupersetCompress */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_bddConstrain.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddConstrain

*/
DdNode *
cuddBddConstrainRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode       *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r;
    DdNode	 *one, *zero;
    int		 topf, topc;
    unsigned int index;
    int          comple = 0;

    statLine(dd);
    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    /* Trivial cases. */
    if (c == one)		return(f);
    if (c == zero)		return(zero);
    if (Cudd_IsConstantInt(f))	return(f);
    if (f == c)			return(one);
    if (f == Cudd_Not(c))	return(zero);

    /* Make canonical to increase the utilization of the cache. */
    if (Cudd_IsComplement(f)) {
	f = Cudd_Not(f);
	comple = 1;
    }
    /* Now f is a regular pointer to a non-constant node; c is also
    ** non-constant, but may be complemented.
    */

    /* Check the cache. */
    r = cuddCacheLookup2(dd, Cudd_bddConstrain, f, c);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple));
    }

    checkWhetherToGiveUp(dd);
    
    /* Recursive step. */
    topf = dd->perm[f->index];
    topc = dd->perm[Cudd_Regular(c)->index];
    if (topf <= topc) {
	index = f->index;
	Fv = cuddT(f); Fnv = cuddE(f);
    } else {
	index = Cudd_Regular(c)->index;
	Fv = Fnv = f;
    }
    if (topc <= topf) {
	Cv = cuddT(Cudd_Regular(c)); Cnv = cuddE(Cudd_Regular(c));
	if (Cudd_IsComplement(c)) {
	    Cv = Cudd_Not(Cv);
	    Cnv = Cudd_Not(Cnv);
	}
    } else {
	Cv = Cnv = c;
    }

    if (!Cudd_IsConstantInt(Cv)) {
	t = cuddBddConstrainRecur(dd, Fv, Cv);
	if (t == NULL)
	    return(NULL);
    } else if (Cv == one) {
	t = Fv;
    } else {		/* Cv == zero: return Fnv @ Cnv */
	if (Cnv == one) {
	    r = Fnv;
	} else {
	    r = cuddBddConstrainRecur(dd, Fnv, Cnv);
	    if (r == NULL)
		return(NULL);
	}
	return(Cudd_NotCond(r,comple));
    }
    cuddRef(t);

    if (!Cudd_IsConstantInt(Cnv)) {
	e = cuddBddConstrainRecur(dd, Fnv, Cnv);
	if (e == NULL) {
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
    } else if (Cnv == one) {
	e = Fnv;
    } else {		/* Cnv == zero: return Fv @ Cv previously computed */
	cuddDeref(t);
	return(Cudd_NotCond(t,comple));
    }
    cuddRef(e);

    if (Cudd_IsComplement(t)) {
	t = Cudd_Not(t);
	e = Cudd_Not(e);
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
	r = Cudd_Not(r);
    } else {
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert2(dd, Cudd_bddConstrain, f, c, r);
    return(Cudd_NotCond(r,comple));

} /* end of cuddBddConstrainRecur */


/**
  @brief Performs the recursive step of Cudd_bddRestrict.

  @return the restricted %BDD if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_bddRestrict

*/
DdNode *
cuddBddRestrictRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode	 *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r, *one, *zero;
    int		 topf, topc;
    unsigned int index;
    int		 comple = 0;

    statLine(dd);
    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    /* Trivial cases */
    if (c == one)		return(f);
    if (c == zero)		return(zero);
    if (Cudd_IsConstantInt(f))	return(f);
    if (f == c)			return(one);
    if (f == Cudd_Not(c))	return(zero);

    /* Make canonical to increase the utilization of the cache. */
    if (Cudd_IsComplement(f)) {
	f = Cudd_Not(f);
	comple = 1;
    }
    /* Now f is a regular pointer to a non-constant node; c is also
    ** non-constant, but may be complemented.
    */

    /* Check the cache. */
    r = cuddCacheLookup2(dd, Cudd_bddRestrict, f, c);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple));
    }

    checkWhetherToGiveUp(dd);

    topf = dd->perm[f->index];
    topc = dd->perm[Cudd_Regular(c)->index];

    if (topc < topf) {	/* abstract top variable from c */
	DdNode *d, *s1, *s2;

	/* Find complements of cofactors of c. */
	if (Cudd_IsComplement(c)) {
	    s1 = cuddT(Cudd_Regular(c));
	    s2 = cuddE(Cudd_Regular(c));
	} else {
	    s1 = Cudd_Not(cuddT(c));
	    s2 = Cudd_Not(cuddE(c));
	}
	/* Take the OR by applying DeMorgan. */
	d = cuddBddAndRecur(dd, s1, s2);
	if (d == NULL) return(NULL);
	d = Cudd_Not(d);
	cuddRef(d);
	r = cuddBddRestrictRecur(dd, f, d);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, d);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_IterDerefBdd(dd, d);
	cuddCacheInsert2(dd, Cudd_bddRestrict, f, c, r);
	cuddDeref(r);
	return(Cudd_NotCond(r,comple));
    }

    /* Recursive step. Here topf <= topc. */
    index = f->index;
    Fv = cuddT(f); Fnv = cuddE(f);
    if (topc == topf) {
	Cv = cuddT(Cudd_Regular(c)); Cnv = cuddE(Cudd_Regular(c));
	if (Cudd_IsComplement(c)) {
	    Cv = Cudd_Not(Cv);
	    Cnv = Cudd_Not(Cnv);
	}
    } else {
	Cv = Cnv = c;
    }

    if (!Cudd_IsConstantInt(Cv)) {
	t = cuddBddRestrictRecur(dd, Fv, Cv);
	if (t == NULL) return(NULL);
    } else if (Cv == one) {
	t = Fv;
    } else {		/* Cv == zero: return(Fnv @ Cnv) */
	if (Cnv == one) {
	    r = Fnv;
	} else {
	    r = cuddBddRestrictRecur(dd, Fnv, Cnv);
	    if (r == NULL) return(NULL);
	}
	return(Cudd_NotCond(r,comple));
    }
    cuddRef(t);

    if (!Cudd_IsConstantInt(Cnv)) {
	e = cuddBddRestrictRecur(dd, Fnv, Cnv);
	if (e == NULL) {
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
    } else if (Cnv == one) {
	e = Fnv;
    } else {		/* Cnv == zero: return (Fv @ Cv) previously computed */
	cuddDeref(t);
	return(Cudd_NotCond(t,comple));
    }
    cuddRef(e);

    if (Cudd_IsComplement(t)) {
	t = Cudd_Not(t);
	e = Cudd_Not(e);
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
	r = Cudd_Not(r);
    } else {
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert2(dd, Cudd_bddRestrict, f, c, r);
    return(Cudd_NotCond(r,comple));

} /* end of cuddBddRestrictRecur */


/**
  @brief Implements the recursive step of Cudd_bddAnd.

  @return a pointer to the result is successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddNPAnd

*/
DdNode *
cuddBddNPAndRecur(
  DdManager * manager,
  DdNode * f,
  DdNode * g)
{
    DdNode *F, *ft, *fe, *G, *gt, *ge;
    DdNode *one, *r, *t, *e;
    int topf, topg;
    unsigned int index;

    statLine(manager);
    one = DD_ONE(manager);

    /* Terminal cases. */
    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    if (F == G) {
	if (f == g) return(one);
	else return(Cudd_Not(one));
    }
    if (G == one) {
	if (g == one) return(f);
	else return(g);
    }
    if (F == one) {
	return(f);
    }

    /* At this point f and g are not constant. */
    /* Check cache. */
    if (F->ref != 1 || G->ref != 1) {
	r = cuddCacheLookup2(manager, Cudd_bddNPAnd, f, g);
	if (r != NULL) return(r);
    }

    checkWhetherToGiveUp(manager);

    /* Here we can skip the use of cuddI, because the operands are known
    ** to be non-constant.
    */
    topf = manager->perm[F->index];
    topg = manager->perm[G->index];

    if (topg < topf) {	/* abstract top variable from g */
	DdNode *d;

	/* Find complements of cofactors of g. */
	if (Cudd_IsComplement(g)) {
	    gt = cuddT(G);
	    ge = cuddE(G);
	} else {
	    gt = Cudd_Not(cuddT(g));
	    ge = Cudd_Not(cuddE(g));
	}
	/* Take the OR by applying DeMorgan. */
	d = cuddBddAndRecur(manager, gt, ge);
	if (d == NULL) return(NULL);
	d = Cudd_Not(d);
	cuddRef(d);
	r = cuddBddNPAndRecur(manager, f, d);
	if (r == NULL) {
	    Cudd_IterDerefBdd(manager, d);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_IterDerefBdd(manager, d);
	cuddCacheInsert2(manager, Cudd_bddNPAnd, f, g, r);
	cuddDeref(r);
	return(r);
    }

    /* Compute cofactors. */
    index = F->index;
    ft = cuddT(F);
    fe = cuddE(F);
    if (Cudd_IsComplement(f)) {
      ft = Cudd_Not(ft);
      fe = Cudd_Not(fe);
    }

    if (topg == topf) {
	gt = cuddT(G);
	ge = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gt = Cudd_Not(gt);
	    ge = Cudd_Not(ge);
	}
    } else {
	gt = ge = g;
    }

    t = cuddBddAndRecur(manager, ft, gt);
    if (t == NULL) return(NULL);
    cuddRef(t);

    e = cuddBddAndRecur(manager, fe, ge);
    if (e == NULL) {
	Cudd_IterDerefBdd(manager, t);
	return(NULL);
    }
    cuddRef(e);

    if (t == e) {
	r = t;
    } else {
	if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(manager,(int)index,Cudd_Not(t),Cudd_Not(e));
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(manager,(int)index,t,e);
	    if (r == NULL) {
		Cudd_IterDerefBdd(manager, t);
		Cudd_IterDerefBdd(manager, e);
		return(NULL);
	    }
	}
    }
    cuddDeref(e);
    cuddDeref(t);
    if (F->ref != 1 || G->ref != 1)
	cuddCacheInsert2(manager, Cudd_bddNPAnd, f, g, r);
    return(r);

} /* end of cuddBddNPAndRecur */


/**
  @brief Performs the recursive step of Cudd_addConstrain.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addConstrain

*/
DdNode *
cuddAddConstrainRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode       *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r;
    DdNode	 *one, *zero;
    int		 topf, topc;
    unsigned int index;

    statLine(dd);
    one = DD_ONE(dd);
    zero = DD_ZERO(dd);

    /* Trivial cases. */
    if (c == one)		return(f);
    if (c == zero)		return(zero);
    if (cuddIsConstant(f))	return(f);
    if (f == c)			return(one);

    /* Now f and c are non-constant. */

    /* Check the cache. */
    r = cuddCacheLookup2(dd, Cudd_addConstrain, f, c);
    if (r != NULL) {
	return(r);
    }

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    topf = dd->perm[f->index];
    topc = dd->perm[c->index];
    if (topf <= topc) {
	index = f->index;
	Fv = cuddT(f); Fnv = cuddE(f);
    } else {
	index = c->index;
	Fv = Fnv = f;
    }
    if (topc <= topf) {
	Cv = cuddT(c); Cnv = cuddE(c);
    } else {
	Cv = Cnv = c;
    }

    if (!cuddIsConstant(Cv)) {
	t = cuddAddConstrainRecur(dd, Fv, Cv);
	if (t == NULL)
	    return(NULL);
    } else if (Cv == one) {
	t = Fv;
    } else {		/* Cv == zero: return Fnv @ Cnv */
	if (Cnv == one) {
	    r = Fnv;
	} else {
	    r = cuddAddConstrainRecur(dd, Fnv, Cnv);
	    if (r == NULL)
		return(NULL);
	}
	return(r);
    }
    cuddRef(t);

    if (!cuddIsConstant(Cnv)) {
	e = cuddAddConstrainRecur(dd, Fnv, Cnv);
	if (e == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
    } else if (Cnv == one) {
	e = Fnv;
    } else {		/* Cnv == zero: return Fv @ Cv previously computed */
	cuddDeref(t);
	return(t);
    }
    cuddRef(e);

    r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
    if (r == NULL) {
	Cudd_RecursiveDeref(dd, e);
	Cudd_RecursiveDeref(dd, t);
	return(NULL);
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert2(dd, Cudd_addConstrain, f, c, r);
    return(r);

} /* end of cuddAddConstrainRecur */


/**
  @brief Performs the recursive step of Cudd_addRestrict.

  @return the restricted %ADD if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_addRestrict

*/
DdNode *
cuddAddRestrictRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * c)
{
    DdNode	 *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r, *one, *zero;
    int		 topf, topc;
    unsigned int index;

    statLine(dd);
    one = DD_ONE(dd);
    zero = DD_ZERO(dd);

    /* Trivial cases */
    if (c == one)		return(f);
    if (c == zero)		return(zero);
    if (cuddIsConstant(f))	return(f);
    if (f == c)			return(one);

    /* Now f and c are non-constant. */

    /* Check the cache. */
    r = cuddCacheLookup2(dd, Cudd_addRestrict, f, c);
    if (r != NULL) {
	return(r);
    }

    checkWhetherToGiveUp(dd);

    topf = dd->perm[f->index];
    topc = dd->perm[c->index];

    if (topc < topf) {	/* abstract top variable from c */
	DdNode *d, *s1, *s2;

	/* Find cofactors of c. */
	s1 = cuddT(c);
	s2 = cuddE(c);
	/* Take the OR by applying DeMorgan. */
	d = cuddAddApplyRecur(dd, Cudd_addOr, s1, s2);
	if (d == NULL) return(NULL);
	cuddRef(d);
	r = cuddAddRestrictRecur(dd, f, d);
	if (r == NULL) {
	    Cudd_RecursiveDeref(dd, d);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_RecursiveDeref(dd, d);
	cuddCacheInsert2(dd, Cudd_addRestrict, f, c, r);
	cuddDeref(r);
	return(r);
    }

    /* Recursive step. Here topf <= topc. */
    index = f->index;
    Fv = cuddT(f); Fnv = cuddE(f);
    if (topc == topf) {
	Cv = cuddT(c); Cnv = cuddE(c);
    } else {
	Cv = Cnv = c;
    }

    if (!Cudd_IsConstantInt(Cv)) {
	t = cuddAddRestrictRecur(dd, Fv, Cv);
	if (t == NULL) return(NULL);
    } else if (Cv == one) {
	t = Fv;
    } else {		/* Cv == zero: return(Fnv @ Cnv) */
	if (Cnv == one) {
	    r = Fnv;
	} else {
	    r = cuddAddRestrictRecur(dd, Fnv, Cnv);
	    if (r == NULL) return(NULL);
	}
	return(r);
    }
    cuddRef(t);

    if (!cuddIsConstant(Cnv)) {
	e = cuddAddRestrictRecur(dd, Fnv, Cnv);
	if (e == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    return(NULL);
	}
    } else if (Cnv == one) {
	e = Fnv;
    } else {		/* Cnv == zero: return (Fv @ Cv) previously computed */
	cuddDeref(t);
	return(t);
    }
    cuddRef(e);

    r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
    if (r == NULL) {
	Cudd_RecursiveDeref(dd, e);
	Cudd_RecursiveDeref(dd, t);
	return(NULL);
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert2(dd, Cudd_addRestrict, f, c, r);
    return(r);

} /* end of cuddAddRestrictRecur */



/**
  @brief Performs safe minimization of a %BDD.

  @details Given the %BDD `f` of a function to be minimized and a %BDD
  `c` representing the care set, Cudd_bddLICompaction produces the
  %BDD of a function that agrees with `f` wherever `c` is 1.  Safe
  minimization means that the size of the result is guaranteed not to
  exceed the size of `f`. This function is based on the DAC97 paper by
  Hong et al..

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddLICompaction

*/
DdNode *
cuddBddLICompaction(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be minimized */,
  DdNode * c /**< constraint (care set) */)
{
    st_table *marktable, *markcache, *buildcache;
    DdNode *res, *zero;

    zero = Cudd_Not(DD_ONE(dd));
    if (c == zero) return(zero);

    /* We need to use local caches for both steps of this operation.
    ** The results of the edge marking step are only valid as long as the
    ** edge markings themselves are available. However, the edge markings
    ** are lost at the end of one invocation of Cudd_bddLICompaction.
    ** Hence, the cache entries for the edge marking step must be
    ** invalidated at the end of this function.
    ** For the result of the building step we argue as follows. The result
    ** for a node and a given constrain depends on the BDD in which the node
    ** appears. Hence, the same node and constrain may give different results
    ** in successive invocations.
    */
    marktable = st_init_table(st_ptrcmp,st_ptrhash);
    if (marktable == NULL) {
	return(NULL);
    }
    markcache = st_init_table(MarkCacheCompare,MarkCacheHash);
    if (markcache == NULL) {
	st_free_table(marktable);
	return(NULL);
    }
    if (cuddBddLICMarkEdges(dd,f,c,marktable,markcache) == CUDD_OUT_OF_MEM) {
	st_foreach(markcache, MarkCacheCleanUp, NULL);
	st_free_table(marktable);
	st_free_table(markcache);
	return(NULL);
    }
    st_foreach(markcache, MarkCacheCleanUp, NULL);
    st_free_table(markcache);
    buildcache = st_init_table(st_ptrcmp,st_ptrhash);
    if (buildcache == NULL) {
	st_free_table(marktable);
	return(NULL);
    }
    res = cuddBddLICBuildResult(dd,f,buildcache,marktable);
    st_free_table(buildcache);
    st_free_table(marktable);
    return(res);

} /* end of cuddBddLICompaction */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_bddConstrainDecomp.

  @return f super (i) if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_bddConstrainDecomp

*/
static int
cuddBddConstrainDecomp(
  DdManager * dd,
  DdNode * f,
  DdNode ** decomp)
{
    DdNode *F, *fv, *fvn;
    DdNode *fAbs;
    DdNode *result;
    int ok;

    if (Cudd_IsConstantInt(f)) return(1);
    /* Compute complements of cofactors. */
    F = Cudd_Regular(f);
    fv = cuddT(F);
    fvn = cuddE(F);
    if (F == f) {
	fv = Cudd_Not(fv);
	fvn = Cudd_Not(fvn);
    }
    /* Compute abstraction of top variable. */
    fAbs = cuddBddAndRecur(dd, fv, fvn);
    if (fAbs == NULL) {
	return(0);
    }
    cuddRef(fAbs);
    fAbs = Cudd_Not(fAbs);
    /* Recursively find the next abstraction and the components of the
    ** decomposition. */
    ok = cuddBddConstrainDecomp(dd, fAbs, decomp);
    if (ok == 0) {
	Cudd_IterDerefBdd(dd,fAbs);
	return(0);
    }
    /* Compute the component of the decomposition corresponding to the
    ** top variable and store it in the decomposition array. */
    result = cuddBddConstrainRecur(dd, f, fAbs);
    if (result == NULL) {
	Cudd_IterDerefBdd(dd,fAbs);
	return(0);
    }
    cuddRef(result);
    decomp[F->index] = result;
    Cudd_IterDerefBdd(dd, fAbs);
    return(1);

} /* end of cuddBddConstrainDecomp */


/**
  @brief Performs the recursive step of Cudd_bddCharToVect.

  @details This function maintains the invariant that f is non-zero.

  @return the i-th component of the vector if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_bddCharToVect

*/
static DdNode *
cuddBddCharToVect(
  DdManager * dd,
  DdNode * f,
  DdNode * x)
{
    int topf;
    int level;
    int comple;

    DdNode *one, *zero, *res, *F, *fT, *fE, *T, *E;

    statLine(dd);
    /* Check the cache. */
    res = cuddCacheLookup2(dd, cuddBddCharToVect, f, x);
    if (res != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(dd);

    F = Cudd_Regular(f);

    topf = cuddI(dd,F->index);
    level = dd->perm[x->index];

    if (topf > level) return(x);

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    comple = F != f;
    fT = Cudd_NotCond(cuddT(F),comple);
    fE = Cudd_NotCond(cuddE(F),comple);

    if (topf == level) {
	if (fT == zero) return(zero);
	if (fE == zero) return(one);
	return(x);
    }

    /* Here topf < level. */
    if (fT == zero) return(cuddBddCharToVect(dd, fE, x));
    if (fE == zero) return(cuddBddCharToVect(dd, fT, x));

    T = cuddBddCharToVect(dd, fT, x);
    if (T == NULL) {
	return(NULL);
    }
    cuddRef(T);
    E = cuddBddCharToVect(dd, fE, x);
    if (E == NULL) {
	Cudd_IterDerefBdd(dd,T);
	return(NULL);
    }
    cuddRef(E);
    res = cuddBddIteRecur(dd, dd->vars[F->index], T, E);
    if (res == NULL) {
	Cudd_IterDerefBdd(dd,T);
	Cudd_IterDerefBdd(dd,E);
	return(NULL);
    }
    cuddDeref(T);
    cuddDeref(E);
    cuddCacheInsert2(dd, cuddBddCharToVect, f, x, res);
    return(res);

} /* end of cuddBddCharToVect */


/**
  @brief Performs the edge marking step of Cudd_bddLICompaction.

  @return the LUB of the markings of the two outgoing edges of
  <code>f</code> if successful; otherwise CUDD_OUT_OF_MEM.

  @sideeffect None

  @see Cudd_bddLICompaction cuddBddLICBuildResult

*/
static int
cuddBddLICMarkEdges(
  DdManager * dd,
  DdNode * f,
  DdNode * c,
  st_table * table,
  st_table * cache)
{
    DdNode *Fv, *Fnv, *Cv, *Cnv;
    DdNode *one, *zero;
    int topf, topc;
    int comple;
    int resT, resE, res, retval;
    void **slot;
    MarkCacheKey *key;

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    /* Terminal cases. */
    if (c == zero) return(DD_LIC_DC);
    if (f == one)  return(DD_LIC_1);
    if (f == zero) return(DD_LIC_0);

    /* Make canonical to increase the utilization of the cache. */
    comple = Cudd_IsComplement(f);
    f = Cudd_Regular(f);
    /* Now f is a regular pointer to a non-constant node; c may be
    ** constant, or it may be complemented.
    */

    /* Check the cache. */
    key = ALLOC(MarkCacheKey, 1);
    if (key == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(CUDD_OUT_OF_MEM);
    }
    key->f = f; key->c = c;
    if (st_lookup_int(cache, key, &res)) {
	FREE(key);
	if (comple) {
	    if (res == DD_LIC_0) res = DD_LIC_1;
	    else if (res == DD_LIC_1) res = DD_LIC_0;
	}
	return(res);
    }

    /* Recursive step. */
    topf = dd->perm[f->index];
    topc = cuddI(dd,Cudd_Regular(c)->index);
    if (topf <= topc) {
	Fv = cuddT(f); Fnv = cuddE(f);
    } else {
	Fv = Fnv = f;
    }
    if (topc <= topf) {
	/* We know that c is not constant because f is not. */
	Cv = cuddT(Cudd_Regular(c)); Cnv = cuddE(Cudd_Regular(c));
	if (Cudd_IsComplement(c)) {
	    Cv = Cudd_Not(Cv);
	    Cnv = Cudd_Not(Cnv);
	}
    } else {
	Cv = Cnv = c;
    }

    resT = cuddBddLICMarkEdges(dd, Fv, Cv, table, cache);
    if (resT == CUDD_OUT_OF_MEM) {
	FREE(key);
	return(CUDD_OUT_OF_MEM);
    }
    resE = cuddBddLICMarkEdges(dd, Fnv, Cnv, table, cache);
    if (resE == CUDD_OUT_OF_MEM) {
	FREE(key);
	return(CUDD_OUT_OF_MEM);
    }

    /* Update edge markings. */
    if (topf <= topc) {
	retval = st_find_or_add(table, f, &slot);
	if (retval == 0) {
	    *slot = (void **) (ptrint)((resT << 2) | resE);
	} else if (retval == 1) {
	    *slot = (void **) (ptrint)((int)((ptrint) *slot) | (resT << 2) | resE);
	} else {
	    FREE(key);
	    return(CUDD_OUT_OF_MEM);
	}
    }

    /* Cache result. */
    res = resT | resE;
    if (st_insert(cache, key, (void *)(ptrint)res) == ST_OUT_OF_MEM) {
	FREE(key);
	return(CUDD_OUT_OF_MEM);
    }

    /* Take into account possible complementation. */
    if (comple) {
	if (res == DD_LIC_0) res = DD_LIC_1;
	else if (res == DD_LIC_1) res = DD_LIC_0;
    }
    return(res);

} /* end of cuddBddLICMarkEdges */


/**
  @brief Builds the result of Cudd_bddLICompaction.

  @return a pointer to the minimized %BDD if successful; otherwise NULL.

  @sideeffect None

  @see Cudd_bddLICompaction cuddBddLICMarkEdges

*/
static DdNode *
cuddBddLICBuildResult(
  DdManager * dd,
  DdNode * f,
  st_table * cache,
  st_table * table)
{
    DdNode *Fv, *Fnv, *r, *t, *e;
    DdNode *one, *zero;
    unsigned int index;
    int comple;
    int markT, markE, markings;

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    if (Cudd_IsConstantInt(f)) return(f);
    /* Make canonical to increase the utilization of the cache. */
    comple = Cudd_IsComplement(f);
    f = Cudd_Regular(f);

    /* Check the cache. */
    if (st_lookup(cache, f, (void **) &r)) {
	return(Cudd_NotCond(r,comple));
    }

    /* Retrieve the edge markings. */
    if (st_lookup_int(table, f, &markings) == 0)
	return(NULL);
    markT = markings >> 2;
    markE = markings & 3;

    index = f->index;
    Fv = cuddT(f); Fnv = cuddE(f);

    if (markT == DD_LIC_NL) {
	t = cuddBddLICBuildResult(dd,Fv,cache,table);
	if (t == NULL) {
	    return(NULL);
	}
    } else if (markT == DD_LIC_1) {
	t = one;
    } else {
	t = zero;
    }
    cuddRef(t);
    if (markE == DD_LIC_NL) {
	e = cuddBddLICBuildResult(dd,Fnv,cache,table);
	if (e == NULL) {
	    Cudd_IterDerefBdd(dd,t);
	    return(NULL);
	}
    } else if (markE == DD_LIC_1) {
	e = one;
    } else {
	e = zero;
    }
    cuddRef(e);

    if (markT == DD_LIC_DC && markE != DD_LIC_DC) {
	r = e;
    } else if (markT != DD_LIC_DC && markE == DD_LIC_DC) {
	r = t;
    } else {
	if (Cudd_IsComplement(t)) {
	    t = Cudd_Not(t);
	    e = Cudd_Not(e);
	    r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	    if (r == NULL) {
		Cudd_IterDerefBdd(dd, e);
		Cudd_IterDerefBdd(dd, t);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	    if (r == NULL) {
		Cudd_IterDerefBdd(dd, e);
		Cudd_IterDerefBdd(dd, t);
		return(NULL);
	    }
	}
    }
    cuddDeref(t);
    cuddDeref(e);

    if (st_insert(cache, f, r) == ST_OUT_OF_MEM) {
	cuddRef(r);
	Cudd_IterDerefBdd(dd,r);
	return(NULL);
    }

    return(Cudd_NotCond(r,comple));

} /* end of cuddBddLICBuildResult */


/**
  @brief Hash function for the computed table of cuddBddLICMarkEdges.

  @return the bucket number.

  @sideeffect None

  @see Cudd_bddLICompaction

*/
static int
MarkCacheHash(
  void const * ptr,
  int  modulus)
{
    int val = 0;
    MarkCacheKey const *entry = (MarkCacheKey const *) ptr;

    val = (int) (ptrint) entry->f;
    val = val * 997 + (int) (ptrint) entry->c;

    return ((val < 0) ? -val : val) % modulus;

} /* end of MarkCacheHash */


/**
  @brief Comparison function for the computed table of
  cuddBddLICMarkEdges.

  @return 0 if the two nodes of the key are equal; 1 otherwise.

  @sideeffect None

  @see Cudd_bddLICompaction

*/
static int
MarkCacheCompare(
  const void * ptr1,
  const void * ptr2)
{
    MarkCacheKey const *entry1 = (MarkCacheKey const *) ptr1;
    MarkCacheKey const *entry2 = (MarkCacheKey const *) ptr2;
    
    return((entry1->f != entry2->f) || (entry1->c != entry2->c));

} /* end of MarkCacheCompare */


/**
  @brief Frees memory associated with computed table of
  cuddBddLICMarkEdges.

  @return ST_CONTINUE.

  @sideeffect None

  @see Cudd_bddLICompaction

*/
static enum st_retval
MarkCacheCleanUp(
  void * key,
  void * value,
  void * arg)
{
    MarkCacheKey *entry = (MarkCacheKey *) key;

    (void) value; /* avoid warning */
    (void) arg;   /* avoid warning */
    FREE(entry);
    return ST_CONTINUE;

} /* end of MarkCacheCleanUp */


/**
  @brief Performs the recursive step of Cudd_bddSqueeze.

  @details This procedure exploits the fact that if we complement and
  swap the bounds of the interval we obtain a valid solution by taking
  the complement of the solution to the original problem. Therefore,
  we can enforce the condition that the upper bound is always regular.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddSqueeze

*/
static DdNode *
cuddBddSqueeze(
  DdManager * dd,
  DdNode * l,
  DdNode * u)
{
    DdNode *one, *zero, *r, *lt, *le, *ut, *ue, *t, *e;
#if 0
    DdNode *ar;
#endif
    int comple = 0;
    int topu, topl;
    unsigned int index;

    statLine(dd);
    if (l == u) {
	return(l);
    }
    one = DD_ONE(dd);
    zero = Cudd_Not(one);
    /* The only case when l == zero && u == one is at the top level,
    ** where returning either one or zero is OK. In all other cases
    ** the procedure will detect such a case and will perform
    ** remapping. Therefore the order in which we test l and u at this
    ** point is immaterial. */
    if (l == zero) return(l);
    if (u == one)  return(u);

    /* Make canonical to increase the utilization of the cache. */
    if (Cudd_IsComplement(u)) {
	DdNode *temp;
	temp = Cudd_Not(l);
	l = Cudd_Not(u);
	u = temp;
	comple = 1;
    }
    /* At this point u is regular and non-constant; l is non-constant, but
    ** may be complemented. */

    /* Here we could check the relative sizes. */

    /* Check the cache. */
    r = cuddCacheLookup2(dd, Cudd_bddSqueeze, l, u);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple));
    }

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    topu = dd->perm[u->index];
    topl = dd->perm[Cudd_Regular(l)->index];
    if (topu <= topl) {
	index = u->index;
	ut = cuddT(u); ue = cuddE(u);
    } else {
	index = Cudd_Regular(l)->index;
	ut = ue = u;
    }
    if (topl <= topu) {
	lt = cuddT(Cudd_Regular(l)); le = cuddE(Cudd_Regular(l));
	if (Cudd_IsComplement(l)) {
	    lt = Cudd_Not(lt);
	    le = Cudd_Not(le);
	}
    } else {
	lt = le = l;
    }

    /* If one interval is contained in the other, use the smaller
    ** interval. This corresponds to one-sided matching. */
    if ((lt == zero || Cudd_bddLeq(dd,lt,le)) &&
	(ut == one  || Cudd_bddLeq(dd,ue,ut))) { /* remap */
	r = cuddBddSqueeze(dd, le, ue);
	if (r == NULL)
	    return(NULL);
	return(Cudd_NotCond(r,comple));
    } else if ((le == zero || Cudd_bddLeq(dd,le,lt)) &&
	       (ue == one  || Cudd_bddLeq(dd,ut,ue))) { /* remap */
	r = cuddBddSqueeze(dd, lt, ut);
	if (r == NULL)
	    return(NULL);
	return(Cudd_NotCond(r,comple));
    } else if ((le == zero || Cudd_bddLeq(dd,le,Cudd_Not(ut))) &&
	       (ue == one  || Cudd_bddLeq(dd,Cudd_Not(lt),ue))) { /* c-remap */
	t = cuddBddSqueeze(dd, lt, ut);
	cuddRef(t);
	if (Cudd_IsComplement(t)) {
	    r = cuddUniqueInter(dd, index, Cudd_Not(t), t);
	    if (r == NULL) {
		Cudd_IterDerefBdd(dd, t);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	} else {
	    r = cuddUniqueInter(dd, index, t, Cudd_Not(t));
	    if (r == NULL) {
		Cudd_IterDerefBdd(dd, t);
		return(NULL);
	    }
	}
	cuddDeref(t);
	if (r == NULL)
	    return(NULL);
	cuddCacheInsert2(dd, Cudd_bddSqueeze, l, u, r);
	return(Cudd_NotCond(r,comple));
    } else if ((lt == zero || Cudd_bddLeq(dd,lt,Cudd_Not(ue))) &&
	       (ut == one  || Cudd_bddLeq(dd,Cudd_Not(le),ut))) { /* c-remap */
	e = cuddBddSqueeze(dd, le, ue);
	cuddRef(e);
	if (Cudd_IsComplement(e)) {
	    r = cuddUniqueInter(dd, index, Cudd_Not(e), e);
	    if (r == NULL) {
		Cudd_IterDerefBdd(dd, e);
		return(NULL);
	    }
	} else {
	    r = cuddUniqueInter(dd, index, e, Cudd_Not(e));
	    if (r == NULL) {
		Cudd_IterDerefBdd(dd, e);
		return(NULL);
	    }
	    r = Cudd_Not(r);
	}
	cuddDeref(e);
	if (r == NULL)
	    return(NULL);
	cuddCacheInsert2(dd, Cudd_bddSqueeze, l, u, r);
	return(Cudd_NotCond(r,comple));
    }

#if 0
    /* If the two intervals intersect, take a solution from
    ** the intersection of the intervals. This guarantees that the
    ** splitting variable will not appear in the result.
    ** This approach corresponds to two-sided matching, and is very
    ** expensive. */
    if (Cudd_bddLeq(dd,lt,ue) && Cudd_bddLeq(dd,le,ut)) {
	DdNode *au, *al;
	au = cuddBddAndRecur(dd,ut,ue);
	if (au == NULL)
	    return(NULL);
	cuddRef(au);
	al = cuddBddAndRecur(dd,Cudd_Not(lt),Cudd_Not(le));
	if (al == NULL) {
	    Cudd_IterDerefBdd(dd,au);
	    return(NULL);
	}
	cuddRef(al);
	al = Cudd_Not(al);
	ar = cuddBddSqueeze(dd, al, au);
	if (ar == NULL) {
	    Cudd_IterDerefBdd(dd,au);
	    Cudd_IterDerefBdd(dd,al);
	    return(NULL);
	}
	cuddRef(ar);
	Cudd_IterDerefBdd(dd,au);
	Cudd_IterDerefBdd(dd,al);
    } else {
	ar = NULL;
    }
#endif

    t = cuddBddSqueeze(dd, lt, ut);
    if (t == NULL) {
	return(NULL);
    }
    cuddRef(t);
    e = cuddBddSqueeze(dd, le, ue);
    if (e == NULL) {
	Cudd_IterDerefBdd(dd,t);
	return(NULL);
    }
    cuddRef(e);

    if (Cudd_IsComplement(t)) {
	t = Cudd_Not(t);
	e = Cudd_Not(e);
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
	r = Cudd_Not(r);
    } else {
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
    }
    cuddDeref(t);
    cuddDeref(e);

#if 0
    /* Check whether there is a result obtained by abstraction and whether
    ** it is better than the one obtained by recursion. */
    cuddRef(r);
    if (ar != NULL) {
	if (Cudd_DagSize(ar) <= Cudd_DagSize(r)) {
	    Cudd_IterDerefBdd(dd, r);
	    r = ar;
	} else {
	    Cudd_IterDerefBdd(dd, ar);
	}
    }
    cuddDeref(r);
#endif

    cuddCacheInsert2(dd, Cudd_bddSqueeze, l, u, r);
    return(Cudd_NotCond(r,comple));

} /* end of cuddBddSqueeze */


/**
  @brief Performs the recursive step of Cudd_bddInterpolate.

  @details This procedure exploits the fact that if we complement and
  swap the bounds of the interval we obtain a valid solution by taking
  the complement of the solution to the original problem. Therefore,
  we can enforce the condition that the upper bound is always regular.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddInterpolate

*/
static DdNode *
cuddBddInterpolate(
  DdManager * dd,
  DdNode * l,
  DdNode * u)
{
    DdNode *one, *zero, *r, *lt, *le, *ut, *ue, *t, *e;
#if 0
    DdNode *ar;
#endif
    int comple = 0;
    int topu, topl;
    unsigned int index;

    statLine(dd);
    if (l == u) {
	return(l);
    }
    one = DD_ONE(dd);
    zero = Cudd_Not(one);
    if (l == zero) return(l);
    if (u == one)  return(u);

    /* Make canonical to increase the utilization of the cache. */
    if (Cudd_IsComplement(u)) {
	DdNode *temp;
	temp = Cudd_Not(l);
	l = Cudd_Not(u);
	u = temp;
	comple = 1;
    }
    /* At this point u is regular and non-constant; l is non-constant, but
    ** may be complemented. */

    /* Check the cache. */
    r = cuddCacheLookup2(dd, Cudd_bddInterpolate, l, u);
    if (r != NULL) {
	return(Cudd_NotCond(r,comple));
    }

    checkWhetherToGiveUp(dd);

    /* Recursive step. */
    topu = dd->perm[u->index];
    topl = dd->perm[Cudd_Regular(l)->index];
    if (topu < topl) {
        /* Universally quantify top variable from upper bound. */
        DdNode *qu;
	ut = cuddT(u); ue = cuddE(u);
        qu = cuddBddAndRecur(dd, ut, ue);
        if (qu == NULL) return(NULL);
        cuddRef(qu);
        r = cuddBddInterpolate(dd, l, qu);
        if (r == NULL) {
            Cudd_IterDerefBdd(dd, qu);
            return(NULL);
        }
        cuddRef(r);
        Cudd_IterDerefBdd(dd, qu);
        cuddCacheInsert2(dd, Cudd_bddInterpolate, l, u, r);
        cuddDeref(r);
        return(Cudd_NotCond(r, comple));
    } else if (topl < topu) {
        /* Existentially quantify top variable from lower bound. */
        DdNode *ql;
        /* Find complements of cofactors of c. */
        if (Cudd_IsComplement(l)) {
            lt = cuddT(Cudd_Regular(l));
            le = cuddE(Cudd_Regular(l));
        } else {
            lt = Cudd_Not(cuddT(l));
            le = Cudd_Not(cuddE(l));
        }
        /* Disjoin cofactors by applying DeMorgan. */
        ql = cuddBddAndRecur(dd, lt, le);
        if (ql == NULL) return (NULL);
        cuddRef(ql);
        ql = Cudd_Not(ql);
        r = cuddBddInterpolate(dd, ql, u);
        if (r == NULL) {
            Cudd_IterDerefBdd(dd, ql);
            return(NULL);
        }
        cuddRef(r);
        Cudd_IterDerefBdd(dd, ql);
        cuddCacheInsert2(dd, Cudd_bddInterpolate, l, u, r);
        cuddDeref(r);
        return(Cudd_NotCond(r, comple));
    }

    /* Both bounds depend on the top variable: split and recur. */
    index = u->index;
    ut = cuddT(u); ue = cuddE(u);
    lt = cuddT(Cudd_Regular(l)); le = cuddE(Cudd_Regular(l));
    if (Cudd_IsComplement(l)) {
        lt = Cudd_Not(lt);
        le = Cudd_Not(le);
    }

    t = cuddBddInterpolate(dd, lt, ut);
    if (t == NULL) {
	return(NULL);
    }
    cuddRef(t);
    e = cuddBddInterpolate(dd, le, ue);
    if (e == NULL) {
	Cudd_IterDerefBdd(dd,t);
	return(NULL);
    }
    cuddRef(e);

    if (Cudd_IsComplement(t)) {
	t = Cudd_Not(t);
	e = Cudd_Not(e);
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
	r = Cudd_Not(r);
    } else {
	r = (t == e) ? t : cuddUniqueInter(dd, index, t, e);
	if (r == NULL) {
	    Cudd_IterDerefBdd(dd, e);
	    Cudd_IterDerefBdd(dd, t);
	    return(NULL);
	}
    }
    cuddDeref(t);
    cuddDeref(e);

    cuddCacheInsert2(dd, Cudd_bddInterpolate, l, u, r);
    return(Cudd_NotCond(r,comple));

} /* end of cuddBddInterpolate */

cuddGenetic.c
26667
/**
  @file

  @ingroup cudd

  @brief Genetic algorithm for variable reordering.

  @details The genetic algorithm implemented here is as follows.  We
  start with the current %DD order.  We sift this order and use this as
  the reference %DD.  We only keep 1 %DD around for the entire process
  and simply rearrange the order of this %DD, storing the various
  orders and their corresponding %DD sizes.  We generate more random
  orders to build an initial population. This initial population is 3
  times the number of variables, with a maximum of 120. Each random
  order is built (from the reference %DD) and its size stored.  Each
  random order is also sifted to keep the %DD sizes fairly small.  Then
  a crossover is performed between two orders (picked randomly) and
  the two resulting DDs are built and sifted.  For each new order, if
  its size is smaller than any %DD in the population, it is inserted
  into the population and the %DD with the largest number of nodes is
  thrown out. The crossover process happens up to 50 times, and at
  this point the %DD in the population with the smallest size is chosen
  as the result.  This %DD must then be built from the reference %DD.

  @author Curt Musfeldt, Alan Shuler, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef struct GeneticInfo GeneticInfo_t;

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief Miscellaneous information.
 */
struct GeneticInfo {
    int popsize;	/**< the size of the population */
    int numvars;	/**< the number of variables to be ordered. */
/**
 ** @brief storedd stores the population orders and sizes.
 **
 ** @details This table has two extra rows and one extras column. The
 ** two extra rows are used for the offspring produced by a
 ** crossover. Each row stores one order and its size. The order is
 ** stored by storing the indices of variables in the order in which
 ** they appear in the order. The table is in reality a
 ** one-dimensional array which is accessed via a macro to give the
 ** illusion it is a two-dimensional structure.
 */
    int *storedd;
    st_table *computed;	/**< hash table to identify existing orders */
    int *repeat;	/**< how many times an order is present */
    int large;		/**< stores the index of the population with
                         ** the largest number of nodes in the %DD */
    int result;		/**< result */
    int cross;		/**< the number of crossovers to perform */
};

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/**
 ** @brief Used to access the population table as if it were a
 ** two-dimensional structure.
 */
#define STOREDD(info,i,j)	(info)->storedd[(i)*((info)->numvars+1)+(j)]

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int make_random (DdManager *table, int lower, GeneticInfo_t * info);
static int sift_up (DdManager *table, int x, int x_low);
static int build_dd (DdManager *table, int num, int lower, int upper, GeneticInfo_t * info);
static int largest (GeneticInfo_t * info);
static int rand_int (DdManager * dd, int a);
static int array_hash (void const *array, int modulus, void const * arg);
static int array_compare (const void *array1, const void *array2, void const * arg);
static int find_best (GeneticInfo_t * info);
#ifdef DD_STATS
static double find_average_fitness (GeneticInfo_t * info);
#endif
static int PMX (DdManager * dd, int maxvar, GeneticInfo_t * info);
static int roulette (DdManager *dd, int *p1, int *p2, GeneticInfo_t * info);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Genetic algorithm for %DD reordering.

  @details The two children of a crossover will be stored in
  storedd[popsize] and storedd[popsize+1] --- the last two slots in the
  storedd array.  (This will make comparisons and replacement easy.)

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
cuddGa(
  DdManager * table /**< manager */,
  int  lower /**< lowest level to be reordered */,
  int  upper /**< highest level to be reorderded */)
{
    int 	i,n,m;		/* dummy/loop vars */
    int		index;
#ifdef DD_STATS
    double	average_fitness;
#endif
    int		small;		/* index of smallest DD in population */
    GeneticInfo_t info;

    /* Do an initial sifting to produce at least one reasonable individual. */
    if (!cuddSifting(table,lower,upper)) return(0);

    /* Get the initial values. */
    info.numvars = upper - lower + 1; /* number of variables to be reordered */
    if (table->populationSize == 0) {
	info.popsize = 3 * info.numvars;  /* population size is 3 times # of vars */
	if (info.popsize > 120) {
	    info.popsize = 120;	/* Maximum population size is 120 */
	}
    } else {
	info.popsize = table->populationSize;  /* user specified value */
    }
    if (info.popsize < 4) info.popsize = 4;	/* enforce minimum population size */

    /* Allocate population table. */
    info.storedd = ALLOC(int,(info.popsize+2)*(info.numvars+1));
    if (info.storedd == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }

    /* Initialize the computed table. This table is made up of two data
    ** structures: A hash table with the key given by the order, which says
    ** if a given order is present in the population; and the repeat
    ** vector, which says how many copies of a given order are stored in
    ** the population table. If there are multiple copies of an order, only
    ** one has a repeat count greater than 1. This copy is the one pointed
    ** by the computed table.
    */
    info.repeat = ALLOC(int,info.popsize);
    if (info.repeat == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	FREE(info.storedd);
	return(0);
    }
    for (i = 0; i < info.popsize; i++) {
	info.repeat[i] = 0;
    }
    info.computed = st_init_table_with_arg(array_compare,array_hash,
                                           (void *)(ptrint) info.numvars);
    if (info.computed == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	FREE(info.storedd);
	FREE(info.repeat);
	return(0);
    }

    /* Copy the current DD and its size to the population table. */
    for (i = 0; i < info.numvars; i++) {
	STOREDD(&info,0,i) = table->invperm[i+lower]; /* order of initial DD */
    }
    STOREDD(&info,0,info.numvars) =
        (int) (table->keys - table->isolated); /* size of initial DD */

    /* Store the initial order in the computed table. */
    if (st_insert(info.computed,info.storedd,(void *) 0) == ST_OUT_OF_MEM) {
	FREE(info.storedd);
	FREE(info.repeat);
	st_free_table(info.computed);
	return(0);
    }
    info.repeat[0]++;

    /* Insert the reverse order as second element of the population. */
    for (i = 0; i < info.numvars; i++) {
	STOREDD(&info,1,info.numvars-1-i) = table->invperm[i+lower]; /* reverse order */
    }

    /* Now create the random orders. make_random fills the population
    ** table with random permutations. The successive loop builds and sifts
    ** the DDs for the reverse order and each random permutation, and stores
    ** the results in the computed table.
    */
    if (!make_random(table,lower,&info)) {
	table->errorCode = CUDD_MEMORY_OUT;
	FREE(info.storedd);
	FREE(info.repeat);
	st_free_table(info.computed);
	return(0);
    }
    for (i = 1; i < info.popsize; i++) {
	info.result = build_dd(table,i,lower,upper,&info);	/* build and sift order */
	if (!info.result) {
	    FREE(info.storedd);
	    FREE(info.repeat);
	    st_free_table(info.computed);
	    return(0);
	}
	if (st_lookup_int(info.computed,&STOREDD(&info,i,0),&index)) {
	    info.repeat[index]++;
	} else {
	    if (st_insert(info.computed,&STOREDD(&info,i,0),(void *)(ptruint)i) ==
	    ST_OUT_OF_MEM) {
		FREE(info.storedd);
		FREE(info.repeat);
		st_free_table(info.computed);
		return(0);
	    }
	    info.repeat[i]++;
	}
    }

#if 0
#ifdef DD_STATS
    /* Print the initial population. */
    (void) fprintf(table->out,"Initial population after sifting\n");
    for (m = 0; m < info.popsize; m++) {
	for (i = 0; i < info.numvars; i++) {
	    (void) fprintf(table->out," %2d",STOREDD(&info,m,i));
	}
	(void) fprintf(table->out," : %3d (%d)\n",
		       STOREDD(&info,m,numvars),info.repeat[m]);
    }
#endif
#endif

#ifdef DD_STATS
    small = find_best(&info);
    average_fitness = find_average_fitness(&info);
    (void) fprintf(table->out,"\nInitial population: best fitness = %d, average fitness %8.3f",STOREDD(&info,small,info.numvars),average_fitness);
#endif

    /* Decide how many crossovers should be tried. */
    if (table->numberXovers == 0) {
	info.cross = 3*info.numvars;
	if (info.cross > 60) {	/* do a maximum of 50 crossovers */
	    info.cross = 60;
	}
    } else {
	info.cross = table->numberXovers;      /* use user specified value */
    }
    if (info.cross >= info.popsize) {
	info.cross = info.popsize;
    }

    /* Perform the crossovers to get the best order. */
    for (m = 0; m < info.cross; m++) {
	if (!PMX(table, table->size, &info)) {	/* perform one crossover */
	    table->errorCode = CUDD_MEMORY_OUT;
	    FREE(info.storedd);
	    FREE(info.repeat);
	    st_free_table(info.computed);
	    return(0);
	}
	/* The offsprings are left in the last two entries of the
	** population table. These are now considered in turn.
	*/
	for (i = info.popsize; i <= info.popsize+1; i++) {
	    info.result = build_dd(table,i,lower,upper,&info); /* build and sift child */
	    if (!info.result) {
		FREE(info.storedd);
		FREE(info.repeat);
		st_free_table(info.computed);
		return(0);
	    }
	    info.large = largest(&info); /* find the largest DD in population */

	    /* If the new child is smaller than the largest DD in the current
	    ** population, enter it into the population in place of the
	    ** largest DD.
	    */
	    if (STOREDD(&info,i,info.numvars) <
                STOREDD(&info,info.large,info.numvars)) {
		/* Look up the largest DD in the computed table.
		** Decrease its repetition count. If the repetition count
		** goes to 0, remove the largest DD from the computed table.
		*/
		info.result = st_lookup_int(info.computed,&STOREDD(&info,info.large,0),&index);
		if (!info.result) {
		    FREE(info.storedd);
		    FREE(info.repeat);
		    st_free_table(info.computed);
		    return(0);
		}
		info.repeat[index]--;
		if (info.repeat[index] == 0) {
		    int *pointer = &STOREDD(&info,index,0);
		    info.result = st_delete(info.computed, (void **) &pointer, NULL);
		    if (!info.result) {
			FREE(info.storedd);
			FREE(info.repeat);
			st_free_table(info.computed);
			return(0);
		    }
		}
		/* Copy the new individual to the entry of the
		** population table just made available and update the
		** computed table.
		*/
		for (n = 0; n <= info.numvars; n++) {
		    STOREDD(&info,info.large,n) = STOREDD(&info,i,n);
		}
		if (st_lookup_int(info.computed,&STOREDD(&info,info.large,0),&index)) {
		    info.repeat[index]++;
		} else {
		    if (st_insert(info.computed,&STOREDD(&info,info.large,0),
		    (void *)(ptruint)info.large) == ST_OUT_OF_MEM) {
			FREE(info.storedd);
			FREE(info.repeat);
			st_free_table(info.computed);
			return(0);
		    }
		    info.repeat[info.large]++;
		}
	    }
	}
    }

    /* Find the smallest DD in the population and build it;
    ** that will be the result.
    */
    small = find_best(&info);

    /* Print stats on the final population. */
#ifdef DD_STATS
    average_fitness = find_average_fitness(&info);
    (void) fprintf(table->out,"\nFinal population: best fitness = %d, average fitness %8.3f",STOREDD(&info,small,info.numvars),average_fitness);
#endif

    /* Clean up, build the result DD, and return. */
    st_free_table(info.computed);
    info.computed = NULL;
    info.result = build_dd(table,small,lower,upper,&info);
    FREE(info.storedd);
    FREE(info.repeat);
    return(info.result);

} /* end of cuddGa */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
  @brief Generates the random sequences for the initial population.

  @details The sequences are permutations of the indices between lower
  and upper in the current order.

  @sideeffect None

*/
static int
make_random(
  DdManager * table,
  int  lower,
  GeneticInfo_t * info)
{
    int i,j;		/* loop variables */
    int	*used;		/* is a number already in a permutation */
    int	next;		/* next random number without repetitions */

    used = ALLOC(int,info->numvars);
    if (used == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
#if 0
#ifdef DD_STATS
    (void) fprintf(table->out,"Initial population before sifting\n");
    for (i = 0; i < 2; i++) {
	for (j = 0; j < numvars; j++) {
	    (void) fprintf(table->out," %2d",STOREDD(i,j));
	}
	(void) fprintf(table->out,"\n");
    }
#endif
#endif
    for (i = 2; i < info->popsize; i++) {
       	for (j = 0; j < info->numvars; j++) {
	    used[j] = 0;
	}
	/* Generate a permutation of {0...numvars-1} and use it to
	** permute the variables in the layesr from lower to upper.
	*/
       	for (j = 0; j < info->numvars; j++) {
	    do {
		next = rand_int(table,info->numvars-1);
	    } while (used[next] != 0);
	    used[next] = 1;
	    STOREDD(info,i,j) = table->invperm[next+lower];
       	}
#if 0
#ifdef DD_STATS
	/* Print the order just generated. */
	for (j = 0; j < numvars; j++) {
	    (void) fprintf(table->out," %2d",STOREDD(i,j));
	}
	(void) fprintf(table->out,"\n");
#endif
#endif
    }
    FREE(used);
    return(1);

} /* end of make_random */


/**
  @brief Moves one variable up.

  @details Takes a variable from position x and sifts it up to
  position x_low;  x_low should be less than x.

  @return 1 if successful; 0 otherwise

  @sideeffect None

*/
static int
sift_up(
  DdManager * table,
  int  x,
  int  x_low)
{
    int        y;
    int        size;

    y = cuddNextLow(table,x);
    while (y >= x_low) {
	size = cuddSwapInPlace(table,y,x);
	if (size == 0) {
	    return(0);
	}
	x = y;
	y = cuddNextLow(table,x);
    }
    return(1);

} /* end of sift_up */


/**
  @brief Builds a %DD from a given order.

  @details This procedure also sifts the final order and inserts into
  the array the size in nodes of the result.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
build_dd(
  DdManager * table,
  int  num /* the index of the individual to be built */,
  int  lower,
  int  upper,
  GeneticInfo_t * info)
{
    int 	i,j;		/* loop vars */
    int 	position;
    int		index;
    int		limit;		/* how large the DD for this order can grow */
    int		size;

    /* Check the computed table. If the order already exists, it
    ** suffices to copy the size from the existing entry.
    */
    if (info->computed &&
        st_lookup_int(info->computed,&STOREDD(info,num,0),&index)) {
	STOREDD(info,num,info->numvars) = STOREDD(info,index,info->numvars);
#ifdef DD_STATS
	(void) fprintf(table->out,"\nCache hit for index %d", index);
#endif
	return(1);
    }

    /* Stop if the DD grows 20 times larges than the reference size. */
    limit = 20 * STOREDD(info,0,info->numvars);

    /* Sift up the variables so as to build the desired permutation.
    ** First the variable that has to be on top is sifted to the top.
    ** Then the variable that has to occupy the secon position is sifted
    ** up to the second position, and so on.
    */
    for (j = 0; j < info->numvars; j++) {
	i = STOREDD(info,num,j);
	position = table->perm[i];
	info->result = sift_up(table,position,j+lower);
	if (!info->result) return(0);
	size = (int) (table->keys - table->isolated);
	if (size > limit) break;
    }

    /* Sift the DD just built. */
#ifdef DD_STATS
    (void) fprintf(table->out,"\n");
#endif
    info->result = cuddSifting(table,lower,upper);
    if (!info->result) return(0);

    /* Copy order and size to table. */
    for (j = 0; j < info->numvars; j++) {
	STOREDD(info,num,j) = table->invperm[lower+j];
    }
    STOREDD(info,num,info->numvars) = (int) (table->keys - table->isolated); /* size of new DD */
    return(1);

} /* end of build_dd */


/**
  @brief Finds the largest %DD in the population.

  @details If an order is repeated, it avoids choosing the copy that
  is in the computed table (it has repeat[i > 1).]

  @sideeffect None

*/
static int
largest(GeneticInfo_t * info)
{
    int i;	/* loop var */
    int big;	/* temporary holder to return result */

    big = 0;
    while (info->repeat[big] > 1) big++;
    for (i = big + 1; i < info->popsize; i++) {
	if (STOREDD(info,i,info->numvars) >=
            STOREDD(info,big,info->numvars) && info->repeat[i] <= 1) {
	    big = i;
	}
    }
    return(big);

} /* end of largest */


/**
  @brief Generates a random number between 0 and the integer a.

  @sideeffect None

*/
static int
rand_int(
  DdManager *dd,
  int  a)
{
    return(Cudd_Random(dd) % (a+1));

} /* end of rand_int */


/**
  @brief Hash function for the computed table.

  @return the bucket number.

  @sideeffect None

*/
static int
array_hash(
  void const * array,
  int modulus,
  void const * arg)
{
    int val = 0;
    int i;
    int const *intarray = (int const *) array;
    int const numvars = (int const)(ptrint const) arg;

    for (i = 0; i < numvars; i++) {
	val = val * 997 + intarray[i];
    }

    return(((val < 0) ? -val : val) % modulus);

} /* end of array_hash */


/**
  @brief Comparison function for the computed table.

  @return 0 if the two arrays are equal; 1 otherwise.

  @sideeffect None

*/
static int
array_compare(
  void const * array1,
  void const * array2,
  void const * arg)
{
    int i;
    int const *intarray1 = (int const *) array1;
    int const *intarray2 = (int const *) array2;
    int const numvars = (int const)(ptrint const) arg;

    for (i = 0; i < numvars; i++) {
	if (intarray1[i] != intarray2[i]) return(1);
    }
    return(0);

} /* end of array_compare */


/**
  @brief Returns the index of the fittest individual.

  @sideeffect None

*/
static int
find_best(GeneticInfo_t * info)
{
    int i,small;

    small = 0;
    for (i = 1; i < info->popsize; i++) {
	if (STOREDD(info,i,info->numvars) < STOREDD(info,small,info->numvars)) {
	    small = i;
	}
    }
    return(small);

} /* end of find_best */


/**
  @brief Returns the average fitness of the population.

  @sideeffect None

*/
#ifdef DD_STATS
static double
find_average_fitness(GeneticInfo_t * info)
{
    int i;
    int total_fitness = 0;
    double average_fitness;

    for (i = 0; i < info->popsize; i++) {
	total_fitness += STOREDD(info,i,info->numvars);
    }
    average_fitness = (double) total_fitness / (double) info->popsize;
    return(average_fitness);

} /* end of find_average_fitness */
#endif


/**
  @brief Performs the crossover between two parents.

  @details Performs the crossover between two randomly chosen
  parents, and creates two children, x1 and x2. Uses the Partially
  Matched Crossover operator.

  @sideeffect None

*/
static int
PMX(
  DdManager * dd,
  int  maxvar,
  GeneticInfo_t * info)
{
    int 	cut1,cut2;	/* the two cut positions (random) */
    int 	mom,dad;	/* the two randomly chosen parents */
    int		*inv1;		/* inverse permutations for repair algo */
    int		*inv2;
    int 	i;		/* loop vars */
    int		u,v;		/* aux vars */

    inv1 = ALLOC(int,maxvar);
    if (inv1 == NULL) {
	return(0);
    }
    inv2 = ALLOC(int,maxvar);
    if (inv2 == NULL) {
	FREE(inv1);
	return(0);
    }

    /* Choose two orders from the population using roulette wheel. */
    if (!roulette(dd,&mom,&dad,info)) {
	FREE(inv1);
	FREE(inv2);
	return(0);
    }

    /* Choose two random cut positions. A cut in position i means that
    ** the cut immediately precedes position i.  If cut1 < cut2, we
    ** exchange the middle of the two orderings; otherwise, we
    ** exchange the beginnings and the ends.
    */
    cut1 = rand_int(dd,info->numvars-1);
    do {
	cut2 = rand_int(dd,info->numvars-1);
    } while (cut1 == cut2);

#if 0
    /* Print out the parents. */
    (void) fprintf(dd->out,
		   "Crossover of %d (mom) and %d (dad) between %d and %d\n",
		   mom,dad,cut1,cut2);
    for (i = 0; i < info->numvars; i++) {
	if (i == cut1 || i == cut2) (void) fprintf(dd->out,"|");
	(void) fprintf(dd->out,"%2d ",STOREDD(info,mom,i));
    }
    (void) fprintf(dd->out,"\n");
    for (i = 0; i < info->numvars; i++) {
	if (i == cut1 || i == cut2) (void) fprintf(dd->out,"|");
	(void) fprintf(dd->out,"%2d ",STOREDD(info,dad,i));
    }
    (void) fprintf(dd->out,"\n");
#endif

    /* Initialize the inverse permutations: -1 means yet undetermined. */
    for (i = 0; i < maxvar; i++) {
	inv1[i] = -1;
	inv2[i] = -1;
    }

    /* Copy the portions whithin the cuts. */
    for (i = cut1; i != cut2; i = (i == info->numvars-1) ? 0 : i+1) {
	STOREDD(info,info->popsize,i) = STOREDD(info,dad,i);
	inv1[STOREDD(info,info->popsize,i)] = i;
	STOREDD(info,info->popsize+1,i) = STOREDD(info,mom,i);
	inv2[STOREDD(info,info->popsize+1,i)] = i;
    }

    /* Now apply the repair algorithm outside the cuts. */
    for (i = cut2; i != cut1; i = (i == info->numvars-1 ) ? 0 : i+1) {
	v = i;
	do {
	    u = STOREDD(info,mom,v);
	    v = inv1[u];
	} while (v != -1);
	STOREDD(info,info->popsize,i) = u;
	inv1[u] = i;
	v = i;
	do {
	    u = STOREDD(info,dad,v);
	    v = inv2[u];
	} while (v != -1);
	STOREDD(info,info->popsize+1,i) = u;
	inv2[u] = i;
    }

#if 0
    /* Print the results of crossover. */
    for (i = 0; i < info->numvars; i++) {
	if (i == cut1 || i == cut2) (void) fprintf(table->out,"|");
	(void) fprintf(table->out,"%2d ",STOREDD(info,info->popsize,i));
    }
    (void) fprintf(table->out,"\n");
    for (i = 0; i < info->numvars; i++) {
	if (i == cut1 || i == cut2) (void) fprintf(table->out,"|");
	(void) fprintf(table->out,"%2d ",STOREDD(info,info->popsize+1,i));
    }
    (void) fprintf(table->out,"\n");
#endif

    FREE(inv1);
    FREE(inv2);
    return(1);

} /* end of PMX */


/**
  @brief Selects two distinct parents with the roulette wheel method.

  @sideeffect The indices of the selected parents are returned as side
  effects.

*/
static int
roulette(
  DdManager * dd,
  int * p1,
  int * p2,
  GeneticInfo_t * info)
{
    double *wheel;
    double spin;
    int i;

    wheel = ALLOC(double,info->popsize);
    if (wheel == NULL) {
	return(0);
    }

    /* The fitness of an individual is the reciprocal of its size. */
    wheel[0] = 1.0 / (double) STOREDD(info,0,info->numvars);

    for (i = 1; i < info->popsize; i++) {
	wheel[i] = wheel[i-1] + 1.0 / (double) STOREDD(info,i,info->numvars);
    }

    /* Get a random number between 0 and wheel[popsize-1] (that is,
    ** the sum of all fitness values. 2147483561 is the largest number
    ** returned by Cudd_Random.
    */
    spin = wheel[info->numvars-1] * (double) Cudd_Random(dd) / 2147483561.0;

    /* Find the lucky element by scanning the wheel. */
    for (i = 0; i < info->popsize; i++) {
	if (spin <= wheel[i]) break;
    }
    *p1 = i;

    /* Repeat the process for the second parent, making sure it is
    ** distinct from the first.
    */
    do {
	spin = wheel[info->popsize-1] * (double) Cudd_Random(dd) / 2147483561.0;
	for (i = 0; i < info->popsize; i++) {
	    if (spin <= wheel[i]) break;
	}
    } while (i == *p1);
    *p2 = i;

    FREE(wheel);
    return(1);

} /* end of roulette */

cuddGroup.c
57030
/**
  @file

  @ingroup cudd

  @brief Functions for group sifting.

  @author Shipra Panda, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* Constants for lazy sifting */
#define	DD_NORMAL_SIFT	0
#define	DD_LAZY_SIFT	1

/* Constants for sifting up and down */
#define	DD_SIFT_DOWN	0
#define	DD_SIFT_UP	1

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef int (*DD_CHKFP)(DdManager *, int, int);

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int ddTreeSiftingAux (DdManager *table, MtrNode *treenode, Cudd_ReorderingType method);
#ifdef DD_STATS
static int ddCountInternalMtrNodes (DdManager *table, MtrNode *treenode);
#endif
static int ddReorderChildren (DdManager *table, MtrNode *treenode, Cudd_ReorderingType method);
static void ddFindNodeHiLo (DdManager *table, MtrNode *treenode, int *lower, int *upper);
static int ddUniqueCompareGroup (void const *ptrX, void const *ptrY);
static int ddGroupSifting (DdManager *table, int lower, int upper, DD_CHKFP checkFunction, int lazyFlag);
static void ddCreateGroup (DdManager *table, int x, int y);
static int ddGroupSiftingAux (DdManager *table, int x, int xLow, int xHigh, DD_CHKFP checkFunction, int lazyFlag);
static int ddGroupSiftingUp (DdManager *table, int y, int xLow, DD_CHKFP checkFunction, Move **moves);
static int ddGroupSiftingDown (DdManager *table, int x, int xHigh, DD_CHKFP checkFunction, Move **moves);
static int ddGroupMove (DdManager *table, int x, int y, Move **moves);
static int ddGroupMoveBackward (DdManager *table, int x, int y);
static int ddGroupSiftingBackward (DdManager *table, Move *moves, int size, int upFlag, int lazyFlag);
static void ddMergeGroups (DdManager *table, MtrNode *treenode, int low, int high);
static void ddDissolveGroup (DdManager *table, int x, int y);
static int ddNoCheck (DdManager *table, int x, int y);
static int ddSecDiffCheck (DdManager *table, int x, int y);
static int ddExtSymmCheck (DdManager *table, int x, int y);
static int ddVarGroupCheck (DdManager * table, int x, int y);
static int ddSetVarHandled (DdManager *dd, int index);
static int ddResetVarHandled (DdManager *dd, int index);
static int ddIsVarHandled (DdManager *dd, int index);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Creates a new variable group.

  @details The group starts at variable low and contains size
  variables. The parameter low is the index of the first variable. If
  the variable already exists, its current position in the order is
  known to the manager. If the variable does not exist yet, the
  position is assumed to be the same as the index.  The group tree is
  created if it does not exist yet.

  @return a pointer to the group if successful; NULL otherwise.

  @sideeffect The variable tree is changed.

  @see Cudd_MakeZddTreeNode

*/
MtrNode *
Cudd_MakeTreeNode(
  DdManager * dd /**< manager */,
  unsigned int  low /**< index of the first group variable */,
  unsigned int  size /**< number of variables in the group */,
  unsigned int  type /**< MTR_DEFAULT or MTR_FIXED */)
{
    MtrNode *group;
    MtrNode *tree;
    unsigned int level;

    /* If the variable does not exist yet, the position is assumed to be
    ** the same as the index. Therefore, applications that rely on
    ** Cudd_bddNewVarAtLevel or Cudd_addNewVarAtLevel to create new
    ** variables have to create the variables before they group them.
    */
    level = (low < (unsigned int) dd->size) ? (unsigned int) dd->perm[low] : low;

    if (level + size - 1> (int) MTR_MAXHIGH)
	return(NULL);

    /* If the tree does not exist yet, create it. */
    tree = dd->tree;
    if (tree == NULL) {
	dd->tree = tree = Mtr_InitGroupTree(0, dd->size);
	if (tree == NULL)
	    return(NULL);
	tree->index = dd->size == 0 ? 0 : dd->invperm[0];
    }

    /* Extend the upper bound of the tree if necessary. This allows the
    ** application to create groups even before the variables are created.
    */
    tree->size = ddMax(tree->size, ddMax(level + size, (unsigned) dd->size));

    /* Create the group. */
    group = Mtr_MakeGroup(tree, level, size, type);
    if (group == NULL)
	return(NULL);

    /* Initialize the index field to the index of the variable currently
    ** in position low. This field will be updated by the reordering
    ** procedure to provide a handle to the group once it has been moved.
    */
    group->index = (MtrHalfWord) low;

    return(group);

} /* end of Cudd_MakeTreeNode */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Tree sifting algorithm.

  @details Assumes that a tree representing a group hierarchy is
  passed as a parameter.  It then reorders each group in postorder
  fashion by calling ddTreeSiftingAux.  Assumes that no dead nodes are
  present.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddTreeSifting(
  DdManager * table /**< %DD table */,
  Cudd_ReorderingType method /**< reordering method for the groups of leaves */)
{
    int i;
    int nvars;
    int result;
    int tempTree;

    /* If no tree is provided we create a temporary one in which all
    ** variables are in a single group. After reordering this tree is
    ** destroyed.
    */
    tempTree = table->tree == NULL;
    if (tempTree) {
	table->tree = Mtr_InitGroupTree(0,table->size);
	table->tree->index = table->invperm[0];
    }
    nvars = table->size;

#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0 && !tempTree)
        (void) fprintf(table->out,"cuddTreeSifting:");
    Mtr_PrintGroups(table->tree,table->enableExtraDebug <= 0);
#endif

#ifdef DD_STATS
    table->extsymmcalls = 0;
    table->extsymm = 0;
    table->secdiffcalls = 0;
    table->secdiff = 0;
    table->secdiffmisfire = 0;

    (void) fprintf(table->out,"\n");
    if (!tempTree)
	(void) fprintf(table->out,"#:IM_NODES  %8d: group tree nodes\n",
		       ddCountInternalMtrNodes(table,table->tree));
#endif

    /* Initialize the group of each subtable to itself. Initially
    ** there are no groups. Groups are created according to the tree
    ** structure in postorder fashion.
    */
    for (i = 0; i < nvars; i++)
	table->subtables[i].next = i;


    /* Reorder. */
    result = ddTreeSiftingAux(table, table->tree, method);

#ifdef DD_STATS		/* print stats */
    if (!tempTree && method == CUDD_REORDER_GROUP_SIFT &&
	(table->groupcheck == CUDD_GROUP_CHECK7 ||
	 table->groupcheck == CUDD_GROUP_CHECK5)) {
	(void) fprintf(table->out,"\nextsymmcalls = %d\n",table->extsymmcalls);
	(void) fprintf(table->out,"extsymm = %d",table->extsymm);
    }
    if (!tempTree && method == CUDD_REORDER_GROUP_SIFT &&
	table->groupcheck == CUDD_GROUP_CHECK7) {
	(void) fprintf(table->out,"\nsecdiffcalls = %d\n",table->secdiffcalls);
	(void) fprintf(table->out,"secdiff = %d\n",table->secdiff);
	(void) fprintf(table->out,"secdiffmisfire = %d",table->secdiffmisfire);
    }
#endif

    if (tempTree)
	Cudd_FreeTree(table);
    else
      Mtr_ReorderGroups(table->tree, table->perm);

    return(result);

} /* end of cuddTreeSifting */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Visits the group tree and reorders each group.

  @details Recursively visits the group tree and reorders each
  group in postorder fashion.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddTreeSiftingAux(
  DdManager * table,
  MtrNode * treenode,
  Cudd_ReorderingType method)
{
    MtrNode  *auxnode;
    int res;
    Cudd_AggregationType saveCheck;

#ifdef DD_DEBUG
    Mtr_PrintGroups(treenode,1);
#endif

    auxnode = treenode;
    while (auxnode != NULL) {
	if (auxnode->child != NULL) {
	    if (!ddTreeSiftingAux(table, auxnode->child, method))
		return(0);
	    saveCheck = table->groupcheck;
	    table->groupcheck = CUDD_NO_CHECK;
	    if (method != CUDD_REORDER_LAZY_SIFT)
	      res = ddReorderChildren(table, auxnode, CUDD_REORDER_GROUP_SIFT);
	    else
	      res = ddReorderChildren(table, auxnode, CUDD_REORDER_LAZY_SIFT);
	    table->groupcheck = saveCheck;

	    if (res == 0)
		return(0);
	} else if (auxnode->size > 1) {
	    if (!ddReorderChildren(table, auxnode, method))
		return(0);
	}
	auxnode = auxnode->younger;
    }

    return(1);

} /* end of ddTreeSiftingAux */


#ifdef DD_STATS
/**
  @brief Counts the number of internal nodes of the group tree.

  @return the count.

  @sideeffect None

*/
static int
ddCountInternalMtrNodes(
  DdManager * table,
  MtrNode * treenode)
{
    MtrNode *auxnode;
    int     count,nodeCount;


    nodeCount = 0;
    auxnode = treenode;
    while (auxnode != NULL) {
	if (!(MTR_TEST(auxnode,MTR_TERMINAL))) {
	    nodeCount++;
	    count = ddCountInternalMtrNodes(table,auxnode->child);
	    nodeCount += count;
	}
	auxnode = auxnode->younger;
    }

    return(nodeCount);

} /* end of ddCountInternalMtrNodes */
#endif


/**
  @brief Reorders the children of a group tree node according to
  the options.

  @details After reordering puts all the variables in the group and/or
  its descendents in a single group. This allows hierarchical
  reordering.  If the variables in the group do not exist yet, simply
  does nothing.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddReorderChildren(
  DdManager * table,
  MtrNode * treenode,
  Cudd_ReorderingType method)
{
    int lower;
    int upper = 0;
    int result;
    unsigned int initialSize;

    ddFindNodeHiLo(table,treenode,&lower,&upper);
    /* If upper == -1 these variables do not exist yet. */
    if (upper == -1)
	return(1);

    if (treenode->flags == MTR_FIXED) {
	result = 1;
    } else {
#ifdef DD_STATS
	(void) fprintf(table->out," ");
#endif
	switch (method) {
	case CUDD_REORDER_RANDOM:
	case CUDD_REORDER_RANDOM_PIVOT:
	    result = cuddSwapping(table,lower,upper,method);
	    break;
	case CUDD_REORDER_SIFT:
	    result = cuddSifting(table,lower,upper);
	    break;
	case CUDD_REORDER_SIFT_CONVERGE:
	    do {
		initialSize = table->keys - table->isolated;
		result = cuddSifting(table,lower,upper);
		if (initialSize <= table->keys - table->isolated)
		    break;
#ifdef DD_STATS
		else
		    (void) fprintf(table->out,"\n");
#endif
	    } while (result != 0);
	    break;
	case CUDD_REORDER_SYMM_SIFT:
	    result = cuddSymmSifting(table,lower,upper);
	    break;
	case CUDD_REORDER_SYMM_SIFT_CONV:
	    result = cuddSymmSiftingConv(table,lower,upper);
	    break;
	case CUDD_REORDER_GROUP_SIFT:
	    if (table->groupcheck == CUDD_NO_CHECK) {
		result = ddGroupSifting(table,lower,upper,ddNoCheck,
					DD_NORMAL_SIFT);
	    } else if (table->groupcheck == CUDD_GROUP_CHECK5) {
		result = ddGroupSifting(table,lower,upper,ddExtSymmCheck,
					DD_NORMAL_SIFT);
	    } else if (table->groupcheck == CUDD_GROUP_CHECK7) {
		result = ddGroupSifting(table,lower,upper,ddExtSymmCheck,
					DD_NORMAL_SIFT);
	    } else {
		(void) fprintf(table->err,
			       "Unknown group ckecking method\n");
		result = 0;
	    }
	    break;
	case CUDD_REORDER_GROUP_SIFT_CONV:
	    do {
		initialSize = table->keys - table->isolated;
		if (table->groupcheck == CUDD_NO_CHECK) {
		    (void) ddGroupSifting(table,lower,upper,ddNoCheck,
                                          DD_NORMAL_SIFT);
		} else if (table->groupcheck == CUDD_GROUP_CHECK5) {
		    (void) ddGroupSifting(table,lower,upper,ddExtSymmCheck,
                                          DD_NORMAL_SIFT);
		} else if (table->groupcheck == CUDD_GROUP_CHECK7) {
		    (void) ddGroupSifting(table,lower,upper,ddExtSymmCheck,
                                          DD_NORMAL_SIFT);
		} else {
		    (void) fprintf(table->err,
				   "Unknown group ckecking method\n");
		}
#ifdef DD_STATS
		(void) fprintf(table->out,"\n");
#endif
		result = cuddWindowReorder(table,lower,upper,
					   CUDD_REORDER_WINDOW4);
		if (initialSize <= table->keys - table->isolated)
		    break;
#ifdef DD_STATS
		else
		    (void) fprintf(table->out,"\n");
#endif
	    } while (result != 0);
	    break;
	case CUDD_REORDER_WINDOW2:
	case CUDD_REORDER_WINDOW3:
	case CUDD_REORDER_WINDOW4:
	case CUDD_REORDER_WINDOW2_CONV:
	case CUDD_REORDER_WINDOW3_CONV:
	case CUDD_REORDER_WINDOW4_CONV:
	    result = cuddWindowReorder(table,lower,upper,method);
	    break;
	case CUDD_REORDER_ANNEALING:
	    result = cuddAnnealing(table,lower,upper);
	    break;
	case CUDD_REORDER_GENETIC:
	    result = cuddGa(table,lower,upper);
	    break;
	case CUDD_REORDER_LINEAR:
	    result = cuddLinearAndSifting(table,lower,upper);
	    break;
	case CUDD_REORDER_LINEAR_CONVERGE:
	    do {
		initialSize = table->keys - table->isolated;
		result = cuddLinearAndSifting(table,lower,upper);
		if (initialSize <= table->keys - table->isolated)
		    break;
#ifdef DD_STATS
		else
		    (void) fprintf(table->out,"\n");
#endif
	    } while (result != 0);
	    break;
	case CUDD_REORDER_EXACT:
	    result = cuddExact(table,lower,upper);
	    break;
	case CUDD_REORDER_LAZY_SIFT:
	    result = ddGroupSifting(table,lower,upper,ddVarGroupCheck,
				    DD_LAZY_SIFT);
	    break;
	default:
	    return(0);
	}
    }

    /* Create a single group for all the variables that were sifted,
    ** so that they will be treated as a single block by successive
    ** invocations of ddGroupSifting.
    */
    ddMergeGroups(table,treenode,lower,upper);

#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,"ddReorderChildren:");
#endif

    return(result);

} /* end of ddReorderChildren */


/**
  @brief Finds the lower and upper bounds of the group represented
  by treenode.

  @details From the index and size fields we need to derive the
  current positions, and find maximum and minimum.

  @sideeffect The bounds are returned as side effects.

*/
static void
ddFindNodeHiLo(
  DdManager * table,
  MtrNode * treenode,
  int * lower,
  int * upper)
{
    int low;
    int high;

    /* Check whether no variables in this group already exist.
    ** If so, return immediately. The calling procedure will know from
    ** the values of upper that no reordering is needed.
    */
    if ((int) treenode->low >= table->size) {
	*lower = table->size;
	*upper = -1;
	return;
    }

    *lower = low = (unsigned int) table->perm[treenode->index];
    high = (int) (low + treenode->size - 1);

    if (high >= table->size) {
	/* This is the case of a partially existing group. The aim is to
	** reorder as many variables as safely possible.  If the tree
	** node is terminal, we just reorder the subset of the group
	** that is currently in existence.  If the group has
	** subgroups, then we only reorder those subgroups that are
	** fully instantiated.  This way we avoid breaking up a group.
	*/
	MtrNode *auxnode = treenode->child;
	if (auxnode == NULL) {
	    *upper = (unsigned int) table->size - 1;
	} else {
	    /* Search the subgroup that strands the table->size line.
	    ** If the first group starts at 0 and goes past table->size
	    ** upper will get -1, thus correctly signaling that no reordering
	    ** should take place.
	    */
	    while (auxnode != NULL) {
		int thisLower = table->perm[auxnode->low];
		int thisUpper = thisLower + auxnode->size - 1;
		if (thisUpper >= table->size && thisLower < table->size)
		    *upper = (unsigned int) thisLower - 1;
		auxnode = auxnode->younger;
	    }
	}
    } else {
	/* Normal case: All the variables of the group exist. */
	*upper = (unsigned int) high;
    }

#ifdef DD_DEBUG
    /* Make sure that all variables in group are contiguous. */
    assert(treenode->size >= (MtrHalfWord) (*upper - *lower + 1));
#endif

    return;

} /* end of ddFindNodeHiLo */


/**
  @brief Comparison function used by qsort.

  @details Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.

  @return the difference in number of keys between the two variables
  being compared.

  @sideeffect None

*/
static int
ddUniqueCompareGroup(
  void const * ptrX,
  void const * ptrY)
{
    IndexKey const * pX = (IndexKey const *) ptrX;
    IndexKey const * pY = (IndexKey const *) ptrY;
#if 0
    if (pY->keys == pX->keys) {
	return(pX->index - pY->index);
    }
#endif
    return(pY->keys - pX->keys);

} /* end of ddUniqueCompareGroup */


/**
  @brief Sifts from treenode->low to treenode->high.

  @details If croupcheck == CUDD_GROUP_CHECK7, it checks for group
  creation at the end of the initial sifting. If a group is created,
  it is then sifted again. After sifting one variable, the group that
  contains it is dissolved.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddGroupSifting(
  DdManager * table,
  int  lower,
  int  upper,
  DD_CHKFP checkFunction,
  int lazyFlag)
{
    IndexKey	*var;
    int		i,j,x,xInit;
    int		nvars;
    int		classes;
    int		result;
    int		*sifted;
    int		merged;
    int		dissolve;
#ifdef DD_STATS
    unsigned	previousSize;
#endif
    int		xindex;

    nvars = table->size;

    /* Order variables to sift. */
    sifted = NULL;
    var = ALLOC(IndexKey,nvars);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto ddGroupSiftingOutOfMem;
    }
    sifted = ALLOC(int,nvars);
    if (sifted == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto ddGroupSiftingOutOfMem;
    }

    /* Here we consider only one representative for each group. */
    for (i = 0, classes = 0; i < nvars; i++) {
	sifted[i] = 0;
	x = table->perm[i];
	if ((unsigned) x >= table->subtables[x].next) {
	    var[classes].index = i;
	    var[classes].keys = table->subtables[x].keys;
	    classes++;
	}
    }

    util_qsort(var, classes, sizeof(IndexKey), ddUniqueCompareGroup);

    if (lazyFlag) {
	for (i = 0; i < nvars; i ++) {
	    ddResetVarHandled(table, i);
	}
    }

    /* Now sift. */
    for (i = 0; i < ddMin(table->siftMaxVar,classes); i++) {
	if (table->ddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime + table->reordTime
            > table->timeLimit) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
	xindex = var[i].index;
	if (sifted[xindex] == 1) /* variable already sifted as part of group */
	    continue;
	x = table->perm[xindex]; /* find current level of this variable */

	if (x < lower || x > upper || table->subtables[x].bindVar == 1)
	    continue;
#ifdef DD_STATS
	previousSize = table->keys - table->isolated;
#endif
#ifdef DD_DEBUG
	/* x is bottom of group */
	assert((unsigned) x >= table->subtables[x].next);
#endif
	if ((unsigned) x == table->subtables[x].next) {
	    dissolve = 1;
	    result = ddGroupSiftingAux(table,x,lower,upper,checkFunction,
					lazyFlag);
	} else {
	    dissolve = 0;
	    result = ddGroupSiftingAux(table,x,lower,upper,ddNoCheck,lazyFlag);
	}
	if (!result) goto ddGroupSiftingOutOfMem;

	/* check for aggregation */
	merged = 0;
	if (lazyFlag == 0 && table->groupcheck == CUDD_GROUP_CHECK7) {
	    x = table->perm[xindex]; /* find current level */
	    if ((unsigned) x == table->subtables[x].next) { /* not part of a group */
		if (x != upper && sifted[table->invperm[x+1]] == 0 &&
		(unsigned) x+1 == table->subtables[x+1].next) {
		    if (ddSecDiffCheck(table,x,x+1)) {
			merged =1;
			ddCreateGroup(table,x,x+1);
		    }
		}
		if (x != lower && sifted[table->invperm[x-1]] == 0 &&
		(unsigned) x-1 == table->subtables[x-1].next) {
		    if (ddSecDiffCheck(table,x-1,x)) {
			merged =1;
			ddCreateGroup(table,x-1,x);
		    }
		}
	    }
	}

	if (merged) { /* a group was created */
	    /* move x to bottom of group */
	    while ((unsigned) x < table->subtables[x].next)
		x = table->subtables[x].next;
	    /* sift */
	    result = ddGroupSiftingAux(table,x,lower,upper,ddNoCheck,lazyFlag);
	    if (!result) goto ddGroupSiftingOutOfMem;
#ifdef DD_STATS
	    if (table->keys < previousSize + table->isolated) {
		(void) fprintf(table->out,"_");
	    } else if (table->keys > previousSize + table->isolated) {
		(void) fprintf(table->out,"^");
	    } else {
		(void) fprintf(table->out,"*");
	    }
	    fflush(table->out);
	} else {
	    if (table->keys < previousSize + table->isolated) {
		(void) fprintf(table->out,"-");
	    } else if (table->keys > previousSize + table->isolated) {
		(void) fprintf(table->out,"+");
	    } else {
		(void) fprintf(table->out,"=");
	    }
	    fflush(table->out);
#endif
	}

	/* Mark variables in the group just sifted. */
	x = table->perm[xindex];
	if ((unsigned) x != table->subtables[x].next) {
	    xInit = x;
	    do {
		j = table->invperm[x];
		sifted[j] = 1;
		x = table->subtables[x].next;
	    } while (x != xInit);

	    /* Dissolve the group if it was created. */
	    if (lazyFlag == 0 && dissolve) {
		do {
		    j = table->subtables[x].next;
		    table->subtables[x].next = x;
		    x = j;
		} while (x != xInit);
	    }
	}

#ifdef DD_DEBUG
	if (table->enableExtraDebug > 0)
            (void) fprintf(table->out,"ddGroupSifting:");
#endif

        if (lazyFlag) ddSetVarHandled(table, xindex);
    } /* for */

    FREE(sifted);
    FREE(var);

    return(1);

ddGroupSiftingOutOfMem:
    if (var != NULL)	FREE(var);
    if (sifted != NULL)	FREE(sifted);

    return(0);

} /* end of ddGroupSifting */


/**
  @brief Creates a group encompassing variables from x to y in the
  %DD table.

  @details In the current implementation it must be y == x+1.

  @sideeffect None

*/
static void
ddCreateGroup(
  DdManager * table,
  int  x,
  int  y)
{
    int  gybot;

#ifdef DD_DEBUG
    assert(y == x+1);
#endif

    /* Find bottom of second group. */
    gybot = y;
    while ((unsigned) gybot < table->subtables[gybot].next)
	gybot = table->subtables[gybot].next;

    /* Link groups. */
    table->subtables[x].next = y;
    table->subtables[gybot].next = x;

    return;

} /* ddCreateGroup */


/**
  @brief Sifts one variable up and down until it has taken all
  positions. Checks for aggregation.

  @details There may be at most two sweeps, even if the group grows.
  Assumes that x is either an isolated variable, or it is the bottom
  of a group. All groups may not have been found. The variable being
  moved is returned to the best position seen during sifting.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddGroupSiftingAux(
  DdManager * table,
  int  x,
  int  xLow,
  int  xHigh,
  DD_CHKFP checkFunction,
  int lazyFlag)
{
    Move *move;
    Move *moves;	/* list of moves */
    int  initialSize;
    int  result;
    int  y;
    int  topbot;

#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,
                       "ddGroupSiftingAux from %d to %d\n",xLow,xHigh);
    assert((unsigned) x >= table->subtables[x].next); /* x is bottom of group */
#endif

    table->originalSize = (table->keys - table->isolated);
    initialSize = (int) table->originalSize;
    moves = NULL;

    /* If we have a singleton, we check for aggregation in both
    ** directions before we sift.
    */
    if ((unsigned) x == table->subtables[x].next) {
	/* Will go down first, unless x == xHigh:
	** Look for aggregation above x.
	*/
	for (y = x; y > xLow; y--) {
	    if (!checkFunction(table,y-1,y))
		break;
	    topbot = table->subtables[y-1].next; /* find top of y-1's group */
	    table->subtables[y-1].next = y;
	    table->subtables[x].next = topbot; /* x is bottom of group so its */
					       /* next is top of y-1's group */
	    y = topbot + 1; /* add 1 for y--; new y is top of group */
	}
	/* Will go up first unless x == xlow:
	** Look for aggregation below x.
	*/
	for (y = x; y < xHigh; y++) {
	    if (!checkFunction(table,y,y+1))
		break;
	    /* find bottom of y+1's group */
	    topbot = y + 1;
	    while ((unsigned) topbot < table->subtables[topbot].next) {
		topbot = table->subtables[topbot].next;
	    }
	    table->subtables[topbot].next = table->subtables[y].next;
	    table->subtables[y].next = y + 1;
	    y = topbot - 1; /* subtract 1 for y++; new y is bottom of group */
	}
    }

    /* Now x may be in the middle of a group.
    ** Find bottom of x's group.
    */
    while ((unsigned) x < table->subtables[x].next)
	x = table->subtables[x].next;

    if (x == xLow) { /* Sift down */
#ifdef DD_DEBUG
	/* x must be a singleton */
	assert((unsigned) x == table->subtables[x].next);
#endif
	if (x == xHigh) return(1);	/* just one variable */

	if (!ddGroupSiftingDown(table,x,xHigh,checkFunction,&moves))
	    goto ddGroupSiftingAuxOutOfMem;
	/* at this point x == xHigh, unless early term */

	/* move backward and stop at best position */
	result = ddGroupSiftingBackward(table,moves,initialSize,
					DD_SIFT_DOWN,lazyFlag);
#ifdef DD_DEBUG
	assert(table->keys - table->isolated <= (unsigned) initialSize);
#endif
	if (!result) goto ddGroupSiftingAuxOutOfMem;

    } else if (cuddNextHigh(table,x) > xHigh) { /* Sift up */
#ifdef DD_DEBUG
	/* x is bottom of group */
	assert((unsigned) x >= table->subtables[x].next);
#endif
	/* Find top of x's group */
	x = table->subtables[x].next;

	if (!ddGroupSiftingUp(table,x,xLow,checkFunction,&moves))
	    goto ddGroupSiftingAuxOutOfMem;
	/* at this point x == xLow, unless early term */

	/* move backward and stop at best position */
	result = ddGroupSiftingBackward(table,moves,initialSize,
					DD_SIFT_UP,lazyFlag);
#ifdef DD_DEBUG
	assert(table->keys - table->isolated <= (unsigned) initialSize);
#endif
	if (!result) goto ddGroupSiftingAuxOutOfMem;

    } else if (x - xLow > xHigh - x) { /* must go down first: shorter */
	if (!ddGroupSiftingDown(table,x,xHigh,checkFunction,&moves))
	    goto ddGroupSiftingAuxOutOfMem;
	/* at this point x == xHigh, unless early term */

	/* Find top of group */
	if (moves) {
	    x = moves->y;
	}
	while ((unsigned) x < table->subtables[x].next)
	    x = table->subtables[x].next;
	x = table->subtables[x].next;
#ifdef DD_DEBUG
	/* x should be the top of a group */
	assert((unsigned) x <= table->subtables[x].next);
#endif

	if (!ddGroupSiftingUp(table,x,xLow,checkFunction,&moves))
	    goto ddGroupSiftingAuxOutOfMem;

	/* move backward and stop at best position */
	result = ddGroupSiftingBackward(table,moves,initialSize,
					DD_SIFT_UP,lazyFlag);
#ifdef DD_DEBUG
	assert(table->keys - table->isolated <= (unsigned) initialSize);
#endif
	if (!result) goto ddGroupSiftingAuxOutOfMem;

    } else { /* moving up first: shorter */
	/* Find top of x's group */
	x = table->subtables[x].next;

	if (!ddGroupSiftingUp(table,x,xLow,checkFunction,&moves))
	    goto ddGroupSiftingAuxOutOfMem;
	/* at this point x == xHigh, unless early term */

	if (moves) {
	    x = moves->x;
	}
	while ((unsigned) x < table->subtables[x].next)
	    x = table->subtables[x].next;
#ifdef DD_DEBUG
	/* x is bottom of a group */
	assert((unsigned) x >= table->subtables[x].next);
#endif

	if (!ddGroupSiftingDown(table,x,xHigh,checkFunction,&moves))
	    goto ddGroupSiftingAuxOutOfMem;

	/* move backward and stop at best position */
	result = ddGroupSiftingBackward(table,moves,initialSize,
					DD_SIFT_DOWN,lazyFlag);
#ifdef DD_DEBUG
	assert(table->keys - table->isolated <= (unsigned) initialSize);
#endif
	if (!result) goto ddGroupSiftingAuxOutOfMem;
    }

    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }

    return(1);

ddGroupSiftingAuxOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }

    return(0);

} /* end of ddGroupSiftingAux */


/**
  @brief Sifts up a variable until either it reaches position xLow
  or the size of the %DD heap increases too much.

  @details Assumes that y is the top of a group (or a singleton).
  Checks y for aggregation to the adjacent variables. Records all the
  moves that are appended to the list of moves received as input and
  returned as a side effect.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddGroupSiftingUp(
  DdManager * table,
  int  y,
  int  xLow,
  DD_CHKFP checkFunction,
  Move ** moves)
{
    Move *move;
    int  x;
    int  size;
    int  i;
    int  gxtop,gybot;
    int  limitSize;
    int  xindex, yindex;
    int  zindex;
    int  z;
    unsigned int isolated;
    int  L;	/* lower bound on DD size */
#ifdef DD_DEBUG
    int  checkL;
#endif

    yindex = table->invperm[y];

    /* Initialize the lower bound.
    ** The part of the DD below the bottom of y's group will not change.
    ** The part of the DD above y that does not interact with any
    ** variable of y's group will not change.
    ** The rest may vanish in the best case, except for
    ** the nodes at level xLow, which will not vanish, regardless.
    ** What we use here is not really a lower bound, because we ignore
    ** the interactions with all variables except y.
    */
    limitSize = L = (int) (table->keys - table->isolated);
    gybot = y;
    while ((unsigned) gybot < table->subtables[gybot].next)
	gybot = table->subtables[gybot].next;
    for (z = xLow + 1; z <= gybot; z++) {
	zindex = table->invperm[z];
	if (zindex == yindex || cuddTestInteract(table,zindex,yindex)) {
	    isolated = table->vars[zindex]->ref == 1;
	    L -= table->subtables[z].keys - isolated;
	}
    }

    x = cuddNextLow(table,y);
    while (x >= xLow && L <= limitSize) {
#ifdef DD_DEBUG
	gybot = y;
	while ((unsigned) gybot < table->subtables[gybot].next)
	    gybot = table->subtables[gybot].next;
	checkL = table->keys - table->isolated;
	for (z = xLow + 1; z <= gybot; z++) {
	    zindex = table->invperm[z];
	    if (zindex == yindex || cuddTestInteract(table,zindex,yindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkL -= table->subtables[z].keys - isolated;
	    }
	}
	if (table->enableExtraDebug > 0 && L != checkL) {
	    (void) fprintf(table->out,
			   "Inaccurate lower bound: L = %d checkL = %d\n",
			   L, checkL);
	}
#endif
	gxtop = table->subtables[x].next;
	if (checkFunction(table,x,y)) {
	    /* Group found, attach groups */
	    table->subtables[x].next = y;
	    i = table->subtables[y].next;
	    while (table->subtables[i].next != (unsigned) y)
		i = table->subtables[i].next;
	    table->subtables[i].next = gxtop;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddGroupSiftingUpOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->flags = MTR_NEWNODE;
	    move->size = (int) (table->keys - table->isolated);
	    move->next = *moves;
	    *moves = move;
	} else if (table->subtables[x].next == (unsigned) x &&
		   table->subtables[y].next == (unsigned) y) {
	    /* x and y are self groups */
	    xindex = table->invperm[x];
	    size = cuddSwapInPlace(table,x,y);
#ifdef DD_DEBUG
	    assert(table->subtables[x].next == (unsigned) x);
	    assert(table->subtables[y].next == (unsigned) y);
#endif
	    if (size == 0) goto ddGroupSiftingUpOutOfMem;
	    /* Update the lower bound. */
	    if (cuddTestInteract(table,xindex,yindex)) {
		isolated = table->vars[xindex]->ref == 1;
		L += table->subtables[y].keys - isolated;
	    }
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddGroupSiftingUpOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->flags = MTR_DEFAULT;
	    move->size = size;
	    move->next = *moves;
	    *moves = move;

#ifdef DD_DEBUG
	    if (table->enableExtraDebug > 0)
                (void) fprintf(table->out,
                               "ddGroupSiftingUp (2 single groups):\n");
#endif
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;
	} else { /* Group move */
	    size = ddGroupMove(table,x,y,moves);
	    if (size == 0) goto ddGroupSiftingUpOutOfMem;
	    /* Update the lower bound. */
	    z = (*moves)->y;
	    do {
		zindex = table->invperm[z];
		if (cuddTestInteract(table,zindex,yindex)) {
		    isolated = table->vars[zindex]->ref == 1;
		    L += table->subtables[z].keys - isolated;
		}
		z = table->subtables[z].next;
	    } while (z != (int) (*moves)->y);
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;
	}
	y = gxtop;
	x = cuddNextLow(table,y);
    }

    return(1);

ddGroupSiftingUpOutOfMem:
    while (*moves != NULL) {
	move = (*moves)->next;
	cuddDeallocMove(table, *moves);
	*moves = move;
    }
    return(0);

} /* end of ddGroupSiftingUp */


/**
  @brief Sifts down a variable until it reaches position xHigh.

  @details Assumes that x is the bottom of a group (or a singleton).
  Records all the moves.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddGroupSiftingDown(
  DdManager * table,
  int  x,
  int  xHigh,
  DD_CHKFP checkFunction,
  Move ** moves)
{
    Move *move;
    int  y;
    int  size;
    int  limitSize;
    int  gxtop,gybot;
    int  R;	/* upper bound on node decrease */
    int  xindex, yindex;
    unsigned isolated;
    int  allVars;
    int  z;
    int  zindex;
#ifdef DD_DEBUG
    int  checkR;
#endif

    /* If the group consists of simple variables, there is no point in
    ** sifting it down. This check is redundant if the projection functions
    ** do not have external references, because the computation of the
    ** lower bound takes care of the problem.  It is necessary otherwise to
    ** prevent the sifting down of simple variables. */
    y = x;
    allVars = 1;
    do {
	if (table->subtables[y].keys != 1) {
	    allVars = 0;
	    break;
	}
	y = table->subtables[y].next;
    } while (table->subtables[y].next != (unsigned) x);
    if (allVars)
	return(1);

    /* Initialize R. */
    xindex = table->invperm[x];
    gxtop = table->subtables[x].next;
    limitSize = size = (int) (table->keys - table->isolated);
    R = 0;
    for (z = xHigh; z > gxtop; z--) {
	zindex = table->invperm[z];
	if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
	    isolated = table->vars[zindex]->ref == 1;
	    R += table->subtables[z].keys - isolated;
	}
    }

    y = cuddNextHigh(table,x);
    while (y <= xHigh && size - R < limitSize) {
#ifdef DD_DEBUG
	gxtop = table->subtables[x].next;
	checkR = 0;
	for (z = xHigh; z > gxtop; z--) {
	    zindex = table->invperm[z];
	    if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkR += table->subtables[z].keys - isolated;
	    }
	}
	assert(R >= checkR);
#endif
	/* Find bottom of y group. */
	gybot = table->subtables[y].next;
	while (table->subtables[gybot].next != (unsigned) y)
	    gybot = table->subtables[gybot].next;

	if (checkFunction(table,x,y)) {
	    /* Group found: attach groups and record move. */
	    gxtop = table->subtables[x].next;
	    table->subtables[x].next = y;
	    table->subtables[gybot].next = gxtop;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddGroupSiftingDownOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->flags = MTR_NEWNODE;
	    move->size = (int) (table->keys - table->isolated);
	    move->next = *moves;
	    *moves = move;
	} else if (table->subtables[x].next == (unsigned) x &&
		   table->subtables[y].next == (unsigned) y) {
	    /* x and y are self groups */
	    /* Update upper bound on node decrease. */
	    yindex = table->invperm[y];
	    if (cuddTestInteract(table,xindex,yindex)) {
		isolated = table->vars[yindex]->ref == 1;
		R -= table->subtables[y].keys - isolated;
	    }
	    size = cuddSwapInPlace(table,x,y);
#ifdef DD_DEBUG
	    assert(table->subtables[x].next == (unsigned) x);
	    assert(table->subtables[y].next == (unsigned) y);
#endif
	    if (size == 0) goto ddGroupSiftingDownOutOfMem;

	    /* Record move. */
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddGroupSiftingDownOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->flags = MTR_DEFAULT;
	    move->size = size;
	    move->next = *moves;
	    *moves = move;

#ifdef DD_DEBUG
	    if (table->enableExtraDebug > 0)
                (void) fprintf(table->out,
                               "ddGroupSiftingDown (2 single groups):\n");
#endif
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;

	} else { /* Group move */
	    /* Update upper bound on node decrease: first phase. */
	    gxtop = table->subtables[x].next;
	    z = gxtop + 1;
	    do {
		zindex = table->invperm[z];
		if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
		    isolated = table->vars[zindex]->ref == 1;
		    R -= table->subtables[z].keys - isolated;
		}
		z++;
	    } while (z <= gybot);
	    size = ddGroupMove(table,x,y,moves);
	    if (size == 0) goto ddGroupSiftingDownOutOfMem;
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;

	    /* Update upper bound on node decrease: second phase. */
	    gxtop = table->subtables[gybot].next;
	    for (z = gxtop + 1; z <= gybot; z++) {
		zindex = table->invperm[z];
		if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
		    isolated = table->vars[zindex]->ref == 1;
		    R += table->subtables[z].keys - isolated;
		}
	    }
	}
	x = gybot;
	y = cuddNextHigh(table,x);
    }

    return(1);

ddGroupSiftingDownOutOfMem:
    while (*moves != NULL) {
	move = (*moves)->next;
	cuddDeallocMove(table, *moves);
	*moves = move;
    }

    return(0);

} /* end of ddGroupSiftingDown */


/**
  @brief Swaps two groups and records the move.

  @return the number of keys in the %DD table in case of success; 0
  otherwise.

  @sideeffect None

*/
static int
ddGroupMove(
  DdManager * table,
  int  x,
  int  y,
  Move ** moves)
{
    Move *move;
    int  size;
    int  i,j,xtop,xbot,xsize,ytop,ybot,ysize,newxtop;
    int  swapx = 0, swapy = 0;
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    int  initialSize,bestSize;
#endif

#ifdef DD_DEBUG
    /* We assume that x < y */
    assert(x < y);
#endif
    /* Find top, bottom, and size for the two groups. */
    xbot = x;
    xtop = table->subtables[x].next;
    xsize = xbot - xtop + 1;
    ybot = y;
    while ((unsigned) ybot < table->subtables[ybot].next)
	ybot = table->subtables[ybot].next;
    ytop = y;
    ysize = ybot - ytop + 1;

#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    initialSize = bestSize = table->keys - table->isolated;
#endif
    /* Sift the variables of the second group up through the first group */
    for (i = 1; i <= ysize; i++) {
	for (j = 1; j <= xsize; j++) {
	    size = cuddSwapInPlace(table,x,y);
	    if (size == 0) goto ddGroupMoveOutOfMem;
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
	    if (size < bestSize)
		bestSize = size;
#endif
	    swapx = x; swapy = y;
	    y = x;
	    x = cuddNextLow(table,y);
	}
	y = ytop + i;
	x = cuddNextLow(table,y);
    }
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    if ((bestSize < initialSize) && (bestSize < size))
	(void) fprintf(table->out,"Missed local minimum: initialSize:%d  bestSize:%d  finalSize:%d\n",initialSize,bestSize,size);
#endif

    /* fix groups */
    y = xtop; /* ytop is now where xtop used to be */
    for (i = 0; i < ysize - 1; i++) {
	table->subtables[y].next = cuddNextHigh(table,y);
	y = cuddNextHigh(table,y);
    }
    table->subtables[y].next = xtop; /* y is bottom of its group, join */
				    /* it to top of its group */
    x = cuddNextHigh(table,y);
    newxtop = x;
    for (i = 0; i < xsize - 1; i++) {
	table->subtables[x].next = cuddNextHigh(table,x);
	x = cuddNextHigh(table,x);
    }
    table->subtables[x].next = newxtop; /* x is bottom of its group, join */
				    /* it to top of its group */
#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,"ddGroupMove:\n");
#endif

    /* Store group move */
    move = (Move *) cuddDynamicAllocNode(table);
    if (move == NULL) goto ddGroupMoveOutOfMem;
    move->x = swapx;
    move->y = swapy;
    move->flags = MTR_DEFAULT;
    move->size = (int) (table->keys - table->isolated);
    move->next = *moves;
    *moves = move;

    return((int)(table->keys - table->isolated));

ddGroupMoveOutOfMem:
    while (*moves != NULL) {
	move = (*moves)->next;
	cuddDeallocMove(table, *moves);
	*moves = move;
    }
    return(0);

} /* end of ddGroupMove */


/**
  @brief Undoes the swap two groups.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddGroupMoveBackward(
  DdManager * table,
  int  x,
  int  y)
{
    int size;
    int i,j,xtop,xbot,xsize,ytop,ybot,ysize,newxtop;


#ifdef DD_DEBUG
    /* We assume that x < y */
    assert(x < y);
#endif

    /* Find top, bottom, and size for the two groups. */
    xbot = x;
    xtop = table->subtables[x].next;
    xsize = xbot - xtop + 1;
    ybot = y;
    while ((unsigned) ybot < table->subtables[ybot].next)
	ybot = table->subtables[ybot].next;
    ytop = y;
    ysize = ybot - ytop + 1;

    /* Sift the variables of the second group up through the first group */
    for (i = 1; i <= ysize; i++) {
	for (j = 1; j <= xsize; j++) {
	    size = cuddSwapInPlace(table,x,y);
	    if (size == 0)
		return(0);
	    y = x;
	    x = cuddNextLow(table,y);
	}
	y = ytop + i;
	x = cuddNextLow(table,y);
    }

    /* fix groups */
    y = xtop;
    for (i = 0; i < ysize - 1; i++) {
	table->subtables[y].next = cuddNextHigh(table,y);
	y = cuddNextHigh(table,y);
    }
    table->subtables[y].next = xtop; /* y is bottom of its group, join */
				    /* to its top */
    x = cuddNextHigh(table,y);
    newxtop = x;
    for (i = 0; i < xsize - 1; i++) {
	table->subtables[x].next = cuddNextHigh(table,x);
	x = cuddNextHigh(table,x);
    }
    table->subtables[x].next = newxtop; /* x is bottom of its group, join */
				    /* to its top */
#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,"ddGroupMoveBackward:\n");
#endif

    return(1);

} /* end of ddGroupMoveBackward */


/**
  @brief Determines the best position for a variables and returns
  it there.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddGroupSiftingBackward(
  DdManager * table,
  Move * moves,
  int  size,
  int  upFlag,
  int  lazyFlag)
{
    Move *move;
    int  res;
    Move *end_move = NULL;
    int diff, tmp_diff;
    int index;
    unsigned int pairlev;

    if (lazyFlag) {
	end_move = NULL;

	/* Find the minimum size, and the earliest position at which it
	** was achieved. */
	for (move = moves; move != NULL; move = move->next) {
	    if (move->size < size) {
		size = move->size;
		end_move = move;
	    } else if (move->size == size) {
		if (end_move == NULL) end_move = move;
	    }
	}

	/* Find among the moves that give minimum size the one that
	** minimizes the distance from the corresponding variable. */
	if (moves != NULL) {
	    diff = Cudd_ReadSize(table) + 1;
	    index = (upFlag == 1) ?
		    table->invperm[moves->x] : table->invperm[moves->y];
	    pairlev =
		(unsigned) table->perm[Cudd_bddReadPairIndex(table, index)];

	    for (move = moves; move != NULL; move = move->next) {
		if (move->size == size) {
		    if (upFlag == 1) {
			tmp_diff = (move->x > pairlev) ?
				    move->x - pairlev : pairlev - move->x;
		    } else {
			tmp_diff = (move->y > pairlev) ?
				    move->y - pairlev : pairlev - move->y;
		    }
		    if (tmp_diff < diff) {
			diff = tmp_diff;
			end_move = move;
		    }
		}
	    }
	}
    } else {
	/* Find the minimum size. */
	for (move = moves; move != NULL; move = move->next) {
	    if (move->size < size) {
		size = move->size;
	    }
	}
    }

    /* In case of lazy sifting, end_move identifies the position at
    ** which we want to stop.  Otherwise, we stop as soon as we meet
    ** the minimum size. */
    for (move = moves; move != NULL; move = move->next) {
	if (lazyFlag) {
	    if (move == end_move) return(1);
	} else {
	    if (move->size == size) return(1);
	}
	if ((table->subtables[move->x].next == move->x) &&
	(table->subtables[move->y].next == move->y)) {
	    res = cuddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!res) return(0);
#ifdef DD_DEBUG
	    if (table->enableExtraDebug > 0)
                (void) fprintf(table->out,"ddGroupSiftingBackward:\n");
	    assert(table->subtables[move->x].next == move->x);
	    assert(table->subtables[move->y].next == move->y);
#endif
	} else { /* Group move necessary */
	    if (move->flags == MTR_NEWNODE) {
		ddDissolveGroup(table,(int)move->x,(int)move->y);
	    } else {
		res = ddGroupMoveBackward(table,(int)move->x,(int)move->y);
		if (!res) return(0);
	    }
	}

    }

    return(1);

} /* end of ddGroupSiftingBackward */


/**
  @brief Merges groups in the %DD table.

  @details Creates a single group from low to high and adjusts the
  index field of the tree node.

  @sideeffect None

*/
static void
ddMergeGroups(
  DdManager * table,
  MtrNode * treenode,
  int  low,
  int  high)
{
    int i;
    MtrNode *auxnode;
    int saveindex;
    int newindex;

    /* Merge all variables from low to high in one group, unless
    ** this is the topmost group. In such a case we do not merge lest
    ** we lose the symmetry information. */
    if (treenode != table->tree) {
	for (i = low; i < high; i++)
	    table->subtables[i].next = i+1;
	table->subtables[high].next = low;
    }

    /* Adjust the index fields of the tree nodes. If a node is the
    ** first child of its parent, then the parent may also need adjustment. */
    saveindex = treenode->index;
    newindex = table->invperm[low];
    auxnode = treenode;
    do {
	auxnode->index = newindex;
	if (auxnode->parent == NULL ||
		(int) auxnode->parent->index != saveindex)
	    break;
	auxnode = auxnode->parent;
    } while (1);
    return;

} /* end of ddMergeGroups */


/**
  @brief Dissolves a group in the %DD table.

  @details x and y are variables in a group to be cut in two. The cut
  is to pass between x and y.

  @sideeffect None

*/
static void
ddDissolveGroup(
  DdManager * table,
  int  x,
  int  y)
{
    int topx;
    int boty;

    /* find top and bottom of the two groups */
    boty = y;
    while ((unsigned) boty < table->subtables[boty].next)
	boty = table->subtables[boty].next;

    topx = table->subtables[boty].next;

    table->subtables[boty].next = y;
    table->subtables[x].next = topx;

    return;

} /* end of ddDissolveGroup */


/**
  @brief Pretends to check two variables for aggregation.

  @return always 0.

  @sideeffect None

*/
static int
ddNoCheck(
  DdManager * table,
  int  x,
  int  y)
{
    (void) table; /* avoid warning */
    (void) x;     /* avoid warning */
    (void) y;     /* avoid warning */
    return(0);

} /* end of ddNoCheck */


/**
  @brief Checks two variables for aggregation.

  @details The check is based on the second difference of the number
  of nodes as a function of the layer. If the second difference is
  lower than a given threshold (typically negative) then the two
  variables should be aggregated.

  @return 1 if the two variables pass the test; 0 otherwise.

  @sideeffect None

*/
static int
ddSecDiffCheck(
  DdManager * table,
  int  x,
  int  y)
{
    double Nx,Nx_1;
    double Sx;
    double threshold;
    int    xindex,yindex;

    if (x==0) return(0);

#ifdef DD_STATS
    table->secdiffcalls++;
#endif
    Nx = (double) table->subtables[x].keys;
    Nx_1 = (double) table->subtables[x-1].keys;
    Sx = (table->subtables[y].keys/Nx) - (Nx/Nx_1);

    threshold = table->recomb / 100.0;
    if (Sx < threshold) {
	xindex = table->invperm[x];
	yindex = table->invperm[y];
	if (cuddTestInteract(table,xindex,yindex)) {
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
	    (void) fprintf(table->out,
			   "Second difference for %d = %g Pos(%d)\n",
			   table->invperm[x],Sx,x);
#endif
#ifdef DD_STATS
	    table->secdiff++;
#endif
	    return(1);
	} else {
#ifdef DD_STATS
	    table->secdiffmisfire++;
#endif
	    return(0);
	}

    }
    return(0);

} /* end of ddSecDiffCheck */


/**
  @brief Checks for extended symmetry of x and y.

  @return 1 in case of extended symmetry; 0 otherwise.

  @sideeffect None

*/
static int
ddExtSymmCheck(
  DdManager * table,
  int  x,
  int  y)
{
    DdNode *f,*f0,*f1,*f01,*f00,*f11,*f10;
    DdNode *one;
    int comple;		/* f0 is complemented */
    int notproj;	/* f is not a projection function */
    int arccount;	/* number of arcs from layer x to layer y */
    int TotalRefCount;	/* total reference count of layer y minus 1 */
    int counter;	/* number of nodes of layer x that are allowed */
			/* to violate extended symmetry conditions */
    int arccounter;	/* number of arcs into layer y that are allowed */
			/* to come from layers other than x */
    int i;
    int xindex;
    int yindex;
    int res;
    int slots;
    DdNodePtr *list;
    DdNode *sentinel = &(table->sentinel);

    xindex = table->invperm[x];
    yindex = table->invperm[y];

    /* If the two variables do not interact, we do not want to merge them. */
    if (!cuddTestInteract(table,xindex,yindex))
	return(0);

#ifdef DD_DEBUG
    /* Checks that x and y do not contain just the projection functions.
    ** With the test on interaction, these test become redundant,
    ** because an isolated projection function does not interact with
    ** any other variable.
    */
    if (table->subtables[x].keys == 1) {
	assert(table->vars[xindex]->ref != 1);
    }
    if (table->subtables[y].keys == 1) {
	assert(table->vars[yindex]->ref != 1);
    }
#endif

#ifdef DD_STATS
    table->extsymmcalls++;
#endif

    arccount = 0;
    counter = (int) (table->subtables[x].keys *
	      (table->symmviolation/100.0) + 0.5);
    one = DD_ONE(table);

    slots = table->subtables[x].slots;
    list = table->subtables[x].nodelist;
    for (i = 0; i < slots; i++) {
	f = list[i];
	while (f != sentinel) {
	    /* Find f1, f0, f11, f10, f01, f00. */
	    f1 = cuddT(f);
	    f0 = Cudd_Regular(cuddE(f));
	    comple = Cudd_IsComplement(cuddE(f));
	    notproj = f1 != one || f0 != one || f->ref != (DdHalfWord) 1;
	    if (f1->index == (unsigned) yindex) {
		arccount++;
		f11 = cuddT(f1); f10 = cuddE(f1);
	    } else {
		if ((int) f0->index != yindex) {
		    /* If f is an isolated projection function it is
		    ** allowed to bypass layer y.
		    */
		    if (notproj) {
			if (counter == 0)
			    return(0);
			counter--; /* f bypasses layer y */
		    }
		}
		f11 = f10 = f1;
	    }
	    if ((int) f0->index == yindex) {
		arccount++;
		f01 = cuddT(f0); f00 = cuddE(f0);
	    } else {
		f01 = f00 = f0;
	    }
	    if (comple) {
		f01 = Cudd_Not(f01);
		f00 = Cudd_Not(f00);
	    }

	    /* Unless we are looking at a projection function
	    ** without external references except the one from the
	    ** table, we insist that f01 == f10 or f11 == f00
	    */
	    if (notproj) {
		if (f01 != f10 && f11 != f00) {
		    if (counter == 0)
			return(0);
		    counter--;
		}
	    }

	    f = f->next;
	} /* while */
    } /* for */

    /* Calculate the total reference counts of y */
    TotalRefCount = -1;	/* -1 for projection function */
    slots = table->subtables[y].slots;
    list = table->subtables[y].nodelist;
    for (i = 0; i < slots; i++) {
	f = list[i];
	while (f != sentinel) {
	    TotalRefCount += f->ref;
	    f = f->next;
	}
    }

    arccounter = (int) (table->subtables[y].keys *
		 (table->arcviolation/100.0) + 0.5);
    res = arccount >= TotalRefCount - arccounter;

#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    if (res) {
	(void) fprintf(table->out,
		       "Found extended symmetry! x = %d\ty = %d\tPos(%d,%d)\n",
		       xindex,yindex,x,y);
    }
#endif

#ifdef DD_STATS
    if (res)
	table->extsymm++;
#endif
    return(res);

} /* end ddExtSymmCheck */


/**
  @brief Checks for grouping of x and y.

  @details This function is used for lazy sifting.

  @return 1 in case of grouping; 0 otherwise.

  @sideeffect None

*/
static int
ddVarGroupCheck(
  DdManager * table,
  int x,
  int y)
{
    int xindex = table->invperm[x];
    int yindex = table->invperm[y];

    if (Cudd_bddIsVarToBeUngrouped(table, xindex)) return(0);

    if (Cudd_bddReadPairIndex(table, xindex) == yindex) {
	if (ddIsVarHandled(table, xindex) ||
	    ddIsVarHandled(table, yindex)) {
	    if (Cudd_bddIsVarToBeGrouped(table, xindex) ||
		Cudd_bddIsVarToBeGrouped(table, yindex) ) {
		if (table->keys - table->isolated <= table->originalSize) {
		    return(1);
		}
	    }
	}
    }

    return(0);

} /* end of ddVarGroupCheck */


/**
  @brief Sets a variable to already handled.

  @details This function is used for lazy sifting.

  @sideeffect none

*/
static int
ddSetVarHandled(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(0);
    dd->subtables[dd->perm[index]].varHandled = 1;
    return(1);

} /* end of ddSetVarHandled */


/**
  @brief Resets a variable to be processed.

  @details This function is used for lazy sifting.

  @sideeffect none

*/
static int
ddResetVarHandled(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(0);
    dd->subtables[dd->perm[index]].varHandled = 0;
    return(1);

} /* end of ddResetVarHandled */


/**
  @brief Checks whether a variables is already handled.

  @details This function is used for lazy sifting.

  @sideeffect none

*/
static int
ddIsVarHandled(
  DdManager *dd,
  int index)
{
    if (index >= dd->size || index < 0) return(-1);
    return dd->subtables[dd->perm[index]].varHandled;

} /* end of ddIsVarHandled */

cuddHarwell.c
15705
/**
  @file

  @ingroup cudd

  @brief Function to read a matrix in Harwell format.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Reads in a matrix in the format of the Harwell-Boeing
  benchmark suite.

  @details The variables are ordered as follows:
  <blockquote>
  x\[0\] y\[0\] x\[1\] y\[1\] ...
  </blockquote>
  0 is the most significant bit.  On input, nx and ny hold the numbers
  of row and column variables already in existence.

  @return 1 on success; 0 otherwise.

  @sideeffect On output, nx and ny hold the numbers of row and column
  variables actually used by the matrix.  m and n are set to the
  numbers of rows and columns of the matrix.  Their values on input
  are immaterial.  The %ADD for the sparse matrix is returned in E, and
  its reference count is > 0.

  @see Cudd_addRead Cudd_bddRead

*/
int
Cudd_addHarwell(
  FILE * fp /**< pointer to the input file */,
  DdManager * dd /**< %DD manager */,
  DdNode ** E /**< characteristic function of the graph */,
  DdNode *** x /**< array of row variables */,
  DdNode *** y /**< array of column variables */,
  DdNode *** xn /**< array of complemented row variables */,
  DdNode *** yn_ /**< array of complemented column variables */,
  int * nx /**< number or row variables */,
  int * ny /**< number or column variables */,
  int * m /**< number of rows */,
  int * n /**< number of columns */,
  int  bx /**< first index of row variables */,
  int  sx /**< step of row variables */,
  int  by /**< first index of column variables */,
  int  sy /**< step of column variables */,
  int  pr /**< verbosity level */)
{
    DdNode *one, *zero;
    DdNode *w;
    DdNode *cubex, *cubey, *minterm1;
    int u, v, err, i, j, nv;
    double val;
    /* local copies of x, y, xn, yn_ */
    DdNode **lx = NULL, **ly = NULL, **lxn = NULL, **lyn = NULL;
    int lnx, lny;			/* local copies of nx and ny */
    char title[73], key[9], mxtype[4], rhstyp[4];
    int totcrd, ptrcrd, indcrd, valcrd, rhscrd,
        nrow, ncol, nnzero, neltvl,
	nrhs, nrhsix;
    int *colptr, *rowind;
#if 0
    int nguess, nexact;
    int	*rhsptr, *rhsind;
#endif

    if (*nx < 0 || *ny < 0) return(0);

    one = DD_ONE(dd);
    zero = DD_ZERO(dd);

    /* Read the header */
    err = fscanf(fp, "%72c %8c", title, key);
    if (err == EOF) {
	return(0);
    } else if (err != 2) {
        return(0);
    }
    title[72] = (char) 0;
    key[8] = (char) 0;

    err = fscanf(fp, "%d %d %d %d %d", &totcrd, &ptrcrd, &indcrd,
    &valcrd, &rhscrd);
    if (err == EOF) {
	return(0);
    } else if (err != 5) {
        return(0);
    }

    err = fscanf(fp, "%3s %d %d %d %d", mxtype, &nrow, &ncol,
    &nnzero, &neltvl);
    if (err == EOF) {
	return(0);
    } else if (err != 5) {
        return(0);
    }

    /* Skip FORTRAN formats */
    if (rhscrd == 0) {
	err = fscanf(fp, "%*s %*s %*s \n");
    } else {
	err = fscanf(fp, "%*s %*s %*s %*s \n");
    }
    if (err == EOF) {
	return(0);
    } else if (err != 0) {
        return(0);
    }

    /* Print out some stuff if requested to be verbose */
    if (pr>0) {
	(void) fprintf(dd->out,"%s: type %s, %d rows, %d columns, %d entries\n", key,
	mxtype, nrow, ncol, nnzero);
	if (pr>1) (void) fprintf(dd->out,"%s\n", title);
    }

    /* Check matrix type */
    if (mxtype[0] != 'R' || mxtype[1] != 'U' || mxtype[2] != 'A') {
	(void) fprintf(dd->err,"%s: Illegal matrix type: %s\n",
		       key, mxtype);
	return(0);
    }
    if (neltvl != 0) return(0);

    /* Read optional 5-th line */
    if (rhscrd != 0) {
	err = fscanf(fp, "%3c %d %d", rhstyp, &nrhs, &nrhsix);
	if (err == EOF) {
	    return(0);
	} else if (err != 3) {
	    return(0);
	}
	rhstyp[3] = (char) 0;
	if (rhstyp[0] != 'F') {
	    (void) fprintf(dd->err,
	    "%s: Sparse right-hand side not yet supported\n", key);
	    return(0);
	}
	if (pr>0) (void) fprintf(dd->out,"%d right-hand side(s)\n", nrhs);
    } else {
	nrhs = 0;
    }

    /* Compute the number of variables */

    /* row and column numbers start from 0 */
    u = nrow - 1;
    for (i=0; u > 0; i++) {
	u >>= 1;
    }
    lnx = i;
    if (nrhs == 0) {
	v = ncol - 1;
    } else {
	v = 2* (ddMax(ncol, nrhs) - 1);
    }
    for (i=0; v > 0; i++) {
	v >>= 1;
    }
    lny = i;

    /* Allocate or reallocate arrays for variables as needed */
    if (*nx == 0) {
	if (lnx > 0) {
	    *x = lx = ALLOC(DdNode *,lnx);
	    if (lx == NULL) {
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    *xn = lxn =  ALLOC(DdNode *,lnx);
	    if (lxn == NULL) {
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	} else {
	    *x = *xn = NULL;
	}
    } else if (lnx > *nx) {
	*x = lx = REALLOC(DdNode *, *x, lnx);
	if (lx == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	*xn = lxn =  REALLOC(DdNode *, *xn, lnx);
	if (lxn == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
    } else {
	lx = *x;
	lxn = *xn;
    }
    if (*ny == 0) {
	if (lny >0) {
	    *y = ly = ALLOC(DdNode *,lny);
	    if (ly == NULL) {
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    *yn_ = lyn = ALLOC(DdNode *,lny);
	    if (lyn == NULL) {
		dd->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	} else {
	    *y = *yn_ = NULL;
	}
    } else if (lny > *ny) {
	*y = ly = REALLOC(DdNode *, *y, lny);
	if (ly == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	*yn_ = lyn = REALLOC(DdNode *, *yn_, lny);
	if (lyn == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
    } else {
	ly = *y;
	lyn = *yn_;
    }

    /* Create new variables as needed */
    for (i= *nx,nv=bx+(*nx)*sx; i < lnx; i++,nv+=sx) {
	do {
	    dd->reordered = 0;
	    lx[i] = cuddUniqueInter(dd, nv, one, zero);
	} while (dd->reordered == 1);
	if (lx[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
        cuddRef(lx[i]);
	do {
	    dd->reordered = 0;
	    lxn[i] = cuddUniqueInter(dd, nv, zero, one);
	} while (dd->reordered == 1);
	if (lxn[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
        cuddRef(lxn[i]);
    }
    for (i= *ny,nv=by+(*ny)*sy; i < lny; i++,nv+=sy) {
	do {
	    dd->reordered = 0;
	    ly[i] = cuddUniqueInter(dd, nv, one, zero);
	} while (dd->reordered == 1);
	if (ly[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
	cuddRef(ly[i]);
	do {
	    dd->reordered = 0;
	    lyn[i] = cuddUniqueInter(dd, nv, zero, one);
	} while (dd->reordered == 1);
	if (lyn[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
	cuddRef(lyn[i]);
    }

    /* Update matrix parameters */
    *nx = lnx;
    *ny = lny;
    *m = nrow;
    if (nrhs == 0) {
	*n = ncol;
    } else {
	*n = (1 << (lny - 1)) + nrhs;
    }
    
    /* Read structure data */
    colptr = ALLOC(int, ncol+1);
    if (colptr == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    rowind = ALLOC(int, nnzero);
    if (rowind == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }

    for (i=0; i<ncol+1; i++) {
	err = fscanf(fp, " %d ", &u);
	if (err == EOF){ 
	    FREE(colptr);
	    FREE(rowind);
	    return(0);
	} else if (err != 1) {
	    FREE(colptr);
	    FREE(rowind);
	    return(0);
	}
	colptr[i] = u - 1;
    }
    if (colptr[0] != 0) {
	(void) fprintf(dd->err,"%s: Unexpected colptr[0] (%d)\n",
		       key,colptr[0]);
	FREE(colptr);
	FREE(rowind);
	return(0);
    }
    for (i=0; i<nnzero; i++) {
	err = fscanf(fp, " %d ", &u);
	if (err == EOF){ 
	    FREE(colptr);
	    FREE(rowind);
	    return(0);
	} else if (err != 1) {
	    FREE(colptr);
	    FREE(rowind);
	    return(0);
	}
	rowind[i] = u - 1;
    }

    *E = zero; cuddRef(*E);

    for (j=0; j<ncol; j++) {
	v = j;
	cubey = one; cuddRef(cubey);
	for (nv = lny - 1; nv>=0; nv--) {
	    if (v & 1) {
		w = Cudd_addApply(dd, Cudd_addTimes, cubey, ly[nv]);
	    } else {
		w = Cudd_addApply(dd, Cudd_addTimes, cubey, lyn[nv]);
	    }
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		FREE(colptr);
		FREE(rowind);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd, cubey);
	    cubey = w;
	    v >>= 1;
	}
	for (i=colptr[j]; i<colptr[j+1]; i++) {
	    u = rowind[i];
	    err = fscanf(fp, " %lf ", &val);
	    if (err == EOF || err != 1){ 
		Cudd_RecursiveDeref(dd, cubey);
		FREE(colptr);
		FREE(rowind);
		return(0);
	    }
	    /* Create new Constant node if necessary */
	    cubex = cuddUniqueConst(dd, (CUDD_VALUE_TYPE) val);
	    if (cubex == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		FREE(colptr);
		FREE(rowind);
		return(0);
	    }
	    cuddRef(cubex);

	    for (nv = lnx - 1; nv>=0; nv--) {
		if (u & 1) {
		    w = Cudd_addApply(dd, Cudd_addTimes, cubex, lx[nv]);
		} else { 
		    w = Cudd_addApply(dd, Cudd_addTimes, cubex, lxn[nv]);
		}
		if (w == NULL) {
		    Cudd_RecursiveDeref(dd, cubey);
		    Cudd_RecursiveDeref(dd, cubex);
		    FREE(colptr);
		    FREE(rowind);
		    return(0);
		}
		cuddRef(w);
		Cudd_RecursiveDeref(dd, cubex);
		cubex = w;
		u >>= 1;
	    }
	    minterm1 = Cudd_addApply(dd, Cudd_addTimes, cubey, cubex);
	    if (minterm1 == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		Cudd_RecursiveDeref(dd, cubex);
		FREE(colptr);
		FREE(rowind);
		return(0);
	    }
	    cuddRef(minterm1);
	    Cudd_RecursiveDeref(dd, cubex);
	    w = Cudd_addApply(dd, Cudd_addPlus, *E, minterm1);
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		FREE(colptr);
		FREE(rowind);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd, minterm1);
	    Cudd_RecursiveDeref(dd, *E);
	    *E = w;
	}
	Cudd_RecursiveDeref(dd, cubey);
    }
    FREE(colptr);
    FREE(rowind);

    /* Read right-hand sides */
    for (j=0; j<nrhs; j++) {
	v = j + (1<< (lny-1));
	cubey = one; cuddRef(cubey);
	for (nv = lny - 1; nv>=0; nv--) {
	    if (v & 1) {
		w = Cudd_addApply(dd, Cudd_addTimes, cubey, ly[nv]);
	    } else {
		w = Cudd_addApply(dd, Cudd_addTimes, cubey, lyn[nv]);
	    }
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd, cubey);
	    cubey = w;
	    v >>= 1;
	}
	for (i=0; i<nrow; i++) {
	    u = i;
	    err = fscanf(fp, " %lf ", &val);
	    if (err == EOF || err != 1){ 
		Cudd_RecursiveDeref(dd, cubey);
		return(0);
	    }
	    /* Create new Constant node if necessary */
	    if (val == (double) 0.0) continue;
	    cubex = cuddUniqueConst(dd, (CUDD_VALUE_TYPE) val);
	    if (cubex == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		return(0);
	    }
	    cuddRef(cubex);

	    for (nv = lnx - 1; nv>=0; nv--) {
		if (u & 1) {
		   w = Cudd_addApply(dd, Cudd_addTimes, cubex, lx[nv]);
		} else { 
		    w = Cudd_addApply(dd, Cudd_addTimes, cubex, lxn[nv]);
		}
		if (w == NULL) {
		    Cudd_RecursiveDeref(dd, cubey);
		    Cudd_RecursiveDeref(dd, cubex);
		    return(0);
		}
		cuddRef(w);
		Cudd_RecursiveDeref(dd, cubex);
		cubex = w;
		u >>= 1;
	    }
	    minterm1 = Cudd_addApply(dd, Cudd_addTimes, cubey, cubex);
	    if (minterm1 == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		Cudd_RecursiveDeref(dd, cubex);
		return(0);
	    }
	    cuddRef(minterm1);
	    Cudd_RecursiveDeref(dd, cubex);
	    w = Cudd_addApply(dd, Cudd_addPlus, *E, minterm1);
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, cubey);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd, minterm1);
	    Cudd_RecursiveDeref(dd, *E);
	    *E = w;
	}
	Cudd_RecursiveDeref(dd, cubey);
    }

    return(1);

} /* end of Cudd_addHarwell */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


cuddInit.c
8575
/**
  @file 

  @ingroup cudd

  @brief Functions to initialize and shut down the %DD manager.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Creates a new DD manager.

  @details Initializes the table, the basic constants and the
  projection functions. If maxMemory is 0, Cudd_Init decides suitable
  values for the maximum size of the cache and for the limit for fast
  unique table growth based on the available memory.

  @return a pointer to the manager if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_Quit

*/
DdManager *
Cudd_Init(
  unsigned int numVars /**< initial number of %BDD variables (i.e., subtables) */,
  unsigned int numVarsZ /**< initial number of %ZDD variables (i.e., subtables) */,
  unsigned int numSlots /**< initial size of the unique tables */,
  unsigned int cacheSize /**< initial size of the cache */,
  size_t maxMemory /**< target maximum memory occupation */)
{
    DdManager *unique;
    int i,result;
    DdNode *one, *zero;
    unsigned int maxCacheSize;
    unsigned int looseUpTo;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    if (maxMemory == 0) {
	maxMemory = getSoftDataLimit();
    }
    looseUpTo = (unsigned int) ((maxMemory / sizeof(DdNode)) /
				DD_MAX_LOOSE_FRACTION);
    unique = cuddInitTable(numVars,numVarsZ,numSlots,looseUpTo);
    if (unique == NULL) return(NULL);
    unique->maxmem = (size_t) maxMemory / 10 * 9;
    maxCacheSize = (unsigned int) ((maxMemory / sizeof(DdCache)) /
				   DD_MAX_CACHE_FRACTION);
    result = cuddInitCache(unique,cacheSize,maxCacheSize);
    if (result == 0) return(NULL);

    saveHandler = MMoutOfMemory;
    MMoutOfMemory = unique->outOfMemCallback;
    unique->stash = ALLOC(char,(maxMemory / DD_STASH_FRACTION) + 4);
    MMoutOfMemory = saveHandler;
    if (unique->stash == NULL) {
	(void) fprintf(unique->err,"Unable to set aside memory\n");
    }

    /* Initialize constants. */
    unique->one = cuddUniqueConst(unique,1.0);
    if (unique->one == NULL) return(0);
    cuddRef(unique->one);
    unique->zero = cuddUniqueConst(unique,0.0);
    if (unique->zero == NULL) return(0);
    cuddRef(unique->zero);
#ifdef HAVE_IEEE_754
    if (DD_PLUS_INF_VAL != DD_PLUS_INF_VAL * 3 ||
	DD_PLUS_INF_VAL != DD_PLUS_INF_VAL / 3) {
	(void) fprintf(unique->err,"Warning: Crippled infinite values\n");
	(void) fprintf(unique->err,"Recompile without -DHAVE_IEEE_754\n");
    }
#endif
    unique->plusinfinity = cuddUniqueConst(unique,DD_PLUS_INF_VAL);
    if (unique->plusinfinity == NULL) return(0);
    cuddRef(unique->plusinfinity);
    unique->minusinfinity = cuddUniqueConst(unique,DD_MINUS_INF_VAL);
    if (unique->minusinfinity == NULL) return(0);
    cuddRef(unique->minusinfinity);
    unique->background = unique->zero;

    /* The logical zero is different from the CUDD_VALUE_TYPE zero! */
    one = unique->one;
    zero = Cudd_Not(one);
    /* Create the projection functions. */
    unique->vars = ALLOC(DdNodePtr,unique->maxSize);
    if (unique->vars == NULL) {
	unique->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < unique->size; i++) {
	unique->vars[i] = cuddUniqueInter(unique,i,one,zero);
	if (unique->vars[i] == NULL) return(0);
	cuddRef(unique->vars[i]);
    }

    if (unique->sizeZ)
	cuddZddInitUniv(unique);

    unique->memused += sizeof(DdNode *) * unique->maxSize;

    return(unique);

} /* end of Cudd_Init */


/**
  @brief Deletes resources associated with a %DD manager.

  @details Calling Cudd_Quit with a null pointer has no effect.

  @sideeffect None

  @see Cudd_Init

*/
void
Cudd_Quit(
  DdManager * unique /**< pointer to manager */)
{
    if (unique)
        cuddFreeTable(unique);

} /* end of Cudd_Quit */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Initializes the %ZDD universe.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddZddFreeUniv

*/
int
cuddZddInitUniv(
  DdManager * zdd)
{
    DdNode	*p, *res;
    int		i;

    zdd->univ = ALLOC(DdNodePtr, zdd->sizeZ);
    if (zdd->univ == NULL) {
	zdd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }

    res = DD_ONE(zdd);
    cuddRef(res);
    for (i = zdd->sizeZ - 1; i >= 0; i--) {
	unsigned int index = zdd->invpermZ[i];
	p = res;
	res = cuddUniqueInterZdd(zdd, index, p, p);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(zdd,p);
	    FREE(zdd->univ);
	    return(0);
	}
	cuddRef(res);
	cuddDeref(p);
	zdd->univ[i] = res;
    }

#ifdef DD_VERBOSE
    cuddZddP(zdd, zdd->univ[0]);
#endif

    return(1);

} /* end of cuddZddInitUniv */


/**
  @brief Frees the %ZDD universe.

  @sideeffect None

  @see cuddZddInitUniv

*/
void
cuddZddFreeUniv(
  DdManager * zdd)
{
    if (zdd->univ) {
	Cudd_RecursiveDerefZdd(zdd, zdd->univ[0]);
	FREE(zdd->univ);
    }

} /* end of cuddZddFreeUniv */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


cuddInt.h
47169
/**
  @file

  @ingroup cudd

  @brief Internal data structures of the CUDD package.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef CUDD_INT_H_
#define CUDD_INT_H_


/*---------------------------------------------------------------------------*/
/* Nested includes                                                           */
/*---------------------------------------------------------------------------*/

#include <math.h>
#include "config.h"
#include "st.h"
#include "mtr.h"
#include "epd.h"
#include "cudd.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define CUDD_VERSION		PACKAGE_VERSION

#define DD_MAXREF		((DdHalfWord) ~0)

#define DD_DEFAULT_RESIZE	10	/* how many extra variables */
					/* should be added when resizing */
#define DD_MEM_CHUNK		1022

/* These definitions work for CUDD_VALUE_TYPE == double */
#define DD_ONE_VAL		(1.0)
#define DD_ZERO_VAL		(0.0)
#define DD_EPSILON		(1.0e-12)

/* The definitions of +/- infinity in terms of HUGE_VAL work on
** the DECstations and on many other combinations of OS/compiler.
*/
#ifdef HAVE_IEEE_754
#  define DD_PLUS_INF_VAL	(HUGE_VAL)
#else
#  define DD_PLUS_INF_VAL	(10e301)
#  define DD_CRI_HI_MARK	(10e150)
#  define DD_CRI_LO_MARK	(-(DD_CRI_HI_MARK))
#endif
#define DD_MINUS_INF_VAL	(-(DD_PLUS_INF_VAL))

#define DD_NON_CONSTANT		((DdNode *) 1)	/* for Cudd_bddIteConstant */

/* Unique table and cache management constants. */
#define DD_MAX_SUBTABLE_DENSITY 4	/* tells when to resize a subtable */
/* gc when this percent are dead (measured w.r.t. slots, not keys)
** The first limit (LO) applies normally. The second limit applies when
** the package believes more space for the unique table (i.e., more dead
** nodes) would improve performance, and the unique table is not already
** too large. The third limit applies when memory is low.
*/
#define DD_GC_FRAC_LO		DD_MAX_SUBTABLE_DENSITY * 0.25
#define DD_GC_FRAC_HI		DD_MAX_SUBTABLE_DENSITY * 1.0
#define DD_GC_FRAC_MIN		0.2
#define DD_MIN_HIT		30	/* resize cache when hit ratio
					   above this percentage (default) */
#define DD_MAX_LOOSE_FRACTION	5 /* 1 / (max fraction of memory used for
				     unique table in fast growth mode) */
#define DD_MAX_CACHE_FRACTION	3 /* 1 / (max fraction of memory used for
				     computed table if resizing enabled) */
#define DD_STASH_FRACTION	64 /* 1 / (fraction of memory set
				      aside for emergencies) */
#define DD_MAX_CACHE_TO_SLOTS_RATIO 4 /* used to limit the cache size */

/* Variable ordering default parameter values. */
#define DD_SIFT_MAX_VAR		1000
#define DD_SIFT_MAX_SWAPS	2000000
#define DD_DEFAULT_RECOMB	0
#define DD_MAX_REORDER_GROWTH	1.2
#define DD_FIRST_REORDER	4004	/* 4 for the constants */
#define DD_DYN_RATIO		2	/* when to dynamically reorder */

/* Primes for cache hash functions. */
#define DD_P1			12582917
#define DD_P2			4256249
#define DD_P3			741457
#define DD_P4			1618033999

/* Cache tags for 3-operand operators.  These tags are stored in the
** least significant bits of the cache operand pointers according to
** the following scheme.  The tag consists of two hex digits.  Both digits
** must be even, so that they do not interfere with complementation bits.
** The least significant one is stored in Bits 3:1 of the f operand in the
** cache entry.  Bit 1 is always 1, so that we can differentiate
** three-operand operations from one- and two-operand operations.
** Therefore, the least significant digit is one of {2,6,a,e}.  The most
** significant digit occupies Bits 3:1 of the g operand in the cache
** entry.  It can by any even digit between 0 and e.  This gives a total
** of 5 bits for the tag proper, which means a maximum of 32 three-operand
** operations. */
#define DD_ADD_ITE_TAG				0x02
#define DD_BDD_AND_ABSTRACT_TAG			0x06
#define DD_BDD_XOR_EXIST_ABSTRACT_TAG		0x0a
#define DD_BDD_ITE_TAG				0x0e
#define DD_ADD_BDD_DO_INTERVAL_TAG		0x22
#define DD_BDD_CLIPPING_AND_ABSTRACT_UP_TAG	0x26
#define DD_BDD_CLIPPING_AND_ABSTRACT_DOWN_TAG	0x2a
#define DD_BDD_COMPOSE_RECUR_TAG		0x2e
#define DD_ADD_COMPOSE_RECUR_TAG		0x42
#define DD_ADD_NON_SIM_COMPOSE_TAG		0x46
#define DD_EQUIV_DC_TAG				0x4a
#define DD_ZDD_ITE_TAG				0x4e
#define DD_ADD_ITE_CONSTANT_TAG			0x62
#define DD_ADD_EVAL_CONST_TAG			0x66
#define DD_BDD_ITE_CONSTANT_TAG			0x6a
#define DD_ADD_OUT_SUM_TAG			0x6e
#define DD_BDD_LEQ_UNLESS_TAG			0x82
#define DD_ADD_TRIANGLE_TAG			0x86
#define DD_BDD_MAX_EXP_TAG			0x8a
#define DD_VARS_SYMM_BEFORE_TAG			0x8e
#define DD_VARS_SYMM_BETWEEN_TAG		0xa2

/* Generator constants. */
#define CUDD_GEN_CUBES 0
#define CUDD_GEN_PRIMES 1
#define CUDD_GEN_NODES 2
#define CUDD_GEN_ZDD_PATHS 3
#define CUDD_GEN_EMPTY 0
#define CUDD_GEN_NONEMPTY 1

/**
 ** @brief Maximum variable index.
 **
 ** @details CUDD_MAXINDEX is defined in such a way that on 32-bit and
 ** 64-bit machines one can cast an index to (int) without generating
 ** a negative number.
 */
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define CUDD_MAXINDEX		(((DdHalfWord) ~0) >> 1)
#else
#define CUDD_MAXINDEX		((DdHalfWord) ~0)
#endif

/**
 ** @brief The index of constant nodes.
 **
 ** @details This is a synonim for CUDD_MAXINDEX.
 */
#define CUDD_CONST_INDEX	CUDD_MAXINDEX

/**
 ** @brief Size of the random number generator shuffle table.
 */
#define STAB_SIZE 64

/**
 ** @brief Mask for periodic check of termination and timeout.
 **
 ** @see checkWhetherToGiveUp
 */
#define CUDD_CHECK_MASK 0x7ff

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
   @brief Type that is half the size of a pointer.
*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
typedef uint32_t DdHalfWord;
#else
typedef uint16_t DdHalfWord;
#endif

/**
 * @brief Signed integer that is the size of a pointer.
 *
 * @details The only platforms on which CUDD has been tested define
 * intptr_t and uintptr_t in inttypes.h and satisfy the condition
 *
 *     sizeof(intptr_t) == sizeof(uintptr_t) == sizeof(void *)
 *
 * Neither of these is guaranteed by the C standard.
 */
typedef intptr_t ptrint;

/**
 * @brief Unsigned integer that is the size of a pointer.
 *
 * @see ptrint
 */
typedef uintptr_t ptruint;

typedef struct DdChildren DdChildren;
typedef struct DdHook DdHook;
typedef struct DdSubtable DdSubtable;
typedef struct DdCache DdCache;
typedef struct DdLocalCacheItem DdLocalCacheItem;
typedef struct DdLocalCache DdLocalCache;
typedef struct DdHashItem DdHashItem;
typedef struct DdHashTable DdHashTable;
typedef struct Move Move;
typedef struct IndexKey IndexKey;
typedef struct DdQueueItem DdQueueItem;
typedef struct DdLevelQueue DdLevelQueue;

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief The two children of a non-terminal node.
 */
struct DdChildren {
    struct DdNode *T;	/**< then (true) child */
    struct DdNode *E;	/**< else (false) child */
};

/**
 * @brief Decision diagram node.
 */
struct DdNode {
    DdHalfWord index;		/**< variable index */
    DdHalfWord ref;		/**< reference count */
    DdNode *next;		/**< next pointer for unique table */
    union {
	CUDD_VALUE_TYPE value;	/**< for constant (terminal) nodes */
	DdChildren kids;	/**< for internal nodes */
    } type;			/**< terminal or internal */
};

/**
 * @brief CUDD generator.
 */
struct DdGen {
    DdManager	*manager;
    int		type;
    int		status;
    union {
	struct {
	    int			*cube;
	    CUDD_VALUE_TYPE	value;
	} cubes;
	struct {
	    int			*cube;
	    DdNode		*ub;
	} primes;
	struct {
	    int                 size;
	} nodes;
    } gen;
    struct {
	int	sp;
	DdNode	**stack;
    } stack;
    DdNode	*node;
};

/**
 ** @brief CUDD hook
 **
 ** Hooks in CUDD are functions that the application registers with the
 ** manager so that they are called at appropriate times. The functions
 ** are passed the manager as argument; they should return 1 if
 ** successful and 0 otherwise.
 */
struct DdHook {
    DD_HFP f;			/**< function to be called */
    struct DdHook *next;	/**< next element in the list */
};

/**
 *  @brief Generic local cache item.
 */
struct DdLocalCacheItem {
    DdNode *value;
#ifdef DD_CACHE_PROFILE
    ptrint count;
#endif
    DdNode *key[1];
};

/**
 *  @brief Local cache.
 */
struct DdLocalCache {
    DdLocalCacheItem *item;
    unsigned int itemsize;
    unsigned int keysize;
    unsigned int slots;
    int shift;
    double lookUps;
    double minHit;
    double hits;
    unsigned int maxslots;
    DdManager *manager;
    struct DdLocalCache *next;
};

/**
 *  @brief Local hash table item.
 */
struct DdHashItem {
    struct DdHashItem *next;	/**< collision list link */
    ptrint count;		/**< reference count of item */
    DdNode *value;		/**< value %DD */
    DdNode *key[1];		/**< key pointers */
};

/**
 * @brief Local hash table.
 */
struct DdHashTable {
    unsigned int keysize;	/**< number of pointers in the key */
    unsigned int itemsize;	/**< size of hash table item in bytes */
    DdHashItem **bucket;	/**< array of buckets */
    DdHashItem *nextFree;	/**< item free list */
    DdHashItem **memoryList;	/**< list of memory blocks for items */
    unsigned int numBuckets;	/**< number of buckets in array */
    int shift;			/**< shift used in hash function */
    unsigned int size;		/**< number of items stored in table */
    unsigned int maxsize;	/**< threshold for table resizing */
    DdManager *manager;		/**< %DD manager */
};

/**
 *  @brief Computed table.
 */
struct DdCache {
    DdNode *f,*g;		/**< DDs */
    ptruint h;			/**< either operator or %DD */
    DdNode *data;		/**< already constructed %DD */
#ifdef DD_CACHE_PROFILE
    ptrint count;		/**< statistical counter */
#endif
};

/**
 *  @brief Subtable for one index.
 */
struct DdSubtable {
    DdNode **nodelist;		/**< hash table */
    int shift;			/**< shift for hash function */
    unsigned int slots;		/**< size of the hash table */
    unsigned int keys;		/**< number of nodes stored in this table */
    unsigned int maxKeys;	/**< slots * DD_MAX_SUBTABLE_DENSITY */
    unsigned int dead;		/**< number of dead nodes in this table */
    unsigned int next;		/**< index of next variable in group */
    int bindVar;		/**< flag to bind this variable to its level */
    /* Fields for lazy sifting. */
    Cudd_VariableType varType;  /**< variable type (ps, ns, pi) */
    int pairIndex;              /**< corresponding variable index (ps <-> ns) */
    int varHandled;		/**< flag: 1 means variable is already handled */
    Cudd_LazyGroupType varToBeGrouped; /**< tells what grouping to apply */
};

/**
 *  @brief Specialized %DD symbol table.
 */
struct DdManager {
    /* Constants */
    DdNode sentinel;		/**< for collision lists */
    DdNode *one;		/**< constant 1 */
    DdNode *zero;		/**< constant 0 */
    DdNode *plusinfinity;	/**< plus infinity */
    DdNode *minusinfinity;	/**< minus infinity */
    DdNode *background;		/**< background value */
    /* Computed Table */
    DdCache *acache;		/**< address of allocated memory for cache */
    DdCache *cache;		/**< the cache-based computed table */
    unsigned int cacheSlots;	/**< total number of cache entries */
    int cacheShift;		/**< shift value for cache hash function */
    double cacheMisses;		/**< number of cache misses (since resizing) */
    double cacheHits;		/**< number of cache hits (since resizing) */
    double minHit;		/**< hit percentage above which to resize */
    int cacheSlack;		/**< slots still available for resizing */
    unsigned int maxCacheHard;	/**< hard limit for cache size */
    /* Unique Table */
    int size;			/**< number of unique subtables */
    int sizeZ;			/**< for %ZDD */
    int maxSize;		/**< max number of subtables before resizing */
    int maxSizeZ;		/**< for %ZDD */
    DdSubtable *subtables;	/**< array of unique subtables */
    DdSubtable *subtableZ;	/**< for %ZDD */
    DdSubtable constants;	/**< unique subtable for the constants */
    unsigned int slots;		/**< total number of hash buckets */
    unsigned int keys;		/**< total number of %BDD and %ADD nodes */
    unsigned int keysZ;		/**< total number of %ZDD nodes */
    unsigned int dead;		/**< total number of dead %BDD and %ADD nodes */
    unsigned int deadZ;		/**< total number of dead %ZDD nodes */
    unsigned int maxLive;	/**< maximum number of live nodes */
    unsigned int minDead;	/**< do not GC if fewer than these dead */
    int gcEnabled;		/**< gc is enabled */
    double gcFrac;		/**< gc when this fraction is dead */
    unsigned int looseUpTo;	/**< slow growth beyond this limit */
				/**< (measured w.r.t. slots, not keys) */
    unsigned int initSlots;	/**< initial size of a subtable */
    DdNode **stack;		/**< stack for iterative procedures */
    double allocated;		/**< number of nodes allocated */
				/**< (not during reordering) */
    double reclaimed;		/**< number of nodes brought back from the dead */
    int *perm;			/**< current variable perm. (index to level) */
    int *permZ;			/**< for %ZDD */
    int *invperm;		/**< current inv. var. perm. (level to index) */
    int *invpermZ;		/**< for %ZDD */
    DdNode **vars;		/**< projection functions */
    int *map;			/**< variable map for fast swap */
    DdNode **univ;		/**< %ZDD 1 for each variable */
    unsigned int isolated;	/**< isolated projection functions */
    unsigned int originalSize;	/**< used by lazy sifting */
    int linearSize;		/**< number of rows and columns of linear */
    ptruint *interact;		/**< interacting variable matrix */
    ptruint *linear;		/**< linear transform matrix */
    /* Memory Management */
    DdNode **memoryList;	/**< memory manager for symbol table */
    DdNode *nextFree;		/**< list of free nodes */
    char *stash;		/**< memory reserve */
#ifndef DD_NO_DEATH_ROW
    DdNode **deathRow;		/**< queue for dereferencing */
    int deathRowDepth;		/**< number of slots in the queue */
    int nextDead;		/**< index in the queue */
    unsigned deadMask;		/**< mask for circular index update */
#endif
    /* General Parameters */
    CUDD_VALUE_TYPE epsilon;	/**< tolerance on comparisons */
    /* Dynamic Reordering Parameters */
    int reordered;		/**< flag set at the end of reordering */
    unsigned int reorderings;	/**< number of calls to Cudd_ReduceHeap */
    unsigned int maxReorderings;/**< maximum number of calls to Cudd_ReduceHeap */
    int siftMaxVar;		/**< maximum number of vars sifted */
    int siftMaxSwap;		/**< maximum number of swaps per sifting */
    int ddTotalNumberSwapping;  /**< number of %BDD/%ADD swaps completed */
    int zddTotalNumberSwapping; /**< number of %ZDD swaps completed */
    int reordCycle;		/**< how often to apply alternate threshold */
    double maxGrowth;		/**< maximum growth during reordering */
    double maxGrowthAlt;	/**< alternate maximum growth for reordering */
    int autoDyn;		/**< automatic dynamic reordering flag (BDD) */
    int autoDynZ;		/**< automatic dynamic reordering flag (ZDD) */
    Cudd_ReorderingType autoMethod;  /**< default reordering method */
    Cudd_ReorderingType autoMethodZ; /**< default reordering method (ZDD) */
    int realign;		/**< realign %ZDD order after %BDD reordering */
    int realignZ;		/**< realign %BDD order after %ZDD reordering */
    unsigned int nextDyn;	/**< reorder if this size is reached */
    unsigned int countDead;	/**< if 0, count deads to trigger reordering */
    MtrNode *tree;		/**< variable group tree (BDD) */
    MtrNode *treeZ;		/**< variable group tree (ZDD) */
    Cudd_AggregationType groupcheck; /**< used during group sifting */
    int recomb;			/**< used during group sifting */
    int symmviolation;		/**< used during group sifting */
    int arcviolation;		/**< used during group sifting */
    int populationSize;		/**< population size for GA */
    int	numberXovers;		/**< number of crossovers for GA */
    unsigned int randomizeOrder; /**< perturb the next reordering threshold */
    DdLocalCache *localCaches;	/**< local caches currently in existence */
    void *hooks;		/**< application-specific field (used by vis) */
    DdHook *preGCHook;		/**< hooks to be called before GC */
    DdHook *postGCHook;		/**< hooks to be called after GC */
    DdHook *preReorderingHook;	/**< hooks to be called before reordering */
    DdHook *postReorderingHook;	/**< hooks to be called after reordering */
    FILE *out;			/**< stdout for this manager */
    FILE *err;			/**< stderr for this manager */
    Cudd_ErrorType errorCode;	/**< info on last error */
    unsigned long startTime;	/**< start time in milliseconds */
    unsigned long timeLimit;	/**< CPU time limit */
    DD_THFP terminationCallback; /**< termination callback */
    void * tcbArg;		/**< second argument passed to termination handler */
    DD_OOMFP outOfMemCallback;	/**< out-of-memory callback */
    DD_TOHFP timeoutHandler;	/**< timeout handler */
    void * tohArg;		/**< second argument passed to timeout handler */
    /* Statistical counters. */
    size_t memused;		/**< total memory allocated for the manager */
    size_t maxmem;		/**< target maximum memory */
    size_t maxmemhard;		/**< hard limit for maximum memory */
    int garbageCollections;	/**< number of garbage collections */
    unsigned long GCTime;	/**< total time spent in garbage collection */
    unsigned long reordTime;	/**< total time spent in reordering */
    double totCachehits;	/**< total number of cache hits */
    double totCacheMisses;	/**< total number of cache misses */
    double cachecollisions;	/**< number of cache collisions */
    double cacheinserts;	/**< number of cache insertions */
    double cacheLastInserts;	/**< insertions at the last cache resizing */
    double cachedeletions;	/**< number of deletions during garbage coll. */
    unsigned int peakLiveNodes;	/**< maximum number of live nodes */
    /* Random number generator. */
    int32_t cuddRand;		/**< state of the random number generator */
    int32_t cuddRand2;		/**< state of the random number generator */
    int32_t shuffleSelect;	/**< state of the random number generator */
    int32_t shuffleTable[STAB_SIZE]; /**< state of the random number generator */
#ifdef DD_STATS
    double nodesFreed;		/**< number of nodes returned to the free list */
    double nodesDropped;	/**< number of nodes killed by dereferencing */
    int	totalNISwaps;		/**< number of non-interacting (cheap) swaps */
    int extsymmcalls;		/**< number of calls to symmetry check fn */
    int extsymm;		/**< number of successful symmetry checks */
    int secdiffcalls;		/**< number of calls to second difference fn */
    int secdiff;		/**< number of successful second diff. checks */
    int secdiffmisfire;		/**< number of misfired second diff. checks */
    int tosses;			/**< number of coin tosses in annealing */
    int acceptances;		/**< number of acceptances in annealing */
    int totalShuffles;		/**< number of shuffles in exact reordering */
    int totalNumberLinearTr;	/**< number of linear transformations */
    int num_calls;		/**< should equal 2n-1 (n is the # of nodes) */
#endif
#ifdef DD_UNIQUE_PROFILE
    double uniqueLookUps;	/**< number of unique table lookups */
    double uniqueLinks;		/**< total distance traveled in coll. chains */
#endif
#ifdef DD_COUNT
    double recursiveCalls;	/**< number of recursive calls */
#ifdef DD_STATS
    double nextSample;		/**< when to write next line of stats */
#endif
    double swapSteps;		/**< number of elementary reordering steps */
#endif
#ifdef DD_DEBUG
    int addPermuteRecurHits;	/**< debug variable for variable permutation */
    int bddPermuteRecurHits;	/**< debug variable for variable permutation */
    int bddVectorComposeHits;	/**< debug variable for vector composition */
    int addVectorComposeHits;	/**< debug variable for vector composition */
    int addGeneralVectorComposeHits; /**< debug var. for vector composition */
    int enableExtraDebug;	/**< deposit a 1 here to enable more debugging */
#endif
};

/**
 *  @brief Reordering move record.
 */
struct Move {
    DdHalfWord x;
    DdHalfWord y;
    unsigned int flags;
    int size;
    struct Move *next;
};

/**
 *  @brief Used to sort variables for reordering.
 */
struct IndexKey {
    int index;
    int keys;
};

/**
 *  @brief Generic level queue item.
 */
struct DdQueueItem {
    struct DdQueueItem *next;
    struct DdQueueItem *cnext;
    void *key;
};

/**
 *  @brief Level queue.
 */
struct DdLevelQueue {
    void *first;
    DdQueueItem **last;
    DdQueueItem *freelist;
    DdQueueItem **buckets;
    int levels;
    int itemsize;
    int size;
    int maxsize;
    int numBuckets;
    int shift;
    DdManager *manager;
};

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/**
  @brief Adds node to the head of the free list.

  @details Does not deallocate memory chunks that become free.  This
  function is also used by the dynamic reordering functions.

  @sideeffect None

  @see cuddAllocNode cuddDynamicAllocNode cuddDeallocMove

*/
#define cuddDeallocNode(unique,node) \
    (node)->next = (unique)->nextFree; \
    (unique)->nextFree = node;

/**
  @brief Adds node to the head of the free list.

  @details Does not deallocate memory chunks that become free.  This
  function is also used by the dynamic reordering functions.

  @sideeffect None

  @see cuddDeallocNode cuddDynamicAllocNode

*/
#define cuddDeallocMove(unique,node) \
    ((DdNode *)(node))->ref = 0; \
    ((DdNode *)(node))->next = (unique)->nextFree; \
    (unique)->nextFree = (DdNode *)(node);


/**
  @brief Increases the reference count of a node, if it is not
  saturated.

  @details This being a macro, it is faster than Cudd_Ref, but it
  cannot be used in constructs like cuddRef(a = b()).

  @sideeffect none

  @see Cudd_Ref

*/
#define cuddRef(n) cuddSatInc(Cudd_Regular(n)->ref)


/**
  @brief Decreases the reference count of a node, if it is not
  saturated.

  @details It is primarily used in recursive procedures to decrease
  the ref count of a result node before returning it. This
  accomplishes the goal of removing the protection applied by a
  previous cuddRef. This being a macro, it is faster than Cudd_Deref,
  but it cannot be used in constructs like cuddDeref(a = b()).

  @sideeffect none

  @see Cudd_Deref

*/
#define cuddDeref(n) cuddSatDec(Cudd_Regular(n)->ref)


/**
  @brief Returns 1 if the node is a constant node.

  @details Returns 1 if the node is a constant node (rather than an
  internal node). All constant nodes have the same index
  (CUDD_CONST_INDEX). The pointer passed to Cudd_IsConstantInt may be either
  regular or complemented.

  @sideeffect none

  @see cuddIsConstant Cudd_IsConstant

*/
#define Cudd_IsConstantInt(node) ((Cudd_Regular(node))->index == CUDD_CONST_INDEX)


/**
  @brief Returns 1 if the node is a constant node.

  @details Returns 1 if the node is a constant node (rather than an
  internal node). All constant nodes have the same index
  (CUDD_CONST_INDEX). The pointer passed to cuddIsConstant must be regular.

  @sideeffect none

  @see Cudd_IsConstant Cudd_IsConstantInt

*/
#define cuddIsConstant(node) ((node)->index == CUDD_CONST_INDEX)


/**
  @brief Returns the then child of an internal node.

  @details If <code>node</code> is a constant node, the result is
  unpredictable.  The pointer passed to cuddT must be regular.

  @sideeffect none

  @see Cudd_T

*/
#define cuddT(node) ((node)->type.kids.T)


/**
  @brief Returns the else child of an internal node.

  @details If <code>node</code> is a constant node, the result is
  unpredictable.  The pointer passed to cuddE must be regular.

  @sideeffect none

  @see Cudd_E

*/
#define cuddE(node) ((node)->type.kids.E)


/**
  @brief Returns the value of a constant node.

  @details If <code>node</code> is an internal node, the result is
  unpredictable.  The pointer passed to cuddV must be regular.

  @sideeffect none

  @see Cudd_V

*/
#define cuddV(node) ((node)->type.value)


/**
  @brief Finds the current position of variable index in the
  order.

  @details This macro duplicates the functionality of Cudd_ReadPerm,
  but it does not check for out-of-bounds indices and it is more
  efficient.

  @sideeffect none

  @see Cudd_ReadPerm

*/
#define cuddI(dd,index) (((index)==CUDD_CONST_INDEX)?(int)(index):(dd)->perm[(index)])


/**
  @brief Finds the current position of %ZDD variable index in the
  order.

  @details This macro duplicates the functionality of
  Cudd_ReadPermZdd, but it does not check for out-of-bounds indices
  and it is more efficient.

  @sideeffect none

  @see Cudd_ReadPermZdd

*/
#define cuddIZ(dd,index) (((index)==CUDD_CONST_INDEX)?(int)(index):(dd)->permZ[(index)])


/**
  @brief Hash function for the unique table.

  @details 

  @sideeffect none

  @see ddCHash ddCHash2

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define ddHash(f,g,s) \
((((unsigned)(ptruint)(f) * DD_P1 + \
   (unsigned)(ptruint)(g)) * DD_P2) >> (s))
#else
#define ddHash(f,g,s) \
((((unsigned)(f) * DD_P1 + (unsigned)(g)) * DD_P2) >> (s))
#endif


/**
  @brief Hash function for the cache.

  @sideeffect none

  @see ddHash ddCHash2

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define ddCHash(o,f,g,h,s) \
((((((unsigned)(ptruint)(f) + (unsigned)(ptruint)(o)) * DD_P1 + \
    (unsigned)(ptruint)(g)) * DD_P2 + \
   (unsigned)(ptruint)(h)) * DD_P3) >> (s))
#else
#define ddCHash(o,f,g,h,s) \
((((((unsigned)(f) + (unsigned)(o)) * DD_P1 + (unsigned)(g)) * DD_P2 + \
   (unsigned)(h)) * DD_P3) >> (s))
#endif


/**
  @brief Hash function for the cache for functions with two operands.

  @sideeffect none

  @see ddHash ddCHash

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define ddCHash2(o,f,g,s) \
(((((unsigned)(ptruint)(f) + (unsigned)(ptruint)(o)) * DD_P1 + \
   (unsigned)(ptruint)(g)) * DD_P2) >> (s))
#else
#define ddCHash2(o,f,g,s) \
(((((unsigned)(f) + (unsigned)(o)) * DD_P1 + (unsigned)(g)) * DD_P2) >> (s))
#endif


/**
  @brief Clears the 4 least significant bits of a pointer.

  @sideeffect none

*/
#define cuddClean(p) ((DdNode *)((ptruint)(p) & ~ (ptruint) 0xf))


/**
  @brief Computes the minimum of two numbers.

  @sideeffect none

  @see ddMax

*/
#define ddMin(x,y) (((y) < (x)) ? (y) : (x))


/**
  @brief Computes the maximum of two numbers.

  @sideeffect none

  @see ddMin

*/
#define ddMax(x,y) (((y) > (x)) ? (y) : (x))


/**
  @brief Computes the absolute value of a number.

  @sideeffect none

*/
#define ddAbs(x) (((x)<0) ? -(x) : (x))


/**
  @brief Returns 1 if the absolute value of the difference of the two
  arguments x and y is less than e.

  @sideeffect none

*/
#define ddEqualVal(x,y,e) (ddAbs((x)-(y))<(e))


/**
  @brief Saturating increment operator.

  @details Saturation is only necessary on 32-bit machines, where the
  reference count is only 16-bit wide.

  @sideeffect none

  @see cuddSatDec

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define cuddSatInc(x) ((x)++)
#else
#define cuddSatInc(x) ((x) += (x) != (DdHalfWord)DD_MAXREF)
#endif


/**
  @brief Saturating decrement operator.

  @details Saturation is only necessary on 32-bit machines, where the
  reference count is only 16-bit wide.

  @sideeffect none

  @see cuddSatInc

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define cuddSatDec(x) ((x)--)
#else
#define cuddSatDec(x) ((x) -= (x) != (DdHalfWord)DD_MAXREF)
#endif


/**
  @brief Returns the constant 1 node.

  @sideeffect none

  @see DD_ZERO DD_PLUS_INFINITY DD_MINUS_INFINITY

*/
#define DD_ONE(dd)		((dd)->one)


/**
  @brief Returns the arithmetic 0 constant node.

  @details This is different from the logical zero. The latter is
  obtained by Cudd_Not(DD_ONE(dd)).

  @sideeffect none

  @see DD_ONE Cudd_Not DD_PLUS_INFINITY DD_MINUS_INFINITY

*/
#define DD_ZERO(dd) ((dd)->zero)


/**
  @brief Returns the plus infinity constant node.

  @sideeffect none

  @see DD_ONE DD_ZERO DD_MINUS_INFINITY

*/
#define DD_PLUS_INFINITY(dd) ((dd)->plusinfinity)


/**
  @brief Returns the minus infinity constant node.

  @sideeffect none

  @see DD_ONE DD_ZERO DD_PLUS_INFINITY

*/
#define DD_MINUS_INFINITY(dd) ((dd)->minusinfinity)


/**
  @brief Enforces DD_MINUS_INF_VAL <= x <= DD_PLUS_INF_VAL.

  @details Furthermore, if x <= DD_MINUS_INF_VAL/2, x is set to
  DD_MINUS_INF_VAL. Similarly, if DD_PLUS_INF_VAL/2 <= x, x is set to
  DD_PLUS_INF_VAL.  Normally this macro is a NOOP. However, if
  HAVE_IEEE_754 is not defined, it makes sure that a value does not
  get larger than infinity in absolute value, and once it gets to
  infinity, stays there.  If the value overflows before this macro is
  applied, no recovery is possible.

  @sideeffect none

*/
#ifdef HAVE_IEEE_754
#define cuddAdjust(x)
#else
#define cuddAdjust(x)		((x) = ((x) >= DD_CRI_HI_MARK) ? DD_PLUS_INF_VAL : (((x) <= DD_CRI_LO_MARK) ? DD_MINUS_INF_VAL : (x)))
#endif


/**
  @brief Outputs a line of stats.

  @details Outputs a line of stats if DD_COUNT and DD_STATS are
  defined. Increments the number of recursive calls if DD_COUNT is
  defined.

  @sideeffect None

*/
#ifdef DD_COUNT
#ifdef DD_STATS
#define statLine(dd)                                                    \
    do {                                                                \
        (dd)->recursiveCalls++;                                         \
        if ((dd)->recursiveCalls == (dd)->nextSample) {                 \
            (void) fprintf((dd)->err,                                   \
                           "@%.0f: %u nodes %u live %.0f dropped"       \
                           " %.0f reclaimed\n",                         \
                           (dd)->recursiveCalls, (dd)->keys,            \
                           (dd)->keys - (dd)->dead,                     \
                           (dd)->nodesDropped, (dd)->reclaimed);        \
            (dd)->nextSample += 250000;}                                \
    } while (0)
#else
#define statLine(dd) (dd)->recursiveCalls++
#endif
#else
#define statLine(dd)
#endif


/**
  @brief Checks for termination or timeout.
*/
#define checkWhetherToGiveUp(dd)                                        \
    do {                                                                \
        if (((int64_t) CUDD_CHECK_MASK & (int64_t) (dd)->cacheMisses) == 0) { \
            if ((dd)->terminationCallback != NULL &&                    \
                (dd)->terminationCallback((dd)->tcbArg)) {              \
                (dd)->errorCode = CUDD_TERMINATION;                     \
                return(NULL);                                           \
            }                                                           \
            if (util_cpu_time() - (dd)->startTime > (dd)->timeLimit) {  \
                (dd)->errorCode = CUDD_TIMEOUT_EXPIRED;                 \
                return(NULL);                                           \
            }                                                           \
        }                                                               \
    } while (0)


/** \cond */

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

extern DdNode * cuddAddExistAbstractRecur(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * cuddAddUnivAbstractRecur(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * cuddAddOrAbstractRecur(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * cuddAddApplyRecur(DdManager *dd, DdNode * (*)(DdManager *, DdNode **, DdNode **), DdNode *f, DdNode *g);
extern DdNode * cuddAddMonadicApplyRecur(DdManager * dd, DdNode * (*op)(DdManager *, DdNode *), DdNode * f);
extern DdNode * cuddAddScalarInverseRecur(DdManager *dd, DdNode *f, DdNode *epsilon);
extern DdNode * cuddAddIteRecur(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * cuddAddCmplRecur(DdManager *dd, DdNode *f);
extern DdNode * cuddAddNegateRecur(DdManager *dd, DdNode *f);
extern DdNode * cuddAddRoundOffRecur(DdManager *dd, DdNode *f, double trunc);
extern DdNode * cuddUnderApprox(DdManager *dd, DdNode *f, int numVars, int threshold, int safe, double quality);
extern DdNode * cuddRemapUnderApprox(DdManager *dd, DdNode *f, int numVars, int threshold, double quality);
extern DdNode * cuddBiasedUnderApprox(DdManager *dd, DdNode *f, DdNode *b, int numVars, int threshold, double quality1, double quality0);
extern DdNode * cuddBddAndAbstractRecur(DdManager *manager, DdNode *f, DdNode *g, DdNode *cube);
extern int cuddAnnealing(DdManager *table, int lower, int upper);
extern DdNode * cuddBddExistAbstractRecur(DdManager *manager, DdNode *f, DdNode *cube);
extern DdNode * cuddBddXorExistAbstractRecur(DdManager *manager, DdNode *f, DdNode *g, DdNode *cube);
extern DdNode * cuddBddBooleanDiffRecur(DdManager *manager, DdNode *f, DdNode *var);
extern DdNode * cuddBddIteRecur(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * cuddBddIntersectRecur(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddBddAndRecur(DdManager *manager, DdNode *f, DdNode *g);
extern DdNode * cuddBddXorRecur(DdManager *manager, DdNode *f, DdNode *g);
extern DdNode * cuddBddTransfer(DdManager *ddS, DdManager *ddD, DdNode *f);
extern DdNode * cuddAddBddDoPattern(DdManager *dd, DdNode *f);
extern int cuddInitCache(DdManager *unique, unsigned int cacheSize, unsigned int maxCacheSize);
extern void cuddCacheInsert(DdManager *table, ptruint op, DdNode *f, DdNode *g, DdNode *h, DdNode *data);
extern void cuddCacheInsert2(DdManager *table, DdNode * (*)(DdManager *, DdNode *, DdNode *), DdNode *f, DdNode *g, DdNode *data);
extern void cuddCacheInsert1(DdManager *table, DdNode * (*)(DdManager *, DdNode *), DdNode *f, DdNode *data);
extern DdNode * cuddCacheLookup(DdManager *table, ptruint op, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * cuddCacheLookupZdd(DdManager *table, ptruint op, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * cuddCacheLookup2(DdManager *table, DdNode * (*)(DdManager *, DdNode *, DdNode *), DdNode *f, DdNode *g);
extern DdNode * cuddCacheLookup1(DdManager *table, DdNode * (*)(DdManager *, DdNode *), DdNode *f);
extern DdNode * cuddCacheLookup2Zdd(DdManager *table, DdNode * (*)(DdManager *, DdNode *, DdNode *), DdNode *f, DdNode *g);
extern DdNode * cuddCacheLookup1Zdd(DdManager *table, DdNode * (*)(DdManager *, DdNode *), DdNode *f);
extern DdNode * cuddConstantLookup(DdManager *table, ptruint op, DdNode *f, DdNode *g, DdNode *h);
extern int cuddCacheProfile(DdManager *table, FILE *fp);
extern void cuddCacheResize(DdManager *table);
extern void cuddCacheFlush(DdManager *table);
extern int cuddComputeFloorLog2(unsigned int value);
extern int cuddHeapProfile(DdManager *dd);
extern void cuddPrintNode(DdNode *f, FILE *fp);
extern void cuddPrintVarGroups(DdManager * dd, MtrNode * root, int zdd, int silent);
extern DdNode * cuddBddClippingAnd(DdManager *dd, DdNode *f, DdNode *g, int maxDepth, int direction);
extern DdNode * cuddBddClippingAndAbstract(DdManager *dd, DdNode *f, DdNode *g, DdNode *cube, int maxDepth, int direction);
extern void cuddGetBranches(DdNode *g, DdNode **g1, DdNode **g0);
extern DdNode * cuddCofactorRecur(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddBddComposeRecur(DdManager *dd, DdNode *f, DdNode *g, DdNode *proj);
extern DdNode * cuddAddComposeRecur(DdManager *dd, DdNode *f, DdNode *g, DdNode *proj);
extern int cuddExact(DdManager *table, int lower, int upper);
extern DdNode * cuddBddConstrainRecur(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * cuddBddRestrictRecur(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * cuddBddNPAndRecur(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * cuddAddConstrainRecur(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * cuddAddRestrictRecur(DdManager *dd, DdNode *f, DdNode *c);
extern DdNode * cuddBddLICompaction(DdManager *dd, DdNode *f, DdNode *c);
extern int cuddGa(DdManager *table, int lower, int upper);
extern int cuddTreeSifting(DdManager *table, Cudd_ReorderingType method);
extern int cuddZddInitUniv(DdManager *zdd);
extern void cuddZddFreeUniv(DdManager *zdd);
extern void cuddSetInteract(DdManager *table, int x, int y);
extern int cuddTestInteract(DdManager *table, int x, int y);
extern int cuddInitInteract(DdManager *table);
extern DdLocalCache * cuddLocalCacheInit(DdManager *manager, unsigned int keySize, unsigned int cacheSize, unsigned int maxCacheSize);
extern void cuddLocalCacheQuit(DdLocalCache *cache);
extern void cuddLocalCacheInsert(DdLocalCache *cache, DdNodePtr *key, DdNode *value);
extern DdNode * cuddLocalCacheLookup(DdLocalCache *cache, DdNodePtr *key);
extern void cuddLocalCacheClearDead(DdManager *manager);
extern int cuddIsInDeathRow(DdManager *dd, DdNode *f);
extern int cuddTimesInDeathRow(DdManager *dd, DdNode *f);
extern void cuddLocalCacheClearAll(DdManager *manager);
#ifdef DD_CACHE_PROFILE
extern int cuddLocalCacheProfile(DdLocalCache *cache);
#endif
extern DdHashTable * cuddHashTableInit(DdManager *manager, unsigned int keySize, unsigned int initSize);
extern void cuddHashTableQuit(DdHashTable *hash);
extern void cuddHashTableGenericQuit(DdHashTable *hash);
extern int cuddHashTableInsert(DdHashTable *hash, DdNodePtr *key, DdNode *value, ptrint count);
extern DdNode * cuddHashTableLookup(DdHashTable *hash, DdNodePtr *key);
extern int cuddHashTableInsert1(DdHashTable *hash, DdNode *f, DdNode *value, ptrint count);
extern DdNode * cuddHashTableLookup1(DdHashTable *hash, DdNode *f);
extern int cuddHashTableInsert2(DdHashTable *hash, DdNode *f, DdNode *g, DdNode *value, ptrint count);
extern DdNode * cuddHashTableLookup2(DdHashTable *hash, DdNode *f, DdNode *g);
extern int cuddHashTableInsert3(DdHashTable *hash, DdNode *f, DdNode *g, DdNode *h, DdNode *value, ptrint count);
extern DdNode * cuddHashTableLookup3(DdHashTable *hash, DdNode *f, DdNode *g, DdNode *h);
extern int cuddHashTableGenericInsert(DdHashTable * hash, DdNode * f, void * value);
extern void * cuddHashTableGenericLookup(DdHashTable * hash, DdNode * f);
extern DdLevelQueue * cuddLevelQueueInit(int levels, int itemSize, int numBuckets, DdManager * manager);
extern void cuddLevelQueueQuit(DdLevelQueue *queue);
extern void * cuddLevelQueueFirst(DdLevelQueue * queue, void * key, int  level);
extern void * cuddLevelQueueEnqueue(DdLevelQueue *queue, void *key, int level);
extern void cuddLevelQueueDequeue(DdLevelQueue *queue, int level);
extern int cuddLinearAndSifting(DdManager *table, int lower, int upper);
extern int cuddLinearInPlace(DdManager * table, int  x, int  y);
extern void cuddUpdateInteractionMatrix(DdManager * table, int  xindex, int  yindex);
extern int cuddInitLinear(DdManager *table);
extern int cuddResizeLinear(DdManager *table);
extern DdNode * cuddBddLiteralSetIntersectionRecur(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddCProjectionRecur(DdManager *dd, DdNode *R, DdNode *Y, DdNode *Ysupp);
extern DdNode * cuddBddClosestCube(DdManager *dd, DdNode *f, DdNode *g, CUDD_VALUE_TYPE bound);
extern void cuddReclaim(DdManager *table, DdNode *n);
extern void cuddReclaimZdd(DdManager *table, DdNode *n);
extern void cuddClearDeathRow(DdManager *table);
extern void cuddShrinkDeathRow(DdManager *table);
extern DdNode * cuddDynamicAllocNode(DdManager *table);
extern int cuddSifting(DdManager *table, int lower, int upper);
extern int cuddSwapping(DdManager *table, int lower, int upper, Cudd_ReorderingType heuristic);
extern int cuddNextHigh(DdManager *table, int x);
extern int cuddNextLow(DdManager *table, int x);
extern int cuddSwapInPlace(DdManager *table, int x, int y);
extern int cuddBddAlignToZdd(DdManager *table);
extern DdNode * cuddBddMakePrime(DdManager *dd, DdNode *cube, DdNode *f);
extern DdNode * cuddSolveEqnRecur(DdManager *bdd, DdNode *F, DdNode *Y, DdNode **G, int n, int *yIndex, int i);
extern DdNode * cuddVerifySol(DdManager *bdd, DdNode *F, DdNode **G, int *yIndex, int n);
#ifdef ST_H_
extern DdNode* cuddSplitSetRecur(DdManager *manager, st_table *mtable, int *varSeen, DdNode *p, double n, double max, int index);
#endif
extern DdNode * cuddSubsetHeavyBranch(DdManager *dd, DdNode *f, int numVars, int threshold);
extern DdNode * cuddSubsetShortPaths(DdManager *dd, DdNode *f, int numVars, int threshold, int hardlimit);
extern int cuddSymmCheck(DdManager *table, int x, int y);
extern int cuddSymmSifting(DdManager *table, int lower, int upper);
extern int cuddSymmSiftingConv(DdManager *table, int lower, int upper);
extern DdNode * cuddAllocNode(DdManager *unique);
extern DdManager * cuddInitTable(unsigned int numVars, unsigned int numVarsZ, unsigned int numSlots, unsigned int looseUpTo);
extern void cuddFreeTable(DdManager *unique);
extern int cuddGarbageCollect(DdManager *unique, int clearCache);
extern DdNode * cuddZddGetNode(DdManager *zdd, int id, DdNode *T, DdNode *E);
extern DdNode * cuddZddGetNodeIVO(DdManager *dd, int index, DdNode *g, DdNode *h);
extern DdNode * cuddUniqueInter(DdManager *unique, int index, DdNode *T, DdNode *E);
extern DdNode * cuddUniqueInterIVO(DdManager *unique, int index, DdNode *T, DdNode *E);
extern DdNode * cuddUniqueInterZdd(DdManager *unique, int index, DdNode *T, DdNode *E);
extern DdNode * cuddUniqueConst(DdManager *unique, CUDD_VALUE_TYPE value);
extern void cuddRehash(DdManager *unique, int i);
extern void cuddShrinkSubtable(DdManager *unique, int i);
extern int cuddInsertSubtables(DdManager *unique, int n, int level);
extern int cuddDestroySubtables(DdManager *unique, int n);
extern int cuddResizeTableZdd(DdManager *unique, int index);
extern void cuddSlowTableGrowth(DdManager *unique);
extern int cuddP(DdManager *dd, DdNode *f);
#ifdef ST_H_
extern enum st_retval cuddStCountfree(void *key, void *value, void *arg);
extern int cuddCollectNodes(DdNode *f, st_table *visited);
#endif
extern DdNodePtr * cuddNodeArray(DdNode *f, int *n);
extern int cuddWindowReorder(DdManager *table, int low, int high, Cudd_ReorderingType submethod);
extern DdNode * cuddZddProduct(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddZddUnateProduct(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddZddWeakDiv(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddZddWeakDivF(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddZddDivide(DdManager *dd, DdNode *f, DdNode *g);
extern DdNode * cuddZddDivideF(DdManager *dd, DdNode *f, DdNode *g);
extern int cuddZddGetCofactors3(DdManager *dd, DdNode *f, int v, DdNode **f1, DdNode **f0, DdNode **fd);
extern int cuddZddGetCofactors2(DdManager *dd, DdNode *f, int v, DdNode **f1, DdNode **f0);
extern DdNode * cuddZddComplement(DdManager *dd, DdNode *node);
extern int cuddZddGetPosVarIndex(DdManager * dd, int index);
extern int cuddZddGetNegVarIndex(DdManager * dd, int index);
extern int cuddZddGetPosVarLevel(DdManager * dd, int index);
extern int cuddZddGetNegVarLevel(DdManager * dd, int index);
extern int cuddZddTreeSifting(DdManager *table, Cudd_ReorderingType method);
extern DdNode * cuddZddIsop(DdManager *dd, DdNode *L, DdNode *U, DdNode **zdd_I);
extern DdNode * cuddBddIsop(DdManager *dd, DdNode *L, DdNode *U);
extern DdNode * cuddMakeBddFromZddCover(DdManager *dd, DdNode *node);
extern int cuddZddLinearSifting(DdManager *table, int lower, int upper);
extern int cuddZddAlignToBdd(DdManager *table);
extern int cuddZddNextHigh(DdManager *table, int x);
extern int cuddZddNextLow(DdManager *table, int x);
extern int cuddZddUniqueCompare(void const *ptr_x, void const *ptr_y);
extern int cuddZddSwapInPlace(DdManager *table, int x, int y);
extern int cuddZddSwapping(DdManager *table, int lower, int upper, Cudd_ReorderingType heuristic);
extern int cuddZddSifting(DdManager *table, int lower, int upper);
extern DdNode * cuddZddIte(DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
extern DdNode * cuddZddUnion(DdManager *zdd, DdNode *P, DdNode *Q);
extern DdNode * cuddZddIntersect(DdManager *zdd, DdNode *P, DdNode *Q);
extern DdNode * cuddZddDiff(DdManager *zdd, DdNode *P, DdNode *Q);
extern DdNode * cuddZddChangeAux(DdManager *zdd, DdNode *P, DdNode *zvar);
extern DdNode * cuddZddSubset1(DdManager *dd, DdNode *P, int var);
extern DdNode * cuddZddSubset0(DdManager *dd, DdNode *P, int var);
extern DdNode * cuddZddChange(DdManager *dd, DdNode *P, int var);
extern int cuddZddSymmCheck(DdManager *table, int x, int y);
extern int cuddZddSymmSifting(DdManager *table, int lower, int upper);
extern int cuddZddSymmSiftingConv(DdManager *table, int lower, int upper);
extern int cuddZddP(DdManager *zdd, DdNode *f);

#ifdef __cplusplus
} /* end of extern "C" */
#endif

/** \endcond */

#endif /* CUDD_INT_H_ */

cuddInteract.c
10989
/**
  @file

  @ingroup cudd

  @brief Functions to manipulate the variable interaction matrix.

  @details The interaction matrix tells whether two variables are both
  in the support of some function of the %DD. The main use of the
  interaction matrix is in the in-place swapping. Indeed, if two
  variables do not interact, there is no arc connecting the two
  layers; therefore, the swap can be performed in constant time,
  without scanning the subtables. Another use of the interaction
  matrix is in the computation of the lower bounds for
  sifting. Finally, the interaction matrix can be used to speed up
  aggregation checks in symmetric and group sifting.<p>
  The computation of the interaction matrix is done with a series of
  depth-first searches. The searches start from those nodes that have
  only external references. The matrix is stored as a packed array of
  bits; since it is symmetric, only the upper triangle is kept in
  memory.  As a final remark, we note that there may be variables that
  do interact, but that for a given variable order have no arc
  connecting their layers when they are adjacent.  For instance, in
  ite(a,b,c) with the order a<b<c, b and c interact, but are not
  connected.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#if SIZEOF_VOID_P == 8
#define BPL 64
#define LOGBPL 6
#else
#define BPL 32
#define LOGBPL 5
#endif

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void ddSuppInteract (DdNode *f, char *support);
static void ddClearLocal (DdNode *f);
static void ddUpdateInteract (DdManager *table, char *support);
static void ddClearGlobal (DdManager *table);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Set interaction matrix entries.

  @details Given a pair of variables 0 <= x < y < table->size,
  sets the corresponding bit of the interaction matrix to 1.

  @sideeffect None

*/
void
cuddSetInteract(
  DdManager * table,
  int  x,
  int  y)
{
    ptruint posn, word, bit;

#ifdef DD_DEBUG
    assert(x < y);
    assert(y < table->size);
    assert(x >= 0);
#endif

    posn = (((((ptruint)table->size << 1) - x - 3) * x) >> 1) + y - 1;
    word = posn >> LOGBPL;
    bit = posn & (BPL-1);
    table->interact[word] |= ((ptruint) 1) << bit;

} /* end of cuddSetInteract */


/**
  @brief Test interaction matrix entries.

  @details Given a pair of variables 0 <= x < y < table->size,
  tests whether the corresponding bit of the interaction matrix is 1.
  Returns the value of the bit.

  @sideeffect None

*/
int
cuddTestInteract(
  DdManager * table,
  int  x,
  int  y)
{
  ptruint posn, word, bit;
  int result;

    if (x > y) {
	int tmp = x;
	x = y;
	y = tmp;
    }
#ifdef DD_DEBUG
    assert(x < y);
    assert(y < table->size);
    assert(x >= 0);
#endif

    posn = (((((ptruint)table->size << 1) - x - 3) * x) >> 1) + y - 1;
    word = posn >> LOGBPL;
    bit = posn & (BPL-1);
    result = (table->interact[word] >> bit) & (ptruint) 1;
    return(result);

} /* end of cuddTestInteract */


/**
  @brief Initializes the interaction matrix.

  @details The interaction matrix is implemented as a bit vector
  storing the upper triangle of the symmetric interaction matrix. The
  bit vector is kept in an array of ptruints. The computation is based
  on a series of depth-first searches, one for each root of the
  DAG. Two flags are needed: The local visited flag uses the LSB of
  the then pointer. The global visited flag uses the LSB of the next
  pointer.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddInitInteract(
  DdManager * table)
{
    unsigned int i;
    int j;
    ptruint words;
    ptruint *interact;
    char *support;
    DdNode *f;
    DdNode *sentinel = &(table->sentinel);
    DdNodePtr *nodelist;
    int slots;
    ptruint n = (ptruint) table->size;

    words = ((n * (n-1)) >> (1 + LOGBPL)) + 1;
    table->interact = interact = ALLOC(ptruint,words);
    if (interact == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (i = 0; i < words; i++) {
	interact[i] = 0;
    }

    support = ALLOC(char,n);
    if (support == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	FREE(interact);
	return(0);
    }
    for (i = 0; i < n; i++) {
        support[i] = 0;
    }

    for (i = 0; i < n; i++) {
	nodelist = table->subtables[i].nodelist;
	slots = table->subtables[i].slots;
	for (j = 0; j < slots; j++) {
	    f = nodelist[j];
	    while (f != sentinel) {
		/* A node is a root of the DAG if it cannot be
		** reached by nodes above it. If a node was never
		** reached during the previous depth-first searches,
		** then it is a root, and we start a new depth-first
		** search from it.
		*/
		if (!Cudd_IsComplement(f->next)) {
		    ddSuppInteract(f,support);
		    ddClearLocal(f);
		    ddUpdateInteract(table,support);
		}
		f = Cudd_Regular(f->next);
	    }
	}
    }
    ddClearGlobal(table);

    FREE(support);
    return(1);

} /* end of cuddInitInteract */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Find the support of f.

  @details Performs a DFS from f. Uses the LSB of the then pointer
  as visited flag.

  @sideeffect Accumulates in support the variables on which f depends.

*/
static void
ddSuppInteract(
  DdNode * f,
  char * support)
{
    if (cuddIsConstant(f) || Cudd_IsComplement(cuddT(f))) {
	return;
    }

    support[f->index] = 1;
    ddSuppInteract(cuddT(f),support);
    ddSuppInteract(Cudd_Regular(cuddE(f)),support);
    /* mark as visited */
    cuddT(f) = Cudd_Complement(cuddT(f));
    f->next = Cudd_Complement(f->next);
    return;

} /* end of ddSuppInteract */


/**
  @brief Performs a DFS from f, clearing the LSB of the then pointers.

  @sideeffect None

*/
static void
ddClearLocal(
  DdNode * f)
{
    if (cuddIsConstant(f) || !Cudd_IsComplement(cuddT(f))) {
	return;
    }
    /* clear visited flag */
    cuddT(f) = Cudd_Regular(cuddT(f));
    ddClearLocal(cuddT(f));
    ddClearLocal(Cudd_Regular(cuddE(f)));
    return;

} /* end of ddClearLocal */


/**
  @brief Marks as interacting all pairs of variables that appear in
  support.

  @details If support[i == support[j] == 1, sets the (i,j) entry
  of the interaction matrix to 1.]

  @sideeffect Clears support.

*/
static void
ddUpdateInteract(
  DdManager * table,
  char * support)
{
    int i,j;
    int n = table->size;

    for (i = 0; i < n-1; i++) {
	if (support[i] == 1) {
            support[i] = 0;
	    for (j = i+1; j < n; j++) {
		if (support[j] == 1) {
		    cuddSetInteract(table,i,j);
		}
	    }
	}
    }
    support[n-1] = 0;

} /* end of ddUpdateInteract */


/**
  @brief Scans the %DD and clears the LSB of the next pointers.

  @details The LSB of the next pointers are used as markers to tell
  whether a node was reached by at least one DFS. Once the interaction
  matrix is built, these flags are reset.

  @sideeffect None

*/
static void
ddClearGlobal(
  DdManager * table)
{
    int i,j;
    DdNode *f;
    DdNode *sentinel = &(table->sentinel);
    DdNodePtr *nodelist;
    int slots;

    for (i = 0; i < table->size; i++) {
	nodelist = table->subtables[i].nodelist;
	slots = table->subtables[i].slots;
	for (j = 0; j < slots; j++) {
	    f = nodelist[j];
	    while (f != sentinel) {
		f->next = Cudd_Regular(f->next);
		f = f->next;
	    }
	}
    }

} /* end of ddClearGlobal */


cuddLCache.c
34453
/**
  @file

  @ingroup cudd

  @brief Functions for local caches.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define DD_MAX_HASHTABLE_DENSITY 2	/* tells when to resize a table */

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/**
  @brief Computes hash function for keys of one operand.

  @sideeffect None

  @see ddLCHash3 ddLCHash

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define ddLCHash1(f,shift) \
(((unsigned)(ptruint)(f) * DD_P1) >> (shift))
#else
#define ddLCHash1(f,shift) \
(((unsigned)(f) * DD_P1) >> (shift))
#endif


/**
  @brief Computes hash function for keys of two operands.

  @sideeffect None

  @see ddLCHash3 ddLCHash

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define ddLCHash2(f,g,shift) \
((((unsigned)(ptruint)(f) * DD_P1 + \
   (unsigned)(ptruint)(g)) * DD_P2) >> (shift))
#else
#define ddLCHash2(f,g,shift) \
((((unsigned)(f) * DD_P1 + (unsigned)(g)) * DD_P2) >> (shift))
#endif


/**
  @brief Computes hash function for keys of three operands.

  @sideeffect None

  @see ddLCHash2 ddLCHash

*/
#define ddLCHash3(f,g,h,shift) ddCHash2(f,g,h,shift)


/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void cuddLocalCacheResize (DdLocalCache *cache);
static unsigned int ddLCHash (DdNodePtr *key, unsigned int keysize, int shift);
static void cuddLocalCacheAddToList (DdLocalCache *cache);
static void cuddLocalCacheRemoveFromList (DdLocalCache *cache);
static int cuddHashTableResize (DdHashTable *hash);
static DdHashItem * cuddHashTableAlloc (DdHashTable *hash);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Initializes a local computed table.

  @return a pointer the the new local cache in case of success; NULL
  otherwise.

  @sideeffect None

  @see cuddInitCache

*/
DdLocalCache *
cuddLocalCacheInit(
  DdManager * manager /**< manager */,
  unsigned int  keySize /**< size of the key (number of operands) */,
  unsigned int  cacheSize /**< Initial size of the cache */,
  unsigned int  maxCacheSize /**< Size of the cache beyond which no resizing occurs */)
{
    DdLocalCache *cache;
    int logSize;

    cache = ALLOC(DdLocalCache,1);
    if (cache == NULL) {
	manager->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    cache->manager = manager;
    cache->keysize = keySize;
    cache->itemsize = (keySize + 1) * sizeof(DdNode *);
#ifdef DD_CACHE_PROFILE
    cache->itemsize += sizeof(ptrint);
#endif
    logSize = cuddComputeFloorLog2(ddMax(cacheSize,manager->slots/2));
    cacheSize = 1U << logSize;
    cache->item = (DdLocalCacheItem *)
	ALLOC(char, cacheSize * cache->itemsize);
    if (cache->item == NULL) {
	manager->errorCode = CUDD_MEMORY_OUT;
	FREE(cache);
	return(NULL);
    }
    cache->slots = cacheSize;
    cache->shift = sizeof(int) * 8 - logSize;
    cache->maxslots = ddMin(maxCacheSize,manager->slots);
    cache->minHit = manager->minHit;
    /* Initialize to avoid division by 0 and immediate resizing. */
    cache->lookUps = (double) (int) (cacheSize * cache->minHit + 1);
    cache->hits = 0;
    manager->memused += cacheSize * cache->itemsize + sizeof(DdLocalCache);

    /* Initialize the cache. */
    memset(cache->item, 0, cacheSize * cache->itemsize);

    /* Add to manager's list of local caches for GC. */
    cuddLocalCacheAddToList(cache);

    return(cache);

} /* end of cuddLocalCacheInit */


/**
  @brief Shuts down a local computed table.

  @sideeffect None

  @see cuddLocalCacheInit

*/
void
cuddLocalCacheQuit(
  DdLocalCache * cache /**< cache to be shut down */)
{
    cache->manager->memused -=
	cache->slots * cache->itemsize + sizeof(DdLocalCache);
    cuddLocalCacheRemoveFromList(cache);
    FREE(cache->item);
    FREE(cache);

    return;

} /* end of cuddLocalCacheQuit */


/**
  @brief Inserts a result in a local cache.

  @sideeffect None

*/
void
cuddLocalCacheInsert(
  DdLocalCache * cache,
  DdNodePtr * key,
  DdNode * value)
{
    unsigned int posn;
    DdLocalCacheItem *entry;

    posn = ddLCHash(key,cache->keysize,cache->shift);
    entry = (DdLocalCacheItem *) ((char *) cache->item +
				  posn * cache->itemsize);
    memcpy(entry->key,key,cache->keysize * sizeof(DdNode *));
    entry->value = value;
#ifdef DD_CACHE_PROFILE
    entry->count++;
#endif

} /* end of cuddLocalCacheInsert */


/**
  @brief Looks up in a local cache.

  @return the result if found; it returns NULL if no result is found.

  @sideeffect None

*/
DdNode *
cuddLocalCacheLookup(
  DdLocalCache * cache,
  DdNodePtr * key)
{
    unsigned int posn;
    DdLocalCacheItem *entry;
    DdNode *value;

    cache->lookUps++;
    posn = ddLCHash(key,cache->keysize,cache->shift);
    entry = (DdLocalCacheItem *) ((char *) cache->item +
				  posn * cache->itemsize);
    if (entry->value != NULL &&
	memcmp(key,entry->key,cache->keysize*sizeof(DdNode *)) == 0) {
	cache->hits++;
	value = Cudd_Regular(entry->value);
	if (value->ref == 0) {
	    cuddReclaim(cache->manager,value);
	}
	return(entry->value);
    }

    /* Cache miss: decide whether to resize */

    if (cache->slots < cache->maxslots &&
	cache->hits > cache->lookUps * cache->minHit) {
	cuddLocalCacheResize(cache);
    }

    return(NULL);

} /* end of cuddLocalCacheLookup */


/**
  @brief Clears the dead entries of the local caches of a manager.

  @details Used during garbage collection.

  @sideeffect None

*/
void
cuddLocalCacheClearDead(
  DdManager * manager)
{
    DdLocalCache *cache = manager->localCaches;
    unsigned int keysize;
    unsigned int itemsize;
    unsigned int slots;
    DdLocalCacheItem *item;
    DdNodePtr *key;
    unsigned int i, j;

    while (cache != NULL) {
	keysize = cache->keysize;
	itemsize = cache->itemsize;
	slots = cache->slots;
	item = cache->item;
	for (i = 0; i < slots; i++) {
	    if (item->value != NULL) {
		if (Cudd_Regular(item->value)->ref == 0) {
		    item->value = NULL;
		} else {
		    key = item->key;
		    for (j = 0; j < keysize; j++) {
			if (Cudd_Regular(key[j])->ref == 0) {
			    item->value = NULL;
			    break;
			}
		    }
		}
	    }
	    item = (DdLocalCacheItem *) ((char *) item + itemsize);
	}
	cache = cache->next;
    }
    return;

} /* end of cuddLocalCacheClearDead */


/**
  @brief Clears the local caches of a manager.

  @details Used before reordering.

  @sideeffect None

*/
void
cuddLocalCacheClearAll(
  DdManager * manager)
{
    DdLocalCache *cache = manager->localCaches;

    while (cache != NULL) {
	memset(cache->item, 0, cache->slots * cache->itemsize);
	cache = cache->next;
    }
    return;

} /* end of cuddLocalCacheClearAll */


#ifdef DD_CACHE_PROFILE

#define DD_HYSTO_BINS 8

/**
  @brief Computes and prints a profile of a local cache usage.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddLocalCacheProfile(
  DdLocalCache * cache)
{
    double count, mean, meansq, stddev, expected;
    long max, min;
    int imax, imin;
    int i, retval, slots;
    long *hystogram;
    int nbins = DD_HYSTO_BINS;
    int bin;
    long thiscount;
    double totalcount;
    int nzeroes;
    DdLocalCacheItem *entry;
    FILE *fp = cache->manager->out;

    slots = cache->slots;

    meansq = mean = expected = 0.0;
    max = min = (long) cache->item[0].count;
    imax = imin = nzeroes = 0;
    totalcount = 0.0;

    hystogram = ALLOC(long, nbins);
    if (hystogram == NULL) {
	return(0);
    }
    for (i = 0; i < nbins; i++) {
	hystogram[i] = 0;
    }

    for (i = 0; i < slots; i++) {
	entry = (DdLocalCacheItem *) ((char *) cache->item +
				      i * cache->itemsize);
	thiscount = (long) entry->count;
	if (thiscount > max) {
	    max = thiscount;
	    imax = i;
	}
	if (thiscount < min) {
	    min = thiscount;
	    imin = i;
	}
	if (thiscount == 0) {
	    nzeroes++;
	}
	count = (double) thiscount;
	mean += count;
	meansq += count * count;
	totalcount += count;
	expected += count * (double) i;
	bin = (i * nbins) / slots;
	hystogram[bin] += thiscount;
    }
    mean /= (double) slots;
    meansq /= (double) slots;
    stddev = sqrt(meansq - mean*mean);

    retval = fprintf(fp,"Cache stats: slots = %d average = %g ", slots, mean);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"standard deviation = %g\n", stddev);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Cache max accesses = %ld for slot %d\n", max, imax);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Cache min accesses = %ld for slot %d\n", min, imin);
    if (retval == EOF) return(0);
    retval = fprintf(fp,"Cache unused slots = %d\n", nzeroes);
    if (retval == EOF) return(0);

    if (totalcount) {
	expected /= totalcount;
	retval = fprintf(fp,"Cache access hystogram for %d bins", nbins);
	if (retval == EOF) return(0);
	retval = fprintf(fp," (expected bin value = %g)\n# ", expected);
	if (retval == EOF) return(0);
	for (i = nbins - 1; i>=0; i--) {
	    retval = fprintf(fp,"%ld ", hystogram[i]);
	    if (retval == EOF) return(0);
	}
	retval = fprintf(fp,"\n");
	if (retval == EOF) return(0);
    }

    FREE(hystogram);
    return(1);

} /* end of cuddLocalCacheProfile */
#endif


/**
  @brief Initializes a hash table.

  @details The table associates tuples of DdNode pointers to one DdNode pointer.
  This type of table is used for functions that cannot (or prefer not to) use
  the main computed table.  The package also provides functions that allow the
  caller to store arbitrary pointers in the table.

  @return a pointer to the new table if successful; NULL otherwise.

  @sideeffect None

  @see cuddHashTableQuit cuddHashTableGenericQuit

*/
DdHashTable *
cuddHashTableInit(
  DdManager * manager /**< %DD manager */,
  unsigned int keySize /**< number of pointers in the key */,
  unsigned int initSize /**< initial size of the table */)
{
    DdHashTable *hash;
    int logSize;

    hash = ALLOC(DdHashTable, 1);
    if (hash == NULL) {
	manager->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    hash->keysize = keySize;
    hash->manager = manager;
    hash->memoryList = NULL;
    hash->nextFree = NULL;
    hash->itemsize = (keySize + 1) * sizeof(DdNode *) +
	sizeof(ptrint) + sizeof(DdHashItem *);
    /* We have to guarantee that the shift be < 32. */
    if (initSize < 2) initSize = 2;
    logSize = cuddComputeFloorLog2(initSize);
    hash->numBuckets = 1U << logSize;
    hash->shift = sizeof(int) * 8 - logSize;
    hash->bucket = ALLOC(DdHashItem *, hash->numBuckets);
    if (hash->bucket == NULL) {
	manager->errorCode = CUDD_MEMORY_OUT;
	FREE(hash);
	return(NULL);
    }
    memset(hash->bucket, 0, hash->numBuckets * sizeof(DdHashItem *));
    hash->size = 0;
    hash->maxsize = hash->numBuckets * DD_MAX_HASHTABLE_DENSITY;
    return(hash);

} /* end of cuddHashTableInit */


/**
  @brief Shuts down a hash table.

  @details Dereferences all the values.

  @sideeffect None

  @see cuddHashTableInit

*/
void
cuddHashTableQuit(
  DdHashTable * hash)
{
    unsigned int i;
    DdManager *dd = hash->manager;
    DdHashItem *bucket;
    DdHashItem **memlist, **nextmem;
    unsigned int numBuckets = hash->numBuckets;

    for (i = 0; i < numBuckets; i++) {
	bucket = hash->bucket[i];
	while (bucket != NULL) {
	    Cudd_RecursiveDeref(dd, bucket->value);
	    bucket = bucket->next;
	}
    }

    memlist = hash->memoryList;
    while (memlist != NULL) {
	nextmem = (DdHashItem **) memlist[0];
	FREE(memlist);
	memlist = nextmem;
    }

    FREE(hash->bucket);
    FREE(hash);

    return;

} /* end of cuddHashTableQuit */


/**
  @brief Shuts down a hash table.

  @details Shuts down a hash table, when the values are not DdNode
  pointers.

  @sideeffect None

  @see cuddHashTableInit

*/
void
cuddHashTableGenericQuit(
  DdHashTable * hash)
{
    DdHashItem **memlist, **nextmem;

    memlist = hash->memoryList;
    while (memlist != NULL) {
	nextmem = (DdHashItem **) memlist[0];
	FREE(memlist);
	memlist = nextmem;
    }

    FREE(hash->bucket);
    FREE(hash);

    return;

} /* end of cuddHashTableGenericQuit */


/**
  @brief Inserts an item in a hash table.

  @details Inserts an item in a hash table when the key has more than
  three pointers.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see [cuddHashTableInsert1 cuddHashTableInsert2 cuddHashTableInsert3
  cuddHashTableLookup

*/
int
cuddHashTableInsert(
  DdHashTable * hash,
  DdNodePtr * key,
  DdNode * value,
  ptrint count)
{
    int result;
    unsigned int posn;
    DdHashItem *item;
    unsigned int i;

#ifdef DD_DEBUG
    assert(hash->keysize > 3);
#endif

    if (hash->size > hash->maxsize) {
	result = cuddHashTableResize(hash);
	if (result == 0) return(0);
    }
    item = cuddHashTableAlloc(hash);
    if (item == NULL) return(0);
    hash->size++;
    item->value = value;
    cuddRef(value);
    item->count = count;
    for (i = 0; i < hash->keysize; i++) {
	item->key[i] = key[i];
    }
    posn = ddLCHash(key,hash->keysize,hash->shift);
    item->next = hash->bucket[posn];
    hash->bucket[posn] = item;

    return(1);

} /* end of cuddHashTableInsert */


/**
  @brief Looks up a key in a hash table.

  @details Looks up a key consisting of more than three pointers in a
  hash table.  If the entry is present, its reference counter is
  decremented if not saturated. If the counter reaches 0, the value of
  the entry is dereferenced, and the entry is returned to the free
  list.

  @return the value associated to the key if there is an entry for the
  given key in the table; NULL otherwise.

  @sideeffect None

  @see cuddHashTableLookup1 cuddHashTableLookup2 cuddHashTableLookup3
  cuddHashTableInsert

*/
DdNode *
cuddHashTableLookup(
  DdHashTable * hash,
  DdNodePtr * key)
{
    unsigned int posn;
    DdHashItem *item, *prev;
    unsigned int i, keysize;

#ifdef DD_DEBUG
    assert(hash->keysize > 3);
#endif

    posn = ddLCHash(key,hash->keysize,hash->shift);
    item = hash->bucket[posn];
    prev = NULL;

    keysize = hash->keysize;
    while (item != NULL) {
	DdNodePtr *key2 = item->key;
	int equal = 1;
	for (i = 0; i < keysize; i++) {
	    if (key[i] != key2[i]) {
		equal = 0;
		break;
	    }
	}
	if (equal) {
	    DdNode *value = item->value;
	    cuddSatDec(item->count);
	    if (item->count == 0) {
		cuddDeref(value);
		if (prev == NULL) {
		    hash->bucket[posn] = item->next;
		} else {
		    prev->next = item->next;
		}
		item->next = hash->nextFree;
		hash->nextFree = item;
		hash->size--;
	    }
	    return(value);
	}
	prev = item;
	item = item->next;
    }
    return(NULL);

} /* end of cuddHashTableLookup */


/**
  @brief Inserts an item in a hash table.

  @details Inserts an item in a hash table when the key is one pointer.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddHashTableInsert cuddHashTableInsert2 cuddHashTableInsert3
  cuddHashTableLookup1

*/
int
cuddHashTableInsert1(
  DdHashTable * hash,
  DdNode * f,
  DdNode * value,
  ptrint count)
{
    int result;
    unsigned int posn;
    DdHashItem *item;

#ifdef DD_DEBUG
    assert(hash->keysize == 1);
#endif

    if (hash->size > hash->maxsize) {
	result = cuddHashTableResize(hash);
	if (result == 0) return(0);
    }
    item = cuddHashTableAlloc(hash);
    if (item == NULL) return(0);
    hash->size++;
    item->value = value;
    cuddRef(value);
    item->count = count;
    item->key[0] = f;
    posn = ddLCHash1(f,hash->shift);
    item->next = hash->bucket[posn];
    hash->bucket[posn] = item;

    return(1);

} /* end of cuddHashTableInsert1 */


/**
  @brief Looks up a key consisting of one pointer in a hash table.

  @details If the entry is present, its reference count is
  decremented if not saturated. If the counter reaches 0, the value of
  the entry is dereferenced, and the entry is returned to the free
  list.

  @return the value associated to the key if there is an entry for the
  given key in the table; NULL otherwise.

  @sideeffect None

  @see cuddHashTableLookup cuddHashTableLookup2 cuddHashTableLookup3
  cuddHashTableInsert1

*/
DdNode *
cuddHashTableLookup1(
  DdHashTable * hash,
  DdNode * f)
{
    unsigned int posn;
    DdHashItem *item, *prev;

#ifdef DD_DEBUG
    assert(hash->keysize == 1);
#endif

    posn = ddLCHash1(f,hash->shift);
    item = hash->bucket[posn];
    prev = NULL;

    while (item != NULL) {
	DdNodePtr *key = item->key;
	if (f == key[0]) {
	    DdNode *value = item->value;
	    cuddSatDec(item->count);
	    if (item->count == 0) {
		cuddDeref(value);
		if (prev == NULL) {
		    hash->bucket[posn] = item->next;
		} else {
		    prev->next = item->next;
		}
		item->next = hash->nextFree;
		hash->nextFree = item;
		hash->size--;
	    }
	    return(value);
	}
	prev = item;
	item = item->next;
    }
    return(NULL);

} /* end of cuddHashTableLookup1 */


/**
  @brief Inserts a generic item in a hash table.

  @details Inserts an item in a hash table when the key is one
  pointer and the value is not a DdNode pointer.  The main difference w.r.t.
  cuddHashTableInsert1 is that the reference count of the value is not
  incremented.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddHashTableInsert1 cuddHashTableGenericLookup

*/
int
cuddHashTableGenericInsert(
  DdHashTable * hash,
  DdNode * f,
  void * value)
{
    int result;
    unsigned int posn;
    DdHashItem *item;

#ifdef DD_DEBUG
    assert(hash->keysize == 1);
#endif

    if (hash->size > hash->maxsize) {
	result = cuddHashTableResize(hash);
	if (result == 0) return(0);
    }
    item = cuddHashTableAlloc(hash);
    if (item == NULL) return(0);
    hash->size++;
    item->value = (DdNode *) value;
    item->count = 0;
    item->key[0] = f;
    posn = ddLCHash1(f,hash->shift);
    item->next = hash->bucket[posn];
    hash->bucket[posn] = item;

    return(1);

} /* end of cuddHashTableGenericInsert */


/**
  @brief Looks up a key consisting of one pointer in a hash table.

  @details Looks up a key consisting of one pointer in a hash
  table when the value is not a DdNode pointer.

  @return the value associated to the key if there is an entry for the
  given key in the table; NULL otherwise.

  @sideeffect None

  @see cuddHashTableLookup1 cuddHashTableGenericInsert

*/
void *
cuddHashTableGenericLookup(
  DdHashTable * hash,
  DdNode * f)
{
    unsigned int posn;
    DdHashItem *item;

#ifdef DD_DEBUG
    assert(hash->keysize == 1);
#endif

    posn = ddLCHash1(f,hash->shift);
    item = hash->bucket[posn];

    while (item != NULL) {
	if (f == item->key[0]) {
            return ((void *) item->value);
	}
	item = item->next;
    }
    return(NULL);

} /* end of cuddHashTableGenericLookup */


/**
  @brief Inserts an item in a hash table.

  @details Inserts an item in a hash table when the key is
  composed of two pointers.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddHashTableInsert cuddHashTableInsert1 cuddHashTableInsert3
  cuddHashTableLookup2

*/
int
cuddHashTableInsert2(
  DdHashTable * hash,
  DdNode * f,
  DdNode * g,
  DdNode * value,
  ptrint count)
{
    int result;
    unsigned int posn;
    DdHashItem *item;

#ifdef DD_DEBUG
    assert(hash->keysize == 2);
#endif

    if (hash->size > hash->maxsize) {
	result = cuddHashTableResize(hash);
	if (result == 0) return(0);
    }
    item = cuddHashTableAlloc(hash);
    if (item == NULL) return(0);
    hash->size++;
    item->value = value;
    cuddRef(value);
    item->count = count;
    item->key[0] = f;
    item->key[1] = g;
    posn = ddLCHash2(f,g,hash->shift);
    item->next = hash->bucket[posn];
    hash->bucket[posn] = item;

    return(1);

} /* end of cuddHashTableInsert2 */


/**
  @brief Looks up a key consisting of two pointers in a hash table.

  @details If the entry is present, its reference counter is
  decremented if not saturated. If the counter reaches 0, the value of
  the entry is dereferenced, and the entry is returned to the free
  list.

  @return the value associated to the key if there is an entry for the
  given key in the table; NULL otherwise.

  @sideeffect None

  @see cuddHashTableLookup cuddHashTableLookup1 cuddHashTableLookup3
  cuddHashTableInsert2

*/
DdNode *
cuddHashTableLookup2(
  DdHashTable * hash,
  DdNode * f,
  DdNode * g)
{
    unsigned int posn;
    DdHashItem *item, *prev;

#ifdef DD_DEBUG
    assert(hash->keysize == 2);
#endif

    posn = ddLCHash2(f,g,hash->shift);
    item = hash->bucket[posn];
    prev = NULL;

    while (item != NULL) {
	DdNodePtr *key = item->key;
	if ((f == key[0]) && (g == key[1])) {
	    DdNode *value = item->value;
	    cuddSatDec(item->count);
	    if (item->count == 0) {
		cuddDeref(value);
		if (prev == NULL) {
		    hash->bucket[posn] = item->next;
		} else {
		    prev->next = item->next;
		}
		item->next = hash->nextFree;
		hash->nextFree = item;
		hash->size--;
	    }
	    return(value);
	}
	prev = item;
	item = item->next;
    }
    return(NULL);

} /* end of cuddHashTableLookup2 */


/**
  @brief Inserts an item in a hash table.

  @details Inserts an item in a hash table when the key is
  composed of three pointers.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddHashTableInsert cuddHashTableInsert1 cuddHashTableInsert2
  cuddHashTableLookup3

*/
int
cuddHashTableInsert3(
  DdHashTable * hash,
  DdNode * f,
  DdNode * g,
  DdNode * h,
  DdNode * value,
  ptrint count)
{
    int result;
    unsigned int posn;
    DdHashItem *item;

#ifdef DD_DEBUG
    assert(hash->keysize == 3);
#endif

    if (hash->size > hash->maxsize) {
	result = cuddHashTableResize(hash);
	if (result == 0) return(0);
    }
    item = cuddHashTableAlloc(hash);
    if (item == NULL) return(0);
    hash->size++;
    item->value = value;
    cuddRef(value);
    item->count = count;
    item->key[0] = f;
    item->key[1] = g;
    item->key[2] = h;
    posn = ddLCHash3(f,g,h,hash->shift);
    item->next = hash->bucket[posn];
    hash->bucket[posn] = item;

    return(1);

} /* end of cuddHashTableInsert3 */


/**
  @brief Looks up a key consisting of three pointers in a hash table.

  @details If the entry is present, its reference counter is
  decremented if not saturated. If the counter reaches 0, the value of
  the entry is dereferenced, and the entry is returned to the free
  list.

  @return the value associated to the key if there is an entry for the
  given key in the table; NULL otherwise.

  @sideeffect None

  @see cuddHashTableLookup cuddHashTableLookup1 cuddHashTableLookup2
  cuddHashTableInsert3

*/
DdNode *
cuddHashTableLookup3(
  DdHashTable * hash,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    unsigned int posn;
    DdHashItem *item, *prev;

#ifdef DD_DEBUG
    assert(hash->keysize == 3);
#endif

    posn = ddLCHash3(f,g,h,hash->shift);
    item = hash->bucket[posn];
    prev = NULL;

    while (item != NULL) {
	DdNodePtr *key = item->key;
	if ((f == key[0]) && (g == key[1]) && (h == key[2])) {
	    DdNode *value = item->value;
	    cuddSatDec(item->count);
	    if (item->count == 0) {
		cuddDeref(value);
		if (prev == NULL) {
		    hash->bucket[posn] = item->next;
		} else {
		    prev->next = item->next;
		}
		item->next = hash->nextFree;
		hash->nextFree = item;
		hash->size--;
	    }
	    return(value);
	}
	prev = item;
	item = item->next;
    }
    return(NULL);

} /* end of cuddHashTableLookup3 */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Resizes a local cache.

  @sideeffect None

*/
static void
cuddLocalCacheResize(
  DdLocalCache * cache)
{
    DdLocalCacheItem *item, *olditem, *entry, *old;
    int i, shift;
    unsigned int posn;
    unsigned int slots, oldslots;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    olditem = cache->item;
    oldslots = cache->slots;
    slots = cache->slots = oldslots << 1;

#ifdef DD_VERBOSE
    (void) fprintf(cache->manager->err,
		   "Resizing local cache from %d to %d entries\n",
		   oldslots, slots);
    (void) fprintf(cache->manager->err,
		   "\thits = %.0f\tlookups = %.0f\thit ratio = %5.3f\n",
		   cache->hits, cache->lookUps, cache->hits / cache->lookUps);
#endif

    saveHandler = MMoutOfMemory;
    MMoutOfMemory = cache->manager->outOfMemCallback;
    cache->item = item =
	(DdLocalCacheItem *) ALLOC(char, slots * cache->itemsize);
    MMoutOfMemory = saveHandler;
    /* If we fail to allocate the new table we just give up. */
    if (item == NULL) {
#ifdef DD_VERBOSE
	(void) fprintf(cache->manager->err,"Resizing failed. Giving up.\n");
#endif
	cache->slots = oldslots;
	cache->item = olditem;
	/* Do not try to resize again. */
	cache->maxslots = oldslots - 1;
	return;
    }
    shift = --(cache->shift);
    cache->manager->memused += (slots - oldslots) * cache->itemsize;

    /* Clear new cache. */
    memset(item, 0, slots * cache->itemsize);

    /* Copy from old cache to new one. */
    for (i = 0; (unsigned) i < oldslots; i++) {
	old = (DdLocalCacheItem *) ((char *) olditem + i * cache->itemsize);
	if (old->value != NULL) {
	    posn = ddLCHash(old->key,cache->keysize,shift);
	    entry = (DdLocalCacheItem *) ((char *) item +
					  posn * cache->itemsize);
	    memcpy(entry->key,old->key,cache->keysize*sizeof(DdNode *));
	    entry->value = old->value;
	}
    }

    FREE(olditem);

    /* Reinitialize measurements so as to avoid division by 0 and
    ** immediate resizing.
    */
    cache->lookUps = (double) (int) (slots * cache->minHit + 1);
    cache->hits = 0;

} /* end of cuddLocalCacheResize */


/**
  @brief Computes the hash value for a local cache.

  @return the bucket index.

  @sideeffect None

*/
static unsigned int
ddLCHash(
  DdNodePtr * key,
  unsigned int keysize,
  int shift)
{
    unsigned int val = (unsigned int) (ptrint) key[0] * DD_P2;
    unsigned int i;

    for (i = 1; i < keysize; i++) {
	val = val * DD_P1 + (int) (ptrint) key[i];
    }

    return(val >> shift);

} /* end of ddLCHash */


/**
  @brief Inserts a local cache in the manager list.

  @sideeffect None

*/
static void
cuddLocalCacheAddToList(
  DdLocalCache * cache)
{
    DdManager *manager = cache->manager;

    cache->next = manager->localCaches;
    manager->localCaches = cache;
    return;

} /* end of cuddLocalCacheAddToList */


/**
  @brief Removes a local cache from the manager list.

  @sideeffect None

*/
static void
cuddLocalCacheRemoveFromList(
  DdLocalCache * cache)
{
    DdManager *manager = cache->manager;
    DdLocalCache **prevCache, *nextCache;

    prevCache = &(manager->localCaches);
    nextCache = manager->localCaches;

    while (nextCache != NULL) {
	if (nextCache == cache) {
	    *prevCache = nextCache->next;
	    return;
	}
	prevCache = &(nextCache->next);
	nextCache = nextCache->next;
    }
    return;			/* should never get here */

} /* end of cuddLocalCacheRemoveFromList */


/**
  @brief Resizes a hash table.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddHashTableInsert

*/
static int
cuddHashTableResize(
  DdHashTable * hash)
{
    int j;
    unsigned int posn;
    DdHashItem *item;
    DdHashItem *next;
    DdNode **key;
    int numBuckets;
    DdHashItem **buckets;
    DdHashItem **oldBuckets = hash->bucket;
    int shift;
    int oldNumBuckets = hash->numBuckets;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    /* Compute the new size of the table. */
    numBuckets = oldNumBuckets << 1;
    saveHandler = MMoutOfMemory;
    MMoutOfMemory = hash->manager->outOfMemCallback;
    buckets = ALLOC(DdHashItem *, numBuckets);
    MMoutOfMemory = saveHandler;
    if (buckets == NULL) {
	hash->maxsize <<= 1;
	return(1);
    }

    hash->bucket = buckets;
    hash->numBuckets = numBuckets;
    shift = --(hash->shift);
    hash->maxsize <<= 1;
    memset(buckets, 0, numBuckets * sizeof(DdHashItem *));
    if (hash->keysize == 1) {
	for (j = 0; j < oldNumBuckets; j++) {
	    item = oldBuckets[j];
	    while (item != NULL) {
		next = item->next;
		key = item->key;
		posn = ddLCHash2(key[0], key[0], shift);
		item->next = buckets[posn];
		buckets[posn] = item;
		item = next;
	    }
	}
    } else if (hash->keysize == 2) {
	for (j = 0; j < oldNumBuckets; j++) {
	    item = oldBuckets[j];
	    while (item != NULL) {
		next = item->next;
		key = item->key;
		posn = ddLCHash2(key[0], key[1], shift);
		item->next = buckets[posn];
		buckets[posn] = item;
		item = next;
	    }
	}
    } else if (hash->keysize == 3) {
	for (j = 0; j < oldNumBuckets; j++) {
	    item = oldBuckets[j];
	    while (item != NULL) {
		next = item->next;
		key = item->key;
		posn = ddLCHash3(key[0], key[1], key[2], shift);
		item->next = buckets[posn];
		buckets[posn] = item;
		item = next;
	    }
	}
    } else {
	for (j = 0; j < oldNumBuckets; j++) {
	    item = oldBuckets[j];
	    while (item != NULL) {
		next = item->next;
		posn = ddLCHash(item->key, hash->keysize, shift);
		item->next = buckets[posn];
		buckets[posn] = item;
		item = next;
	    }
	}
    }
    FREE(oldBuckets);
    return(1);

} /* end of cuddHashTableResize */


/**
  @brief Fast storage allocation for items in a hash table.

  @details The first sizeof(void *) bytes of a chunk contain a pointer to the
  next block; the rest contains DD_MEM_CHUNK spaces for hash items.

  @return a pointer to a new item if successful; NULL is memory is full.

  @sideeffect None

  @see cuddAllocNode cuddDynamicAllocNode

*/
static DdHashItem *
cuddHashTableAlloc(
  DdHashTable * hash)
{
    int i;
    unsigned int itemsize = hash->itemsize;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;
    DdHashItem **mem, *thisOne, *next, *item;

    if (hash->nextFree == NULL) {
	saveHandler = MMoutOfMemory;
	MMoutOfMemory = hash->manager->outOfMemCallback;
	mem = (DdHashItem **) ALLOC(char,(DD_MEM_CHUNK+1) * itemsize);
	MMoutOfMemory = saveHandler;
	if (mem == NULL) {
	    if (hash->manager->stash != NULL) {
		FREE(hash->manager->stash);
		hash->manager->stash = NULL;
		/* Inhibit resizing of tables. */
		hash->manager->maxCacheHard = hash->manager->cacheSlots - 1;
		hash->manager->cacheSlack = - (int) (hash->manager->cacheSlots + 1);
		for (i = 0; i < hash->manager->size; i++) {
		    hash->manager->subtables[i].maxKeys <<= 2;
		}
		hash->manager->gcFrac = 0.2;
		hash->manager->minDead =
		    (unsigned) (0.2 * (double) hash->manager->slots);
		mem = (DdHashItem **) ALLOC(char,(DD_MEM_CHUNK+1) * itemsize);
	    }
	    if (mem == NULL) {
		(*MMoutOfMemory)((size_t)((DD_MEM_CHUNK + 1) * itemsize));
		hash->manager->errorCode = CUDD_MEMORY_OUT;
		return(NULL);
	    }
	}

	mem[0] = (DdHashItem *) hash->memoryList;
	hash->memoryList = mem;

	thisOne = (DdHashItem *) ((char *) mem + itemsize);
	hash->nextFree = thisOne;
	for (i = 1; i < DD_MEM_CHUNK; i++) {
	    next = (DdHashItem *) ((char *) thisOne + itemsize);
	    thisOne->next = next;
	    thisOne = next;
	}

	thisOne->next = NULL;

    }
    item = hash->nextFree;
    hash->nextFree = item->next;
    return(item);

} /* end of cuddHashTableAlloc */

cuddLevelQ.c
14636
/**
  @file

  @ingroup cudd

  @brief Procedure to manage level queues.

  @details The functions in this file allow an application to easily
  manipulate a queue where nodes are prioritized by level. The
  emphasis is on efficiency. Therefore, the queue items can have
  variable size.  If the application does not need to attach
  information to the nodes, it can declare the queue items to be of
  type DdQueueItem. Otherwise, it can declare them to be of a
  structure type such that the first three fields are data
  pointers. The third pointer points to the node.  The first two
  pointers are used by the level queue functions. The remaining fields
  are initialized to 0 when a new item is created, and are then left
  to the exclusive use of the application. On the DEC Alphas the three
  pointers must be 32-bit pointers when CUDD is compiled with 32-bit
  pointers.  The level queue functions make sure that each node
  appears at most once in the queue. They do so by keeping a hash
  table where the node is used as key.  Queue items are recycled via a
  free list for efficiency.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/


/**
  @brief Hash function for the table of a level queue.

  @sideeffect None

  @see hashInsert hashLookup hashDelete

*/
#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
#define lqHash(key,shift) \
(((unsigned)(ptruint)(key) * DD_P1) >> (shift))
#else
#define lqHash(key,shift) \
(((unsigned)(key) * DD_P1) >> (shift))
#endif


/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdQueueItem * hashLookup(DdLevelQueue *queue, void *key);
static int hashInsert(DdLevelQueue *queue, DdQueueItem *item);
static void hashDelete(DdLevelQueue *queue, DdQueueItem *item);
static int hashResize(DdLevelQueue *queue);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Initializes a level queue.

  @details A level queue is a queue where inserts are based on the
  levels of the nodes. Within each level the policy is FIFO. Level
  queues are useful in traversing a %BDD top-down. Queue items are kept
  in a free list when dequeued for efficiency.

  @return a pointer to the new queue if successful; NULL otherwise.

  @sideeffect None

  @see cuddLevelQueueQuit cuddLevelQueueEnqueue cuddLevelQueueDequeue

*/
DdLevelQueue *
cuddLevelQueueInit(
  int  levels /**< number of levels */,
  int  itemSize /**< size of the item */,
  int  numBuckets /**< initial number of hash buckets */,
  DdManager * manager /*<< DD manager */)
{
    DdLevelQueue *queue;
    int logSize;

    queue = ALLOC(DdLevelQueue,1);
    if (queue == NULL)
	return(NULL);
    /* Keep pointers to the insertion points for all levels. */
    queue->last = ALLOC(DdQueueItem *, levels);
    if (queue->last == NULL) {
	FREE(queue);
	return(NULL);
    }
    /* Use a hash table to test for uniqueness. */
    if (numBuckets < 2) numBuckets = 2;
    logSize = cuddComputeFloorLog2(numBuckets);
    queue->numBuckets = 1U << logSize;
    queue->shift = sizeof(int) * 8 - logSize;
    queue->buckets = ALLOC(DdQueueItem *, queue->numBuckets);
    if (queue->buckets == NULL) {
	FREE(queue->last);
	FREE(queue);
	return(NULL);
    }
    memset(queue->last, 0, levels * sizeof(DdQueueItem *));
    memset(queue->buckets, 0, queue->numBuckets * sizeof(DdQueueItem *));
    queue->first = NULL;
    queue->freelist = NULL;
    queue->levels = levels;
    queue->itemsize = itemSize;
    queue->size = 0;
    queue->maxsize = queue->numBuckets * DD_MAX_SUBTABLE_DENSITY;
    queue->manager = manager;
    return(queue);

} /* end of cuddLevelQueueInit */


/**
  @brief Shuts down a level queue.

  @details Releases all the associated memory.

  @sideeffect None

  @see cuddLevelQueueInit

*/
void
cuddLevelQueueQuit(
  DdLevelQueue * queue)
{
    DdQueueItem *item;

    while (queue->freelist != NULL) {
	item = queue->freelist;
	queue->freelist = item->next;
	FREE(item);
    }
    while (queue->first != NULL) {
	item = (DdQueueItem *) queue->first;
	queue->first = item->next;
	FREE(item);
    }
    FREE(queue->buckets);
    FREE(queue->last);
    FREE(queue);
    return;

} /* end of cuddLevelQueueQuit */


/**
  @brief Inserts a new key in a level queue.

  @details A new entry is created in the queue only if the node is not
  already enqueued.

  @return a pointer to the queue item if successful; NULL otherwise.

  @sideeffect None

  @see cuddLevelQueueInit cuddLevelQueueDequeue

*/
void *
cuddLevelQueueEnqueue(
  DdLevelQueue * queue /**< level queue */,
  void * key /**< key to be enqueued */,
  int  level /**< level at which to insert */)
{
    DdQueueItem *item;

#ifdef DD_DEBUG
    assert(level < queue->levels);
#endif
    /* Check whether entry for this node exists. */
    item = hashLookup(queue,key);
    if (item != NULL) return(item);

    /* Get a free item from either the free list or the memory manager. */
    if (queue->freelist == NULL) {
	item = (DdQueueItem *) ALLOC(char, queue->itemsize);
	if (item == NULL)
	    return(NULL);
    } else {
	item = queue->freelist;
	queue->freelist = item->next;
    }
    /* Initialize. */
    memset(item, 0, queue->itemsize);
    item->key = key;
    /* Update stats. */
    queue->size++;

    if (queue->last[level]) {
	/* There are already items for this level in the queue. */
	item->next = queue->last[level]->next;
	queue->last[level]->next = item;
    } else {
	/* There are no items at the current level.  Look for the first
	** non-empty level preceeding this one. */
        int plevel = level;
	while (plevel != 0 && queue->last[plevel] == NULL)
	    plevel--;
	if (queue->last[plevel] == NULL) {
	    /* No element precedes this one in the queue. */
	    item->next = (DdQueueItem *) queue->first;
	    queue->first = item;
	} else {
	    item->next = queue->last[plevel]->next;
	    queue->last[plevel]->next = item;
	}
    }
    queue->last[level] = item;

    /* Insert entry for the key in the hash table. */
    if (hashInsert(queue,item) == 0) {
	return(NULL);
    }
    return(item);

} /* end of cuddLevelQueueEnqueue */


/**
  @brief Inserts the first key in a level queue.

  @return a pointer to the queue item if successful; NULL otherwise.

  @sideeffect None

  @see cuddLevelQueueEnqueue

*/
void *
cuddLevelQueueFirst(
  DdLevelQueue * queue /**< level queue */,
  void * key /**< key to be enqueued */,
  int  level /**< level at which to insert */)
{
    DdQueueItem *item;

#ifdef DD_DEBUG
    assert(level < queue->levels);
    /* Check whether entry for this node exists. */
    item = hashLookup(queue,key);
    assert(item == NULL);
#endif

    /* Get a free item from either the free list or the memory manager. */
    if (queue->freelist == NULL) {
	item = (DdQueueItem *) ALLOC(char, queue->itemsize);
	if (item == NULL)
	    return(NULL);
    } else {
	item = queue->freelist;
	queue->freelist = item->next;
    }
    /* Initialize. */
    memset(item, 0, queue->itemsize);
    item->key = key;
    /* Update stats. */
    queue->size = 1;

    /* No element precedes this one in the queue. */
    queue->first = item;
    queue->last[level] = item;

    /* Insert entry for the key in the hash table. */
    if (hashInsert(queue,item) == 0) {
	return(NULL);
    }
    return(item);

} /* end of cuddLevelQueueFirst */


/**
  @brief Remove an item from the front of a level queue.

  @sideeffect None

  @see cuddLevelQueueEnqueue

*/
void
cuddLevelQueueDequeue(
  DdLevelQueue * queue,
  int  level)
{
    DdQueueItem *item = (DdQueueItem *) queue->first;

    /* Delete from the hash table. */
    hashDelete(queue,item);

    /* Since we delete from the front, if this is the last item for
    ** its level, there are no other items for the same level. */
    if (queue->last[level] == item) {
	queue->last[level] = NULL;
    }

    queue->first = item->next;
    /* Put item on the free list. */
    item->next = queue->freelist;
    queue->freelist = item;
    /* Update stats. */
    queue->size--;
    return;

} /* end of cuddLevelQueueDequeue */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Looks up a key in the hash table of a level queue.

  @return a pointer to the item with the given key if the key is
  found; NULL otherwise.

  @sideeffect None

  @see cuddLevelQueueEnqueue hashInsert

*/
static DdQueueItem *
hashLookup(
  DdLevelQueue * queue,
  void * key)
{
    int posn;
    DdQueueItem *item;

    posn = lqHash(key,queue->shift);
    item = queue->buckets[posn];

    while (item != NULL) {
	if (item->key == key) {
	    return(item);
	}
	item = item->cnext;
    }
    return(NULL);

} /* end of hashLookup */


/**
  @brief Inserts an item in the hash table of a level queue.

  @details No check is performed to see if an item with the same key
  is already in the hash table.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddLevelQueueEnqueue

*/
static int
hashInsert(
  DdLevelQueue * queue,
  DdQueueItem * item)
{
    int result;
    int posn;

    if (queue->size > queue->maxsize) {
	result = hashResize(queue);
	if (result == 0) return(0);
    }

    posn = lqHash(item->key,queue->shift);
    item->cnext = queue->buckets[posn];
    queue->buckets[posn] = item;

    return(1);
    
} /* end of hashInsert */


/**
  @brief Removes an item from the hash table of a level queue.

  @details Nothing is done if the item is not in the table.

  @sideeffect None

  @see cuddLevelQueueDequeue hashInsert

*/
static void
hashDelete(
  DdLevelQueue * queue,
  DdQueueItem * item)
{
    int posn;
    DdQueueItem *prevItem;

    posn = lqHash(item->key,queue->shift);
    prevItem = queue->buckets[posn];

    if (prevItem == NULL) return;
    if (prevItem == item) {
	queue->buckets[posn] = prevItem->cnext;
	return;
    }

    while (prevItem->cnext != NULL) {
	if (prevItem->cnext == item) {
	    prevItem->cnext = item->cnext;
	    return;
	}
	prevItem = prevItem->cnext;
    }
    return;

} /* end of hashDelete */


/**
  @brief Resizes the hash table of a level queue.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see hashInsert

*/
static int
hashResize(
  DdLevelQueue * queue)
{
    int j;
    int posn;
    DdQueueItem *item;
    DdQueueItem *next;
    int numBuckets;
    DdQueueItem **buckets;
    DdQueueItem **oldBuckets = queue->buckets;
    int shift;
    int oldNumBuckets = queue->numBuckets;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    /* Compute the new size of the subtable. */
    numBuckets = oldNumBuckets << 1;
    saveHandler = MMoutOfMemory;
    MMoutOfMemory = queue->manager->outOfMemCallback;
    buckets = queue->buckets = ALLOC(DdQueueItem *, numBuckets);
    MMoutOfMemory = saveHandler;
    if (buckets == NULL) {
	queue->maxsize <<= 1;
	return(1);
    }

    queue->numBuckets = numBuckets;
    shift = --(queue->shift);
    queue->maxsize <<= 1;
    memset(buckets, 0, numBuckets * sizeof(DdQueueItem *));
    for (j = 0; j < oldNumBuckets; j++) {
	item = oldBuckets[j];
	while (item != NULL) {
	    next = item->cnext;
	    posn = lqHash(item->key, shift);
	    item->cnext = buckets[posn];
	    buckets[posn] = item;
	    item = next;
	}
    }
    FREE(oldBuckets);
    return(1);

} /* end of hashResize */

cuddLinear.c
35196
/**
  @file

  @ingroup cudd

  @brief Functions for %BDD and %ADD reduction by linear
  transformations.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define CUDD_SWAP_MOVE 0
#define CUDD_LINEAR_TRANSFORM_MOVE 1
#define CUDD_INVERSE_TRANSFORM_MOVE 2
#if SIZEOF_VOID_P == 8
#define BPL 64
#define LOGBPL 6
#else
#define BPL 32
#define LOGBPL 5
#endif

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int ddLinearUniqueCompare (void const *ptrX, void const *ptrY);
static int ddLinearAndSiftingAux (DdManager *table, int x, int xLow, int xHigh);
static Move * ddLinearAndSiftingUp (DdManager *table, int y, int xLow, Move *prevMoves);
static Move * ddLinearAndSiftingDown (DdManager *table, int x, int xHigh, Move *prevMoves);
static int ddLinearAndSiftingBackward (DdManager *table, int size, Move *moves);
static Move* ddUndoMoves (DdManager *table, Move *moves);
static void cuddXorLinear (DdManager *table, int x, int y);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints the linear transform matrix.

  @return 1 in case of success; 0 otherwise.

  @sideeffect none

*/
int
Cudd_PrintLinear(
  DdManager * table)
{
    int i,j,k;
    int retval;
    int nvars = table->linearSize;
    int wordsPerRow = ((nvars - 1) >> LOGBPL) + 1;
    ptruint word;

    for (i = 0; i < nvars; i++) {
	for (j = 0; j < wordsPerRow; j++) {
	    word = table->linear[i*wordsPerRow + j];
	    for (k = 0; k < BPL; k++) {
              retval = fprintf(table->out,"%" PRIuPTR,word & (ptruint) 1);
		if (retval == 0) return(0);
		word >>= 1;
	    }
	}
	retval = fprintf(table->out,"\n");
	if (retval == 0) return(0);
    }
    return(1);

} /* end of Cudd_PrintLinear */


/**
  @brief Reads an entry of the linear transform matrix.

  @sideeffect none

*/
int
Cudd_ReadLinear(
  DdManager * table /**< CUDD manager */,
  int  x /**< row index */,
  int  y /**< column index */)
{
    int nvars = table->size;
    ptruint wordsPerRow = ((ptruint)(nvars - 1) >> LOGBPL) + 1;
    ptruint word;
    int bit;
    int result;

    assert(table->size == table->linearSize);

    word = wordsPerRow * (ptruint) x + ((ptruint) y >> LOGBPL);
    bit  = y & (BPL-1);
    result = (int) ((table->linear[word] >> bit) & (ptruint) 1);
    return(result);

} /* end of Cudd_ReadLinear */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief %BDD reduction based on combination of sifting and linear
  transformations.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the %DD heap. At each position, linear transformation
    of the two adjacent variables is tried and is accepted if it reduces
    the size of the %DD.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddLinearAndSifting(
  DdManager * table,
  int  lower,
  int  upper)
{
    int		i;
    IndexKey	*var;
    int		size;
    int		x;
    int		result;
#ifdef DD_STATS
    int		previousSize;
#endif

#ifdef DD_STATS
    table->totalNumberLinearTr = 0;
#endif

    size = table->size;

    var = NULL;
    if (table->linear == NULL) {
	result = cuddInitLinear(table);
	if (result == 0) goto cuddLinearAndSiftingOutOfMem;
#if 0
	(void) fprintf(table->out,"\n");
	result = Cudd_PrintLinear(table);
	if (result == 0) goto cuddLinearAndSiftingOutOfMem;
#endif
    } else if (table->size != table->linearSize) {
	result = cuddResizeLinear(table);
	if (result == 0) goto cuddLinearAndSiftingOutOfMem;
#if 0
	(void) fprintf(table->out,"\n");
	result = Cudd_PrintLinear(table);
	if (result == 0) goto cuddLinearAndSiftingOutOfMem;
#endif
    }

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey,size);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto cuddLinearAndSiftingOutOfMem;
    }

    for (i = 0; i < size; i++) {
	x = table->perm[i];
	var[i].index = i;
	var[i].keys = table->subtables[x].keys;
    }

    util_qsort(var,size,sizeof(IndexKey),ddLinearUniqueCompare);

    /* Now sift. */
    for (i = 0; i < ddMin(table->siftMaxVar,size); i++) {
	x = table->perm[var[i].index];
	if (x < lower || x > upper) continue;
#ifdef DD_STATS
	previousSize = (int) (table->keys - table->isolated);
#endif
	result = ddLinearAndSiftingAux(table,x,lower,upper);
	if (!result) goto cuddLinearAndSiftingOutOfMem;
#ifdef DD_STATS
	if (table->keys < (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"-");
	} else if (table->keys > (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	    (void) fprintf(table->out,"\nSize increased from %d to %u while sifting variable %d\n", previousSize, table->keys - table->isolated, var[i].index);
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
#ifdef DD_DEBUG
	(void) Cudd_DebugCheck(table);
#endif
    }

    FREE(var);

#ifdef DD_STATS
    (void) fprintf(table->out,"\n#:L_LINSIFT %8d: linear trans.",
		   table->totalNumberLinearTr);
#endif

    return(1);

cuddLinearAndSiftingOutOfMem:

    if (var != NULL) FREE(var);

    return(0);

} /* end of cuddLinearAndSifting */


/**
  @brief Linearly combines two adjacent variables.

  @details Specifically, replaces the top variable with the exclusive
  nor of the two variables.  It assumes that no dead nodes are present
  on entry to this procedure.  The procedure then guarantees that no
  dead nodes will be present when it terminates.  cuddLinearInPlace
  assumes that x &lt; y.

  @return the number of keys in the table if successful; 0 otherwise.

  @sideeffect The two subtables corrresponding to variables x and y are
  modified. The global counters of the unique table are also affected.

  @see cuddSwapInPlace

*/
int
cuddLinearInPlace(
  DdManager * table,
  int  x,
  int  y)
{
    DdNodePtr *xlist, *ylist;
    int    xindex, yindex;
    int    xslots, yslots;
    int    xshift, yshift;
#if defined(DD_COUNT) || defined(DD_DEBUG)
    int    oldxkeys;
#endif
    int oldykeys;
    int    newxkeys, newykeys;
    int    comple, newcomplement;
    int    i;
    int    posn;
    int    isolated;
    DdNode *f,*f0,*f1,*f01,*f00,*f11,*f10,*newf1,*newf0;
    DdNode *g,*next,*last=NULL;
    DdNodePtr *previousP;
    DdNode *tmp;
    DdNode *sentinel = &(table->sentinel);
#ifdef DD_DEBUG
    int    count, idcheck;
#endif

#ifdef DD_DEBUG
    assert(x < y);
    assert(cuddNextHigh(table,x) == y);
    assert(table->subtables[x].keys != 0);
    assert(table->subtables[y].keys != 0);
    assert(table->subtables[x].dead == 0);
    assert(table->subtables[y].dead == 0);
#endif

    xindex = table->invperm[x];
    yindex = table->invperm[y];

    if (cuddTestInteract(table,xindex,yindex)) {
#ifdef DD_STATS
	table->totalNumberLinearTr++;
#endif
	/* Get parameters of x subtable. */
	xlist = table->subtables[x].nodelist;
#if defined(DD_COUNT) || defined(DD_DEBUG)
	oldxkeys = table->subtables[x].keys;
#endif
	xslots = table->subtables[x].slots;
	xshift = table->subtables[x].shift;

	/* Get parameters of y subtable. */
	ylist = table->subtables[y].nodelist;
	oldykeys = table->subtables[y].keys;
	yslots = table->subtables[y].slots;
	yshift = table->subtables[y].shift;

	newxkeys = 0;
	newykeys = oldykeys;

	/* Check whether the two projection functions involved in this
	** swap are isolated. At the end, we'll be able to tell how many
	** isolated projection functions are there by checking only these
	** two functions again. This is done to eliminate the isolated
	** projection functions from the node count.
	*/
	isolated = - ((table->vars[xindex]->ref == 1) +
		     (table->vars[yindex]->ref == 1));

	/* The nodes in the x layer are put in a chain.
	** The chain is handled as a FIFO; g points to the beginning and
	** last points to the end.
	*/
	g = NULL;
#ifdef DD_DEBUG
	last = NULL;
#endif
	for (i = 0; i < xslots; i++) {
	    f = xlist[i];
	    if (f == sentinel) continue;
	    xlist[i] = sentinel;
	    if (g == NULL) {
		g = f;
	    } else {
		last->next = f;
	    }
	    while ((next = f->next) != sentinel) {
		f = next;
	    } /* while there are elements in the collision chain */
	    last = f;
	} /* for each slot of the x subtable */
#ifdef DD_DEBUG
	/* last is always assigned in the for loop because there is at
	** least one key */
	assert(last != NULL);
#endif
	last->next = NULL;

#ifdef DD_COUNT
	table->swapSteps += oldxkeys;
#endif
	/* Take care of the x nodes that must be re-expressed.
	** They form a linked list pointed by g.
	*/
	f = g;
	while (f != NULL) {
	    next = f->next;
	    /* Find f1, f0, f11, f10, f01, f00. */
	    f1 = cuddT(f);
#ifdef DD_DEBUG
	    assert(!(Cudd_IsComplement(f1)));
#endif
	    if ((int) f1->index == yindex) {
		f11 = cuddT(f1); f10 = cuddE(f1);
	    } else {
		f11 = f10 = f1;
	    }
#ifdef DD_DEBUG
	    assert(!(Cudd_IsComplement(f11)));
#endif
	    f0 = cuddE(f);
	    comple = Cudd_IsComplement(f0);
	    f0 = Cudd_Regular(f0);
	    if ((int) f0->index == yindex) {
		f01 = cuddT(f0); f00 = cuddE(f0);
	    } else {
		f01 = f00 = f0;
	    }
	    if (comple) {
		f01 = Cudd_Not(f01);
		f00 = Cudd_Not(f00);
	    }
	    /* Decrease ref count of f1. */
	    cuddSatDec(f1->ref);
	    /* Create the new T child. */
	    if (f11 == f00) {
		newf1 = f11;
		cuddSatInc(newf1->ref);
	    } else {
		/* Check ylist for triple (yindex,f11,f00). */
		posn = ddHash(f11, f00, yshift);
		/* For each element newf1 in collision list ylist[posn]. */
		previousP = &(ylist[posn]);
		newf1 = *previousP;
		while (f11 < cuddT(newf1)) {
		    previousP = &(newf1->next);
		    newf1 = *previousP;
		}
		while (f11 == cuddT(newf1) && f00 < cuddE(newf1)) {
		    previousP = &(newf1->next);
		    newf1 = *previousP;
		}
		if (cuddT(newf1) == f11 && cuddE(newf1) == f00) {
		    cuddSatInc(newf1->ref);
		} else { /* no match */
		    newf1 = cuddDynamicAllocNode(table);
		    if (newf1 == NULL)
			goto cuddLinearOutOfMem;
		    newf1->index = yindex; newf1->ref = 1;
		    cuddT(newf1) = f11;
		    cuddE(newf1) = f00;
		    /* Insert newf1 in the collision list ylist[posn];
		    ** increase the ref counts of f11 and f00.
		    */
		    newykeys++;
		    newf1->next = *previousP;
		    *previousP = newf1;
		    cuddSatInc(f11->ref);
		    tmp = Cudd_Regular(f00);
		    cuddSatInc(tmp->ref);
		}
	    }
	    cuddT(f) = newf1;
#ifdef DD_DEBUG
	    assert(!(Cudd_IsComplement(newf1)));
#endif

	    /* Do the same for f0, keeping complement dots into account. */
	    /* decrease ref count of f0 */
	    tmp = Cudd_Regular(f0);
	    cuddSatDec(tmp->ref);
	    /* create the new E child */
	    if (f01 == f10) {
		newf0 = f01;
		tmp = Cudd_Regular(newf0);
		cuddSatInc(tmp->ref);
	    } else {
		/* make sure f01 is regular */
		newcomplement = Cudd_IsComplement(f01);
		if (newcomplement) {
		    f01 = Cudd_Not(f01);
		    f10 = Cudd_Not(f10);
		}
		/* Check ylist for triple (yindex,f01,f10). */
		posn = ddHash(f01, f10, yshift);
		/* For each element newf0 in collision list ylist[posn]. */
		previousP = &(ylist[posn]);
		newf0 = *previousP;
		while (f01 < cuddT(newf0)) {
		    previousP = &(newf0->next);
		    newf0 = *previousP;
		}
		while (f01 == cuddT(newf0) && f10 < cuddE(newf0)) {
		    previousP = &(newf0->next);
		    newf0 = *previousP;
		}
		if (cuddT(newf0) == f01 && cuddE(newf0) == f10) {
		    cuddSatInc(newf0->ref);
		} else { /* no match */
		    newf0 = cuddDynamicAllocNode(table);
		    if (newf0 == NULL)
			goto cuddLinearOutOfMem;
		    newf0->index = yindex; newf0->ref = 1;
		    cuddT(newf0) = f01;
		    cuddE(newf0) = f10;
		    /* Insert newf0 in the collision list ylist[posn];
		    ** increase the ref counts of f01 and f10.
		    */
		    newykeys++;
		    newf0->next = *previousP;
		    *previousP = newf0;
		    cuddSatInc(f01->ref);
		    tmp = Cudd_Regular(f10);
		    cuddSatInc(tmp->ref);
		}
		if (newcomplement) {
		    newf0 = Cudd_Not(newf0);
		}
	    }
	    cuddE(f) = newf0;

	    /* Re-insert the modified f in xlist.
	    ** The modified f does not already exists in xlist.
	    ** (Because of the uniqueness of the cofactors.)
	    */
	    posn = ddHash(newf1, newf0, xshift);
	    newxkeys++;
	    previousP = &(xlist[posn]);
	    tmp = *previousP;
	    while (newf1 < cuddT(tmp)) {
		previousP = &(tmp->next);
		tmp = *previousP;
	    }
	    while (newf1 == cuddT(tmp) && newf0 < cuddE(tmp)) {
		previousP = &(tmp->next);
		tmp = *previousP;
	    }
	    f->next = *previousP;
	    *previousP = f;
	    f = next;
	} /* while f != NULL */

	/* GC the y layer. */

	/* For each node f in ylist. */
	for (i = 0; i < yslots; i++) {
	    previousP = &(ylist[i]);
	    f = *previousP;
	    while (f != sentinel) {
		next = f->next;
		if (f->ref == 0) {
		    tmp = cuddT(f);
		    cuddSatDec(tmp->ref);
		    tmp = Cudd_Regular(cuddE(f));
		    cuddSatDec(tmp->ref);
		    cuddDeallocNode(table,f);
		    newykeys--;
		} else {
		    *previousP = f;
		    previousP = &(f->next);
		}
		f = next;
	    } /* while f */
	    *previousP = sentinel;
	} /* for every collision list */

#ifdef DD_DEBUG
#if 0
	(void) fprintf(table->out,"Linearly combining %d and %d\n",x,y);
#endif
	count = 0;
	idcheck = 0;
	for (i = 0; i < yslots; i++) {
	    f = ylist[i];
	    while (f != sentinel) {
		count++;
		if (f->index != (DdHalfWord) yindex)
		    idcheck++;
		f = f->next;
	    }
	}
	if (count != newykeys) {
	    fprintf(table->err,"Error in finding newykeys\toldykeys = %d\tnewykeys = %d\tactual = %d\n",oldykeys,newykeys,count);
	}
	if (idcheck != 0)
	    fprintf(table->err,"Error in id's of ylist\twrong id's = %d\n",idcheck);
	count = 0;
	idcheck = 0;
	for (i = 0; i < xslots; i++) {
	    f = xlist[i];
	    while (f != sentinel) {
		count++;
		if (f->index != (DdHalfWord) xindex)
		    idcheck++;
		f = f->next;
	    }
	}
	if (count != newxkeys || newxkeys != oldxkeys) {
	    fprintf(table->err,"Error in finding newxkeys\toldxkeys = %d \tnewxkeys = %d \tactual = %d\n",oldxkeys,newxkeys,count);
	}
	if (idcheck != 0)
	    fprintf(table->err,"Error in id's of xlist\twrong id's = %d\n",idcheck);
#endif

	isolated += (table->vars[xindex]->ref == 1) +
		    (table->vars[yindex]->ref == 1);
	table->isolated += (unsigned int) isolated;

	/* Set the appropriate fields in table. */
	table->subtables[y].keys = newykeys;

	/* Here we should update the linear combination table
	** to record that x <- x EXNOR y. This is done by complementing
	** the (x,y) entry of the table.
	*/

	table->keys += newykeys - oldykeys;

	cuddXorLinear(table,xindex,yindex);
    }

#ifdef DD_DEBUG
    if (table->enableExtraDebug) {
	(void) Cudd_DebugCheck(table);
    }
#endif

    return((int) (table->keys - table->isolated));

cuddLinearOutOfMem:
    (void) fprintf(table->err,"Error: cuddLinearInPlace out of memory\n");

    return (0);

} /* end of cuddLinearInPlace */


/**
  @brief Updates the interaction matrix.

  @sideeffect none

*/
void
cuddUpdateInteractionMatrix(
  DdManager * table,
  int  xindex,
  int  yindex)
{
    int i;
    for (i = 0; i < yindex; i++) {
	if (i != xindex && cuddTestInteract(table,i,yindex)) {
	    if (i < xindex) {
		cuddSetInteract(table,i,xindex);
	    } else {
		cuddSetInteract(table,xindex,i);
	    }
	}
    }
    for (i = yindex+1; i < table->size; i++) {
	if (i != xindex && cuddTestInteract(table,yindex,i)) {
	    if (i < xindex) {
		cuddSetInteract(table,i,xindex);
	    } else {
		cuddSetInteract(table,xindex,i);
	    }
	}
    }

} /* end of cuddUpdateInteractionMatrix */


/**
  @brief Initializes the linear transform matrix.

  @return 1 if successful; 0 otherwise.

  @sideeffect none

*/
int
cuddInitLinear(
  DdManager * table)
{
    int words;
    int wordsPerRow;
    int nvars;
    int word;
    int bit;
    int i;
    ptruint *linear;

    nvars = table->size;
    wordsPerRow = ((nvars - 1) >> LOGBPL) + 1;
    words = wordsPerRow * nvars;
    table->linear = linear = ALLOC(ptruint,words);
    if (linear == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    table->memused += words * sizeof(ptruint);
    table->linearSize = nvars;
    for (i = 0; i < words; i++) linear[i] = 0;
    for (i = 0; i < nvars; i++) {
	word = wordsPerRow * i + (i >> LOGBPL);
	bit  = i & (BPL-1);
	linear[word] = (ptruint) 1 << bit;
    }
    return(1);

} /* end of cuddInitLinear */


/**
  @brief Resizes the linear transform matrix.

  @return 1 if successful; 0 otherwise.

  @sideeffect none

*/
int
cuddResizeLinear(
  DdManager * table)
{
    int words,oldWords;
    int wordsPerRow,oldWordsPerRow;
    int nvars,oldNvars;
    int word,oldWord;
    int bit;
    int i,j;
    ptruint *linear,*oldLinear;

    oldNvars = table->linearSize;
    oldWordsPerRow = ((oldNvars - 1) >> LOGBPL) + 1;
    oldWords = oldWordsPerRow * oldNvars;
    oldLinear = table->linear;

    nvars = table->size;
    wordsPerRow = ((nvars - 1) >> LOGBPL) + 1;
    words = wordsPerRow * nvars;
    table->linear = linear = ALLOC(ptruint,words);
    if (linear == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    table->memused += (words - oldWords) * sizeof(ptruint);
    for (i = 0; i < words; i++) linear[i] = 0;

    /* Copy old matrix. */
    for (i = 0; i < oldNvars; i++) {
	for (j = 0; j < oldWordsPerRow; j++) {
	    oldWord = oldWordsPerRow * i + j;
	    word = wordsPerRow * i + j;
	    linear[word] = oldLinear[oldWord];
	}
    }
    FREE(oldLinear);

    /* Add elements to the diagonal. */
    for (i = oldNvars; i < nvars; i++) {
	word = wordsPerRow * i + (i >> LOGBPL);
	bit  = i & (BPL-1);
	linear[word] = (ptruint) 1 << bit;
    }
    table->linearSize = nvars;

    return(1);

} /* end of cuddResizeLinear */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Comparison function used by qsort.

  @details Comparison function used by qsort to order the
  variables according to the number of keys in the subtables.

  @return the difference in number of keys between the two variables
  being compared.

  @sideeffect None

*/
static int
ddLinearUniqueCompare(
  void const * ptrX,
  void const * ptrY)
{
    IndexKey const * pX = (IndexKey const *) ptrX;
    IndexKey const * pY = (IndexKey const *) ptrY;
#if 0
    if (pY->keys == pX->keys) {
	return(pX->index - pY->index);
    }
#endif
    return(pY->keys - pX->keys);

} /* end of ddLinearUniqueCompare */


/**
  @brief Given xLow <= x <= xHigh moves x up and down between the
  boundaries.

  @details At each step a linear transformation is tried, and, if it
  decreases the size of the %DD, it is accepted. Finds the best position
  and does the required changes.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddLinearAndSiftingAux(
  DdManager * table,
  int  x,
  int  xLow,
  int  xHigh)
{

    Move	*move;
    Move	*moveUp;		/* list of up moves */
    Move	*moveDown;		/* list of down moves */
    int		initialSize;
    int		result;

    initialSize = (int) (table->keys - table->isolated);

    moveDown = NULL;
    moveUp = NULL;

    if (x == xLow) {
	moveDown = ddLinearAndSiftingDown(table,x,xHigh,NULL);
	/* At this point x --> xHigh unless bounding occurred. */
	if (moveDown == (Move *) CUDD_OUT_OF_MEM) goto ddLinearAndSiftingAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = ddLinearAndSiftingBackward(table,initialSize,moveDown);
	if (!result) goto ddLinearAndSiftingAuxOutOfMem;

    } else if (x == xHigh) {
	moveUp = ddLinearAndSiftingUp(table,x,xLow,NULL);
	/* At this point x --> xLow unless bounding occurred. */
	if (moveUp == (Move *) CUDD_OUT_OF_MEM) goto ddLinearAndSiftingAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = ddLinearAndSiftingBackward(table,initialSize,moveUp);
	if (!result) goto ddLinearAndSiftingAuxOutOfMem;

    } else if ((x - xLow) > (xHigh - x)) { /* must go down first: shorter */
	moveDown = ddLinearAndSiftingDown(table,x,xHigh,NULL);
	/* At this point x --> xHigh unless bounding occurred. */
	if (moveDown == (Move *) CUDD_OUT_OF_MEM) goto ddLinearAndSiftingAuxOutOfMem;
	moveUp = ddUndoMoves(table,moveDown);
#ifdef DD_DEBUG
	assert(moveUp == NULL || moveUp->x == (DdHalfWord) x);
#endif
	moveUp = ddLinearAndSiftingUp(table,x,xLow,moveUp);
	if (moveUp == (Move *) CUDD_OUT_OF_MEM) goto ddLinearAndSiftingAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = ddLinearAndSiftingBackward(table,initialSize,moveUp);
	if (!result) goto ddLinearAndSiftingAuxOutOfMem;

    } else { /* must go up first: shorter */
	moveUp = ddLinearAndSiftingUp(table,x,xLow,NULL);
	/* At this point x --> xLow unless bounding occurred. */
	if (moveUp == (Move *) CUDD_OUT_OF_MEM) goto ddLinearAndSiftingAuxOutOfMem;
	moveDown = ddUndoMoves(table,moveUp);
#ifdef DD_DEBUG
	assert(moveDown == NULL || moveDown->y == (DdHalfWord) x);
#endif
	moveDown = ddLinearAndSiftingDown(table,x,xHigh,moveDown);
	if (moveDown == (Move *) CUDD_OUT_OF_MEM) goto ddLinearAndSiftingAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = ddLinearAndSiftingBackward(table,initialSize,moveDown);
	if (!result) goto ddLinearAndSiftingAuxOutOfMem;
    }

    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(1);

ddLinearAndSiftingAuxOutOfMem:
    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(0);

} /* end of ddLinearAndSiftingAux */


/**
  @brief Sifts a variable up and applies linear transformations.

  @details Moves y up until either it reaches the bound (xLow) or the
  size of the %DD heap increases too much.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
ddLinearAndSiftingUp(
  DdManager * table,
  int  y,
  int  xLow,
  Move * prevMoves)
{
    Move	*moves;
    Move	*move;
    int		x;
    int		size, newsize;
    int		limitSize;
    int		xindex, yindex;
    int		isolated;
    int		L;	/* lower bound on DD size */
#ifdef DD_DEBUG
    int checkL;
    int z;
    int zindex;
#endif

    moves = prevMoves;
    yindex = table->invperm[y];

    /* Initialize the lower bound.
    ** The part of the DD below y will not change.
    ** The part of the DD above y that does not interact with y will not
    ** change. The rest may vanish in the best case, except for
    ** the nodes at level xLow, which will not vanish, regardless.
    */
    limitSize = L = (int) (table->keys - table->isolated);
    for (x = xLow + 1; x < y; x++) {
	xindex = table->invperm[x];
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[xindex]->ref == 1;
	    L -= (int) table->subtables[x].keys - isolated;
	}
    }
    isolated = table->vars[yindex]->ref == 1;
    L -= (int) table->subtables[y].keys - isolated;

    x = cuddNextLow(table,y);
    while (x >= xLow && L <= limitSize) {
	xindex = table->invperm[x];
#ifdef DD_DEBUG
	checkL = table->keys - table->isolated;
	for (z = xLow + 1; z < y; z++) {
	    zindex = table->invperm[z];
	    if (cuddTestInteract(table,zindex,yindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkL -= table->subtables[z].keys - isolated;
	    }
	}
	isolated = table->vars[yindex]->ref == 1;
	checkL -= table->subtables[y].keys - isolated;
	if (L != checkL) {
	    (void) fprintf(table->out, "checkL(%d) != L(%d)\n",checkL,L);
	}
#endif
	size = cuddSwapInPlace(table,x,y);
	if (size == 0) goto ddLinearAndSiftingUpOutOfMem;
	newsize = cuddLinearInPlace(table,x,y);
	if (newsize == 0) goto ddLinearAndSiftingUpOutOfMem;
	move = (Move *) cuddDynamicAllocNode(table);
	if (move == NULL) goto ddLinearAndSiftingUpOutOfMem;
	move->x = x;
	move->y = y;
	move->next = moves;
	moves = move;
	move->flags = CUDD_SWAP_MOVE;
	if (newsize >= size) {
	    /* Undo transformation. The transformation we apply is
	    ** its own inverse. Hence, we just apply the transformation
	    ** again.
	    */
	    newsize = cuddLinearInPlace(table,x,y);
	    if (newsize == 0) goto ddLinearAndSiftingUpOutOfMem;
#ifdef DD_DEBUG
	    if (newsize != size) {
		(void) fprintf(table->out,"Change in size after identity transformation! From %d to %d\n",size,newsize);
	    }
#endif
	} else if (cuddTestInteract(table,xindex,yindex)) {
	    size = newsize;
	    move->flags = CUDD_LINEAR_TRANSFORM_MOVE;
	    cuddUpdateInteractionMatrix(table,xindex,yindex);
	}
	move->size = size;
	/* Update the lower bound. */
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[xindex]->ref == 1;
	    L += (int) table->subtables[y].keys - isolated;
	}
	if ((double) size > (double) limitSize * table->maxGrowth) break;
	if (size < limitSize) limitSize = size;
	y = x;
	x = cuddNextLow(table,y);
    }
    return(moves);

ddLinearAndSiftingUpOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of ddLinearAndSiftingUp */


/**
  @brief Sifts a variable down and applies linear transformations.

  @details Moves x down until either it reaches the bound (xHigh) or
  the size of the %DD heap increases too much.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
ddLinearAndSiftingDown(
  DdManager * table,
  int  x,
  int  xHigh,
  Move * prevMoves)
{
    Move	*moves;
    Move	*move;
    int		y;
    int		size, newsize;
    int		R;	/* upper bound on node decrease */
    int		limitSize;
    int		xindex, yindex;
    int		isolated;
#ifdef DD_DEBUG
    int		checkR;
    int		z;
    int		zindex;
#endif

    moves = prevMoves;
    /* Initialize R */
    xindex = table->invperm[x];
    limitSize = size = table->keys - table->isolated;
    R = 0;
    for (y = xHigh; y > x; y--) {
	yindex = table->invperm[y];
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[yindex]->ref == 1;
	    R += table->subtables[y].keys - isolated;
	}
    }

    y = cuddNextHigh(table,x);
    while (y <= xHigh && size - R < limitSize) {
#ifdef DD_DEBUG
	checkR = 0;
	for (z = xHigh; z > x; z--) {
	    zindex = table->invperm[z];
	    if (cuddTestInteract(table,xindex,zindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkR += (int) table->subtables[z].keys - isolated;
	    }
	}
	if (R != checkR) {
	    (void) fprintf(table->out, "checkR(%d) != R(%d)\n",checkR,R);
	}
#endif
	/* Update upper bound on node decrease. */
	yindex = table->invperm[y];
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[yindex]->ref == 1;
	    R -= (int) table->subtables[y].keys - isolated;
	}
	size = cuddSwapInPlace(table,x,y);
	if (size == 0) goto ddLinearAndSiftingDownOutOfMem;
	newsize = cuddLinearInPlace(table,x,y);
	if (newsize == 0) goto ddLinearAndSiftingDownOutOfMem;
	move = (Move *) cuddDynamicAllocNode(table);
	if (move == NULL) goto ddLinearAndSiftingDownOutOfMem;
	move->x = x;
	move->y = y;
	move->next = moves;
	moves = move;
	move->flags = CUDD_SWAP_MOVE;
	if (newsize >= size) {
	    /* Undo transformation. The transformation we apply is
	    ** its own inverse. Hence, we just apply the transformation
	    ** again.
	    */
	    newsize = cuddLinearInPlace(table,x,y);
	    if (newsize == 0) goto ddLinearAndSiftingDownOutOfMem;
	    if (newsize != size) {
		(void) fprintf(table->out,"Change in size after identity transformation! From %d to %d\n",size,newsize);
	    }
	} else if (cuddTestInteract(table,xindex,yindex)) {
	    size = newsize;
	    move->flags = CUDD_LINEAR_TRANSFORM_MOVE;
	    cuddUpdateInteractionMatrix(table,xindex,yindex);
	}
	move->size = size;
	if ((double) size > (double) limitSize * table->maxGrowth) break;
	if (size < limitSize) limitSize = size;
	x = y;
	y = cuddNextHigh(table,x);
    }
    return(moves);

ddLinearAndSiftingDownOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of ddLinearAndSiftingDown */


/**
  @brief Given a set of moves, returns the %DD heap to the order
  giving the minimum size.

  @details In case of ties, returns to the closest position giving the
  minimum size.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddLinearAndSiftingBackward(
  DdManager * table,
  int  size,
  Move * moves)
{
    Move *move;
    int	res;

    for (move = moves; move != NULL; move = move->next) {
	if (move->size < size) {
	    size = move->size;
	}
    }

    for (move = moves; move != NULL; move = move->next) {
	if (move->size == size) return(1);
	if (move->flags == CUDD_LINEAR_TRANSFORM_MOVE) {
	    res = cuddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!res) return(0);
	}
	res = cuddSwapInPlace(table,(int)move->x,(int)move->y);
	if (!res) return(0);
	if (move->flags == CUDD_INVERSE_TRANSFORM_MOVE) {
	    res = cuddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!res) return(0);
	}
    }

    return(1);

} /* end of ddLinearAndSiftingBackward */


/**
  @brief Given a set of moves, returns the %DD heap to the order
  in effect before the moves.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static Move*
ddUndoMoves(
  DdManager * table,
  Move * moves)
{
    Move *invmoves = NULL;
    Move *move;
    Move *invmove;
    int	size;

    for (move = moves; move != NULL; move = move->next) {
	invmove = (Move *) cuddDynamicAllocNode(table);
	if (invmove == NULL) goto ddUndoMovesOutOfMem;
	invmove->x = move->x;
	invmove->y = move->y;
	invmove->next = invmoves;
	invmoves = invmove;
	if (move->flags == CUDD_SWAP_MOVE) {
	    invmove->flags = CUDD_SWAP_MOVE;
	    size = cuddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto ddUndoMovesOutOfMem;
	} else if (move->flags == CUDD_LINEAR_TRANSFORM_MOVE) {
	    invmove->flags = CUDD_INVERSE_TRANSFORM_MOVE;
	    size = cuddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto ddUndoMovesOutOfMem;
	    size = cuddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto ddUndoMovesOutOfMem;
	} else { /* must be CUDD_INVERSE_TRANSFORM_MOVE */
#ifdef DD_DEBUG
	    (void) fprintf(table->err,"Unforseen event in ddUndoMoves!\n");
#endif
	    invmove->flags = CUDD_LINEAR_TRANSFORM_MOVE;
	    size = cuddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto ddUndoMovesOutOfMem;
	    size = cuddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto ddUndoMovesOutOfMem;
	}
	invmove->size = size;
    }

    return(invmoves);

ddUndoMovesOutOfMem:
    while (invmoves != NULL) {
	move = invmoves->next;
	cuddDeallocMove(table, invmoves);
	invmoves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of ddUndoMoves */


/**
  @brief XORs two rows of the linear transform matrix.

  @details Replaces the first row with the result.

  @sideeffect none

*/
static void
cuddXorLinear(
  DdManager * table,
  int  x,
  int  y)
{
    int i;
    int nvars = table->size;
    int wordsPerRow = ((nvars - 1) >> LOGBPL) + 1;
    int xstart = wordsPerRow * x;
    int ystart = wordsPerRow * y;
    ptruint *linear = table->linear;

    for (i = 0; i < wordsPerRow; i++) {
	linear[xstart+i] ^= linear[ystart+i];
    }

} /* end of cuddXorLinear */

cuddLiteral.c
7710
/**
  @file

  @ingroup cudd

  @brief Functions for manipulation of literal sets represented by BDDs.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes the intesection of two sets of literals
  represented as BDDs.

  @details Each set is represented as a cube of the literals in the
  set. The empty set is represented by the constant 1.  No variable
  can be simultaneously present in both phases in a set.

  @return a pointer to the %BDD representing the intersected sets, if
  successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_bddLiteralSetIntersection(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddBddLiteralSetIntersectionRecur(dd,f,g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddLiteralSetIntersection */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of
  Cudd_bddLiteralSetIntersection.

  @details Scans the cubes for common variables, and checks whether
  they agree in phase.

  @return a pointer to the resulting cube if successful; NULL
  otherwise.

  @sideeffect None

*/
DdNode *
cuddBddLiteralSetIntersectionRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode *res, *tmp;
    DdNode *F, *G;
    DdNode *fc, *gc;
    DdNode *one;
    DdNode *zero;
    int topf, topg, comple;
    int phasef, phaseg;

    statLine(dd);
    if (f == g) return(f);

    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    one = DD_ONE(dd);

    /* Here f != g. If F == G, then f and g are complementary.
    ** Since they are two cubes, this case only occurs when f == v,
    ** g == v', and v is a variable or its complement.
    */
    if (F == G) return(one);

    zero = Cudd_Not(one);
    topf = cuddI(dd,F->index);
    topg = cuddI(dd,G->index);
    /* Look for a variable common to both cubes. If there are none, this
    ** loop will stop when the constant node is reached in both cubes.
    */
    while (topf != topg) {
	if (topf < topg) {	/* move down on f */
	    comple = f != F;
	    f = cuddT(F);
	    if (comple) f = Cudd_Not(f);
	    if (f == zero) {
		f = cuddE(F);
		if (comple) f = Cudd_Not(f);
	    }
	    F = Cudd_Regular(f);
	    topf = cuddI(dd,F->index);
	} else if (topg < topf) {
	    comple = g != G;
	    g = cuddT(G);
	    if (comple) g = Cudd_Not(g);
	    if (g == zero) {
		g = cuddE(G);
		if (comple) g = Cudd_Not(g);
	    }
	    G = Cudd_Regular(g);
	    topg = cuddI(dd,G->index);
	}
    }

    /* At this point, f == one <=> g == 1. It suffices to test one of them. */
    if (f == one) return(one);

    res = cuddCacheLookup2(dd,Cudd_bddLiteralSetIntersection,f,g);
    if (res != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(dd);

    /* Here f and g are both non constant and have the same top variable. */
    comple = f != F;
    fc = cuddT(F);
    phasef = 1;
    if (comple) fc = Cudd_Not(fc);
    if (fc == zero) {
	fc = cuddE(F);
	phasef = 0;
	if (comple) fc = Cudd_Not(fc);
    }
    comple = g != G;
    gc = cuddT(G);
    phaseg = 1;
    if (comple) gc = Cudd_Not(gc);
    if (gc == zero) {
	gc = cuddE(G);
	phaseg = 0;
	if (comple) gc = Cudd_Not(gc);
    }

    tmp = cuddBddLiteralSetIntersectionRecur(dd,fc,gc);
    if (tmp == NULL) {
	return(NULL);
    }

    if (phasef != phaseg) {
	res = tmp;
    } else {
	cuddRef(tmp);
	if (phasef == 0) {
	    res = cuddBddAndRecur(dd,Cudd_Not(dd->vars[F->index]),tmp);
	} else {
	    res = cuddBddAndRecur(dd,dd->vars[F->index],tmp);
	}
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd,tmp);
	    return(NULL);
	}
	cuddDeref(tmp); /* Just cuddDeref, because it is included in result */
    }

    cuddCacheInsert2(dd,Cudd_bddLiteralSetIntersection,f,g,res);

    return(res);

} /* end of cuddBddLiteralSetIntersectionRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


cuddMatMult.c
18676
/**
  @file

  @ingroup cudd

  @brief Matrix multiplication functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * addMMRecur (DdManager *dd, DdNode *A, DdNode *B, int topP, int *vars);
static DdNode * addTriangleRecur (DdManager *dd, DdNode *f, DdNode *g, int *vars, DdNode *cube);
static DdNode * cuddAddOuterSumRecur (DdManager *dd, DdNode *M, DdNode *r, DdNode *c);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Calculates the product of two matrices represented as
  ADDs.

  @details This procedure implements the quasiring multiplication
  algorithm.  A is assumed to depend on variables x (rows) and z
  (columns).  B is assumed to depend on variables z (rows) and y
  (columns).  The product of A and B then depends on x (rows) and y
  (columns).  Only the z variables have to be explicitly identified;
  they are the "summation" variables.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addTimesPlus Cudd_addTriangle Cudd_bddAndAbstract

*/
DdNode *
Cudd_addMatrixMultiply(
  DdManager * dd,
  DdNode * A,
  DdNode * B,
  DdNode ** z,
  int  nz)
{
    int i, nvars, *vars;
    DdNode *res; 

    /* Array vars says what variables are "summation" variables. */
    nvars = dd->size;
    vars = ALLOC(int,nvars);
    if (vars == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < nvars; i++) {
        vars[i] = 0;
    }
    for (i = 0; i < nz; i++) {
        vars[z[i]->index] = 1;
    }

    do {
	dd->reordered = 0;
	res = addMMRecur(dd,A,B,-1,vars);
    } while (dd->reordered == 1);
    FREE(vars);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addMatrixMultiply */


/**
  @brief Calculates the product of two matrices represented as
  ADDs.

  @details Calculates the product of two matrices, A and B,
  represented as ADDs, using the CMU matrix by matrix multiplication
  procedure by Clarke et al..  Matrix A has x's as row variables and
  z's as column variables, while matrix B has z's as row variables and
  y's as column variables.  The resulting matrix has x's as row
  variables and y's as column variables.

  @return the pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addMatrixMultiply

*/
DdNode *
Cudd_addTimesPlus(
  DdManager * dd,
  DdNode * A,
  DdNode * B,
  DdNode ** z,
  int  nz)
{
    DdNode *w, *cube, *tmp, *res; 
    int i;
    tmp = Cudd_addApply(dd,Cudd_addTimes,A,B);
    if (tmp == NULL) return(NULL);
    Cudd_Ref(tmp);
    Cudd_Ref(cube = DD_ONE(dd));
    for (i = nz-1; i >= 0; i--) {
	 w = Cudd_addIte(dd,z[i],cube,DD_ZERO(dd));
	 if (w == NULL) {
	    Cudd_RecursiveDeref(dd,tmp);
	    return(NULL);
	 }
	 Cudd_Ref(w);
	 Cudd_RecursiveDeref(dd,cube);
	 cube = w;
    }
    res = Cudd_addExistAbstract(dd,tmp,cube);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd,tmp);
	Cudd_RecursiveDeref(dd,cube);
	return(NULL);
    }
    Cudd_Ref(res);
    Cudd_RecursiveDeref(dd,cube);
    Cudd_RecursiveDeref(dd,tmp);
    Cudd_Deref(res);
    return(res);

} /* end of Cudd_addTimesPlus */


/**
  @brief Performs the triangulation step for the shortest path
  computation.

  @details Implements the semiring multiplication algorithm used in
  the triangulation step for the shortest path computation.  f
  is assumed to depend on variables x (rows) and z (columns).  g is
  assumed to depend on variables z (rows) and y (columns).  The product
  of f and g then depends on x (rows) and y (columns).  Only the z
  variables have to be explicitly identified; they are the
  "abstraction" variables.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addMatrixMultiply Cudd_bddAndAbstract

*/
DdNode *
Cudd_addTriangle(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode ** z,
  int  nz)
{
    int    i, nvars, *vars;
    DdNode *res, *cube;

    nvars = dd->size;
    vars = ALLOC(int, nvars);
    if (vars == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < nvars; i++) vars[i] = -1;
    for (i = 0; i < nz; i++) vars[z[i]->index] = i;
    cube = Cudd_addComputeCube(dd, z, NULL, nz);
    if (cube == NULL) {
	FREE(vars);
	return(NULL);
    }
    cuddRef(cube);

    do {
	dd->reordered = 0;
	res = addTriangleRecur(dd, f, g, vars, cube);
    } while (dd->reordered == 1);
    if (res != NULL) cuddRef(res);
    Cudd_RecursiveDeref(dd,cube);
    if (res != NULL) cuddDeref(res);
    FREE(vars);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addTriangle */


/**
  @brief Takes the minimum of a matrix and the outer sum of two vectors.

  @details Takes the pointwise minimum of a matrix and the outer
  sum of two vectors.  This procedure is used in the Floyd-Warshall
  all-pair shortest path algorithm.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_addOuterSum(
  DdManager *dd,
  DdNode *M,
  DdNode *r,
  DdNode *c)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddAddOuterSumRecur(dd, M, r, c);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_addOuterSum */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
  @brief Performs the recursive step of Cudd_addMatrixMultiply.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
addMMRecur(
  DdManager * dd,
  DdNode * A,
  DdNode * B,
  int  topP,
  int * vars)
{
    DdNode *zero,
           *At,		/* positive cofactor of first operand */
	   *Ae,		/* negative cofactor of first operand */
	   *Bt,		/* positive cofactor of second operand */
	   *Be,		/* negative cofactor of second operand */
	   *t,		/* positive cofactor of result */
	   *e,		/* negative cofactor of result */
	   *scaled,	/* scaled result */
	   *add_scale,	/* ADD representing the scaling factor */
	   *res;
    int	i;		/* loop index */
    double scale;	/* scaling factor */
    int index;		/* index of the top variable */
    CUDD_VALUE_TYPE value;
    int topA, topB, topV;
    DD_CTFP cacheOp;

    statLine(dd);
    zero = DD_ZERO(dd);

    if (A == zero || B == zero) {
        return(zero);
    }

    if (cuddIsConstant(A) && cuddIsConstant(B)) {
	/* Compute the scaling factor. It is 2^k, where k is the
	** number of summation variables below the current variable.
	** Indeed, these constants represent blocks of 2^k identical
	** constant values in both A and B.
	*/
	value = cuddV(A) * cuddV(B);
	for (i = 0; i < dd->size; i++) {
	    if (vars[i]) {
		if (dd->perm[i] > topP) {
		    value *= (CUDD_VALUE_TYPE) 2;
		}
	    }
	}
	res = cuddUniqueConst(dd, value);
	return(res);
    }

    /* Standardize to increase cache efficiency. Clearly, A*B != B*A
    ** in matrix multiplication. However, which matrix is which is
    ** determined by the variables appearing in the ADDs and not by
    ** which one is passed as first argument.
    */
    if (A > B) {
	DdNode *tmp = A;
	A = B;
	B = tmp;
    }

    topA = cuddI(dd,A->index); topB = cuddI(dd,B->index);
    topV = ddMin(topA,topB);

    cacheOp = (DD_CTFP) addMMRecur;
    res = cuddCacheLookup2(dd,cacheOp,A,B);
    if (res != NULL) {
	/* If the result is 0, there is no need to normalize.
	** Otherwise we count the number of z variables between
	** the current depth and the top of the ADDs. These are
	** the missing variables that determine the size of the
	** constant blocks.
	*/
	if (res == zero) return(res);
	scale = 1.0;
	for (i = 0; i < dd->size; i++) {
	    if (vars[i]) {
		if (dd->perm[i] > topP && dd->perm[i] < topV) {
		    scale *= 2;
		}
	    }
	}
	if (scale > 1.0) {
	    cuddRef(res);
	    add_scale = cuddUniqueConst(dd,(CUDD_VALUE_TYPE)scale);
	    if (add_scale == NULL) {
		Cudd_RecursiveDeref(dd, res);
		return(NULL);
	    }
	    cuddRef(add_scale);
	    scaled = cuddAddApplyRecur(dd,Cudd_addTimes,res,add_scale);
	    if (scaled == NULL) {
		Cudd_RecursiveDeref(dd, add_scale);
		Cudd_RecursiveDeref(dd, res);
		return(NULL);
	    }
	    cuddRef(scaled);
	    Cudd_RecursiveDeref(dd, add_scale);
	    Cudd_RecursiveDeref(dd, res);
	    res = scaled;
	    cuddDeref(res);
	}
        return(res);
    }

    checkWhetherToGiveUp(dd);

    /* compute the cofactors */
    if (topV == topA) {
	At = cuddT(A);
	Ae = cuddE(A);
    } else {
	At = Ae = A;
    }
    if (topV == topB) {
	Bt = cuddT(B);
	Be = cuddE(B);
    } else {
	Bt = Be = B;
    }

    t = addMMRecur(dd, At, Bt, (int)topV, vars);
    if (t == NULL) return(NULL);
    cuddRef(t);
    e = addMMRecur(dd, Ae, Be, (int)topV, vars);
    if (e == NULL) {
	Cudd_RecursiveDeref(dd, t);
	return(NULL);
    }
    cuddRef(e);

    index = dd->invperm[topV];
    if (vars[index] == 0) {
	/* We have split on either the rows of A or the columns
	** of B. We just need to connect the two subresults,
	** which correspond to two submatrices of the result.
	*/
	res = (t == e) ? t : cuddUniqueInter(dd,index,t,e);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    Cudd_RecursiveDeref(dd, e);
	    return(NULL);
	}
	cuddRef(res);
	cuddDeref(t);
	cuddDeref(e);
    } else {
	/* we have simultaneously split on the columns of A and
	** the rows of B. The two subresults must be added.
	*/
	res = cuddAddApplyRecur(dd,Cudd_addPlus,t,e);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    Cudd_RecursiveDeref(dd, e);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDeref(dd, t);
	Cudd_RecursiveDeref(dd, e);
    }

    cuddCacheInsert2(dd,cacheOp,A,B,res);

    /* We have computed (and stored in the computed table) a minimal
    ** result; that is, a result that assumes no summation variables
    ** between the current depth of the recursion and its top
    ** variable. We now take into account the z variables by properly
    ** scaling the result.
    */
    if (res != zero) {
	scale = 1.0;
	for (i = 0; i < dd->size; i++) {
	    if (vars[i]) {
		if (dd->perm[i] > topP && dd->perm[i] < topV) {
		    scale *= 2;
		}
	    }
	}
	if (scale > 1.0) {
	    add_scale = cuddUniqueConst(dd,(CUDD_VALUE_TYPE)scale);
	    if (add_scale == NULL) {
		Cudd_RecursiveDeref(dd, res);
		return(NULL);
	    }
	    cuddRef(add_scale);
	    scaled = cuddAddApplyRecur(dd,Cudd_addTimes,res,add_scale);
	    if (scaled == NULL) {
		Cudd_RecursiveDeref(dd, res);
		Cudd_RecursiveDeref(dd, add_scale);
		return(NULL);
	    }
	    cuddRef(scaled);
	    Cudd_RecursiveDeref(dd, add_scale);
	    Cudd_RecursiveDeref(dd, res);
	    res = scaled;
	}
    }
    cuddDeref(res);
    return(res);

} /* end of addMMRecur */


/**
  @brief Performs the recursive step of Cudd_addTriangle.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
addTriangleRecur(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  int * vars,
  DdNode *cube)
{
    DdNode *fv, *fvn, *gv, *gvn, *t, *e, *res;
    CUDD_VALUE_TYPE value;
    int top, topf, topg, index;

    statLine(dd);
    if (f == DD_PLUS_INFINITY(dd) || g == DD_PLUS_INFINITY(dd)) {
	return(DD_PLUS_INFINITY(dd));
    }

    if (cuddIsConstant(f) && cuddIsConstant(g)) {
	value = cuddV(f) + cuddV(g);
	res = cuddUniqueConst(dd, value);
	return(res);
    }
    if (f < g) {
	DdNode *tmp = f;
	f = g;
	g = tmp;
    }

    if (f->ref != 1 || g->ref != 1) {
	res = cuddCacheLookup(dd, DD_ADD_TRIANGLE_TAG, f, g, cube);
	if (res != NULL) {
	    return(res);
	}
    }

    checkWhetherToGiveUp(dd);

    topf = cuddI(dd,f->index); topg = cuddI(dd,g->index);
    top = ddMin(topf,topg);

    if (top == topf) {fv = cuddT(f); fvn = cuddE(f);} else {fv = fvn = f;}
    if (top == topg) {gv = cuddT(g); gvn = cuddE(g);} else {gv = gvn = g;}

    t = addTriangleRecur(dd, fv, gv, vars, cube);
    if (t == NULL) return(NULL);
    cuddRef(t);
    e = addTriangleRecur(dd, fvn, gvn, vars, cube);
    if (e == NULL) {
	Cudd_RecursiveDeref(dd, t);
	return(NULL);
    }
    cuddRef(e);

    index = dd->invperm[top];
    if (vars[index] < 0) {
	res = (t == e) ? t : cuddUniqueInter(dd,index,t,e);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    Cudd_RecursiveDeref(dd, e);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    } else {
	res = cuddAddApplyRecur(dd,Cudd_addMinimum,t,e);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd, t);
	    Cudd_RecursiveDeref(dd, e);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDeref(dd, t);
	Cudd_RecursiveDeref(dd, e);
	cuddDeref(res);
    }

    if (f->ref != 1 || g->ref != 1) {
	cuddCacheInsert(dd, DD_ADD_TRIANGLE_TAG, f, g, cube, res);
    }

    return(res);

} /* end of addTriangleRecur */


/**
  @brief Performs the recursive step of Cudd_addOuterSum.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
cuddAddOuterSumRecur(
  DdManager *dd,
  DdNode *M,
  DdNode *r,
  DdNode *c)
{
    DdNode *P, *R, *Mt, *Me, *rt, *re, *ct, *ce, *Rt, *Re;
    int topM, topc, topr;
    int v, index;

    statLine(dd);
    /* Check special cases. */
    if (r == DD_PLUS_INFINITY(dd) || c == DD_PLUS_INFINITY(dd)) return(M); 

    if (cuddIsConstant(c) && cuddIsConstant(r)) {
	R = cuddUniqueConst(dd,Cudd_V(c)+Cudd_V(r));
	cuddRef(R);
	if (cuddIsConstant(M)) {
	    if (cuddV(R) <= cuddV(M)) {
		cuddDeref(R);
	        return(R);
	    } else {
	        Cudd_RecursiveDeref(dd,R);       
		return(M);
	    }
	} else {
	    P = Cudd_addApply(dd,Cudd_addMinimum,R,M);
	    cuddRef(P);
	    Cudd_RecursiveDeref(dd,R);
	    cuddDeref(P);
	    return(P);
	}
    }

    /* Check the cache. */
    R = cuddCacheLookup(dd,DD_ADD_OUT_SUM_TAG,M,r,c);
    if (R != NULL) return(R);

    checkWhetherToGiveUp(dd);

    topM = cuddI(dd,M->index); topr = cuddI(dd,r->index);
    topc = cuddI(dd,c->index);
    v = ddMin(topM,ddMin(topr,topc));

    /* Compute cofactors. */
    if (topM == v) { Mt = cuddT(M); Me = cuddE(M); } else { Mt = Me = M; }
    if (topr == v) { rt = cuddT(r); re = cuddE(r); } else { rt = re = r; }
    if (topc == v) { ct = cuddT(c); ce = cuddE(c); } else { ct = ce = c; }

    /* Recursively solve. */
    Rt = cuddAddOuterSumRecur(dd,Mt,rt,ct);
    if (Rt == NULL) return(NULL);
    cuddRef(Rt);
    Re = cuddAddOuterSumRecur(dd,Me,re,ce);
    if (Re == NULL) {
	Cudd_RecursiveDeref(dd, Rt);
	return(NULL);
    }
    cuddRef(Re);
    index = dd->invperm[v];
    R = (Rt == Re) ? Rt : cuddUniqueInter(dd,index,Rt,Re);
    if (R == NULL) {
	Cudd_RecursiveDeref(dd, Rt);
	Cudd_RecursiveDeref(dd, Re);
	return(NULL);
    }
    cuddDeref(Rt);
    cuddDeref(Re);

    /* Store the result in the cache. */
    cuddCacheInsert(dd,DD_ADD_OUT_SUM_TAG,M,r,c,R);

    return(R);

} /* end of cuddAddOuterSumRecur */

cuddObj.cc
118352
/**
  @file

  @ingroup cplusplus

  @brief Functions for the C++ object-oriented encapsulation of CUDD.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/
#include <iostream>
#include <sstream>
#include <cassert>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <stdexcept>
#include "epdInt.h"
#include "cuddInt.h"
#include "cuddObj.hh"

using std::cout;
using std::cerr;
using std::ostream;
using std::endl;
using std::hex;
using std::dec;
using std::string;
using std::vector;
using std::sort;

// ---------------------------------------------------------------------------
// Variable declarations
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// Members of class Capsule
// ---------------------------------------------------------------------------

/**
  @brief Class for reference counting of CUDD managers.

  @see Cudd DD ABDD ADD BDD ZDD

*/
class Capsule {
public:
    Capsule(unsigned int numVars, unsigned int numVarsZ,
            unsigned int numSlots, unsigned int cacheSize,
            unsigned long maxMemory, PFC defaultHandler);
    ~Capsule();
#if HAVE_MODERN_CXX == 1
    Capsule(Capsule const &) = delete;
    Capsule & operator=(Capsule const &) = delete;
#else
private:
    Capsule(Capsule const &); // not defined
    Capsule & operator=(Capsule const &); // not defined
public:
#endif
    DdManager *manager;
    PFC errorHandler;
    PFC timeoutHandler;
    PFC terminationHandler;
    std::vector<char *> varnames;
    int ref;
    bool verbose;
};


Capsule::Capsule(
  unsigned int numVars,
  unsigned int numVarsZ,
  unsigned int numSlots,
  unsigned int cacheSize,
  unsigned long maxMemory,
  PFC defaultHandler)
{
    errorHandler = defaultHandler;
    timeoutHandler = defaultHandler;
    terminationHandler = defaultHandler;
    manager = Cudd_Init(numVars, numVarsZ, numSlots, cacheSize, maxMemory);
    if (!manager)
        errorHandler("Out of memory");
    verbose = 0; // initially terse
    ref = 1;

} // Capsule::Capsule


Capsule::~Capsule()
{
#ifdef DD_DEBUG
    if (manager) {
        int retval = Cudd_CheckZeroRef(manager);
        if (retval != 0) {
            cerr << retval << " unexpected non-zero reference counts" << endl;
        } else if (verbose) {
            cerr << "All went well" << endl;
        }
    }
#endif
    for (vector<char *>::iterator it = varnames.begin();
         it != varnames.end(); ++it) {
        delete [] *it;
    }   
    Cudd_Quit(manager);

} // Capsule::~Capsule


// ---------------------------------------------------------------------------
// Members of class DD
// ---------------------------------------------------------------------------


DD::DD() : p(0), node(0) {}


DD::DD(Capsule *cap, DdNode *ddNode) : p(cap), node(ddNode) {
    if (node) Cudd_Ref(node);
    if (p->verbose) {
	cout << "Standard DD constructor for node " << hex << node << dec <<
	    " ref = " << Cudd_Regular(node)->ref << "\n";
    }

} // DD::DD


DD::DD(Cudd const & manager, DdNode *ddNode) : p(manager.p), node(ddNode) {
    checkReturnValue(ddNode);
    if (node) Cudd_Ref(node);
    if (p->verbose) {
	cout << "Standard DD constructor for node " << hex << node << dec <<
	    " ref = " << Cudd_Regular(node)->ref << "\n";
    }

} // DD::DD


DD::DD(const DD &from) {
    p = from.p;
    node = from.node;
    if (node) {
	Cudd_Ref(node);
	if (p->verbose) {
	    cout << "Copy DD constructor for node " << hex << node << dec <<
		" ref = " << Cudd_Regular(node)->ref << "\n";
	}
    }

} // DD::DD


DD::~DD() {}


inline DdManager *
DD::checkSameManager(
  const DD &other) const
{
    DdManager *mgr = p->manager;
    if (mgr != other.p->manager) {
	p->errorHandler("Operands come from different manager.");
    }
    return mgr;

} // DD::checkSameManager


inline void
DD::checkReturnValue(
  const void *result) const
{
    if (result == 0) {
	DdManager *mgr = p->manager;
	Cudd_ErrorType errType = Cudd_ReadErrorCode(mgr);
	switch (errType) {
	case CUDD_MEMORY_OUT:
	    p->errorHandler("Out of memory.");
	    break;
	case CUDD_TOO_MANY_NODES:
	    break;
	case CUDD_MAX_MEM_EXCEEDED:
	    p->errorHandler("Maximum memory exceeded.");
	    break;
        case CUDD_TIMEOUT_EXPIRED: 
            {
                std::ostringstream msg;
                unsigned long lag = 
                    Cudd_ReadElapsedTime(mgr) - Cudd_ReadTimeLimit(mgr);
                msg << "Timeout expired.  Lag = " << lag << " ms.";
                p->timeoutHandler(msg.str());
            }
	    break;
        case CUDD_TERMINATION:
            {
                std::ostringstream msg;
                msg << "Terminated.\n";
                p->terminationHandler(msg.str());
            }
            break;
	case CUDD_INVALID_ARG:
	    p->errorHandler("Invalid argument.");
	    break;
	case CUDD_INTERNAL_ERROR:
	    p->errorHandler("Internal error.");
	    break;
	case CUDD_NO_ERROR:
	    p->errorHandler("Unexpected error.");
	    break;
	}
    }

} // DD::checkReturnValue


inline void
DD::checkReturnValue(
  int result,
  int expected) const
{
    if (result != expected) {
	DdManager *mgr = p->manager;
	Cudd_ErrorType errType = Cudd_ReadErrorCode(mgr);
	switch (errType) {
	case CUDD_MEMORY_OUT:
	    p->errorHandler("Out of memory.");
	    break;
	case CUDD_TOO_MANY_NODES:
	    break;
	case CUDD_MAX_MEM_EXCEEDED:
	    p->errorHandler("Maximum memory exceeded.");
	    break;
        case CUDD_TIMEOUT_EXPIRED:
            {
                std::ostringstream msg;
                unsigned long lag = 
                    Cudd_ReadElapsedTime(mgr) - Cudd_ReadTimeLimit(mgr);
                msg << "Timeout expired.  Lag = " << lag << " ms.\n";
                p->timeoutHandler(msg.str());
            }
	    break;
        case CUDD_TERMINATION:
            {
                std::ostringstream msg;
                msg << "Terminated.\n";
                p->terminationHandler(msg.str());
            }
            break;
	case CUDD_INVALID_ARG:
	    p->errorHandler("Invalid argument.");
	    break;
	case CUDD_INTERNAL_ERROR:
	    p->errorHandler("Internal error.");
	    break;
	case CUDD_NO_ERROR:
	    p->errorHandler("Unexpected error.");
	    break;
	}
    }

} // DD::checkReturnValue


DdManager *
DD::manager() const
{
    return p->manager;

} // DD::manager


DdNode *
DD::getNode() const
{
    return node;

} // DD::getNode


DdNode *
DD::getRegularNode() const
{
    return Cudd_Regular(node);

} // DD::getRegularNode


int
DD::nodeCount() const
{
    return Cudd_DagSize(node);

} // DD::nodeCount


unsigned int
DD::NodeReadIndex() const
{
    return Cudd_NodeReadIndex(node);

} // DD::NodeReadIndex


// ---------------------------------------------------------------------------
// Members of class ABDD
// ---------------------------------------------------------------------------


ABDD::ABDD() : DD() {}
ABDD::ABDD(Capsule *cap, DdNode *bddNode) : DD(cap,bddNode) {}
ABDD::ABDD(Cudd const & manager, DdNode *bddNode) : DD(manager,bddNode) {}
ABDD::ABDD(const ABDD &from) : DD(from) {}


ABDD::~ABDD() {
    if (node) {
	Cudd_RecursiveDeref(p->manager,node);
	if (p->verbose) {
	    cout << "ADD/BDD destructor called for node " << hex << dec <<
		node << " ref = " << Cudd_Regular(node)->ref << "\n";
	}
    }

} // ABDD::~ABDD


bool
ABDD::operator==(
  const ABDD& other) const
{
    checkSameManager(other);
    return node == other.node;

} // ABDD::operator==


bool
ABDD::operator!=(
  const ABDD& other) const
{
    checkSameManager(other);
    return node != other.node;

} // ABDD::operator!=


bool
ABDD::IsOne() const
{
    return node == Cudd_ReadOne(p->manager);

} // ABDD::IsOne


void
ABDD::print(
  int nvars,
  int verbosity) const
{
    cout.flush();
    if (!node) defaultError("empty DD.");
    int retval = Cudd_PrintDebug(p->manager,node,nvars,verbosity);
    fflush(Cudd_ReadStdout(p->manager));
    checkReturnValue(retval);
    //if (retval == 0) p->errorHandler("print failed");

} // ABDD::print

void
ABDD::summary(
  int nvars,
  int mode) const
{
    cout.flush();
    if (!node) defaultError("empty DD.");
    int retval = Cudd_PrintSummary(p->manager,node,nvars,mode);
    fflush(Cudd_ReadStdout(p->manager));
    checkReturnValue(retval);

} // ABDD::summary

// ---------------------------------------------------------------------------
// Members of class BDD
// ---------------------------------------------------------------------------

BDD::BDD() : ABDD() {}
BDD::BDD(Capsule *cap, DdNode *bddNode) : ABDD(cap,bddNode) {}
BDD::BDD(Cudd const & manager, DdNode *bddNode) : ABDD(manager,bddNode) {}
BDD::BDD(const BDD &from) : ABDD(from) {}


BDD
BDD::operator=(
  const BDD& right)
{
    if (this == &right) return *this;
    if (right.node) Cudd_Ref(right.node);
    if (node) {
	Cudd_RecursiveDeref(p->manager,node);
	if (p->verbose) {
	    cout << "BDD dereferencing for node " << hex << node << dec <<
		" ref = " << Cudd_Regular(node)->ref << "\n";
	}
    }
    node = right.node;
    p = right.p;
    if (node && p->verbose) {
	cout << "BDD assignment for node " << hex << node << dec <<
	    " ref = " << Cudd_Regular(node)->ref << "\n";
    }
    return *this;

} // BDD::operator=


bool
BDD::operator<=(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return Cudd_bddLeq(mgr,node,other.node);

} // BDD::operator<=


bool
BDD::operator>=(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return Cudd_bddLeq(mgr,other.node,node);

} // BDD::operator>=


bool
BDD::operator<(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return node != other.node && Cudd_bddLeq(mgr,node,other.node);

} // BDD::operator<


bool
BDD::operator>(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return node != other.node && Cudd_bddLeq(mgr,other.node,node);

} // BDD::operator>


BDD
BDD::operator!() const
{
    return BDD(p, Cudd_Not(node));

} // BDD::operator!


BDD
BDD::operator~() const
{
    return BDD(p, Cudd_Not(node));

} // BDD::operator~


BDD
BDD::operator*(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddAnd(mgr,node,other.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::operator*


BDD
BDD::operator*=(
  const BDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddAnd(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // BDD::operator*=


BDD
BDD::operator&(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddAnd(mgr,node,other.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::operator&


BDD
BDD::operator&=(
  const BDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddAnd(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // BDD::operator&=


BDD
BDD::operator+(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddOr(mgr,node,other.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::operator+


BDD
BDD::operator+=(
  const BDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddOr(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // BDD::operator+=


BDD
BDD::operator|(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddOr(mgr,node,other.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::operator|


BDD
BDD::operator|=(
  const BDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddOr(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // BDD::operator|=


BDD
BDD::operator^(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddXor(mgr,node,other.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::operator^


BDD
BDD::operator^=(
  const BDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddXor(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // BDD::operator^=


BDD
BDD::operator-(
  const BDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddAnd(mgr,node,Cudd_Not(other.node));
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::operator-


BDD
BDD::operator-=(
  const BDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_bddAnd(mgr,node,Cudd_Not(other.node));
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // BDD::operator-=


ostream & operator<<(ostream & os, BDD const & f)
{
    if (!f.node) defaultError("empty DD.");
    DdManager *mgr = f.p->manager;
    vector<char *> const & vn = f.p->varnames;
    char const * const *inames = vn.size() == (size_t) Cudd_ReadSize(mgr) ?
        &vn[0] : 0;
    char * str = Cudd_FactoredFormString(mgr, f.node, inames);
    f.checkReturnValue(str);
    os << string(str);
    free(str);
    return os;

} // operator<<


bool
BDD::IsZero() const
{
    return node == Cudd_ReadLogicZero(p->manager);

} // BDD::IsZero


bool
BDD::IsVar() const
{
    return Cudd_bddIsVar(p->manager, node);

} // BDD::IsVar


// ---------------------------------------------------------------------------
// Members of class ADD
// ---------------------------------------------------------------------------


ADD::ADD() : ABDD() {}
ADD::ADD(Capsule *cap, DdNode *bddNode) : ABDD(cap,bddNode) {}
ADD::ADD(Cudd const & manager, DdNode *bddNode) : ABDD(manager,bddNode) {}
ADD::ADD(const ADD &from) : ABDD(from) {}


ADD
ADD::operator=(
  const ADD& right)
{
    if (this == &right) return *this;
    if (right.node) Cudd_Ref(right.node);
    if (node) {
	Cudd_RecursiveDeref(p->manager,node);
    }
    node = right.node;
    p = right.p;
    return *this;

} // ADD::operator=


bool
ADD::operator<=(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return Cudd_addLeq(mgr,node,other.node);

} // ADD::operator<=


bool
ADD::operator>=(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return Cudd_addLeq(mgr,other.node,node);

} // ADD::operator>=


bool
ADD::operator<(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return node != other.node && Cudd_addLeq(mgr,node,other.node);

} // ADD::operator<


bool
ADD::operator>(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return node != other.node && Cudd_addLeq(mgr,other.node,node);

} // ADD::operator>


ADD
ADD::operator-() const
{
    return ADD(p, Cudd_addNegate(p->manager,node));

} // ADD::operator-


ADD
ADD::operator*(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addTimes,node,other.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::operator*


ADD
ADD::operator*=(
  const ADD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addTimes,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // ADD::operator*=


ADD
ADD::operator+(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addPlus,node,other.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::operator+


ADD
ADD::operator+=(
  const ADD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addPlus,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // ADD::operator+=


ADD
ADD::operator-(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addMinus,node,other.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::operator-


ADD
ADD::operator-=(
  const ADD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addMinus,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // ADD::operator-=


ADD
ADD::operator~() const
{
    return ADD(p, Cudd_addCmpl(p->manager,node));

} // ADD::operator~


ADD
ADD::operator&(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addTimes,node,other.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::operator&


ADD
ADD::operator&=(
  const ADD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addTimes,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // ADD::operator&=


ADD
ADD::operator|(
  const ADD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addOr,node,other.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::operator|


ADD
ADD::operator|=(
  const ADD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_addApply(mgr,Cudd_addOr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDeref(mgr,node);
    node = result;
    return *this;

} // ADD::operator|=


bool
ADD::IsZero() const
{
    return node == Cudd_ReadZero(p->manager);

} // ADD::IsZero


// ---------------------------------------------------------------------------
// Members of class ZDD
// ---------------------------------------------------------------------------


ZDD::ZDD(Capsule *cap, DdNode *bddNode) : DD(cap,bddNode) {}
ZDD::ZDD() : DD() {}
ZDD::ZDD(const ZDD &from) : DD(from) {}


ZDD::~ZDD() {
    if (node) {
	Cudd_RecursiveDerefZdd(p->manager,node);
	if (p->verbose) {
	    cout << "ZDD destructor called for node " << hex << node << dec <<
		" ref = " << Cudd_Regular(node)->ref << "\n";
	}
    }

} // ZDD::~ZDD


ZDD
ZDD::operator=(
  const ZDD& right)
{
    if (this == &right) return *this;
    if (right.node) Cudd_Ref(right.node);
    if (node) {
	Cudd_RecursiveDerefZdd(p->manager,node);
	if (p->verbose) {
	    cout << "ZDD dereferencing for node " << hex << node << dec <<
		" ref = " << node->ref << "\n";
	}
    }
    node = right.node;
    p = right.p;
    if (node && p->verbose) {
	cout << "ZDD assignment for node " << hex << node << dec <<
	    " ref = " << node->ref << "\n";
    }
    return *this;

} // ZDD::operator=


bool
ZDD::operator==(
  const ZDD& other) const
{
    checkSameManager(other);
    return node == other.node;

} // ZDD::operator==


bool
ZDD::operator!=(
  const ZDD& other) const
{
    checkSameManager(other);
    return node != other.node;

} // ZDD::operator!=


bool
ZDD::operator<=(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return Cudd_zddDiffConst(mgr,node,other.node) == Cudd_ReadZero(mgr);

} // ZDD::operator<=


bool
ZDD::operator>=(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return Cudd_zddDiffConst(mgr,other.node,node) == Cudd_ReadZero(mgr);

} // ZDD::operator>=


bool
ZDD::operator<(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return node != other.node &&
	Cudd_zddDiffConst(mgr,node,other.node) == Cudd_ReadZero(mgr);

} // ZDD::operator<


bool
ZDD::operator>(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    return node != other.node &&
	Cudd_zddDiffConst(mgr,other.node,node) == Cudd_ReadZero(mgr);

} // ZDD::operator>


void
ZDD::print(
  int nvars,
  int verbosity) const
{
    cout.flush();
    int retval = Cudd_zddPrintDebug(p->manager,node,nvars,verbosity);
    fflush(Cudd_ReadStdout(p->manager));
    if (retval == 0) p->errorHandler("print failed");

} // ZDD::print


ZDD
ZDD::operator*(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddIntersect(mgr,node,other.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::operator*


ZDD
ZDD::operator*=(
  const ZDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddIntersect(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDerefZdd(mgr,node);
    node = result;
    return *this;

} // ZDD::operator*=


ZDD
ZDD::operator&(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddIntersect(mgr,node,other.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::operator&


ZDD
ZDD::operator&=(
  const ZDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddIntersect(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDerefZdd(mgr,node);
    node = result;
    return *this;

} // ZDD::operator&=


ZDD
ZDD::operator+(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddUnion(mgr,node,other.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::operator+


ZDD
ZDD::operator+=(
  const ZDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddUnion(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDerefZdd(mgr,node);
    node = result;
    return *this;

} // ZDD::operator+=


ZDD
ZDD::operator|(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddUnion(mgr,node,other.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::operator|


ZDD
ZDD::operator|=(
  const ZDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddUnion(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDerefZdd(mgr,node);
    node = result;
    return *this;

} // ZDD::operator|=


ZDD
ZDD::operator-(
  const ZDD& other) const
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddDiff(mgr,node,other.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::operator-


ZDD
ZDD::operator-=(
  const ZDD& other)
{
    DdManager *mgr = checkSameManager(other);
    DdNode *result = Cudd_zddDiff(mgr,node,other.node);
    checkReturnValue(result);
    Cudd_Ref(result);
    Cudd_RecursiveDerefZdd(mgr,node);
    node = result;
    return *this;

} // ZDD::operator-=


// ---------------------------------------------------------------------------
// Members of class Cudd
// ---------------------------------------------------------------------------


Cudd::Cudd(
  unsigned int numVars,
  unsigned int numVarsZ,
  unsigned int numSlots,
  unsigned int cacheSize,
  unsigned long maxMemory,
  PFC defaultHandler)
{
    p = new Capsule(numVars,numVarsZ,numSlots,cacheSize,maxMemory,defaultHandler);

} // Cudd::Cudd


Cudd::Cudd(
  const Cudd& x)
{
    p = x.p;
    x.p->ref++;
    if (p->verbose)
        cout << "Cudd Copy Constructor" << endl;

} // Cudd::Cudd


Cudd::~Cudd()
{
    if (--p->ref == 0) {
	delete p;
    }

} // Cudd::~Cudd


DdManager *
Cudd::getManager(void) const
{
    return p->manager;

} // Cudd::getManager


void
Cudd::makeVerbose(void) const
{
    p->verbose = 1;

} // Cudd::makeVerbose


void
Cudd::makeTerse(void) const
{
    p->verbose = 0;

} // Cudd::makeTerse


bool
Cudd::isVerbose(void) const
{
    return p->verbose;

} // Cudd::isVerbose


Cudd&
Cudd::operator=(
  const Cudd& right)
{
    right.p->ref++;
    if (--p->ref == 0) {	// disconnect self
	delete p;
    }
    p = right.p;
    return *this;

} // Cudd::operator=


PFC
Cudd::setHandler(
  PFC newHandler) const
{
    PFC oldHandler = p->errorHandler;
    p->errorHandler = newHandler;
    return oldHandler;

} // Cudd::setHandler


PFC
Cudd::getHandler() const
{
    return p->errorHandler;

} // Cudd::getHandler


PFC
Cudd::setTimeoutHandler(
  PFC newHandler) const
{
    PFC oldHandler = p->timeoutHandler;
    p->timeoutHandler = newHandler;
    return oldHandler;

} // Cudd::setTimeoutHandler


PFC
Cudd::getTimeoutHandler() const
{
    return p->timeoutHandler;

} // Cudd::getTimeourHandler


PFC
Cudd::setTerminationHandler(
  PFC newHandler) const
{
    PFC oldHandler = p->terminationHandler;
    p->terminationHandler = newHandler;
    return oldHandler;

} // Cudd::setTerminationHandler


PFC
Cudd::getTerminationHandler() const
{
    return p->terminationHandler;

} // Cudd::getTerminationHandler


void
Cudd::pushVariableName(std::string s) const
{
    char * cstr = new char[s.length() + 1];
    strcpy(cstr, s.c_str());
    p->varnames.push_back(cstr);
}


void
Cudd::clearVariableNames(void) const
{
    for (vector<char *>::iterator it = p->varnames.begin();
         it != p->varnames.end(); ++it) {
        delete [] *it;
    }
    p->varnames.clear();
}


std::string
Cudd::getVariableName(size_t i) const
{
    return std::string(p->varnames.at(i));
}


inline void
Cudd::checkReturnValue(
  const void *result) const
{
    if (result == 0) {
	if (Cudd_ReadErrorCode(p->manager) == CUDD_MEMORY_OUT) {
	    p->errorHandler("Out of memory.");
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_TOO_MANY_NODES) {
            p->errorHandler("Too many nodes.");
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_MAX_MEM_EXCEEDED) {
            p->errorHandler("Maximum memory exceeded.");
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_TIMEOUT_EXPIRED) {
            std::ostringstream msg;
            DdManager *mgr = p->manager;
            unsigned long lag = 
                Cudd_ReadElapsedTime(mgr) - Cudd_ReadTimeLimit(mgr);
            msg << "Timeout expired.  Lag = " << lag << " ms.\n";
            p->timeoutHandler(msg.str());
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_TERMINATION) {
            std::ostringstream msg;
            msg << "Terminated.\n";
            p->terminationHandler(msg.str());
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_INVALID_ARG) {
            p->errorHandler("Invalid argument.");
	} else if (Cudd_ReadErrorCode(p->manager) == CUDD_INTERNAL_ERROR) {
	    p->errorHandler("Internal error.");
	} else {
            p->errorHandler("Unexpected error.");
        }
    }

} // Cudd::checkReturnValue


inline void
Cudd::checkReturnValue(
  const int result) const
{
    if (result == 0) {
	if (Cudd_ReadErrorCode(p->manager) == CUDD_MEMORY_OUT) {
	    p->errorHandler("Out of memory.");
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_TOO_MANY_NODES) {
            p->errorHandler("Too many nodes.");
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_MAX_MEM_EXCEEDED) {
            p->errorHandler("Maximum memory exceeded.");
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_TIMEOUT_EXPIRED) {
            std::ostringstream msg;
            DdManager *mgr = p->manager;
            unsigned long lag = 
                Cudd_ReadElapsedTime(mgr) - Cudd_ReadTimeLimit(mgr);
            msg << "Timeout expired.  Lag = " << lag << " ms.\n";
            p->timeoutHandler(msg.str());
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_TERMINATION) {
            std::ostringstream msg;
            msg << "Terminated.\n";
            p->terminationHandler(msg.str());
        } else if (Cudd_ReadErrorCode(p->manager) == CUDD_INVALID_ARG) {
            p->errorHandler("Invalid argument.");
	} else if (Cudd_ReadErrorCode(p->manager) == CUDD_INTERNAL_ERROR) {
	    p->errorHandler("Internal error.");
	} else {
	    p->errorHandler("Unexpected error.");
	}
    }

} // Cudd::checkReturnValue


void
Cudd::info() const
{
    cout.flush();
    int retval = Cudd_PrintInfo(p->manager,stdout);
    checkReturnValue(retval);

} // Cudd::info


BDD
Cudd::bddVar() const
{
    DdNode *result = Cudd_bddNewVar(p->manager);
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::bddVar


BDD
Cudd::bddVar(
  int index) const
{
    DdNode *result = Cudd_bddIthVar(p->manager,index);
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::bddVar


BDD
Cudd::bddOne() const
{
    DdNode *result = Cudd_ReadOne(p->manager);
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::bddOne


BDD
Cudd::bddZero() const
{
    DdNode *result = Cudd_ReadLogicZero(p->manager);
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::bddZero


ADD
Cudd::addVar() const
{
    DdNode *result = Cudd_addNewVar(p->manager);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::addVar


ADD
Cudd::addVar(
  int index) const
{
    DdNode *result = Cudd_addIthVar(p->manager,index);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::addVar


ADD
Cudd::addOne() const
{
    DdNode *result = Cudd_ReadOne(p->manager);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::addOne


ADD
Cudd::addZero() const
{
    DdNode *result = Cudd_ReadZero(p->manager);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::addZero


ADD
Cudd::constant(
  CUDD_VALUE_TYPE c) const
{
    DdNode *result = Cudd_addConst(p->manager, c);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::constant


ADD
Cudd::plusInfinity() const
{
    DdNode *result = Cudd_ReadPlusInfinity(p->manager);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::plusInfinity


ADD
Cudd::minusInfinity() const
{
    DdNode *result = Cudd_ReadMinusInfinity(p->manager);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::minusInfinity


ZDD
Cudd::zddVar(
  int index) const
{
    DdNode *result = Cudd_zddIthVar(p->manager,index);
    checkReturnValue(result);
    return ZDD(p, result);

} // Cudd::zddVar


ZDD
Cudd::zddOne(
  int i) const
{
    DdNode *result = Cudd_ReadZddOne(p->manager,i);
    checkReturnValue(result);
    return ZDD(p, result);

} // Cudd::zddOne


ZDD
Cudd::zddZero() const
{
    DdNode *result = Cudd_ReadZero(p->manager);
    checkReturnValue(result);
    return ZDD(p, result);

} // Cudd::zddZero


void
defaultError(
  string message)
{
    throw std::logic_error(message);

} // defaultError


// ---------------------------------------------------------------------------
// All the rest
// ---------------------------------------------------------------------------


ADD
Cudd::addNewVarAtLevel(
  int level) const
{
    DdNode *result = Cudd_addNewVarAtLevel(p->manager, level);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::addNewVarAtLevel


BDD
Cudd::bddNewVarAtLevel(
  int level) const
{
    DdNode *result = Cudd_bddNewVarAtLevel(p->manager, level);
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::bddNewVarAtLevel


void
Cudd::zddVarsFromBddVars(
  int multiplicity) const
{
    int result = Cudd_zddVarsFromBddVars(p->manager, multiplicity);
    checkReturnValue(result);

} // Cudd::zddVarsFromBddVars


unsigned long
Cudd::ReadStartTime() const
{
    return Cudd_ReadStartTime(p->manager);

} // Cudd::ReadStartTime


unsigned long
Cudd::ReadElapsedTime() const
{
    return Cudd_ReadElapsedTime(p->manager);

} // Cudd::ReadElapsedTime


void 
Cudd::SetStartTime(
  unsigned long st) const
{
    Cudd_SetStartTime(p->manager, st);

} // Cudd::SetStartTime


void 
Cudd::ResetStartTime() const
{
    Cudd_ResetStartTime(p->manager);

} // Cudd::ResetStartTime


unsigned long
Cudd::ReadTimeLimit() const
{
    return Cudd_ReadTimeLimit(p->manager);

} // Cudd::ReadTimeLimit


unsigned long
Cudd::SetTimeLimit(
  unsigned long tl) const
{
    return Cudd_SetTimeLimit(p->manager, tl);

} // Cudd::SetTimeLimit


void
Cudd::UpdateTimeLimit() const
{
    Cudd_UpdateTimeLimit(p->manager);

} // Cudd::UpdateTimeLimit


void
Cudd::IncreaseTimeLimit(
  unsigned long increase) const
{
    Cudd_IncreaseTimeLimit(p->manager, increase);

} // Cudd::IncreaseTimeLimit


void 
Cudd::UnsetTimeLimit() const
{
    Cudd_UnsetTimeLimit(p->manager);

} // Cudd::UnsetTimeLimit


bool
Cudd::TimeLimited() const
{
    return Cudd_TimeLimited(p->manager);

} // Cudd::TimeLimited


void
Cudd::RegisterTerminationCallback(
  DD_THFP callback,
  void * callback_arg) const
{
    Cudd_RegisterTerminationCallback(p->manager, callback, callback_arg);

} // Cudd::RegisterTerminationCallback


void
Cudd::UnregisterTerminationCallback() const
{
    Cudd_UnregisterTerminationCallback(p->manager);

} // Cudd::UnregisterTerminationCallback


DD_OOMFP
Cudd::RegisterOutOfMemoryCallback(
  DD_OOMFP callback) const
{
    return Cudd_RegisterOutOfMemoryCallback(p->manager, callback);

} // Cudd::RegisterOutOfMemoryCallback


void
Cudd::UnregisterOutOfMemoryCallback() const
{
    Cudd_UnregisterOutOfMemoryCallback(p->manager);

} // Cudd::UnregisterOutOfMemoryCallback


void
Cudd::AutodynEnable(
  Cudd_ReorderingType method) const
{
    Cudd_AutodynEnable(p->manager, method);

} // Cudd::AutodynEnable


void
Cudd::AutodynDisable() const
{
    Cudd_AutodynDisable(p->manager);

} // Cudd::AutodynDisable


bool
Cudd::ReorderingStatus(
  Cudd_ReorderingType * method) const
{
    return Cudd_ReorderingStatus(p->manager, method);

} // Cudd::ReorderingStatus


void
Cudd::AutodynEnableZdd(
  Cudd_ReorderingType method) const
{
    Cudd_AutodynEnableZdd(p->manager, method);

} // Cudd::AutodynEnableZdd


void
Cudd::AutodynDisableZdd() const
{
    Cudd_AutodynDisableZdd(p->manager);

} // Cudd::AutodynDisableZdd


bool
Cudd::ReorderingStatusZdd(
  Cudd_ReorderingType * method) const
{
    return Cudd_ReorderingStatusZdd(p->manager, method);

} // Cudd::ReorderingStatusZdd


bool
Cudd::zddRealignmentEnabled() const
{
    return Cudd_zddRealignmentEnabled(p->manager);

} // Cudd::zddRealignmentEnabled


void
Cudd::zddRealignEnable() const
{
    Cudd_zddRealignEnable(p->manager);

} // Cudd::zddRealignEnable


void
Cudd::zddRealignDisable() const
{
    Cudd_zddRealignDisable(p->manager);

} // Cudd::zddRealignDisable


bool
Cudd::bddRealignmentEnabled() const
{
    return Cudd_bddRealignmentEnabled(p->manager);

} // Cudd::bddRealignmentEnabled


void
Cudd::bddRealignEnable() const
{
    Cudd_bddRealignEnable(p->manager);

} // Cudd::bddRealignEnable


void
Cudd::bddRealignDisable() const
{
    Cudd_bddRealignDisable(p->manager);

} // Cudd::bddRealignDisable


ADD
Cudd::background() const
{
    DdNode *result = Cudd_ReadBackground(p->manager);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::background


void
Cudd::SetBackground(
  ADD bg) const
{
    DdManager *mgr = p->manager;
    if (mgr != bg.manager()) {
	p->errorHandler("Background comes from different manager.");
    }
    Cudd_SetBackground(mgr, bg.getNode());

} // Cudd::SetBackground


unsigned int
Cudd::ReadCacheSlots() const
{
    return Cudd_ReadCacheSlots(p->manager);

} // Cudd::ReadCacheSlots


double
Cudd::ReadCacheLookUps() const
{
    return Cudd_ReadCacheLookUps(p->manager);

} // Cudd::ReadCacheLookUps


double
Cudd::ReadCacheUsedSlots() const
{
    return Cudd_ReadCacheUsedSlots(p->manager);

} // Cudd::ReadCacheUsedSlots


double
Cudd::ReadCacheHits() const
{
    return Cudd_ReadCacheHits(p->manager);

} // Cudd::ReadCacheHits


unsigned int
Cudd::ReadMinHit() const
{
    return Cudd_ReadMinHit(p->manager);

} // Cudd::ReadMinHit


void
Cudd::SetMinHit(
  unsigned int hr) const
{
    Cudd_SetMinHit(p->manager, hr);

} // Cudd::SetMinHit


unsigned int
Cudd::ReadLooseUpTo() const
{
    return Cudd_ReadLooseUpTo(p->manager);

} // Cudd::ReadLooseUpTo


void
Cudd::SetLooseUpTo(
  unsigned int lut) const
{
    Cudd_SetLooseUpTo(p->manager, lut);

} // Cudd::SetLooseUpTo


unsigned int
Cudd::ReadMaxCache() const
{
    return Cudd_ReadMaxCache(p->manager);

} // Cudd::ReadMaxCache


unsigned int
Cudd::ReadMaxCacheHard() const
{
    return Cudd_ReadMaxCacheHard(p->manager);

} // Cudd::ReadMaxCacheHard


void
Cudd::SetMaxCacheHard(
  unsigned int mc) const
{
    Cudd_SetMaxCacheHard(p->manager, mc);

} // Cudd::SetMaxCacheHard


int
Cudd::ReadSize() const
{
    return Cudd_ReadSize(p->manager);

} // Cudd::ReadSize


int
Cudd::ReadZddSize() const
{
    return Cudd_ReadZddSize(p->manager);

} // Cudd::ReadZddSize


unsigned int
Cudd::ReadSlots() const
{
    return Cudd_ReadSlots(p->manager);

} // Cudd::ReadSlots


unsigned int
Cudd::ReadKeys() const
{
    return Cudd_ReadKeys(p->manager);

} // Cudd::ReadKeys


unsigned int
Cudd::ReadDead() const
{
    return Cudd_ReadDead(p->manager);

} // Cudd::ReadDead


unsigned int
Cudd::ReadMinDead() const
{
    return Cudd_ReadMinDead(p->manager);

} // Cudd::ReadMinDead


unsigned int
Cudd::ReadReorderings() const
{
    return Cudd_ReadReorderings(p->manager);

} // Cudd::ReadReorderings


unsigned int
Cudd::ReadMaxReorderings() const
{
    return Cudd_ReadMaxReorderings(p->manager);

} // Cudd::ReadMaxReorderings

void
Cudd::SetMaxReorderings(
  unsigned int mr) const
{
    Cudd_SetMaxReorderings(p->manager, mr);

} // Cudd::SetMaxReorderings

long
Cudd::ReadReorderingTime() const
{
    return Cudd_ReadReorderingTime(p->manager);

} // Cudd::ReadReorderingTime


int
Cudd::ReadGarbageCollections() const
{
    return Cudd_ReadGarbageCollections(p->manager);

} // Cudd::ReadGarbageCollections


long
Cudd::ReadGarbageCollectionTime() const
{
    return Cudd_ReadGarbageCollectionTime(p->manager);

} // Cudd::ReadGarbageCollectionTime


int
Cudd::ReadSiftMaxVar() const
{
    return Cudd_ReadSiftMaxVar(p->manager);

} // Cudd::ReadSiftMaxVar


void
Cudd::SetSiftMaxVar(
  int smv) const
{
    Cudd_SetSiftMaxVar(p->manager, smv);

} // Cudd::SetSiftMaxVar


int
Cudd::ReadSiftMaxSwap() const
{
    return Cudd_ReadSiftMaxSwap(p->manager);

} // Cudd::ReadSiftMaxSwap


void
Cudd::SetSiftMaxSwap(
  int sms) const
{
    Cudd_SetSiftMaxSwap(p->manager, sms);

} // Cudd::SetSiftMaxSwap


double
Cudd::ReadMaxGrowth() const
{
    return Cudd_ReadMaxGrowth(p->manager);

} // Cudd::ReadMaxGrowth


void
Cudd::SetMaxGrowth(
  double mg) const
{
    Cudd_SetMaxGrowth(p->manager, mg);

} // Cudd::SetMaxGrowth


MtrNode *
Cudd::ReadTree() const
{
    return Cudd_ReadTree(p->manager);

} // Cudd::ReadTree


void
Cudd::SetTree(
  MtrNode * tree) const
{
    Cudd_SetTree(p->manager, tree);

} // Cudd::SetTree


void
Cudd::FreeTree() const
{
    Cudd_FreeTree(p->manager);

} // Cudd::FreeTree


MtrNode *
Cudd::ReadZddTree() const
{
    return Cudd_ReadZddTree(p->manager);

} // Cudd::ReadZddTree


void
Cudd::SetZddTree(
  MtrNode * tree) const
{
    Cudd_SetZddTree(p->manager, tree);

} // Cudd::SetZddTree


void
Cudd::FreeZddTree() const
{
    Cudd_FreeZddTree(p->manager);

} // Cudd::FreeZddTree


int
Cudd::ReadPerm(
  int i) const
{
    return Cudd_ReadPerm(p->manager, i);

} // Cudd::ReadPerm


int
Cudd::ReadPermZdd(
  int i) const
{
    return Cudd_ReadPermZdd(p->manager, i);

} // Cudd::ReadPermZdd


int
Cudd::ReadInvPerm(
  int i) const
{
    return Cudd_ReadInvPerm(p->manager, i);

} // Cudd::ReadInvPerm


int
Cudd::ReadInvPermZdd(
  int i) const
{
    return Cudd_ReadInvPermZdd(p->manager, i);

} // Cudd::ReadInvPermZdd


BDD
Cudd::ReadVars(
  int i) const
{
    DdNode *result = Cudd_ReadVars(p->manager, i);
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::ReadVars


CUDD_VALUE_TYPE
Cudd::ReadEpsilon() const
{
    return Cudd_ReadEpsilon(p->manager);

} // Cudd::ReadEpsilon


void
Cudd::SetEpsilon(
  CUDD_VALUE_TYPE ep) const
{
    Cudd_SetEpsilon(p->manager, ep);

} // Cudd::SetEpsilon


Cudd_AggregationType
Cudd::ReadGroupcheck() const
{
    return Cudd_ReadGroupcheck(p->manager);

} // Cudd::ReadGroupcheck


void
Cudd::SetGroupcheck(
  Cudd_AggregationType gc) const
{
    Cudd_SetGroupcheck(p->manager, gc);

} // Cudd::SetGroupcheck


bool
Cudd::GarbageCollectionEnabled() const
{
    return Cudd_GarbageCollectionEnabled(p->manager);

} // Cudd::GarbageCollectionEnabled


void
Cudd::EnableGarbageCollection() const
{
    Cudd_EnableGarbageCollection(p->manager);

} // Cudd::EnableGarbageCollection


void
Cudd::DisableGarbageCollection() const
{
    Cudd_DisableGarbageCollection(p->manager);

} // Cudd::DisableGarbageCollection


bool
Cudd::DeadAreCounted() const
{
    return Cudd_DeadAreCounted(p->manager);

} // Cudd::DeadAreCounted


void
Cudd::TurnOnCountDead() const
{
    Cudd_TurnOnCountDead(p->manager);

} // Cudd::TurnOnCountDead


void
Cudd::TurnOffCountDead() const
{
    Cudd_TurnOffCountDead(p->manager);

} // Cudd::TurnOffCountDead


int
Cudd::ReadRecomb() const
{
    return Cudd_ReadRecomb(p->manager);

} // Cudd::ReadRecomb


void
Cudd::SetRecomb(
  int recomb) const
{
    Cudd_SetRecomb(p->manager, recomb);

} // Cudd::SetRecomb


int
Cudd::ReadSymmviolation() const
{
    return Cudd_ReadSymmviolation(p->manager);

} // Cudd::ReadSymmviolation


void
Cudd::SetSymmviolation(
  int symmviolation) const
{
    Cudd_SetSymmviolation(p->manager, symmviolation);

} // Cudd::SetSymmviolation


int
Cudd::ReadArcviolation() const
{
    return Cudd_ReadArcviolation(p->manager);

} // Cudd::ReadArcviolation


void
Cudd::SetArcviolation(
  int arcviolation) const
{
    Cudd_SetArcviolation(p->manager, arcviolation);

} // Cudd::SetArcviolation


int
Cudd::ReadPopulationSize() const
{
    return Cudd_ReadPopulationSize(p->manager);

} // Cudd::ReadPopulationSize


void
Cudd::SetPopulationSize(
  int populationSize) const
{
    Cudd_SetPopulationSize(p->manager, populationSize);

} // Cudd::SetPopulationSize


int
Cudd::ReadNumberXovers() const
{
    return Cudd_ReadNumberXovers(p->manager);

} // Cudd::ReadNumberXovers


void
Cudd::SetNumberXovers(
  int numberXovers) const
{
    Cudd_SetNumberXovers(p->manager, numberXovers);

} // Cudd::SetNumberXovers


unsigned int 
Cudd::ReadOrderRandomization() const
{
    return Cudd_ReadOrderRandomization(p->manager);

} // Cudd::ReadOrderRandomization


void 
Cudd::SetOrderRandomization(
  unsigned int factor) const
{
    Cudd_SetOrderRandomization(p->manager, factor);

} // Cudd::SetOrderRandomization


unsigned long
Cudd::ReadMemoryInUse() const
{
    return Cudd_ReadMemoryInUse(p->manager);

} // Cudd::ReadMemoryInUse


long
Cudd::ReadPeakNodeCount() const
{
    return Cudd_ReadPeakNodeCount(p->manager);

} // Cudd::ReadPeakNodeCount


long
Cudd::ReadNodeCount() const
{
    return Cudd_ReadNodeCount(p->manager);

} // Cudd::ReadNodeCount


long
Cudd::zddReadNodeCount() const
{
    return Cudd_zddReadNodeCount(p->manager);

} // Cudd::zddReadNodeCount


void
Cudd::AddHook(
  DD_HFP f,
  Cudd_HookType where) const
{
    int result = Cudd_AddHook(p->manager, f, where);
    checkReturnValue(result);

} // Cudd::AddHook


void
Cudd::RemoveHook(
  DD_HFP f,
  Cudd_HookType where) const
{
    int result = Cudd_RemoveHook(p->manager, f, where);
    checkReturnValue(result);

} // Cudd::RemoveHook


bool
Cudd::IsInHook(
  DD_HFP f,
  Cudd_HookType where) const
{
    return Cudd_IsInHook(p->manager, f, where);

} // Cudd::IsInHook


void
Cudd::EnableReorderingReporting() const
{
    int result = Cudd_EnableReorderingReporting(p->manager);
    checkReturnValue(result);

} // Cudd::EnableReorderingReporting


void
Cudd::DisableReorderingReporting() const
{
    int result = Cudd_DisableReorderingReporting(p->manager);
    checkReturnValue(result);

} // Cudd::DisableReorderingReporting


bool
Cudd::ReorderingReporting() const
{
    return Cudd_ReorderingReporting(p->manager);

} // Cudd::ReorderingReporting


int
Cudd::ReadErrorCode() const
{
    return Cudd_ReadErrorCode(p->manager);

} // Cudd::ReadErrorCode


void
Cudd::ClearErrorCode() const
{
    Cudd_ClearErrorCode(p->manager);

} // Cudd::ClearErrorCode


DD_OOMFP Cudd::InstallOutOfMemoryHandler(DD_OOMFP newHandler) const
{
    return Cudd_InstallOutOfMemoryHandler(newHandler);

} // Cudd::InstallOutOfMemoryHandler


FILE *
Cudd::ReadStdout() const
{
    return Cudd_ReadStdout(p->manager);

} // Cudd::ReadStdout


void
Cudd::SetStdout(FILE *fp) const
{
    Cudd_SetStdout(p->manager, fp);

} // Cudd::SetStdout


FILE *
Cudd::ReadStderr() const
{
    return Cudd_ReadStderr(p->manager);

} // Cudd::ReadStderr


void
Cudd::SetStderr(FILE *fp) const
{
    Cudd_SetStderr(p->manager, fp);

} // Cudd::SetStderr


unsigned int
Cudd::ReadNextReordering() const
{
    return Cudd_ReadNextReordering(p->manager);

} // Cudd::ReadNextReordering


void
Cudd::SetNextReordering(
  unsigned int next) const
{
    Cudd_SetNextReordering(p->manager, next);

} // Cudd::SetNextReordering


double
Cudd::ReadSwapSteps() const
{
    return Cudd_ReadSwapSteps(p->manager);

} // Cudd::ReadSwapSteps


unsigned int
Cudd::ReadMaxLive() const
{
    return Cudd_ReadMaxLive(p->manager);

} // Cudd::ReadMaxLive


void
Cudd::SetMaxLive(unsigned int maxLive) const
{
    Cudd_SetMaxLive(p->manager, maxLive);

} // Cudd::SetMaxLive


size_t
Cudd::ReadMaxMemory() const
{
    return Cudd_ReadMaxMemory(p->manager);

} // Cudd::ReadMaxMemory


size_t
Cudd::SetMaxMemory(size_t maxMem) const
{
    return Cudd_SetMaxMemory(p->manager, maxMem);

} // Cudd::SetMaxMemory


int
Cudd::bddBindVar(int index) const
{
    return Cudd_bddBindVar(p->manager, index);

} // Cudd::bddBindVar


int
Cudd::bddUnbindVar(int index) const
{
    return Cudd_bddUnbindVar(p->manager, index);

} // Cudd::bddUnbindVar


bool
Cudd::bddVarIsBound(int index) const
{
    return Cudd_bddVarIsBound(p->manager, index);

} // Cudd::bddVarIsBound


ADD
ADD::ExistAbstract(
  const ADD& cube) const
{
    DdManager *mgr = checkSameManager(cube);
    DdNode *result = Cudd_addExistAbstract(mgr, node, cube.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::ExistAbstract


ADD
ADD::UnivAbstract(
  const ADD& cube) const
{
    DdManager *mgr = checkSameManager(cube);
    DdNode *result = Cudd_addUnivAbstract(mgr, node, cube.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::UnivAbstract


ADD
ADD::OrAbstract(
  const ADD& cube) const
{
    DdManager *mgr = checkSameManager(cube);
    DdNode *result = Cudd_addOrAbstract(mgr, node, cube.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::OrAbstract


ADD
ADD::Plus(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addPlus, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Plus


ADD
ADD::Times(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addTimes, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Times


ADD
ADD::Threshold(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addThreshold, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Threshold


ADD
ADD::SetNZ(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addSetNZ, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::SetNZ


ADD
ADD::Divide(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addDivide, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Divide


ADD
ADD::Minus(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addMinus, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Minus


ADD
ADD::Minimum(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addMinimum, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Minimum


ADD
ADD::Maximum(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addMaximum, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Maximum


ADD
ADD::OneZeroMaximum(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addOneZeroMaximum, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::OneZeroMaximum


ADD
ADD::Diff(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addDiff, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Diff


ADD
ADD::Agreement(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addAgreement, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Agreement


ADD
ADD::Or(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addOr, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Or


ADD
ADD::Nand(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addNand, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Nand


ADD
ADD::Nor(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addNor, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Nor


ADD
ADD::Xor(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addXor, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Xor


ADD
ADD::Xnor(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addApply(mgr, Cudd_addXnor, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Xnor


ADD
ADD::Log() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addMonadicApply(mgr, Cudd_addLog, node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Log


ADD
ADD::FindMax() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addFindMax(mgr, node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::FindMax


ADD
ADD::FindMin() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addFindMin(mgr, node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::FindMin


ADD
ADD::IthBit(
  int bit) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addIthBit(mgr, node, bit);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::IthBit


ADD
ADD::ScalarInverse(
  const ADD& epsilon) const
{
    DdManager *mgr = checkSameManager(epsilon);
    DdNode *result = Cudd_addScalarInverse(mgr, node, epsilon.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::ScalarInverse


ADD
ADD::Ite(
  const ADD& g,
  const ADD& h) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(h);
    DdNode *result = Cudd_addIte(mgr, node, g.node, h.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Ite


ADD
ADD::IteConstant(
  const ADD& g,
  const ADD& h) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(h);
    DdNode *result = Cudd_addIteConstant(mgr, node, g.node, h.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::IteConstant


ADD
ADD::EvalConst(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addEvalConst(mgr, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::EvalConst


bool
ADD::Leq(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    return Cudd_addLeq(mgr, node, g.node);

} // ADD::Leq


ADD
ADD::Cmpl() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addCmpl(mgr, node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Cmpl


ADD
ADD::Negate() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addNegate(mgr, node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Negate


ADD
ADD::RoundOff(
  int N) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addRoundOff(mgr, node, N);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::RoundOff


ADD
Cudd::Walsh(
  std::vector<ADD> x,
  std::vector<ADD> y) const
{
    size_t n = x.size();
    DdNode **X = new DdNode *[n];
    DdNode **Y = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
    }
    DdNode *result = Cudd_addWalsh(p->manager, X, Y, (int) n);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Walsh


ADD
Cudd::addResidue(
  int n,
  int m,
  int options,
  int top) const
{
    DdNode *result = Cudd_addResidue(p->manager, n, m, options, top);
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::addResidue


BDD
BDD::AndAbstract(
  const BDD& g,
  const BDD& cube,
  unsigned int limit) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(cube);
    DdNode *result;
    if (limit == 0)
	result = Cudd_bddAndAbstract(mgr, node, g.node, cube.node);
    else
	result = Cudd_bddAndAbstractLimit(mgr, node, g.node,
					  cube.node, limit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::AndAbstract


int
Cudd::ApaNumberOfDigits(
  int binaryDigits) const
{
    return Cudd_ApaNumberOfDigits(binaryDigits);

} // Cudd::ApaNumberOfDigits


DdApaNumber
Cudd::NewApaNumber(
  int digits) const
{
    return Cudd_NewApaNumber(digits);

} // Cudd::NewApaNumber


void
Cudd::ApaCopy(
  int digits,
  DdApaNumber source,
  DdApaNumber dest) const
{
    Cudd_ApaCopy(digits, source, dest);

} // Cudd::ApaCopy


DdApaDigit
Cudd::ApaAdd(
  int digits,
  DdApaNumber a,
  DdApaNumber b,
  DdApaNumber sum) const
{
    return Cudd_ApaAdd(digits, a, b, sum);

} // Cudd::ApaAdd


DdApaDigit
Cudd::ApaSubtract(
  int digits,
  DdApaNumber a,
  DdApaNumber b,
  DdApaNumber diff) const
{
    return Cudd_ApaSubtract(digits, a, b, diff);

} // Cudd::ApaSubtract


DdApaDigit
Cudd::ApaShortDivision(
  int digits,
  DdApaNumber dividend,
  DdApaDigit divisor,
  DdApaNumber quotient) const
{
    return Cudd_ApaShortDivision(digits, dividend, divisor, quotient);

} // Cudd::ApaShortDivision


void
Cudd::ApaShiftRight(
  int digits,
  DdApaDigit in,
  DdApaNumber a,
  DdApaNumber b) const
{
    Cudd_ApaShiftRight(digits, in, a, b);

} // Cudd::ApaShiftRight


void
Cudd::ApaSetToLiteral(
  int digits,
  DdApaNumber number,
  DdApaDigit literal) const
{
    Cudd_ApaSetToLiteral(digits, number, literal);

} // Cudd::ApaSetToLiteral


void
Cudd::ApaPowerOfTwo(
  int digits,
  DdApaNumber number,
  int power) const
{
    Cudd_ApaPowerOfTwo(digits, number, power);

} // Cudd::ApaPowerOfTwo


void
Cudd::ApaPrintHex(
  int digits,
  DdApaNumber number,
  FILE * fp) const
{
    cout.flush();
    int result = Cudd_ApaPrintHex(fp, digits, number);
    checkReturnValue(result);

} // Cudd::ApaPrintHex


void
Cudd::ApaPrintDecimal(
  int digits,
  DdApaNumber number,
  FILE * fp) const
{
    cout.flush();
    int result = Cudd_ApaPrintDecimal(fp, digits, number);
    checkReturnValue(result);

} // Cudd::ApaPrintDecimal


std::string
Cudd::ApaStringDecimal(
  int digits,
  DdApaNumber number) const
{
    char * result = Cudd_ApaStringDecimal(digits, number);
    checkReturnValue(result);
    std::string ret = std::string(result);
    free(result);
    return ret;

} // Cudd::ApaStringDecimal


void
Cudd::ApaPrintExponential(
  int digits,
  DdApaNumber number,
  int precision,
  FILE * fp) const
{
    cout.flush();
    int result = Cudd_ApaPrintExponential(fp, digits, number, precision);
    checkReturnValue(result);

} // Cudd::ApaPrintExponential


DdApaNumber
ABDD::ApaCountMinterm(
  int nvars,
  int * digits) const
{
    DdManager *mgr = p->manager;
    return Cudd_ApaCountMinterm(mgr, node, nvars, digits);

} // ABDD::ApaCountMinterm


void
ABDD::ApaPrintMinterm(
  int nvars,
  FILE * fp) const
{
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_ApaPrintMinterm(fp, mgr, node, nvars);
    checkReturnValue(result);

} // ABDD::ApaPrintMinterm


void
ABDD::ApaPrintMintermExp(
  int nvars,
  int precision,
  FILE * fp) const
{
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_ApaPrintMintermExp(fp, mgr, node, nvars, precision);
    checkReturnValue(result);

} // ABDD::ApaPrintMintermExp


void
ABDD::EpdPrintMinterm(
  int nvars,
  FILE * fp) const
{
    EpDouble count;
    char str[24];
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_EpdCountMinterm(mgr, node, nvars, &count);
    checkReturnValue(result,0);
    EpdGetString(&count, str);
    fprintf(fp, "%s", str);

} // ABDD::EpdPrintMinterm


long double
ABDD::LdblCountMinterm(
  int nvars) const
{
    cout.flush();
    DdManager *mgr = p->manager;
    long double result = Cudd_LdblCountMinterm(mgr, node, nvars);
    checkReturnValue(result != (long double) CUDD_OUT_OF_MEM);
    return result;

} // ABDD::LdblCountMinterm


BDD
BDD::UnderApprox(
  int numVars,
  int threshold,
  bool safe,
  double quality) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_UnderApprox(mgr, node, numVars, threshold, safe, quality);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::UnderApprox


BDD
BDD::OverApprox(
  int numVars,
  int threshold,
  bool safe,
  double quality) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_OverApprox(mgr, node, numVars, threshold, safe, quality);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::OverApprox


BDD
BDD::RemapUnderApprox(
  int numVars,
  int threshold,
  double quality) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_RemapUnderApprox(mgr, node, numVars, threshold, quality);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::RemapUnderApprox


BDD
BDD::RemapOverApprox(
  int numVars,
  int threshold,
  double quality) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_RemapOverApprox(mgr, node, numVars, threshold, quality);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::RemapOverApprox


BDD
BDD::BiasedUnderApprox(
  const BDD& bias,
  int numVars,
  int threshold,
  double quality1,
  double quality0) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_BiasedUnderApprox(mgr, node, bias.node, numVars, 
                                            threshold, quality1, quality0);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::BiasedUnderApprox


BDD
BDD::BiasedOverApprox(
  const BDD& bias,
  int numVars,
  int threshold,
  double quality1,
  double quality0) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_BiasedOverApprox(mgr, node, bias.node, numVars, 
                                           threshold, quality1, quality0);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::BiasedOverApprox


BDD
BDD::ExistAbstract(
  const BDD& cube,
  unsigned int limit) const
{
    DdManager *mgr = checkSameManager(cube);
    DdNode *result;
    if (limit == 0)
        result = Cudd_bddExistAbstract(mgr, node, cube.node);
    else
        result = Cudd_bddExistAbstractLimit(mgr, node, cube.node, limit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::ExistAbstract


BDD
BDD::XorExistAbstract(
  const BDD& g,
  const BDD& cube) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(cube);
    DdNode *result = Cudd_bddXorExistAbstract(mgr, node, g.node, cube.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::XorExistAbstract


BDD
BDD::UnivAbstract(
  const BDD& cube) const
{
    DdManager *mgr = checkSameManager(cube);
    DdNode *result = Cudd_bddUnivAbstract(mgr, node, cube.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::UnivAbstract


BDD
BDD::BooleanDiff(
  int x) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_bddBooleanDiff(mgr, node, x);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::BooleanDiff


bool
BDD::VarIsDependent(
  const BDD& var) const
{
    DdManager *mgr = p->manager;
    return Cudd_bddVarIsDependent(mgr, node, var.node);

} // BDD::VarIsDependent


double
BDD::Correlation(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    return Cudd_bddCorrelation(mgr, node, g.node);

} // BDD::Correlation


double
BDD::CorrelationWeights(
  const BDD& g,
  double * prob) const
{
    DdManager *mgr = checkSameManager(g);
    return Cudd_bddCorrelationWeights(mgr, node, g.node, prob);

} // BDD::CorrelationWeights


BDD
BDD::Ite(
  const BDD& g,
  const BDD& h,
  unsigned int limit) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(h);
    DdNode *result;
    if (limit == 0)
	result = Cudd_bddIte(mgr, node, g.node, h.node);
    else
	result = Cudd_bddIteLimit(mgr, node, g.node, h.node, limit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Ite


BDD
BDD::IteConstant(
  const BDD& g,
  const BDD& h) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(h);
    DdNode *result = Cudd_bddIteConstant(mgr, node, g.node, h.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::IteConstant


BDD
BDD::Intersect(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddIntersect(mgr, node, g.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Intersect


BDD
BDD::And(
  const BDD& g,
  unsigned int limit) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result;
    if (limit == 0)
	result = Cudd_bddAnd(mgr, node, g.node);
    else
	result = Cudd_bddAndLimit(mgr, node, g.node, limit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::And


BDD
BDD::Or(
  const BDD& g,
  unsigned int limit) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result;
    if (limit == 0)
	result = Cudd_bddOr(mgr, node, g.node);
    else
	result = Cudd_bddOrLimit(mgr, node, g.node, limit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Or


BDD
BDD::Nand(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddNand(mgr, node, g.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Nand


BDD
BDD::Nor(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddNor(mgr, node, g.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Nor


BDD
BDD::Xor(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddXor(mgr, node, g.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Xor


BDD
BDD::Xnor(
  const BDD& g,
  unsigned int limit) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result;
    if (limit == 0)
	result = Cudd_bddXnor(mgr, node, g.node);
    else
	result = Cudd_bddXnorLimit(mgr, node, g.node, limit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Xnor


bool
BDD::Leq(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    return Cudd_bddLeq(mgr, node, g.node);

} // BDD::Leq


BDD
ADD::BddThreshold(
  CUDD_VALUE_TYPE value) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addBddThreshold(mgr, node, value);
    checkReturnValue(result);
    return BDD(p, result);

} // ADD::BddThreshold


BDD
ADD::BddStrictThreshold(
  CUDD_VALUE_TYPE value) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addBddStrictThreshold(mgr, node, value);
    checkReturnValue(result);
    return BDD(p, result);

} // ADD::BddStrictThreshold


BDD
ADD::BddInterval(
  CUDD_VALUE_TYPE lower,
  CUDD_VALUE_TYPE upper) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addBddInterval(mgr, node, lower, upper);
    checkReturnValue(result);
    return BDD(p, result);

} // ADD::BddInterval


BDD
ADD::BddIthBit(
  int bit) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addBddIthBit(mgr, node, bit);
    checkReturnValue(result);
    return BDD(p, result);

} // ADD::BddIthBit


ADD
BDD::Add() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_BddToAdd(mgr, node);
    checkReturnValue(result);
    return ADD(p, result);

} // BDD::Add


BDD
ADD::BddPattern() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addBddPattern(mgr, node);
    checkReturnValue(result);
    return BDD(p, result);

} // ADD::BddPattern


BDD
BDD::Transfer(
  Cudd& destination) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_bddTransfer(mgr, destination.p->manager, node);
    checkReturnValue(result);
    return BDD(destination.p, result);

} // BDD::Transfer


void
Cudd::DebugCheck() const
{
    int result = Cudd_DebugCheck(p->manager);
    checkReturnValue(result == 0);

} // Cudd::DebugCheck


void
Cudd::CheckKeys() const
{
    int result = Cudd_CheckKeys(p->manager);
    checkReturnValue(result == 0);

} // Cudd::CheckKeys


BDD
BDD::ClippingAnd(
  const BDD& g,
  int maxDepth,
  int direction) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddClippingAnd(mgr, node, g.node, maxDepth,
					 direction);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::ClippingAnd


BDD
BDD::ClippingAndAbstract(
  const BDD& g,
  const BDD& cube,
  int maxDepth,
  int direction) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(cube);
    DdNode *result = Cudd_bddClippingAndAbstract(mgr, node, g.node, cube.node,
						 maxDepth, direction);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::ClippingAndAbstract


ADD
ADD::Cofactor(
  const ADD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_Cofactor(mgr, node, g.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Cofactor


BDD
BDD::Cofactor(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_Cofactor(mgr, node, g.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Cofactor


bool
BDD::VarAreSymmetric(int index1, int index2) const
{
    return Cudd_VarsAreSymmetric(p->manager, node, index1, index2);

} // BDD::VarAreSymmetric

BDD
BDD::Compose(
  const BDD& g,
  int v) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddCompose(mgr, node, g.node, v);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Compose


ADD
ADD::Compose(
  const ADD& g,
  int v) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_addCompose(mgr, node, g.node, v);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Compose


ADD
ADD::Permute(
  int * permut) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_addPermute(mgr, node, permut);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Permute


ADD
ADD::SwapVariables(
  std::vector<ADD> x,
  std::vector<ADD> y) const
{
    size_t n = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[n];
    DdNode **Y = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = x[i].node;
	Y[i] = y[i].node;
    }
    DdNode *result = Cudd_addSwapVariables(mgr, node, X, Y, (int) n);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::SwapVariables


BDD
BDD::Permute(
  int * permut) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_bddPermute(mgr, node, permut);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Permute


BDD
BDD::SwapVariables(
  std::vector<BDD> x,
  std::vector<BDD> y) const
{
    size_t n = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[n];
    DdNode **Y = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
        X[i] = x[i].node;
        Y[i] = y[i].node;
    }
    DdNode *result = Cudd_bddSwapVariables(mgr, node, X, Y, (int) n);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SwapVariables


BDD
BDD::AdjPermuteX(
  std::vector<BDD> x) const
{
    size_t n = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = x[i].node;
    }
    DdNode *result = Cudd_bddAdjPermuteX(mgr, node, X, (int) n);
    delete [] X;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::AdjPermuteX


ADD
ADD::VectorCompose(
  std::vector<ADD> vect) const
{
    DdManager *mgr = p->manager;
    size_t n = (size_t) Cudd_ReadSize(mgr);
    DdNode **X = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = vect[i].node;
    }
    DdNode *result = Cudd_addVectorCompose(mgr, node, X);
    delete [] X;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::VectorCompose


ADD
ADD::NonSimCompose(
  std::vector<ADD> vect) const
{
    DdManager *mgr = p->manager;
    size_t n = (size_t) Cudd_ReadSize(mgr);
    DdNode **X = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = vect[i].node;
    }
    DdNode *result = Cudd_addNonSimCompose(mgr, node, X);
    delete [] X;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::NonSimCompose


BDD
BDD::VectorCompose(
  std::vector<BDD> vect) const
{
    DdManager *mgr = p->manager;
    size_t n = (size_t) Cudd_ReadSize(mgr);
    DdNode **X = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = vect[i].node;
    }
    DdNode *result = Cudd_bddVectorCompose(mgr, node, X);
    delete [] X;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::VectorCompose


void
BDD::ApproxConjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddApproxConjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::ApproxConjDecomp


void
BDD::ApproxDisjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddApproxDisjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::ApproxDisjDecomp


void
BDD::IterConjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddIterConjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::IterConjDecomp


void
BDD::IterDisjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddIterDisjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::IterDisjDecomp


void
BDD::GenConjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddGenConjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::GenConjDecomp


void
BDD::GenDisjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddGenDisjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::GenDisjDecomp


void
BDD::VarConjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddVarConjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::VarConjDecomp


void
BDD::VarDisjDecomp(
  BDD* g,
  BDD* h) const
{
    DdManager *mgr = p->manager;
    DdNode **pieces;
    int result = Cudd_bddVarDisjDecomp(mgr, node, &pieces);
    checkReturnValue(result == 2);
    *g = BDD(p, pieces[0]);
    *h = BDD(p, pieces[1]);
    Cudd_RecursiveDeref(mgr,pieces[0]);
    Cudd_RecursiveDeref(mgr,pieces[1]);
    free(pieces);

} // BDD::VarDisjDecomp


bool
ABDD::IsCube() const
{
    DdManager *mgr = p->manager;
    return Cudd_CheckCube(mgr, node);

} // ABDD::IsCube


BDD
ABDD::FindEssential() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_FindEssential(mgr, node);
    checkReturnValue(result);
    return BDD(p, result);

} // ABDD::FindEssential


bool
BDD::IsVarEssential(
  int id,
  int phase) const
{
    DdManager *mgr = p->manager;
    return Cudd_bddIsVarEssential(mgr, node, id, phase);

} // BDD::IsVarEssential


void
ABDD::PrintTwoLiteralClauses(
  char **names,
  FILE *fp) const
{
    DdManager *mgr = p->manager;
    int result = Cudd_PrintTwoLiteralClauses(mgr, node, names, fp);
    checkReturnValue(result);

} // ABDD::PrintTwoLiteralClauses


void
Cudd::DumpBlif(
  const std::vector<BDD>& nodes,
  char const * const * inames,
  char const * const * onames,
  char * mname,
  FILE * fp,
  int mv) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i ++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_DumpBlif(mgr, (int) n, F, inames, onames, mname, fp, mv);
    delete [] F;
    checkReturnValue(result);

} // Cudd::DumpBlif


void
Cudd::DumpDot(
  const std::vector<BDD>& nodes,
  char const * const * inames,
  char const * const * onames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i ++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_DumpDot(mgr, (int) n, F, inames, onames, fp);
    delete [] F;
    checkReturnValue(result);

} // Cudd::DumpDot


void
Cudd::DumpDot(
  const std::vector<ADD>& nodes,
  char const * const * inames,
  char const * const * onames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i ++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_DumpDot(mgr, (int) n, F, inames, onames, fp);
    delete [] F;
    checkReturnValue(result);

} // Cudd::DumpDot


void
Cudd::DumpDaVinci(
  const std::vector<BDD>& nodes,
  char const * const * inames,
  char const * const * onames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i ++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_DumpDaVinci(mgr, (int) n, F, inames, onames, fp);
    delete [] F;
    checkReturnValue(result);

} // Cudd::DumpDaVinci


void
Cudd::DumpDaVinci(
  const std::vector<ADD>& nodes,
  char const * const * inames,
  char const * const * onames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i ++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_DumpDaVinci(mgr, (int) n, F, inames, onames, fp);
    delete [] F;
    checkReturnValue(result);

} // Cudd::DumpDaVinci


void
Cudd::DumpDDcal(
  const std::vector<BDD>& nodes,
  char const * const * inames,
  char const * const * onames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i ++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_DumpDDcal(mgr, (int) n, F, inames, onames, fp);
    delete [] F;
    checkReturnValue(result);

} // Cudd::DumpDDcal


void
Cudd::DumpFactoredForm(
  const std::vector<BDD>& nodes,
  char const * const * inames,
  char const * const * onames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i ++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_DumpFactoredForm(mgr, (int) n, F, inames, onames, fp);
    delete [] F;
    checkReturnValue(result);

} // Cudd::DumpFactoredForm


void
BDD::PrintFactoredForm(
  char const * const * inames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    DdNode *f = node;
    int result = Cudd_DumpFactoredForm(mgr, 0, &f, inames, 0, fp);
    checkReturnValue(result);

} // BDD::PrintFactoredForm


string
BDD::FactoredFormString(char const * const * inames) const
{
    DdManager *mgr = p->manager;
    DdNode *f = node;
    char *cstr = Cudd_FactoredFormString(mgr, f, inames);
    checkReturnValue(cstr);
    string str(cstr);
    free(cstr);
    return str;

} // BDD::FactoredFormString


BDD
BDD::Constrain(
  const BDD& c) const
{
    DdManager *mgr = checkSameManager(c);
    DdNode *result = Cudd_bddConstrain(mgr, node, c.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Constrain


BDD
BDD::Restrict(
  const BDD& c) const
{
    DdManager *mgr = checkSameManager(c);
    DdNode *result = Cudd_bddRestrict(mgr, node, c.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Restrict


BDD
BDD::NPAnd(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddNPAnd(mgr, node, g.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::NPAnd


ADD
ADD::Constrain(
  const ADD& c) const
{
    DdManager *mgr = checkSameManager(c);
    DdNode *result = Cudd_addConstrain(mgr, node, c.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Constrain


std::vector<BDD>
BDD::ConstrainDecomp() const
{
    DdManager *mgr = p->manager;
    DdNode **result = Cudd_bddConstrainDecomp(mgr, node);
    checkReturnValue(result);
    int size = Cudd_ReadSize(mgr);
    vector<BDD> vect;
    for (int i = 0; i < size; i++) {
	Cudd_Deref(result[i]);
	vect.push_back(BDD(p, result[i]));
    }
    free(result);
    return vect;

} // BDD::ConstrainDecomp


ADD
ADD::Restrict(
  const ADD& c) const
{
    DdManager *mgr = checkSameManager(c);
    DdNode *result = Cudd_addRestrict(mgr, node, c.node);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Restrict


std::vector<BDD>
BDD::CharToVect() const
{
    DdManager *mgr = p->manager;
    DdNode **result = Cudd_bddCharToVect(mgr, node);
    checkReturnValue(result);
    int size = Cudd_ReadSize(mgr);
    vector<BDD> vect;
    for (int i = 0; i < size; i++) {
	Cudd_Deref(result[i]);
	vect.push_back(BDD(p, result[i]));
    }
    free(result);
    return vect;

} // BDD::CharToVect


BDD
BDD::LICompaction(
  const BDD& c) const
{
    DdManager *mgr = checkSameManager(c);
    DdNode *result = Cudd_bddLICompaction(mgr, node, c.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::LICompaction


BDD
BDD::Squeeze(
  const BDD& u) const
{
    DdManager *mgr = checkSameManager(u);
    DdNode *result = Cudd_bddSqueeze(mgr, node, u.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Squeeze


BDD
BDD::Interpolate(
  const BDD& u) const
{
    DdManager *mgr = checkSameManager(u);
    DdNode *result = Cudd_bddInterpolate(mgr, node, u.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Interpolate


BDD
BDD::Minimize(
  const BDD& c) const
{
    DdManager *mgr = checkSameManager(c);
    DdNode *result = Cudd_bddMinimize(mgr, node, c.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Minimize


BDD
BDD::SubsetCompress(
  int nvars,
  int threshold) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_SubsetCompress(mgr, node, nvars, threshold);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SubsetCompress


BDD
BDD::SupersetCompress(
  int nvars,
  int threshold) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_SupersetCompress(mgr, node, nvars, threshold);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SupersetCompress


MtrNode *
Cudd::MakeTreeNode(
  unsigned int low,
  unsigned int size,
  unsigned int type) const
{
    return Cudd_MakeTreeNode(p->manager, low, size, type);

} // Cudd::MakeTreeNode


ADD
Cudd::Harwell(
  FILE * fp,
  std::vector<ADD>& x,
  std::vector<ADD>& y,
  std::vector<ADD>& xn,
  std::vector<ADD>& yn_,
  int * m,
  int * n,
  int bx,
  int sx,
  int by,
  int sy,
  int pr) const
{
    DdManager *mgr = p->manager;
    DdNode *E;
    DdNode **xa = 0, **ya = 0, **xna = 0, **yna = 0;
    int nx = x.size(), ny = y.size();
    if (nx > 0) {
        xa = (DdNode **) malloc(nx * sizeof(DdNode *));
        if (!xa) {
            p->errorHandler("Out of memory.");
        }
        xna = (DdNode **) malloc(nx * sizeof(DdNode *));
        if (!xna) {
            free(xa);
            p->errorHandler("Out of memory.");
        }
        for (int i = 0; i < nx; ++i) {
            xa[i] = x.at(i).node;
            xna[i] = xn.at(i).node;
        }
    }
    if (ny > 0) {
        ya = (DdNode **) malloc(ny * sizeof(DdNode *));
        if (!ya) {
            free(xa);
            free(xna);
            p->errorHandler("Out of memory.");
        }
        yna = (DdNode **) malloc(ny * sizeof(DdNode *));
        if (!yna) {
            free(xa);
            free(xna);
            free(ya);
            p->errorHandler("Out of memory.");
        }
        for (int j = 0; j < ny; ++j) {
            ya[j] = y.at(j).node;
            yna[j] = yn_.at(j).node;
        }
    }
    int result = Cudd_addHarwell(fp, mgr, &E, &xa, &ya, &xna, &yna, &nx, &ny,
                                 m, n, bx, sx, by, sy, pr);
    checkReturnValue(result);
    for (int i = x.size(); i < nx; ++i) {
        x.push_back(ADD(p, xa[i]));
        xn.push_back(ADD(p, xna[i]));
    }
    free(xa);
    free(xna);
    for (int j = y.size(); j < ny; ++j) {
        y.push_back(ADD(p, ya[j]));
        yn_.push_back(ADD(p, yna[j]));
    }
    free(ya);
    free(yna);
    Cudd_Deref(E);
    return ADD(p, E);

} // Cudd::Harwell


void
Cudd::PrintLinear(void) const
{
    cout.flush();
    int result = Cudd_PrintLinear(p->manager);
    checkReturnValue(result);

} // Cudd::PrintLinear


int
Cudd::ReadLinear(
  int x,
  int y) const
{
    return Cudd_ReadLinear(p->manager, x, y);

} // Cudd::ReadLinear


BDD
BDD::LiteralSetIntersection(
  const BDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_bddLiteralSetIntersection(mgr, node, g.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::LiteralSetIntersection


ADD
ADD::MatrixMultiply(
  const ADD& B,
  std::vector<ADD> z) const
{
    size_t nz = z.size();
    DdManager *mgr = checkSameManager(B);
    DdNode **Z = new DdNode *[nz];
    for (size_t i = 0; i < nz; i++) {
	Z[i] = z[i].node;
    }
    DdNode *result = Cudd_addMatrixMultiply(mgr, node, B.node, Z, (int) nz);
    delete [] Z;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::MatrixMultiply


ADD
ADD::TimesPlus(
  const ADD& B,
  std::vector<ADD> z) const
{
    size_t nz = z.size();
    DdManager *mgr = checkSameManager(B);
    DdNode **Z = new DdNode *[nz];
    for (size_t i = 0; i < nz; i++) {
	Z[i] = z[i].node;
    }
    DdNode *result = Cudd_addTimesPlus(mgr, node, B.node, Z, (int) nz);
    delete [] Z;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::TimesPlus


ADD
ADD::Triangle(
  const ADD& g,
  std::vector<ADD> z) const
{
    size_t nz = z.size();
    DdManager *mgr = checkSameManager(g);
    DdNode **Z = new DdNode *[nz];
    for (size_t i = 0; i < nz; i++) {
	Z[i] = z[i].node;
    }
    DdNode *result = Cudd_addTriangle(mgr, node, g.node, Z, (int) nz);
    delete [] Z;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Triangle


BDD
BDD::PrioritySelect(
  std::vector<BDD> x,
  std::vector<BDD> y,
  std::vector<BDD> z,
  const BDD& Pi,
  DD_PRFP Pifunc) const
{
    size_t n = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[n];
    DdNode **Y = new DdNode *[n];
    DdNode **Z = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = x[i].node;
	Y[i] = y[i].node;
	Z[i] = z[i].node;
    }
    DdNode *result = Cudd_PrioritySelect(mgr, node, X, Y, Z, Pi.node,
                                         (int) n, Pifunc);
    delete [] X;
    delete [] Y;
    delete [] Z;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::PrioritySelect


BDD
Cudd::Xgty(
  std::vector<BDD> z,
  std::vector<BDD> x,
  std::vector<BDD> y) const
{
    size_t N = z.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    DdNode **Y = new DdNode *[N];
    DdNode **Z = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
	Z[i] = z[i].getNode();
    }
    DdNode *result = Cudd_Xgty(mgr, (int) N, Z, X, Y);
    delete [] X;
    delete [] Y;
    delete [] Z;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::Xgty


BDD
Cudd::Xeqy(
  std::vector<BDD> x,
  std::vector<BDD> y) const
{
    size_t N = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    DdNode **Y = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
    }
    DdNode *result = Cudd_Xeqy(mgr, (int) N, X, Y);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Xeqy


ADD
Cudd::Xeqy(
  std::vector<ADD> x,
  std::vector<ADD> y) const
{
    size_t N = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    DdNode **Y = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
    }
    DdNode *result = Cudd_addXeqy(mgr, (int) N, X, X);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Xeqy


BDD
Cudd::Dxygtdxz(
  std::vector<BDD> x,
  std::vector<BDD> y,
  std::vector<BDD> z) const
{
    size_t N = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    DdNode **Y = new DdNode *[N];
    DdNode **Z = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
	Z[i] = z[i].getNode();
    }
    DdNode *result = Cudd_Dxygtdxz(mgr, (int) N, X, Y, Z);
    delete [] X;
    delete [] Y;
    delete [] Z;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::Dxygtdxz


BDD
Cudd::Dxygtdyz(
  std::vector<BDD> x,
  std::vector<BDD> y,
  std::vector<BDD> z) const
{
    size_t N = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    DdNode **Y = new DdNode *[N];
    DdNode **Z = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
	Z[i] = z[i].getNode();
    }
    DdNode *result = Cudd_Dxygtdyz(mgr, (int) N, X, Y, Z);
    delete [] X;
    delete [] Y;
    delete [] Z;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::Dxygtdyz


BDD
Cudd::Inequality(
  int c,
  std::vector<BDD> x,
  std::vector<BDD> y) const
{
    size_t N = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    DdNode **Y = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
    }
    DdNode *result = Cudd_Inequality(mgr, (int) N, c, X, Y);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::Inequality


BDD
Cudd::Disequality(
  int c,
  std::vector<BDD> x,
  std::vector<BDD> y) const
{
    size_t N = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    DdNode **Y = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
	Y[i] = y[i].getNode();
    }
    DdNode *result = Cudd_Disequality(mgr, (int) N, c, X, Y);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::Disequality


BDD
Cudd::Interval(
  std::vector<BDD> x,
  unsigned int lowerB,
  unsigned int upperB) const
{
    size_t N = x.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[N];
    for (size_t i = 0; i < N; i++) {
	X[i] = x[i].getNode();
    }
    DdNode *result = Cudd_bddInterval(mgr, (int) N, X, lowerB, upperB);
    delete [] X;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::Interval


BDD
BDD::CProjection(
  const BDD& Y) const
{
    DdManager *mgr = checkSameManager(Y);
    DdNode *result = Cudd_CProjection(mgr, node, Y.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::CProjection


int
BDD::MinHammingDist(
  int *minterm,
  int upperBound) const
{
    DdManager *mgr = p->manager;
    int result = Cudd_MinHammingDist(mgr, node, minterm, upperBound);
    return result;

} // BDD::MinHammingDist


ADD
Cudd::Hamming(
  std::vector<ADD> xVars,
  std::vector<ADD> yVars) const
{
    size_t nVars = xVars.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[nVars];
    DdNode **Y = new DdNode *[nVars];
    for (size_t i = 0; i < nVars; i++) {
	X[i] = xVars[i].getNode();
	Y[i] = yVars[i].getNode();
    }
    DdNode *result = Cudd_addHamming(mgr, X, Y, (int) nVars);
    delete [] X;
    delete [] Y;
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::Hamming


ADD
Cudd::Read(
  FILE * fp,
  std::vector<ADD>& x,
  std::vector<ADD>& y,
  std::vector<ADD>& xn,
  std::vector<ADD>& yn_,
  int * m,
  int * n,
  int bx,
  int sx,
  int by,
  int sy) const
{
    DdManager *mgr = p->manager;
    DdNode *E;
    DdNode **xa = 0, **ya = 0, **xna = 0, **yna = 0;
    int nx = x.size(), ny = y.size();
    if (nx > 0) {
        xa = (DdNode **) malloc(nx * sizeof(DdNode *));
        if (!xa) {
            p->errorHandler("Out of memory.");
        }
        xna = (DdNode **) malloc(nx * sizeof(DdNode *));
        if (!xna) {
            free(xa);
            p->errorHandler("Out of memory.");
        }
        for (int i = 0; i < nx; ++i) {
            xa[i] = x.at(i).node;
            xna[i] = xn.at(i).node;
        }
    }
    if (ny > 0) {
        ya = (DdNode **) malloc(ny * sizeof(DdNode *));
        if (!ya) {
            free(xa);
            free(xna);
            p->errorHandler("Out of memory.");
        }
        yna = (DdNode **) malloc(ny * sizeof(DdNode *));
        if (!yna) {
            free(xa);
            free(xna);
            free(ya);
            p->errorHandler("Out of memory.");
        }
        for (int j = 0; j < ny; ++j) {
            ya[j] = y.at(j).node;
            yna[j] = yn_.at(j).node;
        }
    }
    int result = Cudd_addRead(fp, mgr, &E, &xa, &ya, &xna, &yna, &nx, &ny,
                              m, n, bx, sx, by, sy);
    checkReturnValue(result);
    for (int i = x.size(); i < nx; ++i) {
        x.push_back(ADD(p, xa[i]));
        xn.push_back(ADD(p, xna[i]));
    }
    free(xa);
    free(xna);
    for (int j = y.size(); j < ny; ++j) {
        y.push_back(ADD(p, ya[j]));
        yn_.push_back(ADD(p, yna[j]));
    }
    free(ya);
    free(yna);
    Cudd_Deref(E);
    return ADD(p, E);

} // Cudd::Read


BDD
Cudd::Read(
  FILE * fp,
  std::vector<BDD>& x,
  std::vector<BDD>& y,
  int * m,
  int * n,
  int bx,
  int sx,
  int by,
  int sy) const
{
    DdManager *mgr = p->manager;
    DdNode *E;
    DdNode **xa = 0, **ya = 0;
    int nx = x.size(), ny = y.size();
    if (nx > 0) {
        xa = (DdNode **) malloc(nx * sizeof(DdNode *));
        if (!xa) {
            p->errorHandler("Out of memory.");
        }
        for (int i = 0; i < nx; ++i) {
            xa[i] = x.at(i).node;
        }
    }
    if (ny > 0) {
        ya = (DdNode **) malloc(ny * sizeof(DdNode *));
        if (!ya) {
            free(xa);
            p->errorHandler("Out of memory.");
        }
        for (int j = 0; j < nx; ++j) {
            ya[j] = y.at(j).node;
        }
    }
    int result = Cudd_bddRead(fp, mgr, &E, &xa, &ya, &nx, &ny,
                              m, n, bx, sx, by, sy);
    checkReturnValue(result);
    for (int i = x.size(); i < nx; ++i) {
        x.push_back(BDD(p, xa[i]));
    }
    free(xa);
    for (int j = y.size(); j < ny; ++j) {
        y.push_back(BDD(p, ya[j]));
    }
    free(ya);
    Cudd_Deref(E);
    return BDD(p, E);

} // Cudd::Read


void
Cudd::ReduceHeap(
  Cudd_ReorderingType heuristic,
  int minsize) const
{
    int result = Cudd_ReduceHeap(p->manager, heuristic, minsize);
    checkReturnValue(result);

} // Cudd::ReduceHeap


void
Cudd::ShuffleHeap(
  int * permutation) const
{
    int result = Cudd_ShuffleHeap(p->manager, permutation);
    checkReturnValue(result);

} // Cudd::ShuffleHeap


ADD
ADD::Eval(
  int * inputs) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_Eval(mgr, node, inputs);
    checkReturnValue(result);
    return ADD(p, result);

} // ADD::Eval


BDD
BDD::Eval(
  int * inputs) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_Eval(mgr, node, inputs);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Eval


BDD
ABDD::ShortestPath(
  int * weight,
  int * support,
  int * length) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_ShortestPath(mgr, node, weight, support, length);
    checkReturnValue(result);
    return BDD(p, result);

} // ABDD::ShortestPath


BDD
ABDD::LargestCube(
  int * length) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_LargestCube(mgr, node, length);
    checkReturnValue(result);
    return BDD(p, result);

} // ABDD::LargestCube


int
ABDD::ShortestLength(
  int * weight) const
{
    DdManager *mgr = p->manager;
    int result = Cudd_ShortestLength(mgr, node, weight);
    checkReturnValue(result != CUDD_OUT_OF_MEM);
    return result;

} // ABDD::ShortestLength


BDD
BDD::Decreasing(
  int i) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_Decreasing(mgr, node, i);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Decreasing


BDD
BDD::Increasing(
  int i) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_Increasing(mgr, node, i);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Increasing


bool
ABDD::EquivDC(
  const ABDD& G,
  const ABDD& D) const
{
    DdManager *mgr = checkSameManager(G);
    checkSameManager(D);
    return Cudd_EquivDC(mgr, node, G.node, D.node);

} // ABDD::EquivDC

bool
BDD::LeqUnless(
  const BDD& G,
  const BDD& D) const
{
    DdManager *mgr = checkSameManager(G);
    checkSameManager(D);
    int res = Cudd_bddLeqUnless(mgr, node, G.node, D.node);
    return res;

} // BDD::LeqUnless


bool
ADD::EqualSupNorm(
  const ADD& g,
  CUDD_VALUE_TYPE tolerance,
  int pr) const
{
    DdManager *mgr = checkSameManager(g);
    return Cudd_EqualSupNorm(mgr, node, g.node, tolerance, pr);

} // ADD::EqualSupNorm


BDD
BDD::MakePrime(
  const BDD& F) const
{
    DdManager *mgr = checkSameManager(F);
    if (!Cudd_CheckCube(mgr, node)) {
        p->errorHandler("Invalid argument.");
    }
    DdNode *result = Cudd_bddMakePrime(mgr, node, F.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD:MakePrime


BDD
BDD::MaximallyExpand(
  const BDD& ub,
  const BDD& f)
{
    DdManager *mgr = checkSameManager(ub);
    checkSameManager(f);
    DdNode *result = Cudd_bddMaximallyExpand(mgr, node, ub.node, f.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::MaximallyExpand


BDD
BDD::LargestPrimeUnate(
  const BDD& phases)
{
    DdManager *mgr = checkSameManager(phases);
    DdNode *result = Cudd_bddLargestPrimeUnate(mgr, node, phases.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::LargestPrimeUnate


double *
ABDD::CofMinterm() const
{
    DdManager *mgr = p->manager;
    double *result = Cudd_CofMinterm(mgr, node);
    checkReturnValue(result);
    return result;

} // ABDD::CofMinterm


BDD
BDD::SolveEqn(
  const BDD& Y,
  std::vector<BDD> & G,
  int ** yIndex,
  int n) const
{
    DdManager *mgr = checkSameManager(Y);
    DdNode **g = new DdNode *[n];
    DdNode *result = Cudd_SolveEqn(mgr, node, Y.node, g, yIndex, n);
    checkReturnValue(result);
    for (int i = 0; i < n; i++) {
        G.push_back(BDD(p, g[i]));
	Cudd_RecursiveDeref(mgr,g[i]);
    }
    delete [] g;
    return BDD(p, result);

} // BDD::SolveEqn


BDD
BDD::VerifySol(
  std::vector<BDD> const & G,
  int * yIndex) const
{
    size_t n = G.size();
    DdManager *mgr = p->manager;
    DdNode **g = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	g[i] = G[i].node;
    }
    DdNode *result = Cudd_VerifySol(mgr, node, g, yIndex, (int) n);
    delete [] g;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::VerifySol


BDD
BDD::SplitSet(
  std::vector<BDD> xVars,
  double m) const
{
    size_t n = xVars.size();
    DdManager *mgr = p->manager;
    DdNode **X = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	X[i] = xVars[i].node;
    }
    DdNode *result = Cudd_SplitSet(mgr, node, X, (int) n, m);
    delete [] X;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SplitSet


BDD
BDD::SubsetHeavyBranch(
  int numVars,
  int threshold) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_SubsetHeavyBranch(mgr, node, numVars, threshold);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SubsetHeavyBranch


BDD
BDD::SupersetHeavyBranch(
  int numVars,
  int threshold) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_SupersetHeavyBranch(mgr, node, numVars, threshold);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SupersetHeavyBranch


BDD
BDD::SubsetShortPaths(
  int numVars,
  int threshold,
  bool hardlimit) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_SubsetShortPaths(mgr, node, numVars, threshold, hardlimit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SubsetShortPaths


BDD
BDD::SupersetShortPaths(
  int numVars,
  int threshold,
  bool hardlimit) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_SupersetShortPaths(mgr, node, numVars, threshold, hardlimit);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::SupersetShortPaths


void
Cudd::SymmProfile(
  int lower,
  int upper) const
{
    Cudd_SymmProfile(p->manager, lower, upper);

} // Cudd::SymmProfile


unsigned int
Cudd::Prime(
  unsigned int pr) const
{
    return Cudd_Prime(pr);

} // Cudd::Prime


void
Cudd::Reserve(
  int amount) const
{
    int result = Cudd_Reserve(p->manager, amount);
    checkReturnValue(result);

} // Cudd::Reserve


void
ABDD::PrintMinterm() const
{
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_PrintMinterm(mgr, node);
    checkReturnValue(result);

} // ABDD::PrintMinterm


void
BDD::PrintCover() const
{
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_bddPrintCover(mgr, node, node);
    checkReturnValue(result);

} // BDD::PrintCover


void
BDD::PrintCover(
  const BDD& u) const
{
    checkSameManager(u);
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_bddPrintCover(mgr, node, u.node);
    checkReturnValue(result);

} // BDD::PrintCover


int
BDD::EstimateCofactor(
  int i,
  int phase) const
{
    DdManager *mgr = p->manager;
    int result = Cudd_EstimateCofactor(mgr, node, i, phase);
    checkReturnValue(result != CUDD_OUT_OF_MEM);
    return result;

} // BDD::EstimateCofactor


int
BDD::EstimateCofactorSimple(
  int i) const
{
    int result = Cudd_EstimateCofactorSimple(node, i);
    return result;

} // BDD::EstimateCofactorSimple


int
Cudd::SharingSize(
  DD* nodes,
  int n) const
{
    DdNode **nodeArray = new DdNode *[n];
    for (int i = 0; i < n; i++) {
	nodeArray[i] = nodes[i].getNode();
    }
    int result = Cudd_SharingSize(nodeArray, n);
    delete [] nodeArray;
    checkReturnValue(n == 0 || result > 0);
    return result;

} // Cudd::SharingSize


int
Cudd::SharingSize(
  const std::vector<BDD>& v) const
{
    vector<BDD>::size_type n = v.size();
    DdNode **nodeArray = new DdNode *[n];
    for (vector<BDD>::size_type i = 0; i != n; ++i) {
	nodeArray[i] = v[i].getNode();
    }
    int result = Cudd_SharingSize(nodeArray, (int) n);
    delete [] nodeArray;
    checkReturnValue(n == 0 || result > 0);
    return result;

} // Cudd::SharingSize


double
ABDD::CountMinterm(
  int nvars) const
{
    DdManager *mgr = p->manager;
    double result = Cudd_CountMinterm(mgr, node, nvars);
    checkReturnValue(result != (double) CUDD_OUT_OF_MEM);
    return result;

} // ABDD::CountMinterm


double
ABDD::CountPath() const
{
    double result = Cudd_CountPath(node);
    checkReturnValue(result != (double) CUDD_OUT_OF_MEM);
    return result;

} // ABDD::CountPath


BDD
ABDD::Support() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_Support(mgr, node);
    checkReturnValue(result);
    return BDD(p, result);

} // ABDD::Support


int
ABDD::SupportSize() const
{
    DdManager *mgr = p->manager;
    int result = Cudd_SupportSize(mgr, node);
    checkReturnValue(result != CUDD_OUT_OF_MEM);
    return result;

} // ABDD::SupportSize


BDD
Cudd::VectorSupport(const std::vector<BDD>& roots) const
{
    size_t n = roots.size();
    DdManager *mgr = p->manager;
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	F[i] = roots[i].getNode();
    }
    DdNode *result = Cudd_VectorSupport(mgr, F, (int) n);
    delete [] F;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::VectorSupport


std::vector<unsigned int>
ABDD::SupportIndices() const
{
    unsigned int *support;
    DdManager *mgr = p->manager;
    int size = Cudd_SupportIndices(mgr, node, (int **)&support);
    checkReturnValue(size >= 0);
    // size could be 0, in which case support is 0 too!
    vector<unsigned int> indices(support, support+size);
    if (support) free(support);
    return indices;

} // ABDD::SupportIndices


std::vector<unsigned int>
Cudd::SupportIndices(const std::vector<BDD>& roots) const
{
    unsigned int *support;
    size_t n = roots.size();
    DdManager *mgr = p->manager;
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	F[i] = roots[i].getNode();
    }
    int size = Cudd_VectorSupportIndices(mgr, F, (int) n, (int **)&support);
    delete [] F;
    checkReturnValue(size >= 0);
    // size could be 0, in which case support is 0 too!
    vector<unsigned int> indices(support, support+size);
    if (support) free(support);
    return indices;

} // Cudd::SupportIndices


std::vector<unsigned int>
Cudd::SupportIndices(const std::vector<ADD>& roots) const
{
    unsigned int *support;
    size_t n = roots.size();
    DdManager *mgr = p->manager;
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	F[i] = roots[i].getNode();
    }
    int size = Cudd_VectorSupportIndices(mgr, F, (int) n, (int **)&support);
    delete [] F;
    checkReturnValue(size >= 0);
    // size could be 0, in which case support is 0 too!
    vector<unsigned int> indices(support, support+size);
    if (support) free(support);
    return indices;

} // Cudd::SupportIndices


int
Cudd::nodeCount(const std::vector<BDD>& roots) const
{
    size_t n = roots.size();
    DdNode **nodeArray = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	nodeArray[i] = roots[i].getNode();
    }
    int result = Cudd_SharingSize(nodeArray, (int) n);
    delete [] nodeArray;
    checkReturnValue(result > 0);
    return result;

} // Cudd::nodeCount


BDD
Cudd::VectorSupport(const std::vector<ADD>& roots) const
{
    size_t n = roots.size();
    DdManager *mgr = p->manager;
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	F[i] = roots[i].getNode();
    }
    DdNode *result = Cudd_VectorSupport(mgr, F, (int) n);
    delete [] F;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::VectorSupport


int
Cudd::VectorSupportSize(const std::vector<BDD>& roots) const
{
    size_t n = roots.size();
    DdManager *mgr = p->manager;
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	F[i] = roots[i].getNode();
    }
    int result = Cudd_VectorSupportSize(mgr, F, (int) n);
    delete [] F;
    checkReturnValue(result != CUDD_OUT_OF_MEM);
    return result;

} // Cudd::VectorSupportSize


int
Cudd::VectorSupportSize(const std::vector<ADD>& roots) const
{
    size_t n = roots.size();
    DdManager *mgr = p->manager;
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	F[i] = roots[i].getNode();
    }
    int result = Cudd_VectorSupportSize(mgr, F, (int) n);
    delete [] F;
    checkReturnValue(result != CUDD_OUT_OF_MEM);
    return result;

} // Cudd::VectorSupportSize


void
ABDD::ClassifySupport(
  const ABDD& g,
  BDD* common,
  BDD* onlyF,
  BDD* onlyG) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *C, *F, *G;
    int result = Cudd_ClassifySupport(mgr, node, g.node, &C, &F, &G);
    checkReturnValue(result);
    *common = BDD(p, C);
    *onlyF = BDD(p, F);
    *onlyG = BDD(p, G);

} // ABDD::ClassifySupport


int
ABDD::CountLeaves() const
{
    return Cudd_CountLeaves(node);

} // ABDD::CountLeaves


void
BDD::PickOneCube(
  char * string) const
{
    DdManager *mgr = p->manager;
    int result = Cudd_bddPickOneCube(mgr, node, string);
    checkReturnValue(result);

} // BDD::PickOneCube


BDD
BDD::PickOneMinterm(
  std::vector<BDD> vars) const
{
    size_t n = vars.size();
    DdManager *mgr = p->manager;
    DdNode **V = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	V[i] = vars[i].node;
    }
    DdNode *result = Cudd_bddPickOneMinterm(mgr, node, V, (int) n);
    delete [] V;
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::PickOneMinterm


BDD
Cudd::bddComputeCube(
  BDD * vars,
  int * phase,
  int n) const
{
    DdManager *mgr = p->manager;
    DdNode **V = new DdNode *[n];
    for (int i = 0; i < n; i++) {
	V[i] = vars[i].getNode();
    }
    DdNode *result = Cudd_bddComputeCube(mgr, V, phase, n);
    delete [] V;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::bddComputeCube


BDD
Cudd::computeCube(
  std::vector<BDD> const & vars) const
{
    DdManager *mgr = p->manager;
    size_t n = vars.size();
    DdNode **V = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	V[i] = vars[i].getNode();
    }
    DdNode *result = Cudd_bddComputeCube(mgr, V, 0, n);
    delete [] V;
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::computeCube


ADD
Cudd::addComputeCube(
  ADD * vars,
  int * phase,
  int n) const
{
    DdManager *mgr = p->manager;
    DdNode **V = new DdNode *[n];
    for (int i = 0; i < n; i++) {
	V[i] = vars[i].getNode();
    }
    DdNode *result = Cudd_addComputeCube(mgr, V, phase, n);
    delete [] V;
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::addComputeCube


ADD
Cudd::computeCube(
  std::vector<ADD> const & vars) const
{
    DdManager *mgr = p->manager;
    size_t n = vars.size();
    DdNode **V = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	V[i] = vars[i].getNode();
    }
    DdNode *result = Cudd_addComputeCube(mgr, V, 0, n);
    delete [] V;
    checkReturnValue(result);
    return ADD(p, result);

} // Cudd::computeCube


BDD
Cudd::IndicesToCube(
  int * array,
  int n) const
{
    DdNode *result = Cudd_IndicesToCube(p->manager, array, n);
    checkReturnValue(result);
    return BDD(p, result);

} // Cudd::IndicesToCube


void
Cudd::PrintVersion(
  FILE * fp) const
{
    cout.flush();
    Cudd_PrintVersion(fp);

} // Cudd::PrintVersion


double
Cudd::AverageDistance() const
{
    return Cudd_AverageDistance(p->manager);

} // Cudd::AverageDistance


int32_t
Cudd::Random() const
{
    return Cudd_Random(p->manager);

} // Cudd::Random


void
Cudd::Srandom(
  int32_t seed) const
{
    Cudd_Srandom(p->manager,seed);

} // Cudd::Srandom


double
ABDD::Density(
  int nvars) const
{
    DdManager *mgr = p->manager;
    double result = Cudd_Density(mgr, node, nvars);
    checkReturnValue(result != (double) CUDD_OUT_OF_MEM);
    return result;

} // ABDD::Density


int
ZDD::Count() const
{
    DdManager *mgr = p->manager;
    int result = Cudd_zddCount(mgr, node);
    checkReturnValue(result != CUDD_OUT_OF_MEM);
    return result;

} // ZDD::Count


double
ZDD::CountDouble() const
{
    DdManager *mgr = p->manager;
    double result = Cudd_zddCountDouble(mgr, node);
    checkReturnValue(result != (double) CUDD_OUT_OF_MEM);
    return result;

} // ZDD::CountDouble


ZDD
ZDD::Product(
  const ZDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_zddProduct(mgr, node, g.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Product


ZDD
ZDD::UnateProduct(
  const ZDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_zddUnateProduct(mgr, node, g.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::UnateProduct


ZDD
ZDD::WeakDiv(
  const ZDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_zddWeakDiv(mgr, node, g.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::WeakDiv


ZDD
ZDD::Divide(
  const ZDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_zddDivide(mgr, node, g.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Divide


ZDD
ZDD::WeakDivF(
  const ZDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_zddWeakDivF(mgr, node, g.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::WeakDivF


ZDD
ZDD::DivideF(
  const ZDD& g) const
{
    DdManager *mgr = checkSameManager(g);
    DdNode *result = Cudd_zddDivideF(mgr, node, g.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::DivideF


MtrNode *
Cudd::MakeZddTreeNode(
  unsigned int low,
  unsigned int size,
  unsigned int type) const
{
    return Cudd_MakeZddTreeNode(p->manager, low, size, type);

} // Cudd::MakeZddTreeNode


BDD
BDD::zddIsop(
  const BDD& U,
  ZDD* zdd_I) const
{
    DdManager *mgr = checkSameManager(U);
    DdNode *Z;
    DdNode *result = Cudd_zddIsop(mgr, node, U.node, &Z);
    checkReturnValue(result);
    *zdd_I = ZDD(p, Z);
    return BDD(p, result);

} // BDD::Isop


BDD
BDD::Isop(
  const BDD& U) const
{
    DdManager *mgr = checkSameManager(U);
    DdNode *result = Cudd_bddIsop(mgr, node, U.node);
    checkReturnValue(result);
    return BDD(p, result);

} // BDD::Isop


double
ZDD::CountMinterm(
  int path) const
{
    DdManager *mgr = p->manager;
    double result = Cudd_zddCountMinterm(mgr, node, path);
    checkReturnValue(result != (double) CUDD_OUT_OF_MEM);
    return result;

} // ZDD::CountMinterm


void
Cudd::zddPrintSubtable() const
{
    cout.flush();
    Cudd_zddPrintSubtable(p->manager);

} // Cudd::zddPrintSubtable


ZDD
BDD::PortToZdd() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_zddPortFromBdd(mgr, node);
    checkReturnValue(result);
    return ZDD(p, result);

} // BDD::PortToZdd


BDD
ZDD::PortToBdd() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_zddPortToBdd(mgr, node);
    checkReturnValue(result);
    return BDD(p, result);

} // ZDD::PortToBdd


void
Cudd::zddReduceHeap(
  Cudd_ReorderingType heuristic,
  int minsize) const
{
    int result = Cudd_zddReduceHeap(p->manager, heuristic, minsize);
    checkReturnValue(result);

} // Cudd::zddReduceHeap


void
Cudd::zddShuffleHeap(
  int * permutation) const
{
    int result = Cudd_zddShuffleHeap(p->manager, permutation);
    checkReturnValue(result);

} // Cudd::zddShuffleHeap


ZDD
ZDD::Ite(
  const ZDD& g,
  const ZDD& h) const
{
    DdManager *mgr = checkSameManager(g);
    checkSameManager(h);
    DdNode *result = Cudd_zddIte(mgr, node, g.node, h.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Ite


ZDD
ZDD::Union(
  const ZDD& Q) const
{
    DdManager *mgr = checkSameManager(Q);
    DdNode *result = Cudd_zddUnion(mgr, node, Q.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Union


ZDD
ZDD::Intersect(
  const ZDD& Q) const
{
    DdManager *mgr = checkSameManager(Q);
    DdNode *result = Cudd_zddIntersect(mgr, node, Q.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Intersect


ZDD
ZDD::Diff(
  const ZDD& Q) const
{
    DdManager *mgr = checkSameManager(Q);
    DdNode *result = Cudd_zddDiff(mgr, node, Q.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Diff


ZDD
ZDD::DiffConst(
  const ZDD& Q) const
{
    DdManager *mgr = checkSameManager(Q);
    DdNode *result = Cudd_zddDiffConst(mgr, node, Q.node);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::DiffConst


ZDD
ZDD::Subset1(
  int var) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_zddSubset1(mgr, node, var);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Subset1


ZDD
ZDD::Subset0(
  int var) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_zddSubset0(mgr, node, var);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Subset0


ZDD
ZDD::Change(
  int var) const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_zddChange(mgr, node, var);
    checkReturnValue(result);
    return ZDD(p, result);

} // ZDD::Change


void
Cudd::zddSymmProfile(
  int lower,
  int upper) const
{
    Cudd_zddSymmProfile(p->manager, lower, upper);

} // Cudd::zddSymmProfile


void
ZDD::PrintMinterm() const
{
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_zddPrintMinterm(mgr, node);
    checkReturnValue(result);

} // ZDD::PrintMinterm


void
ZDD::PrintCover() const
{
    cout.flush();
    DdManager *mgr = p->manager;
    int result = Cudd_zddPrintCover(mgr, node);
    checkReturnValue(result);

} // ZDD::PrintCover


BDD
ZDD::Support() const
{
    DdManager *mgr = p->manager;
    DdNode *result = Cudd_zddSupport(mgr, node);
    checkReturnValue(result);
    return BDD(p, result);

} // ZDD::Support


void
Cudd::DumpDot(
  const std::vector<ZDD>& nodes,
  char const * const * inames,
  char const * const * onames,
  FILE * fp) const
{
    DdManager *mgr = p->manager;
    size_t n = nodes.size();
    DdNode **F = new DdNode *[n];
    for (size_t i = 0; i < n; i++) {
	F[i] = nodes[i].getNode();
    }
    int result = Cudd_zddDumpDot(mgr, (int) n, F, inames, onames, fp);
    delete [] F;
    checkReturnValue(result);

} // vector<ZDD>::DumpDot


std::string
Cudd::OrderString(void) const
{
    DdManager * mgr = p->manager;
    int nvars = Cudd_ReadSize(mgr);
    bool hasNames = p->varnames.size() == (size_t) nvars;
    std::ostringstream oss;
    std::string separ = "";
    for (int level = 0; level != nvars; ++level) {
        oss << separ;
        separ = " ";
        int index = Cudd_ReadInvPerm(mgr, level);
        if (hasNames) {
            oss << p->varnames.at(index);
        } else {
            oss << "x" << index;
        }
    }
    return oss.str();

} // Cudd::OrderString

cuddObj.hh
28846
/**
  @file

  @ingroup cplusplus

  @brief Class definitions for C++ object-oriented encapsulation of
  CUDD.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef CUDD_OBJ_H_
#define CUDD_OBJ_H_

/*---------------------------------------------------------------------------*/
/* Nested includes                                                           */
/*---------------------------------------------------------------------------*/

#include <cstdio>
#include <string>
#include <vector>
#include "cudd.h"

/*---------------------------------------------------------------------------*/
/* Type definitions                                                          */
/*---------------------------------------------------------------------------*/
class BDD;
class ADD;
class ZDD;
class Cudd;

typedef void (*PFC)(std::string);	// handler function type

/*---------------------------------------------------------------------------*/
/* Class definitions                                                         */
/*---------------------------------------------------------------------------*/

class Capsule;


/**
  @brief Base class for all decision diagrams in CUDD.

  @see Cudd ABDD ADD BDD ZDD

*/
class DD {
protected:
    Capsule *p;
    DdNode *node;
    inline DdManager * checkSameManager(const DD &other) const;
    inline void checkReturnValue(const void *result) const;
    inline void checkReturnValue(int result, int expected = 1)
	const;
    DD();
    DD(Capsule *cap, DdNode *ddNode);
    DD(Cudd const & manager, DdNode *ddNode);
    DD(const DD &from);
    ~DD();
public:
    // This operator should be declared explicit, but there are still too many
    // compilers out there that do not support this C++11 feature.
    operator bool() const { return (bool)node; }
    DdManager * manager() const;
    DdNode * getNode() const;
    DdNode * getRegularNode() const;
    int nodeCount() const;
    unsigned int NodeReadIndex() const;

}; // DD


/**
  @brief Class for ADDs and BDDs.

  @see Cudd ADD BDD

*/
class ABDD : public DD {
    friend class Cudd;
protected:
    ABDD();
    ABDD(Capsule *cap, DdNode *bddNode);
    ABDD(Cudd const & manager, DdNode *ddNode);
    ABDD(const ABDD &from);
    ~ABDD();
public:
    bool operator==(const ABDD &other) const;
    bool operator!=(const ABDD &other) const;
    void print(int nvars, int verbosity = 1) const;
    void summary(int nvars, int mode = 0) const;
    DdApaNumber ApaCountMinterm(int nvars, int * digits) const;
    void ApaPrintMinterm(int nvars, FILE * fp = stdout) const;
    void ApaPrintMintermExp(int nvars, int precision = 6, FILE * fp = stdout) const;
    void EpdPrintMinterm(int nvars, FILE * fp = stdout) const;
    long double LdblCountMinterm(int nvars) const;
    bool IsOne() const;
    bool IsCube() const;
    BDD FindEssential() const;
    void PrintTwoLiteralClauses(char ** names = 0, FILE * fp = stdout) const;
    BDD ShortestPath(int * weight, int * support, int * length) const;
    BDD LargestCube(int * length = 0) const;
    int ShortestLength(int * weight = 0) const;
    bool EquivDC(const ABDD& G, const ABDD& D) const;
    double * CofMinterm() const;
    void PrintMinterm() const;
    double CountMinterm(int nvars) const;
    double CountPath() const;
    BDD Support() const;
    int SupportSize() const;
    std::vector<unsigned int> SupportIndices() const;
    void ClassifySupport(const ABDD& g, BDD* common, BDD* onlyF, BDD* onlyG)
	const;
    int CountLeaves() const;
    double Density(int nvars) const;

}; // ABDD


/**
  @brief Class for BDDs.

  @see Cudd

*/
class BDD : public ABDD {
    friend class Cudd;
public:
    BDD();
    BDD(Capsule *cap, DdNode *bddNode);
    BDD(Cudd const & manager, DdNode *ddNode);
    BDD(const BDD &from);
    BDD operator=(const BDD& right);
    bool operator<=(const BDD& other) const;
    bool operator>=(const BDD& other) const;
    bool operator<(const BDD& other) const;
    bool operator>(const BDD& other) const;
    BDD operator!() const;
    BDD operator~() const;
    BDD operator*(const BDD& other) const;
    BDD operator*=(const BDD& other);
    BDD operator&(const BDD& other) const;
    BDD operator&=(const BDD& other);
    BDD operator+(const BDD& other) const;
    BDD operator+=(const BDD& other);
    BDD operator|(const BDD& other) const;
    BDD operator|=(const BDD& other);
    BDD operator^(const BDD& other) const;
    BDD operator^=(const BDD& other);
    BDD operator-(const BDD& other) const;
    BDD operator-=(const BDD& other);
    friend std::ostream & operator<<(std::ostream & os, BDD const & f);
    bool IsZero() const;
    bool IsVar() const;
    BDD AndAbstract(const BDD& g, const BDD& cube, unsigned int limit = 0)
	const;
    BDD UnderApprox(
      int numVars,
      int threshold = 0,
      bool safe = false,
      double quality = 1.0) const;
    BDD OverApprox(
      int numVars,
      int threshold = 0,
      bool safe = false,
      double quality = 1.0) const;
    BDD RemapUnderApprox(int numVars, int threshold = 0, double quality = 1.0)
	const;
    BDD RemapOverApprox(int numVars, int threshold = 0, double quality = 1.0)
	const;
    BDD BiasedUnderApprox(const BDD& bias, int numVars, int threshold = 0, 
                          double quality1 = 1.0, double quality0 = 1.0) const;
    BDD BiasedOverApprox(const BDD& bias, int numVars, int threshold = 0, 
                         double quality1 = 1.0, double quality0 = 1.0) const;
    BDD ExistAbstract(const BDD& cube, unsigned int limit = 0) const;
    BDD XorExistAbstract(const BDD& g, const BDD& cube) const;
    BDD UnivAbstract(const BDD& cube) const;
    BDD BooleanDiff(int x) const;
    bool VarIsDependent(const BDD& var) const;
    double Correlation(const BDD& g) const;
    double CorrelationWeights(const BDD& g, double * prob) const;
    BDD Ite(const BDD& g, const BDD& h, unsigned int limit = 0) const;
    BDD IteConstant(const BDD& g, const BDD& h) const;
    BDD Intersect(const BDD& g) const;
    BDD And(const BDD& g, unsigned int limit = 0) const;
    BDD Or(const BDD& g, unsigned int limit = 0) const;
    BDD Nand(const BDD& g) const;
    BDD Nor(const BDD& g) const;
    BDD Xor(const BDD& g) const;
    BDD Xnor(const BDD& g, unsigned int limit = 0) const;
    bool Leq(const BDD& g) const;
    ADD Add() const;
    BDD Transfer(Cudd& destination) const;
    BDD ClippingAnd(const BDD& g, int maxDepth, int direction = 0) const;
    BDD ClippingAndAbstract(const BDD& g, const BDD& cube, int maxDepth,
			    int direction = 0) const;
    BDD Cofactor(const BDD& g) const;
    bool VarAreSymmetric(int index1, int index2) const;
    BDD Compose(const BDD& g, int v) const;
    BDD Permute(int * permut) const;
    BDD SwapVariables(std::vector<BDD> x, std::vector<BDD> y) const;
    BDD AdjPermuteX(std::vector<BDD> x) const;
    BDD VectorCompose(std::vector<BDD> vector) const;
    void ApproxConjDecomp(BDD* g, BDD* h) const;
    void ApproxDisjDecomp(BDD* g, BDD* h) const;
    void IterConjDecomp(BDD* g, BDD* h) const;
    void IterDisjDecomp(BDD* g, BDD* h) const;
    void GenConjDecomp(BDD* g, BDD* h) const;
    void GenDisjDecomp(BDD* g, BDD* h) const;
    void VarConjDecomp(BDD* g, BDD* h) const;
    void VarDisjDecomp(BDD* g, BDD* h) const;
    bool IsVarEssential(int id, int phase) const;
    BDD Constrain(const BDD& c) const;
    BDD Restrict(const BDD& c) const;
    BDD NPAnd(const BDD& g) const;
    std::vector<BDD> ConstrainDecomp() const;
    std::vector<BDD> CharToVect() const;
    BDD LICompaction(const BDD& c) const;
    BDD Squeeze(const BDD& u) const;
    BDD Interpolate(const BDD& u) const;
    BDD Minimize(const BDD& c) const;
    BDD SubsetCompress(int nvars, int threshold) const;
    BDD SupersetCompress(int nvars, int threshold) const;
    BDD LiteralSetIntersection(const BDD& g) const;
    BDD PrioritySelect(std::vector<BDD> x, std::vector<BDD> y,
		       std::vector<BDD> z, const BDD& Pi, DD_PRFP Pifunc) const;
    BDD CProjection(const BDD& Y) const;
    int MinHammingDist(int *minterm, int upperBound) const;
    BDD Eval(int * inputs) const;
    BDD Decreasing(int i) const;
    BDD Increasing(int i) const;
    bool LeqUnless(const BDD& G, const BDD& D) const;
    BDD MakePrime(const BDD& F) const;
    BDD MaximallyExpand(const BDD& ub, const BDD& f);
    BDD LargestPrimeUnate(const BDD& phases);
    BDD SolveEqn(const BDD& Y, std::vector<BDD> & G, int ** yIndex, int n) const;
    BDD VerifySol(std::vector<BDD> const & G, int * yIndex) const;
    BDD SplitSet(std::vector<BDD> xVars, double m) const;
    BDD SubsetHeavyBranch(int numVars, int threshold) const;
    BDD SupersetHeavyBranch(int numVars, int threshold) const;
    BDD SubsetShortPaths(int numVars, int threshold, bool hardlimit = false) const;
    BDD SupersetShortPaths(int numVars, int threshold, bool hardlimit = false) const;
    void PrintCover() const;
    void PrintCover(const BDD& u) const;
    int EstimateCofactor(int i, int phase) const;
    int EstimateCofactorSimple(int i) const;
    void PickOneCube(char * string) const;
    BDD PickOneMinterm(std::vector<BDD> vars) const;
    BDD zddIsop(const BDD& U, ZDD* zdd_I) const;
    BDD Isop(const BDD& U) const;
    ZDD PortToZdd() const;
    void PrintFactoredForm(char const * const * inames = 0, FILE * fp = stdout) const;
    std::string FactoredFormString(char const * const * inames = 0) const;

}; // BDD


/**
  @brief Class for ADDs.

  @see Cudd

*/
class ADD : public ABDD {
    friend class Cudd;
public:
    ADD();
    ADD(Capsule *cap, DdNode *bddNode);
    ADD(Cudd const & manager, DdNode *ddNode);
    ADD(const ADD &from);
    ADD operator=(const ADD& right);
    // Relational operators
    bool operator<=(const ADD& other) const;
    bool operator>=(const ADD& other) const;
    bool operator<(const ADD& other) const;
    bool operator>(const ADD& other) const;
    // Arithmetic operators
    ADD operator-() const;
    ADD operator*(const ADD& other) const;
    ADD operator*=(const ADD& other);
    ADD operator+(const ADD& other) const;
    ADD operator+=(const ADD& other);
    ADD operator-(const ADD& other) const;
    ADD operator-=(const ADD& other);
    // Logical operators
    ADD operator~() const;
    ADD operator&(const ADD& other) const;
    ADD operator&=(const ADD& other);
    ADD operator|(const ADD& other) const;
    ADD operator|=(const ADD& other);
    bool IsZero() const;
    ADD ExistAbstract(const ADD& cube) const;
    ADD UnivAbstract(const ADD& cube) const;
    ADD OrAbstract(const ADD& cube) const;
    ADD Plus(const ADD& g) const;
    ADD Times(const ADD& g) const;
    ADD Threshold(const ADD& g) const;
    ADD SetNZ(const ADD& g) const;
    ADD Divide(const ADD& g) const;
    ADD Minus(const ADD& g) const;
    ADD Minimum(const ADD& g) const;
    ADD Maximum(const ADD& g) const;
    ADD OneZeroMaximum(const ADD& g) const;
    ADD Diff(const ADD& g) const;
    ADD Agreement(const ADD& g) const;
    ADD Or(const ADD& g) const;
    ADD Nand(const ADD& g) const;
    ADD Nor(const ADD& g) const;
    ADD Xor(const ADD& g) const;
    ADD Xnor(const ADD& g) const;
    ADD Log() const;
    ADD FindMax() const;
    ADD FindMin() const;
    ADD IthBit(int bit) const;
    ADD ScalarInverse(const ADD& epsilon) const;
    ADD Ite(const ADD& g, const ADD& h) const;
    ADD IteConstant(const ADD& g, const ADD& h) const;
    ADD EvalConst(const ADD& g) const;
    bool Leq(const ADD& g) const;
    ADD Cmpl() const;
    ADD Negate() const;
    ADD RoundOff(int N) const;
    BDD BddThreshold(CUDD_VALUE_TYPE value) const;
    BDD BddStrictThreshold(CUDD_VALUE_TYPE value) const;
    BDD BddInterval(CUDD_VALUE_TYPE lower, CUDD_VALUE_TYPE upper) const;
    BDD BddIthBit(int bit) const;
    BDD BddPattern() const;
    ADD Cofactor(const ADD& g) const;
    ADD Compose(const ADD& g, int v) const;
    ADD Permute(int * permut) const;
    ADD SwapVariables(std::vector<ADD> x, std::vector<ADD> y) const;
    ADD VectorCompose(std::vector<ADD> vector) const;
    ADD NonSimCompose(std::vector<ADD> vector) const;
    ADD Constrain(const ADD& c) const;
    ADD Restrict(const ADD& c) const;
    ADD MatrixMultiply(const ADD& B, std::vector<ADD> z) const;
    ADD TimesPlus(const ADD& B, std::vector<ADD> z) const;
    ADD Triangle(const ADD& g, std::vector<ADD> z) const;
    ADD Eval(int * inputs) const;
    bool EqualSupNorm(const ADD& g, CUDD_VALUE_TYPE tolerance, int pr) const;

}; // ADD


/**
  @brief Class for ZDDs.

  @see Cudd

*/
class ZDD : public DD {
    friend class Cudd;
public:
    ZDD(Capsule *cap, DdNode *bddNode);
    ZDD();
    ZDD(const ZDD &from);
    ~ZDD();
    ZDD operator=(const ZDD& right);
    bool operator==(const ZDD& other) const;
    bool operator!=(const ZDD& other) const;
    bool operator<=(const ZDD& other) const;
    bool operator>=(const ZDD& other) const;
    bool operator<(const ZDD& other) const;
    bool operator>(const ZDD& other) const;
    void print(int nvars, int verbosity = 1) const;
    ZDD operator*(const ZDD& other) const;
    ZDD operator*=(const ZDD& other);
    ZDD operator&(const ZDD& other) const;
    ZDD operator&=(const ZDD& other);
    ZDD operator+(const ZDD& other) const;
    ZDD operator+=(const ZDD& other);
    ZDD operator|(const ZDD& other) const;
    ZDD operator|=(const ZDD& other);
    ZDD operator-(const ZDD& other) const;
    ZDD operator-=(const ZDD& other);
    int Count() const;
    double CountDouble() const;
    ZDD Product(const ZDD& g) const;
    ZDD UnateProduct(const ZDD& g) const;
    ZDD WeakDiv(const ZDD& g) const;
    ZDD Divide(const ZDD& g) const;
    ZDD WeakDivF(const ZDD& g) const;
    ZDD DivideF(const ZDD& g) const;
    double CountMinterm(int path) const;
    BDD PortToBdd() const;
    ZDD Ite(const ZDD& g, const ZDD& h) const;
    ZDD Union(const ZDD& Q) const;
    ZDD Intersect(const ZDD& Q) const;
    ZDD Diff(const ZDD& Q) const;
    ZDD DiffConst(const ZDD& Q) const;
    ZDD Subset1(int var) const;
    ZDD Subset0(int var) const;
    ZDD Change(int var) const;
    void PrintMinterm() const;
    void PrintCover() const;
    BDD Support() const;

}; // ZDD


/**
   @brief Default error handler.
*/
extern void defaultError(std::string message);


/**
  @brief Class for CUDD managers.

  @see DD

*/
class Cudd {
    friend class DD;
    friend class ABDD;
    friend class BDD;
    friend class ADD;
    friend class ZDD;
    friend std::ostream & operator<<(std::ostream & os, BDD const & f);
private:
    Capsule *p;
public:
    Cudd(
      unsigned int numVars = 0,
      unsigned int numVarsZ = 0,
      unsigned int numSlots = CUDD_UNIQUE_SLOTS,
      unsigned int cacheSize = CUDD_CACHE_SLOTS,
      unsigned long maxMemory = 0,
      PFC defaultHandler = defaultError);
    Cudd(const Cudd& x);
    ~Cudd(void);
    PFC setHandler(PFC newHandler) const;
    PFC getHandler(void) const;
    PFC setTimeoutHandler(PFC newHandler) const;
    PFC getTimeoutHandler(void) const;
    PFC setTerminationHandler(PFC newHandler) const;
    PFC getTerminationHandler(void) const;
    void pushVariableName(std::string s) const;
    void clearVariableNames(void) const;
    std::string getVariableName(size_t i) const;
    DdManager *getManager(void) const;
    void makeVerbose(void) const;
    void makeTerse(void) const;
    bool isVerbose(void) const;
    void checkReturnValue(const void *result) const;
    void checkReturnValue(const int result) const;
    Cudd& operator=(const Cudd& right);
    void info(void) const;
    BDD bddVar(void) const;
    BDD bddVar(int index) const;
    BDD bddOne(void) const;
    BDD bddZero(void) const;
    ADD addVar(void) const;
    ADD addVar(int index) const;
    ADD addOne(void) const;
    ADD addZero(void) const;
    ADD constant(CUDD_VALUE_TYPE c) const;
    ADD plusInfinity(void) const;
    ADD minusInfinity(void) const;
    ZDD zddVar(int index) const;
    ZDD zddOne(int i) const;
    ZDD zddZero(void) const;
    ADD addNewVarAtLevel(int level) const;
    BDD bddNewVarAtLevel(int level) const;
    void zddVarsFromBddVars(int multiplicity) const;
    unsigned long ReadStartTime(void) const;
    unsigned long ReadElapsedTime(void) const;
    void SetStartTime(unsigned long st) const;
    void ResetStartTime(void) const;
    unsigned long ReadTimeLimit(void) const;
    unsigned long SetTimeLimit(unsigned long tl) const;
    void UpdateTimeLimit(void) const;
    void IncreaseTimeLimit(unsigned long increase) const;
    void UnsetTimeLimit(void) const;
    bool TimeLimited(void) const;
    void RegisterTerminationCallback(DD_THFP callback,
                                     void * callback_arg) const;
    void UnregisterTerminationCallback(void) const;
    DD_OOMFP RegisterOutOfMemoryCallback(DD_OOMFP callback) const;
    void UnregisterOutOfMemoryCallback(void) const;
    void AutodynEnable(Cudd_ReorderingType method = CUDD_REORDER_SIFT) const;
    void AutodynDisable(void) const;
    bool ReorderingStatus(Cudd_ReorderingType * method) const;
    void AutodynEnableZdd(Cudd_ReorderingType method = CUDD_REORDER_SIFT) const;
    void AutodynDisableZdd(void) const;
    bool ReorderingStatusZdd(Cudd_ReorderingType * method) const;
    bool zddRealignmentEnabled(void) const;
    void zddRealignEnable(void) const;
    void zddRealignDisable(void) const;
    bool bddRealignmentEnabled(void) const;
    void bddRealignEnable(void) const;
    void bddRealignDisable(void) const;
    ADD background(void) const;
    void SetBackground(ADD bg) const;
    unsigned int ReadCacheSlots(void) const;
    double ReadCacheUsedSlots(void) const;
    double ReadCacheLookUps(void) const;
    double ReadCacheHits(void) const;
    unsigned int ReadMinHit(void) const;
    void SetMinHit(unsigned int hr) const;
    unsigned int ReadLooseUpTo(void) const;
    void SetLooseUpTo(unsigned int lut) const;
    unsigned int ReadMaxCache(void) const;
    unsigned int ReadMaxCacheHard(void) const;
    void SetMaxCacheHard(unsigned int mc) const;
    int ReadSize(void) const;
    int ReadZddSize(void) const;
    unsigned int ReadSlots(void) const;
    unsigned int ReadKeys(void) const;
    unsigned int ReadDead(void) const;
    unsigned int ReadMinDead(void) const;
    unsigned int ReadReorderings(void) const;
    unsigned int ReadMaxReorderings(void) const;
    void SetMaxReorderings(unsigned int mr) const;
    long ReadReorderingTime(void) const;
    int ReadGarbageCollections(void) const;
    long ReadGarbageCollectionTime(void) const;
    int ReadSiftMaxVar(void) const;
    void SetSiftMaxVar(int smv) const;
    int ReadSiftMaxSwap(void) const;
    void SetSiftMaxSwap(int sms) const;
    double ReadMaxGrowth(void) const;
    void SetMaxGrowth(double mg) const;
#ifdef MTR_H_
    MtrNode * ReadTree(void) const;
    void SetTree(MtrNode * tree) const;
    void FreeTree(void) const;
    MtrNode * ReadZddTree(void) const;
    void SetZddTree(MtrNode * tree) const;
    void FreeZddTree(void) const;
    MtrNode * MakeTreeNode(unsigned int low, unsigned int size,
                           unsigned int type) const;
    MtrNode * MakeZddTreeNode(unsigned int low, unsigned int size,
                              unsigned int type) const;
#endif
    int ReadPerm(int i) const;
    int ReadPermZdd(int i) const;
    int ReadInvPerm(int i) const;
    int ReadInvPermZdd(int i) const;
    BDD ReadVars(int i) const;
    CUDD_VALUE_TYPE ReadEpsilon(void) const;
    void SetEpsilon(CUDD_VALUE_TYPE ep) const;
    Cudd_AggregationType ReadGroupcheck(void) const;
    void SetGroupcheck(Cudd_AggregationType gc) const;
    bool GarbageCollectionEnabled(void) const;
    void EnableGarbageCollection(void) const;
    void DisableGarbageCollection(void) const;
    bool DeadAreCounted(void) const;
    void TurnOnCountDead(void) const;
    void TurnOffCountDead(void) const;
    int ReadRecomb(void) const;
    void SetRecomb(int recomb) const;
    int ReadSymmviolation(void) const;
    void SetSymmviolation(int symmviolation) const;
    int ReadArcviolation(void) const;
    void SetArcviolation(int arcviolation) const;
    int ReadPopulationSize(void) const;
    void SetPopulationSize(int populationSize) const;
    int ReadNumberXovers(void) const;
    void SetNumberXovers(int numberXovers) const;
    unsigned int ReadOrderRandomization(void) const;
    void SetOrderRandomization(unsigned int factor) const;
    unsigned long ReadMemoryInUse(void) const;
    long ReadPeakNodeCount(void) const;
    long ReadNodeCount(void) const;
    long zddReadNodeCount(void) const;
    void AddHook(DD_HFP f, Cudd_HookType where) const;
    void RemoveHook(DD_HFP f, Cudd_HookType where) const;
    bool IsInHook(DD_HFP f, Cudd_HookType where) const;
    void EnableReorderingReporting(void) const;
    void DisableReorderingReporting(void) const;
    bool ReorderingReporting(void) const;
    int ReadErrorCode(void) const;
    DD_OOMFP InstallOutOfMemoryHandler(DD_OOMFP newHandler) const;
    void ClearErrorCode(void) const;
    FILE *ReadStdout(void) const;
    void SetStdout(FILE * fp) const;
    FILE *ReadStderr(void) const;
    void SetStderr(FILE * fp) const;
    unsigned int ReadNextReordering(void) const;
    void SetNextReordering(unsigned int) const;
    double ReadSwapSteps(void) const;
    unsigned int ReadMaxLive(void) const;
    void SetMaxLive(unsigned int) const;
    size_t ReadMaxMemory(void) const;
    size_t SetMaxMemory(size_t) const;
    int bddBindVar(int) const;
    int bddUnbindVar(int) const;
    bool bddVarIsBound(int) const;
    ADD Walsh(std::vector<ADD> x, std::vector<ADD> y) const;
    ADD addResidue(int n, int m, int options, int top) const;
    int ApaNumberOfDigits(int binaryDigits) const;
    DdApaNumber NewApaNumber(int digits) const;
    void ApaCopy(int digits, DdApaNumber source, DdApaNumber dest) const;
    DdApaDigit ApaAdd(int digits, DdApaNumber a, DdApaNumber b, DdApaNumber
		      sum) const;
    DdApaDigit ApaSubtract(int digits, DdApaNumber a, DdApaNumber b,
			   DdApaNumber diff) const;
    DdApaDigit ApaShortDivision(int digits, DdApaNumber dividend, DdApaDigit
				divisor, DdApaNumber quotient) const;
    void ApaShiftRight(int digits, DdApaDigit in, DdApaNumber a, DdApaNumber
		       b) const;
    void ApaSetToLiteral(int digits, DdApaNumber number, DdApaDigit literal)
      const;
    void ApaPowerOfTwo(int digits, DdApaNumber number, int power) const;
    void ApaPrintHex(int digits, DdApaNumber number, FILE * fp = stdout) const;
    void ApaPrintDecimal(int digits, DdApaNumber number, FILE * fp = stdout) const;
    std::string ApaStringDecimal(int digits, DdApaNumber number) const;
    void ApaPrintExponential(int digits, DdApaNumber number,
                             int precision = 6, FILE * fp = stdout) const;
    void DebugCheck(void) const;
    void CheckKeys(void) const;
    ADD Harwell(FILE * fp, std::vector<ADD>& x, std::vector<ADD>& y,
                std::vector<ADD>& xn, std::vector<ADD>& yn_,
                int * m, int * n, int bx = 0, int sx = 2, int by = 1,
                int sy = 2, int pr = 0) const;
    void PrintLinear(void) const;
    int ReadLinear(int x, int y) const;
    BDD Xgty(std::vector<BDD> z, std::vector<BDD> x, std::vector<BDD> y) const;
    BDD Xeqy(std::vector<BDD> x, std::vector<BDD> y) const;
    ADD Xeqy(std::vector<ADD> x, std::vector<ADD> y) const;
    BDD Dxygtdxz(std::vector<BDD> x, std::vector<BDD> y,
                 std::vector<BDD> z) const;
    BDD Dxygtdyz(std::vector<BDD> x, std::vector<BDD> y,
                 std::vector<BDD> z) const;
    BDD Inequality(int c, std::vector<BDD> x, std::vector<BDD> y) const;
    BDD Disequality(int c, std::vector<BDD> x, std::vector<BDD> y) const;
    BDD Interval(std::vector<BDD> x, unsigned int lowerB,
                 unsigned int upperB) const;
    ADD Hamming(std::vector<ADD> xVars, std::vector<ADD> yVars) const;
    ADD Read(FILE * fp, std::vector<ADD>& x, std::vector<ADD>& y, std::vector<ADD>& xn,
             std::vector<ADD>& yn_, int * m, int * n, int bx = 0, int sx = 2,
             int by = 1, int sy = 2) const;
    BDD Read(FILE * fp, std::vector<BDD>& x, std::vector<BDD>& y,
             int * m, int * n, int bx = 0, int sx = 2, int by = 1,
             int sy = 2) const;
    void ReduceHeap(Cudd_ReorderingType heuristic = CUDD_REORDER_SIFT,
                    int minsize = 0) const;
    void ShuffleHeap(int * permutation) const;
    void SymmProfile(int lower, int upper) const;
    unsigned int Prime(unsigned int pr) const;
    void Reserve(int amount) const;
    int SharingSize(DD* nodes, int n) const;
    int SharingSize(const std::vector<BDD>& v) const;
    BDD bddComputeCube(BDD * vars, int * phase, int n) const;
    BDD computeCube(std::vector<BDD> const & vars) const;
    ADD addComputeCube(ADD * vars, int * phase, int n) const;
    ADD computeCube(std::vector<ADD> const & vars) const;
    BDD IndicesToCube(int * array, int n) const;
    void PrintVersion(FILE * fp) const;
    double AverageDistance(void) const;
    int32_t Random(void) const;
    void Srandom(int32_t seed) const;
    void zddPrintSubtable() const;
    void zddReduceHeap(Cudd_ReorderingType heuristic = CUDD_REORDER_SIFT,
                       int minsize = 0) const;
    void zddShuffleHeap(int * permutation) const;
    void zddSymmProfile(int lower, int upper) const;
    void DumpDot(
      const std::vector<BDD>& nodes, 
      char const * const * inames = 0, 
      char const * const * onames = 0, 
      FILE * fp = stdout) const;
    void DumpDaVinci(
      const std::vector<BDD>& nodes, 
      char const * const * inames = 0,
      char const * const * onames = 0,
      FILE * fp = stdout) const;
    void DumpBlif(
      const std::vector<BDD>& nodes, 
      char const * const * inames = 0,
      char const * const * onames = 0,
      char * mname = 0,
      FILE * fp = stdout,
      int mv = 0) const;
    void DumpDDcal(
      const std::vector<BDD>& nodes, 
      char const * const * inames = 0, 
      char const * const * onames = 0, 
      FILE * fp = stdout) const;
    void DumpFactoredForm(
      const std::vector<BDD>& nodes, 
      char const * const * inames = 0,
      char const * const * onames = 0,
      FILE * fp = stdout) const;
    BDD VectorSupport(const std::vector<BDD>& roots) const;
    std::vector<unsigned int> 
    SupportIndices(const std::vector<BDD>& roots) const;
    std::vector<unsigned int> 
    SupportIndices(const std::vector<ADD>& roots) const;
    int nodeCount(const std::vector<BDD>& roots) const;
    int VectorSupportSize(const std::vector<BDD>& roots) const;
    void DumpDot(
      const std::vector<ADD>& nodes,
      char const * const * inames = 0, 
      char const * const * onames = 0, 
      FILE * fp = stdout) const;
    void DumpDaVinci(
      const std::vector<ADD>& nodes,
      char const * const * inames = 0,
      char const * const * onames = 0,
      FILE * fp = stdout) const;
    BDD VectorSupport(const std::vector<ADD>& roots) const;
    int VectorSupportSize(const std::vector<ADD>& roots) const;
    void DumpDot(
      const std::vector<ZDD>& nodes,
      char const * const * inames = 0,
      char const * const * onames = 0,
      FILE * fp = stdout) const;
    std::string OrderString(void) const;

}; // Cudd


#endif

cuddPriority.c
54937
/**
  @file

  @ingroup cudd

  @brief Priority functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/
static int cuddMinHammingDistRecur (DdNode * f, int *minterm, DdHashTable * table, int upperBound);
static DdNode * separateCube (DdManager *dd, DdNode *f, CUDD_VALUE_TYPE *distance);
static DdNode * createResult (DdManager *dd, unsigned int index, unsigned int phase, DdNode *cube, CUDD_VALUE_TYPE distance);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Selects pairs from R using a priority function.

  @details Selects pairs from a relation R(x,y) (given as a %BDD)
  in such a way that a given x appears in one pair only. Uses a
  priority function to determine which y should be paired to a given x.
  Three of the arguments--x, y, and z--are vectors of %BDD variables.
  The first two are the variables on which R depends. The third vector
  is a vector of auxiliary variables, used during the computation. This
  vector is optional. If a NULL value is passed instead,
  Cudd_PrioritySelect will create the working variables on the fly.
  The sizes of x and y (and z if it is not NULL) should equal n.
  The priority function Pi can be passed as a %BDD, or can be built by
  Cudd_PrioritySelect. If NULL is passed instead of a DdNode *,
  parameter Pifunc is used by Cudd_PrioritySelect to build a %BDD for the
  priority function. (Pifunc is a pointer to a C function.) If Pi is not
  NULL, then Pifunc is ignored. Pifunc should have the same interface as
  the standard priority functions (e.g., Cudd_Dxygtdxz).
  Cudd_PrioritySelect and Cudd_CProjection can sometimes be used
  interchangeably. Specifically, calling Cudd_PrioritySelect with
  Cudd_Xgty as Pifunc produces the same result as calling
  Cudd_CProjection with the all-zero minterm as reference minterm.
  However, depending on the application, one or the other may be
  preferable:
  <ul>
  <li> When extracting representatives from an equivalence relation,
  Cudd_CProjection has the advantage of nor requiring the auxiliary
  variables.
  <li> When computing matchings in general bipartite graphs,
  Cudd_PrioritySelect normally obtains better results because it can use
  more powerful matching schemes (e.g., Cudd_Dxygtdxz).
  </ul>

  @return a pointer to the selected function if successful; NULL
  otherwise.

  @sideeffect If called with z == NULL, will create new variables in
  the manager.

  @see Cudd_Dxygtdxz Cudd_Dxygtdyz Cudd_Xgty
  Cudd_bddAdjPermuteX Cudd_CProjection

*/
DdNode *
Cudd_PrioritySelect(
  DdManager * dd /**< manager */,
  DdNode * R /**< %BDD of the relation */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */,
  DdNode ** z /**< array of z variables (optional: may be NULL) */,
  DdNode * Pi /**< %BDD of the priority function (optional: may be NULL) */,
  int  n /**< size of x, y, and z */,
  DD_PRFP Pifunc /**< function used to build Pi if it is NULL */)
{
    DdNode *res = NULL;
    DdNode *zcube = NULL;
    DdNode *Rxz, *Q;
    int createdZ = 0;
    int createdPi = 0;
    int i;

    /* Create z variables if needed. */
    if (z == NULL) {
	if (Pi != NULL) return(NULL);
	z = ALLOC(DdNode *,n);
	if (z == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(NULL);
	}
	createdZ = 1;
	for (i = 0; i < n; i++) {
	    if (dd->size >= (int) CUDD_MAXINDEX - 1) goto endgame;
	    z[i] = cuddUniqueInter(dd,dd->size,dd->one,Cudd_Not(dd->one));
	    if (z[i] == NULL) goto endgame;
	}
    }

    /* Create priority function BDD if needed. */
    if (Pi == NULL) {
	Pi = Pifunc(dd,n,x,y,z);
	if (Pi == NULL) goto endgame;
	createdPi = 1;
	cuddRef(Pi);
    }

    /* Initialize abstraction cube. */
    zcube = DD_ONE(dd);
    cuddRef(zcube);
    for (i = n - 1; i >= 0; i--) {
	DdNode *tmpp;
	tmpp = Cudd_bddAnd(dd,z[i],zcube);
	if (tmpp == NULL) goto endgame;
	cuddRef(tmpp);
	Cudd_RecursiveDeref(dd,zcube);
	zcube = tmpp;
    }

    /* Compute subset of (x,y) pairs. */
    Rxz = Cudd_bddSwapVariables(dd,R,y,z,n);
    if (Rxz == NULL) goto endgame;
    cuddRef(Rxz);
    Q = Cudd_bddAndAbstract(dd,Rxz,Pi,zcube);
    if (Q == NULL) {
	Cudd_RecursiveDeref(dd,Rxz);
	goto endgame;
    }
    cuddRef(Q);
    Cudd_RecursiveDeref(dd,Rxz);
    res = Cudd_bddAnd(dd,R,Cudd_Not(Q));
    if (res == NULL) {
	Cudd_RecursiveDeref(dd,Q);
	goto endgame;
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd,Q);

endgame:
    if (zcube != NULL) Cudd_RecursiveDeref(dd,zcube);
    if (createdZ) {
	FREE(z);
    }
    if (createdPi) {
	Cudd_RecursiveDeref(dd,Pi);
    }
    if (res != NULL) cuddDeref(res);
    return(res);

} /* Cudd_PrioritySelect */


/**
  @brief Generates a %BDD for the function x &gt; y.

  @details This function generates a %BDD for the function x &gt; y.
  Both x and y are N-bit numbers, x\[0\] x\[1\] ... x\[N-1\] and
  y\[0\] y\[1\] ...  y\[N-1\], with 0 the most significant bit.
  The %BDD is built bottom-up.
  It has 3*N-1 internal nodes, if the variables are ordered as follows:
  x\[0\] y\[0\] x\[1\] y\[1\] ... x\[N-1\] y\[N-1\].
  Argument z is not used by Cudd_Xgty: it is included to make it
  call-compatible to Cudd_Dxygtdxz and Cudd_Dxygtdyz.

  @sideeffect None

  @see Cudd_PrioritySelect Cudd_Dxygtdxz Cudd_Dxygtdyz

*/
DdNode *
Cudd_Xgty(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x and y variables */,
  DdNode ** z /**< array of z variables: unused */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */)
{
    DdNode *u, *v, *w;
    int     i;

    (void) z; /* avoid warning */
    /* Build bottom part of BDD outside loop. */
    u = Cudd_bddAnd(dd, x[N-1], Cudd_Not(y[N-1]));
    if (u == NULL) return(NULL);
    cuddRef(u);

    /* Loop to build the rest of the BDD. */
    for (i = N-2; i >= 0; i--) {
	v = Cudd_bddAnd(dd, y[i], Cudd_Not(u));
	if (v == NULL) {
	    Cudd_RecursiveDeref(dd, u);
	    return(NULL);
	}
	cuddRef(v);
	w = Cudd_bddAnd(dd, Cudd_Not(y[i]), u);
	if (w == NULL) {
	    Cudd_RecursiveDeref(dd, u);
	    Cudd_RecursiveDeref(dd, v);
	    return(NULL);
	}
	cuddRef(w);
	Cudd_RecursiveDeref(dd, u);
	u = Cudd_bddIte(dd, x[i], Cudd_Not(v), w);
	if (u == NULL) {
	    Cudd_RecursiveDeref(dd, v);
	    Cudd_RecursiveDeref(dd, w);
	    return(NULL);
	}
	cuddRef(u);
	Cudd_RecursiveDeref(dd, v);
	Cudd_RecursiveDeref(dd, w);

    }
    cuddDeref(u);
    return(u);

} /* end of Cudd_Xgty */


/**
  @brief Generates a %BDD for the function x==y.

  @details This function generates a %BDD for the function x==y.
  Both x and y are N-bit numbers, x\[0\] x\[1\] ... x\[N-1\] and
  y\[0\] y\[1\] ...  y\[N-1\].  The %BDD is built bottom-up.
  It has 3*N-1 internal nodes, if the variables are ordered as follows:
  x\[0\] y\[0\] x\[1\] y\[1\] ... x\[N-1\] y\[N-1\].

  @sideeffect None

  @see Cudd_addXeqy

*/
DdNode *
Cudd_Xeqy(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x and y variables */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */)
{
    DdNode *u, *v, *w;
    int     i;

    /* Build bottom part of BDD outside loop. */
    u = Cudd_bddIte(dd, x[N-1], y[N-1], Cudd_Not(y[N-1]));
    if (u == NULL) return(NULL);
    cuddRef(u);

    /* Loop to build the rest of the BDD. */
    for (i = N-2; i >= 0; i--) {
	v = Cudd_bddAnd(dd, y[i], u);
	if (v == NULL) {
	    Cudd_RecursiveDeref(dd, u);
	    return(NULL);
	}
	cuddRef(v);
	w = Cudd_bddAnd(dd, Cudd_Not(y[i]), u);
	if (w == NULL) {
	    Cudd_RecursiveDeref(dd, u);
	    Cudd_RecursiveDeref(dd, v);
	    return(NULL);
	}
	cuddRef(w);
	Cudd_RecursiveDeref(dd, u);
	u = Cudd_bddIte(dd, x[i], v, w);
	if (u == NULL) {
	    Cudd_RecursiveDeref(dd, v);
	    Cudd_RecursiveDeref(dd, w);
	    return(NULL);
	}
	cuddRef(u);
	Cudd_RecursiveDeref(dd, v);
	Cudd_RecursiveDeref(dd, w);
    }
    cuddDeref(u);
    return(u);

} /* end of Cudd_Xeqy */


/**
  @brief Generates an %ADD for the function x==y.

  @details This function generates an %ADD for the function x==y.
  Both x and y are N-bit numbers, x\[0\] x\[1\] ... x\[N-1\] and
  y\[0\] y\[1\] ...  y\[N-1\].  The %ADD is built bottom-up.
  It has 3*N-1 internal nodes, if the variables are ordered as follows:
  x\[0\] y\[0\] x\[1\] y\[1\] ... x\[N-1\] y\[N-1\].

  @sideeffect None

  @see Cudd_Xeqy

*/
DdNode *
Cudd_addXeqy(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x and y variables */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */)
{
    DdNode *one, *zero;
    DdNode *u, *v, *w;
    int     i;

    one = DD_ONE(dd);
    zero = DD_ZERO(dd);

    /* Build bottom part of ADD outside loop. */
    v = Cudd_addIte(dd, y[N-1], one, zero);
    if (v == NULL) return(NULL);
    cuddRef(v);
    w = Cudd_addIte(dd, y[N-1], zero, one);
    if (w == NULL) {
	Cudd_RecursiveDeref(dd, v);
	return(NULL);
    }
    cuddRef(w);
    u = Cudd_addIte(dd, x[N-1], v, w);
    if (u == NULL) {
	Cudd_RecursiveDeref(dd, v);
	Cudd_RecursiveDeref(dd, w);
	return(NULL);
    }
    cuddRef(u);
    Cudd_RecursiveDeref(dd, v);
    Cudd_RecursiveDeref(dd, w);

    /* Loop to build the rest of the ADD. */
    for (i = N-2; i >= 0; i--) {
	v = Cudd_addIte(dd, y[i], u, zero);
	if (v == NULL) {
	    Cudd_RecursiveDeref(dd, u);
	    return(NULL);
	}
	cuddRef(v);
	w = Cudd_addIte(dd, y[i], zero, u);
	if (w == NULL) {
	    Cudd_RecursiveDeref(dd, u);
	    Cudd_RecursiveDeref(dd, v);
	    return(NULL);
	}
	cuddRef(w);
	Cudd_RecursiveDeref(dd, u);
	u = Cudd_addIte(dd, x[i], v, w);
	if (w == NULL) {
	    Cudd_RecursiveDeref(dd, v);
	    Cudd_RecursiveDeref(dd, w);
	    return(NULL);
	}
	cuddRef(u);
	Cudd_RecursiveDeref(dd, v);
	Cudd_RecursiveDeref(dd, w);
    }
    cuddDeref(u);
    return(u);

} /* end of Cudd_addXeqy */


/**
  @brief Generates a %BDD for the function d(x,y) &gt; d(x,z).

  @details This function generates a %BDD for the function d(x,y)
  &gt; d(x,z);
  x, y, and z are N-bit numbers, x\[0\] x\[1\] ... x\[N-1\],
  y\[0\] y\[1\] ...  y\[N-1\], and z\[0\] z\[1\] ...  z\[N-1\],
  with 0 the most significant bit.
  The distance d(x,y) is defined as:
	\f$\sum_{i=0}^{N-1}(|x_i - y_i| \cdot 2^{N-i-1})\f$.
  The %BDD is built bottom-up.
  It has 7*N-3 internal nodes, if the variables are ordered as follows:
  x\[0\] y\[0\] z\[0\] x\[1\] y\[1\] z\[1\] ... x\[N-1\] y\[N-1\] z\[N-1\].

  @sideeffect None

  @see Cudd_PrioritySelect Cudd_Dxygtdyz Cudd_Xgty Cudd_bddAdjPermuteX

*/
DdNode *
Cudd_Dxygtdxz(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x, y, and z variables */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */,
  DdNode ** z /**< array of z variables */)
{
    DdNode *one, *zero;
    DdNode *z1, *z2, *z3, *z4, *y1_, *y2, *x1;
    int     i;

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    /* Build bottom part of BDD outside loop. */
    y1_ = Cudd_bddIte(dd, y[N-1], one, Cudd_Not(z[N-1]));
    if (y1_ == NULL) return(NULL);
    cuddRef(y1_);
    y2 = Cudd_bddIte(dd, y[N-1], z[N-1], one);
    if (y2 == NULL) {
	Cudd_RecursiveDeref(dd, y1_);
	return(NULL);
    }
    cuddRef(y2);
    x1 = Cudd_bddIte(dd, x[N-1], y1_, y2);
    if (x1 == NULL) {
	Cudd_RecursiveDeref(dd, y1_);
	Cudd_RecursiveDeref(dd, y2);
	return(NULL);
    }
    cuddRef(x1);
    Cudd_RecursiveDeref(dd, y1_);
    Cudd_RecursiveDeref(dd, y2);

    /* Loop to build the rest of the BDD. */
    for (i = N-2; i >= 0; i--) {
	z1 = Cudd_bddIte(dd, z[i], one, Cudd_Not(x1));
	if (z1 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    return(NULL);
	}
	cuddRef(z1);
	z2 = Cudd_bddIte(dd, z[i], x1, one);
	if (z2 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    Cudd_RecursiveDeref(dd, z1);
	    return(NULL);
	}
	cuddRef(z2);
	z3 = Cudd_bddIte(dd, z[i], one, x1);
	if (z3 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    return(NULL);
	}
	cuddRef(z3);
	z4 = Cudd_bddIte(dd, z[i], x1, zero);
	if (z4 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    Cudd_RecursiveDeref(dd, z3);
	    return(NULL);
	}
	cuddRef(z4);
	Cudd_RecursiveDeref(dd, x1);
	y1_ = Cudd_bddIte(dd, y[i], z2, Cudd_Not(z1));
	if (y1_ == NULL) {
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    Cudd_RecursiveDeref(dd, z3);
	    Cudd_RecursiveDeref(dd, z4);
	    return(NULL);
	}
	cuddRef(y1_);
	y2 = Cudd_bddIte(dd, y[i], z4, z3);
	if (y2 == NULL) {
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    Cudd_RecursiveDeref(dd, z3);
	    Cudd_RecursiveDeref(dd, z4);
	    Cudd_RecursiveDeref(dd, y1_);
	    return(NULL);
	}
	cuddRef(y2);
	Cudd_RecursiveDeref(dd, z1);
	Cudd_RecursiveDeref(dd, z2);
	Cudd_RecursiveDeref(dd, z3);
	Cudd_RecursiveDeref(dd, z4);
	x1 = Cudd_bddIte(dd, x[i], y1_, y2);
	if (x1 == NULL) {
	    Cudd_RecursiveDeref(dd, y1_);
	    Cudd_RecursiveDeref(dd, y2);
	    return(NULL);
	}
	cuddRef(x1);
	Cudd_RecursiveDeref(dd, y1_);
	Cudd_RecursiveDeref(dd, y2);
    }
    cuddDeref(x1);
    return(Cudd_Not(x1));

} /* end of Cudd_Dxygtdxz */


/**
  @brief Generates a %BDD for the function d(x,y) &gt; d(y,z).

  @details This function generates a %BDD for the function d(x,y)
  &gt; d(y,z);
  x, y, and z are N-bit numbers, x\[0\] x\[1\] ... x\[N-1\],
  y\[0\] y\[1\] ...  y\[N-1\], and z\[0\] z\[1\] ...  z\[N-1\],
  with 0 the most significant bit.
  The distance d(x,y) is defined as:
	\f$\sum_{i=0}^{N-1}(|x_i - y_i| \cdot 2^{N-i-1})\f$.
  The %BDD is built bottom-up.
  It has 7*N-3 internal nodes, if the variables are ordered as follows:
  x\[0\] y\[0\] z\[0\] x\[1\] y\[1\] z\[1\] ... x\[N-1\] y\[N-1\] z\[N-1\].

  @sideeffect None

  @see Cudd_PrioritySelect Cudd_Dxygtdxz Cudd_Xgty Cudd_bddAdjPermuteX

*/
DdNode *
Cudd_Dxygtdyz(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x, y, and z variables */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */,
  DdNode ** z /**< array of z variables */)
{
    DdNode *one, *zero;
    DdNode *z1, *z2, *z3, *z4, *y1_, *y2, *x1;
    int     i;

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    /* Build bottom part of BDD outside loop. */
    y1_ = Cudd_bddIte(dd, y[N-1], one, z[N-1]);
    if (y1_ == NULL) return(NULL);
    cuddRef(y1_);
    y2 = Cudd_bddIte(dd, y[N-1], z[N-1], zero);
    if (y2 == NULL) {
	Cudd_RecursiveDeref(dd, y1_);
	return(NULL);
    }
    cuddRef(y2);
    x1 = Cudd_bddIte(dd, x[N-1], y1_, Cudd_Not(y2));
    if (x1 == NULL) {
	Cudd_RecursiveDeref(dd, y1_);
	Cudd_RecursiveDeref(dd, y2);
	return(NULL);
    }
    cuddRef(x1);
    Cudd_RecursiveDeref(dd, y1_);
    Cudd_RecursiveDeref(dd, y2);

    /* Loop to build the rest of the BDD. */
    for (i = N-2; i >= 0; i--) {
	z1 = Cudd_bddIte(dd, z[i], x1, zero);
	if (z1 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    return(NULL);
	}
	cuddRef(z1);
	z2 = Cudd_bddIte(dd, z[i], x1, one);
	if (z2 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    Cudd_RecursiveDeref(dd, z1);
	    return(NULL);
	}
	cuddRef(z2);
	z3 = Cudd_bddIte(dd, z[i], one, x1);
	if (z3 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    return(NULL);
	}
	cuddRef(z3);
	z4 = Cudd_bddIte(dd, z[i], one, Cudd_Not(x1));
	if (z4 == NULL) {
	    Cudd_RecursiveDeref(dd, x1);
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    Cudd_RecursiveDeref(dd, z3);
	    return(NULL);
	}
	cuddRef(z4);
	Cudd_RecursiveDeref(dd, x1);
	y1_ = Cudd_bddIte(dd, y[i], z2, z1);
	if (y1_ == NULL) {
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    Cudd_RecursiveDeref(dd, z3);
	    Cudd_RecursiveDeref(dd, z4);
	    return(NULL);
	}
	cuddRef(y1_);
	y2 = Cudd_bddIte(dd, y[i], z4, Cudd_Not(z3));
	if (y2 == NULL) {
	    Cudd_RecursiveDeref(dd, z1);
	    Cudd_RecursiveDeref(dd, z2);
	    Cudd_RecursiveDeref(dd, z3);
	    Cudd_RecursiveDeref(dd, z4);
	    Cudd_RecursiveDeref(dd, y1_);
	    return(NULL);
	}
	cuddRef(y2);
	Cudd_RecursiveDeref(dd, z1);
	Cudd_RecursiveDeref(dd, z2);
	Cudd_RecursiveDeref(dd, z3);
	Cudd_RecursiveDeref(dd, z4);
	x1 = Cudd_bddIte(dd, x[i], y1_, Cudd_Not(y2));
	if (x1 == NULL) {
	    Cudd_RecursiveDeref(dd, y1_);
	    Cudd_RecursiveDeref(dd, y2);
	    return(NULL);
	}
	cuddRef(x1);
	Cudd_RecursiveDeref(dd, y1_);
	Cudd_RecursiveDeref(dd, y2);
    }
    cuddDeref(x1);
    return(Cudd_Not(x1));

} /* end of Cudd_Dxygtdyz */


/**
  @brief Generates a %BDD for the function x - y &ge; c.

  @details This function generates a %BDD for the function x -y &ge; c.
  Both x and y are N-bit numbers, x\[0\] x\[1\] ... x\[N-1\] and
  y\[0\] y\[1\] ...  y\[N-1\], with 0 the most significant bit.
  The %BDD is built bottom-up.
  It has a linear number of nodes if the variables are ordered as follows:
  x\[0\] y\[0\] x\[1\] y\[1\] ... x\[N-1\] y\[N-1\].

  @sideeffect None

  @see Cudd_Xgty

*/
DdNode *
Cudd_Inequality(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x and y variables */,
  int c /**< right-hand side constant */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */)
{
    /* The nodes at level i represent values of the difference that are
    ** multiples of 2^i.  We use variables with names starting with k
    ** to denote the multipliers of 2^i in such multiples. */
    int kTrue = c;
    int kFalse = c - 1;
    /* Mask used to compute the ceiling function.  Since we divide by 2^i,
    ** we want to know whether the dividend is a multiple of 2^i.  If it is,
    ** then ceiling and floor coincide; otherwise, they differ by one. */
    int mask = 1;
    int i;

    DdNode *f = NULL;		/* the eventual result */
    DdNode *one = DD_ONE(dd);
    DdNode *zero = Cudd_Not(one);

    /* Two x-labeled nodes are created at most at each iteration.  They are
    ** stored, along with their k values, in these variables.  At each level,
    ** the old nodes are freed and the new nodes are copied into the old map.
    */
    DdNode *map[2] = {NULL, NULL};
    int invalidIndex = 1 << (N-1);
    int index[2] = {invalidIndex, invalidIndex};

    /* This should never happen. */
    if (N < 0) return(NULL);

    /* If there are no bits, both operands are 0.  The result depends on c. */
    if (N == 0) {
	if (c >= 0) return(one);
	else return(zero);
    }

    /* The maximum or the minimum difference comparing to c can generate the terminal case */
    if ((1 << N) - 1 < c) return(zero);
    else if ((-(1 << N) + 1) >= c) return(one);

    /* Build the result bottom up. */
    for (i = 1; i <= N; i++) {
	int kTrueLower, kFalseLower;
	int leftChild, middleChild, rightChild;
	DdNode *g0, *g1, *fplus, *fequal, *fminus;
	int j;
	DdNode *newMap[2] = {NULL, NULL};
	int newIndex[2];

	kTrueLower = kTrue;
	kFalseLower = kFalse;
	/* kTrue = ceiling((c-1)/2^i) + 1 */
	kTrue = ((c-1) >> i) + ((c & mask) != 1) + 1;
	mask = (mask << 1) | 1;
	/* kFalse = floor(c/2^i) - 1 */
	kFalse = (c >> i) - 1;
	newIndex[0] = invalidIndex;
	newIndex[1] = invalidIndex;

	for (j = kFalse + 1; j < kTrue; j++) {
	    /* Skip if node is not reachable from top of BDD. */
	    if ((j >= (1 << (N - i))) || (j <= -(1 << (N -i)))) continue;

	    /* Find f- */
	    leftChild = (j << 1) - 1;
	    if (leftChild >= kTrueLower) {
		fminus = one;
	    } else if (leftChild <= kFalseLower) {
		fminus = zero;
	    } else {
		assert(leftChild == index[0] || leftChild == index[1]);
		if (leftChild == index[0]) {
		    fminus = map[0];
		} else {
		    fminus = map[1];
		}
	    }

	    /* Find f= */
	    middleChild = j << 1;
	    if (middleChild >= kTrueLower) {
		fequal = one;
	    } else if (middleChild <= kFalseLower) {
		fequal = zero;
	    } else {
		assert(middleChild == index[0] || middleChild == index[1]);
		if (middleChild == index[0]) {
		    fequal = map[0];
		} else {
		    fequal = map[1];
		}
	    }

	    /* Find f+ */
	    rightChild = (j << 1) + 1;
	    if (rightChild >= kTrueLower) {
		fplus = one;
	    } else if (rightChild <= kFalseLower) {
		fplus = zero;
	    } else {
		assert(rightChild == index[0] || rightChild == index[1]);
		if (rightChild == index[0]) {
		    fplus = map[0];
		} else {
		    fplus = map[1];
		}
	    }

	    /* Build new nodes. */
	    g1 = Cudd_bddIte(dd, y[N - i], fequal, fplus);
	    if (g1 == NULL) {
		if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
		if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
		if (newIndex[0] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[0]);
		if (newIndex[1] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[1]);
		return(NULL);
	    }
	    cuddRef(g1);
	    g0 = Cudd_bddIte(dd, y[N - i], fminus, fequal);
	    if (g0 == NULL) {
		Cudd_IterDerefBdd(dd, g1);
		if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
		if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
		if (newIndex[0] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[0]);
		if (newIndex[1] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[1]);
		return(NULL);
	    }
	    cuddRef(g0);
	    f = Cudd_bddIte(dd, x[N - i], g1, g0);
	    if (f == NULL) {
		Cudd_IterDerefBdd(dd, g1);
		Cudd_IterDerefBdd(dd, g0);
		if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
		if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
		if (newIndex[0] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[0]);
		if (newIndex[1] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[1]);
		return(NULL);
	    }
	    cuddRef(f);
	    Cudd_IterDerefBdd(dd, g1);
	    Cudd_IterDerefBdd(dd, g0);

	    /* Save newly computed node in map. */
	    assert(newIndex[0] == invalidIndex || newIndex[1] == invalidIndex);
	    if (newIndex[0] == invalidIndex) {
		newIndex[0] = j;
		newMap[0] = f;
	    } else {
		newIndex[1] = j;
		newMap[1] = f;
	    }
	}

	/* Copy new map to map. */
	if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
	if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
	map[0] = newMap[0];
	map[1] = newMap[1];
	index[0] = newIndex[0];
	index[1] = newIndex[1];
    }

    cuddDeref(f);
    return(f);

} /* end of Cudd_Inequality */


/**
  @brief Generates a %BDD for the function x - y != c.

  @details This function generates a %BDD for the function x -y != c.
  Both x and y are N-bit numbers, x\[0\] x\[1\] ... x\[N-1\] and
  y\[0\] y\[1\] ...  y\[N-1\], with 0 the most significant bit.
  The %BDD is built bottom-up.
  It has a linear number of nodes if the variables are ordered as follows:
  x\[0\] y\[0\] x\[1\] y\[1\] ... x\[N-1\] y\[N-1\].

  @sideeffect None

  @see Cudd_Xgty

*/
DdNode *
Cudd_Disequality(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x and y variables */,
  int c /**< right-hand side constant */,
  DdNode ** x /**< array of x variables */,
  DdNode ** y /**< array of y variables */)
{
    /* The nodes at level i represent values of the difference that are
    ** multiples of 2^i.  We use variables with names starting with k
    ** to denote the multipliers of 2^i in such multiples. */
    int kTrueLb = c + 1;
    int kTrueUb = c - 1;
    int kFalse = c;
    /* Mask used to compute the ceiling function.  Since we divide by 2^i,
    ** we want to know whether the dividend is a multiple of 2^i.  If it is,
    ** then ceiling and floor coincide; otherwise, they differ by one. */
    int mask = 1;
    int i;

    DdNode *f = NULL;		/* the eventual result */
    DdNode *one = DD_ONE(dd);
    DdNode *zero = Cudd_Not(one);

    /* Two x-labeled nodes are created at most at each iteration.  They are
    ** stored, along with their k values, in these variables.  At each level,
    ** the old nodes are freed and the new nodes are copied into the old map.
    */
    DdNode *map[2] = {NULL, NULL};
    int invalidIndex = 1 << (N-1);
    int index[2] = {invalidIndex, invalidIndex};

    /* This should never happen. */
    if (N < 0) return(NULL);

    /* If there are no bits, both operands are 0.  The result depends on c. */
    if (N == 0) {
	if (c != 0) return(one);
	else return(zero);
    }

    /* The maximum or the minimum difference comparing to c can generate the terminal case */
    if ((1 << N) - 1 < c || (-(1 << N) + 1) > c) return(one);

    /* Build the result bottom up. */
    for (i = 1; i <= N; i++) {
	int kTrueLbLower, kTrueUbLower;
	int leftChild, middleChild, rightChild;
	DdNode *g0, *g1, *fplus, *fequal, *fminus;
	int j;
	DdNode *newMap[2] = {NULL, NULL};
	int newIndex[2];

	kTrueLbLower = kTrueLb;
	kTrueUbLower = kTrueUb;
	/* kTrueLb = floor((c-1)/2^i) + 2 */
	kTrueLb = ((c-1) >> i) + 2;
	/* kTrueUb = ceiling((c+1)/2^i) - 2 */
	kTrueUb = ((c+1) >> i) + (((c+2) & mask) != 1) - 2;
	mask = (mask << 1) | 1;
	newIndex[0] = invalidIndex;
	newIndex[1] = invalidIndex;

	for (j = kTrueUb + 1; j < kTrueLb; j++) {
	    /* Skip if node is not reachable from top of BDD. */
	    if ((j >= (1 << (N - i))) || (j <= -(1 << (N -i)))) continue;

	    /* Find f- */
	    leftChild = (j << 1) - 1;
	    if (leftChild >= kTrueLbLower || leftChild <= kTrueUbLower) {
		fminus = one;
	    } else if (i == 1 && leftChild == kFalse) {
		fminus = zero;
	    } else {
		assert(leftChild == index[0] || leftChild == index[1]);
		if (leftChild == index[0]) {
		    fminus = map[0];
		} else {
		    fminus = map[1];
		}
	    }

	    /* Find f= */
	    middleChild = j << 1;
	    if (middleChild >= kTrueLbLower || middleChild <= kTrueUbLower) {
		fequal = one;
	    } else if (i == 1 && middleChild == kFalse) {
		fequal = zero;
	    } else {
		assert(middleChild == index[0] || middleChild == index[1]);
		if (middleChild == index[0]) {
		    fequal = map[0];
		} else {
		    fequal = map[1];
		}
	    }

	    /* Find f+ */
	    rightChild = (j << 1) + 1;
	    if (rightChild >= kTrueLbLower || rightChild <= kTrueUbLower) {
		fplus = one;
	    } else if (i == 1 && rightChild == kFalse) {
		fplus = zero;
	    } else {
		assert(rightChild == index[0] || rightChild == index[1]);
		if (rightChild == index[0]) {
		    fplus = map[0];
		} else {
		    fplus = map[1];
		}
	    }

	    /* Build new nodes. */
	    g1 = Cudd_bddIte(dd, y[N - i], fequal, fplus);
	    if (g1 == NULL) {
		if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
		if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
		if (newIndex[0] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[0]);
		if (newIndex[1] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[1]);
		return(NULL);
	    }
	    cuddRef(g1);
	    g0 = Cudd_bddIte(dd, y[N - i], fminus, fequal);
	    if (g0 == NULL) {
		Cudd_IterDerefBdd(dd, g1);
		if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
		if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
		if (newIndex[0] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[0]);
		if (newIndex[1] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[1]);
		return(NULL);
	    }
	    cuddRef(g0);
	    f = Cudd_bddIte(dd, x[N - i], g1, g0);
	    if (f == NULL) {
		Cudd_IterDerefBdd(dd, g1);
		Cudd_IterDerefBdd(dd, g0);
		if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
		if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
		if (newIndex[0] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[0]);
		if (newIndex[1] != invalidIndex) Cudd_IterDerefBdd(dd, newMap[1]);
		return(NULL);
	    }
	    cuddRef(f);
	    Cudd_IterDerefBdd(dd, g1);
	    Cudd_IterDerefBdd(dd, g0);

	    /* Save newly computed node in map. */
	    assert(newIndex[0] == invalidIndex || newIndex[1] == invalidIndex);
	    if (newIndex[0] == invalidIndex) {
		newIndex[0] = j;
		newMap[0] = f;
	    } else {
		newIndex[1] = j;
		newMap[1] = f;
	    }
	}

	/* Copy new map to map. */
	if (index[0] != invalidIndex) Cudd_IterDerefBdd(dd, map[0]);
	if (index[1] != invalidIndex) Cudd_IterDerefBdd(dd, map[1]);
	map[0] = newMap[0];
	map[1] = newMap[1];
	index[0] = newIndex[0];
	index[1] = newIndex[1];
    }

    cuddDeref(f);
    return(f);

} /* end of Cudd_Disequality */


/**
  @brief Generates a %BDD for the function lowerB &le; x &le; upperB.

  @details This function generates a %BDD for the function
  lowerB &le; x &le; upperB, where x is an N-bit number,
  x\[0\] x\[1\] ... x\[N-1\], with 0 the most significant bit (important!).
  The number of variables N should be sufficient to represent the bounds;
  otherwise, the bounds are truncated to their N least significant bits.
  Two BDDs are built bottom-up for lowerB &le; x and x &le; upperB, and they
  are finally conjoined.

  @sideeffect None

  @see Cudd_Xgty

*/
DdNode *
Cudd_bddInterval(
  DdManager * dd /**< %DD manager */,
  int  N /**< number of x variables */,
  DdNode ** x /**< array of x variables */,
  unsigned int lowerB /**< lower bound */,
  unsigned int upperB /**< upper bound */)
{
    DdNode *one, *zero;
    DdNode *r, *rl, *ru;
    int     i;

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    rl = one;
    cuddRef(rl);
    ru = one;
    cuddRef(ru);

    /* Loop to build the rest of the BDDs. */
    for (i = N-1; i >= 0; i--) {
	DdNode *vl, *vu;
	vl = Cudd_bddIte(dd, x[i],
			 lowerB&1 ? rl : one,
			 lowerB&1 ? zero : rl);
	if (vl == NULL) {
	    Cudd_IterDerefBdd(dd, rl);
	    Cudd_IterDerefBdd(dd, ru);
	    return(NULL);
	}
	cuddRef(vl);
	Cudd_IterDerefBdd(dd, rl);
	rl = vl;
	lowerB >>= 1;
	vu = Cudd_bddIte(dd, x[i],
			 upperB&1 ? ru : zero,
			 upperB&1 ? one : ru);
	if (vu == NULL) {
	    Cudd_IterDerefBdd(dd, rl);
	    Cudd_IterDerefBdd(dd, ru);
	    return(NULL);
	}
	cuddRef(vu);
	Cudd_IterDerefBdd(dd, ru);
	ru = vu;
	upperB >>= 1;
    }

    /* Conjoin the two bounds. */
    r = Cudd_bddAnd(dd, rl, ru);
    if (r == NULL) {
	Cudd_IterDerefBdd(dd, rl);
	Cudd_IterDerefBdd(dd, ru);
	return(NULL);
    }
    cuddRef(r);
    Cudd_IterDerefBdd(dd, rl);
    Cudd_IterDerefBdd(dd, ru);
    cuddDeref(r);
    return(r);

} /* end of Cudd_bddInterval */


/**
  @brief Computes the compatible projection of R w.r.t. cube Y.

  @details Computes the compatible projection of relation R with
  respect to cube Y.  For a comparison between Cudd_CProjection and
  Cudd_PrioritySelect, see the documentation of the latter.

  @return a pointer to the c-projection if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_PrioritySelect

*/
DdNode *
Cudd_CProjection(
  DdManager * dd,
  DdNode * R,
  DdNode * Y)
{
    DdNode *res;
    DdNode *support;

    if (Cudd_CheckCube(dd,Y) == 0) {
	(void) fprintf(dd->err,
	"Error: The third argument of Cudd_CProjection should be a cube\n");
	dd->errorCode = CUDD_INVALID_ARG;
	return(NULL);
    }

    /* Compute the support of Y, which is used by the abstraction step
    ** in cuddCProjectionRecur.
    */
    support = Cudd_Support(dd,Y);
    if (support == NULL) return(NULL);
    cuddRef(support);

    do {
	dd->reordered = 0;
	res = cuddCProjectionRecur(dd,R,Y,support);
    } while (dd->reordered == 1);

    if (res == NULL) {
	Cudd_RecursiveDeref(dd,support);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
          dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd,support);
    cuddDeref(res);

    return(res);

} /* end of Cudd_CProjection */


/**
  @brief Computes the Hamming distance %ADD.

  @details The two vectors xVars and yVars identify the variables that
  form the two arguments.

  @return an %ADD that gives the Hamming distance between its two
  arguments if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_addHamming(
  DdManager * dd,
  DdNode ** xVars,
  DdNode ** yVars,
  int  nVars)
{
    DdNode  *result,*tempBdd;
    DdNode  *tempAdd,*temp;
    int     i;

    result = DD_ZERO(dd);
    cuddRef(result);

    for (i = 0; i < nVars; i++) {
	tempBdd = Cudd_bddIte(dd,xVars[i],Cudd_Not(yVars[i]),yVars[i]);
	if (tempBdd == NULL) {
	    Cudd_RecursiveDeref(dd,result);
	    return(NULL);
	}
	cuddRef(tempBdd);
	tempAdd = Cudd_BddToAdd(dd,tempBdd);
	if (tempAdd == NULL) {
	    Cudd_RecursiveDeref(dd,tempBdd);
	    Cudd_RecursiveDeref(dd,result);
	    return(NULL);
	}
	cuddRef(tempAdd);
	Cudd_RecursiveDeref(dd,tempBdd);
	temp = Cudd_addApply(dd,Cudd_addPlus,tempAdd,result);
	if (temp == NULL) {
	    Cudd_RecursiveDeref(dd,tempAdd);
	    Cudd_RecursiveDeref(dd,result);
	    return(NULL);
	}
	cuddRef(temp);
	Cudd_RecursiveDeref(dd,tempAdd);
	Cudd_RecursiveDeref(dd,result);
	result = temp;
    }

    cuddDeref(result);
    return(result);

} /* end of Cudd_addHamming */


/**
  @brief Returns the minimum Hamming distance between f and minterm.

  @details Returns the minimum Hamming distance between the
  minterms of a function f and a reference minterm. The function is
  given as a %BDD; the minterm is given as an array of integers, one
  for each variable in the manager.

  @return the minimum distance if it is less than the upper bound; the
  upper bound if the minimum distance is at least as large;
  CUDD_OUT_OF_MEM in case of failure.

  @sideeffect None

  @see Cudd_addHamming Cudd_bddClosestCube

*/
int
Cudd_MinHammingDist(
  DdManager *dd /**< %DD manager */,
  DdNode *f /**< function to examine */,
  int *minterm /**< reference minterm */,
  int upperBound /**< distance above which an approximate answer is OK */)
{
    DdHashTable *table;
    CUDD_VALUE_TYPE epsilon;
    int res;

    table = cuddHashTableInit(dd,1,2);
    if (table == NULL) {
	return(CUDD_OUT_OF_MEM);
    }
    epsilon = Cudd_ReadEpsilon(dd);
    Cudd_SetEpsilon(dd,(CUDD_VALUE_TYPE)0.0);
    res = cuddMinHammingDistRecur(f,minterm,table,upperBound);
    cuddHashTableQuit(table);
    Cudd_SetEpsilon(dd,epsilon);

    return(res);

} /* end of Cudd_MinHammingDist */


/**
  @brief Finds a cube of f at minimum Hamming distance from the minterms of g.

  @details All the minterms of the cube are at the minimum distance.
  If the distance is 0, the cube belongs to the intersection of f and
  g.

  @return the cube if successful; NULL otherwise.

  @sideeffect The distance is returned as a side effect.

  @see Cudd_MinHammingDist

*/
DdNode *
Cudd_bddClosestCube(
  DdManager *dd,
  DdNode * f,
  DdNode *g,
  int *distance)
{
    DdNode *res, *acube;
    CUDD_VALUE_TYPE rdist;

    /* Compute the cube and distance as a single ADD. */
    do {
	dd->reordered = 0;
	res = cuddBddClosestCube(dd,f,g,CUDD_CONST_INDEX + 1.0);
    } while (dd->reordered == 1);
    if (res == NULL) {
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
        return(NULL);
    }
    cuddRef(res);

    /* Unpack distance and cube. */
    do {
	dd->reordered = 0;
	acube = separateCube(dd, res, &rdist);
    } while (dd->reordered == 1);
    if (acube == NULL) {
	Cudd_RecursiveDeref(dd, res);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(acube);
    Cudd_RecursiveDeref(dd, res);

    /* Convert cube from ADD to BDD. */
    do {
	dd->reordered = 0;
	res = cuddAddBddDoPattern(dd, acube);
    } while (dd->reordered == 1);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, acube);
        if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
            dd->timeoutHandler(dd, dd->tohArg);
        }
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, acube);

    *distance = (int) rdist;
    cuddDeref(res);
    return(res);

} /* end of Cudd_bddClosestCube */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_CProjection.

  @return the projection if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_CProjection

*/
DdNode *
cuddCProjectionRecur(
  DdManager * dd,
  DdNode * R,
  DdNode * Y,
  DdNode * Ysupp)
{
    DdNode *res, *res1, *res2, *resA;
    DdNode *r, *y, *RT, *RE, *YT, *YE, *Yrest, *Ra, *Ran, *Gamma, *Alpha;
    int topR, topY, top;
    unsigned int index;
    DdNode *one = DD_ONE(dd);

    statLine(dd);
    if (Y == one) return(R);

#ifdef DD_DEBUG
    assert(!Cudd_IsConstantInt(Y));
#endif

    if (R == Cudd_Not(one)) return(R);

    res = cuddCacheLookup2(dd, Cudd_CProjection, R, Y);
    if (res != NULL) return(res);

    checkWhetherToGiveUp(dd);

    r = Cudd_Regular(R);
    topR = cuddI(dd,r->index);
    y = Cudd_Regular(Y);
    topY = cuddI(dd,y->index);

    top = ddMin(topR, topY);

    /* Compute the cofactors of R */
    index = r->index;
    if (topR == top) {
	RT = cuddT(r);
	RE = cuddE(r);
	if (r != R) {
	    RT = Cudd_Not(RT); RE = Cudd_Not(RE);
	}
    } else {
	RT = RE = R;
    }

    if (topY > top) {
	/* Y does not depend on the current top variable.
	** We just need to compute the results on the two cofactors of R
	** and make them the children of a node labeled r->index.
	*/
	res1 = cuddCProjectionRecur(dd,RT,Y,Ysupp);
	if (res1 == NULL) return(NULL);
	cuddRef(res1);
	res2 = cuddCProjectionRecur(dd,RE,Y,Ysupp);
	if (res2 == NULL) {
	    Cudd_RecursiveDeref(dd,res1);
	    return(NULL);
	}
	cuddRef(res2);
	res = cuddBddIteRecur(dd, dd->vars[index], res1, res2);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd,res1);
	    Cudd_RecursiveDeref(dd,res2);
	    return(NULL);
	}
	/* If we have reached this point, res1 and res2 are now
	** incorporated in res. cuddDeref is therefore sufficient.
	*/
	cuddDeref(res1);
	cuddDeref(res2);
    } else {
	/* Compute the cofactors of Y */
	index = y->index;
	YT = cuddT(y);
	YE = cuddE(y);
	if (y != Y) {
	    YT = Cudd_Not(YT); YE = Cudd_Not(YE);
	}
	if (YT == Cudd_Not(one)) {
	    Alpha  = Cudd_Not(dd->vars[index]);
	    Yrest = YE;
	    Ra = RE;
	    Ran = RT;
	} else {
	    Alpha = dd->vars[index];
	    Yrest = YT;
	    Ra = RT;
	    Ran = RE;
	}
	Gamma = cuddBddExistAbstractRecur(dd,Ra,cuddT(Ysupp));
	if (Gamma == NULL) return(NULL);
	if (Gamma == one) {
	    res1 = cuddCProjectionRecur(dd,Ra,Yrest,cuddT(Ysupp));
	    if (res1 == NULL) return(NULL);
	    cuddRef(res1);
	    res = cuddBddAndRecur(dd, Alpha, res1);
	    if (res == NULL) {
		Cudd_RecursiveDeref(dd,res1);
		return(NULL);
	    }
	    cuddDeref(res1);
	} else if (Gamma == Cudd_Not(one)) {
	    res1 = cuddCProjectionRecur(dd,Ran,Yrest,cuddT(Ysupp));
	    if (res1 == NULL) return(NULL);
	    cuddRef(res1);
	    res = cuddBddAndRecur(dd, Cudd_Not(Alpha), res1);
	    if (res == NULL) {
		Cudd_RecursiveDeref(dd,res1);
		return(NULL);
	    }
	    cuddDeref(res1);
	} else {
	    cuddRef(Gamma);
	    resA = cuddCProjectionRecur(dd,Ran,Yrest,cuddT(Ysupp));
	    if (resA == NULL) {
		Cudd_RecursiveDeref(dd,Gamma);
		return(NULL);
	    }
	    cuddRef(resA);
	    res2 = cuddBddAndRecur(dd, Cudd_Not(Gamma), resA);
	    if (res2 == NULL) {
		Cudd_RecursiveDeref(dd,Gamma);
		Cudd_RecursiveDeref(dd,resA);
		return(NULL);
	    }
	    cuddRef(res2);
	    Cudd_RecursiveDeref(dd,Gamma);
	    Cudd_RecursiveDeref(dd,resA);
	    res1 = cuddCProjectionRecur(dd,Ra,Yrest,cuddT(Ysupp));
	    if (res1 == NULL) {
		Cudd_RecursiveDeref(dd,res2);
		return(NULL);
	    }
	    cuddRef(res1);
	    res = cuddBddIteRecur(dd, Alpha, res1, res2);
	    if (res == NULL) {
		Cudd_RecursiveDeref(dd,res1);
		Cudd_RecursiveDeref(dd,res2);
		return(NULL);
	    }
	    cuddDeref(res1);
	    cuddDeref(res2);
	}
    }

    cuddCacheInsert2(dd,Cudd_CProjection,R,Y,res);

    return(res);

} /* end of cuddCProjectionRecur */


/**
  @brief Performs the recursive step of Cudd_bddClosestCube.

  @details@parblock
  The procedure uses a four-way recursion to examine all four combinations
  of cofactors of <code>f</code> and <code>g</code> according to the
  following formula.

      H(f,g) = min(H(ft,gt), H(fe,ge), H(ft,ge)+1, H(fe,gt)+1)

  Bounding is based on the following observations.
  <ul>
  <li> If we already found two points at distance 0, there is no point in
       continuing.  Furthermore,
  <li> If F == not(G) then the best we can hope for is a minimum distance
       of 1.  If we have already found two points at distance 1, there is
       no point in continuing.  (Indeed, H(F,G) == 1 in this case.  We
       have to continue, though, to find the cube.)
  </ul>
  The variable <code>bound</code> is set at the largest value of the distance
  that we are still interested in.  Therefore, we desist when

      (bound == -1) and (F != not(G)) or (bound == 0) and (F == not(G)).

  If we were maximally aggressive in using the bound, we would always
  set the bound to the minimum distance seen thus far minus one.  That
  is, we would maintain the invariant

      bound < minD,

  except at the very beginning, when we have no value for
  <code>minD</code>.

  However, we do not use <code>bound < minD</code> when examining the
  two negative cofactors, because we try to find a large cube at
  minimum distance.  To do so, we try to find a cube in the negative
  cofactors at the same or smaller distance from the cube found in the
  positive cofactors.

  When we compute <code>H(ft,ge)</code> and <code>H(fe,gt)</code> we
  know that we are going to add 1 to the result of the recursive call
  to account for the difference in the splitting variable.  Therefore,
  we decrease the bound correspondingly.

  Another important observation concerns the need of examining all
  four pairs of cofators only when both <code>f</code> and
  <code>g</code> depend on the top variable.

  Suppose <code>gt == ge == g</code>.  (That is, <code>g</code> does
  not depend on the top variable.)  Then

      H(f,g) = min(H(ft,g), H(fe,g), H(ft,g)+1, H(fe,g)+1)
             = min(H(ft,g), H(fe,g)) .

  Therefore, under these circumstances, we skip the two "cross" cases.

  An interesting feature of this function is the scheme used for
  caching the results in the global computed table.  Since we have a
  cube and a distance, we combine them to form an %ADD.  The
  combination replaces the zero child of the top node of the cube with
  the negative of the distance.  (The use of the negative is to avoid
  ambiguity with 1.)  The degenerate cases (zero and one) are treated
  specially because the distance is known (0 for one, and infinity for
  zero).
  @endparblock

  @return the cube if succesful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddClosestCube

*/
DdNode *
cuddBddClosestCube(
  DdManager *dd,
  DdNode *f,
  DdNode *g,
  CUDD_VALUE_TYPE bound)
{
    DdNode *res, *F, *G, *ft, *fe, *gt, *ge, *tt, *ee;
    DdNode *ctt, *cee, *cte, *cet;
    CUDD_VALUE_TYPE minD, dtt, dee, dte, det;
    DdNode *one = DD_ONE(dd);
    DdNode *lzero = Cudd_Not(one);
    DdNode *azero = DD_ZERO(dd);
    int topf, topg;
    unsigned int index;

    statLine(dd);
    if (bound < (f == Cudd_Not(g))) return(azero);
    /* Terminal cases. */
    if (g == lzero || f == lzero) return(azero);
    if (f == one && g == one) return(one);

    /* Check cache. */
    F = Cudd_Regular(f);
    G = Cudd_Regular(g);
    if (F->ref != 1 || G->ref != 1) {
	res = cuddCacheLookup2(dd,(DD_CTFP) Cudd_bddClosestCube, f, g);
	if (res != NULL) return(res);
    }

    checkWhetherToGiveUp(dd);

    topf = cuddI(dd,F->index);
    topg = cuddI(dd,G->index);

    /* Compute cofactors. */
    if (topf <= topg) {
	index = F->index;
	ft = cuddT(F);
	fe = cuddE(F);
	if (Cudd_IsComplement(f)) {
	    ft = Cudd_Not(ft);
	    fe = Cudd_Not(fe);
	}
    } else {
	index = G->index;
	ft = fe = f;
    }

    if (topg <= topf) {
	gt = cuddT(G);
	ge = cuddE(G);
	if (Cudd_IsComplement(g)) {
	    gt = Cudd_Not(gt);
	    ge = Cudd_Not(ge);
	}
    } else {
	gt = ge = g;
    }

    tt = cuddBddClosestCube(dd,ft,gt,bound);
    if (tt == NULL) return(NULL);
    cuddRef(tt);
    ctt = separateCube(dd,tt,&dtt);
    if (ctt == NULL) {
	Cudd_RecursiveDeref(dd, tt);
	return(NULL);
    }
    cuddRef(ctt);
    Cudd_RecursiveDeref(dd, tt);
    minD = dtt;
    bound = ddMin(bound,minD);

    ee = cuddBddClosestCube(dd,fe,ge,bound);
    if (ee == NULL) {
	Cudd_RecursiveDeref(dd, ctt);
	return(NULL);
    }
    cuddRef(ee);
    cee = separateCube(dd,ee,&dee);
    if (cee == NULL) {
	Cudd_RecursiveDeref(dd, ctt);
	Cudd_RecursiveDeref(dd, ee);
	return(NULL);
    }
    cuddRef(cee);
    Cudd_RecursiveDeref(dd, ee);
    minD = ddMin(dtt, dee);
    if (minD <= CUDD_CONST_INDEX) bound = ddMin(bound,minD-1);

    if (minD > 0 && topf == topg) {
	DdNode *te = cuddBddClosestCube(dd,ft,ge,bound-1);
	if (te == NULL) {
	    Cudd_RecursiveDeref(dd, ctt);
	    Cudd_RecursiveDeref(dd, cee);
	    return(NULL);
	}
	cuddRef(te);
	cte = separateCube(dd,te,&dte);
	if (cte == NULL) {
	    Cudd_RecursiveDeref(dd, ctt);
	    Cudd_RecursiveDeref(dd, cee);
	    Cudd_RecursiveDeref(dd, te);
	    return(NULL);
	}
	cuddRef(cte);
	Cudd_RecursiveDeref(dd, te);
	dte += 1.0;
	minD = ddMin(minD, dte);
    } else {
	cte = azero;
	cuddRef(cte);
	dte = CUDD_CONST_INDEX + 1.0;
    }
    if (minD <= CUDD_CONST_INDEX) bound = ddMin(bound,minD-1);

    if (minD > 0 && topf == topg) {
	DdNode *et = cuddBddClosestCube(dd,fe,gt,bound-1);
	if (et == NULL) {
	    Cudd_RecursiveDeref(dd, ctt);
	    Cudd_RecursiveDeref(dd, cee);
	    Cudd_RecursiveDeref(dd, cte);
	    return(NULL);
	}
	cuddRef(et);
	cet = separateCube(dd,et,&det);
	if (cet == NULL) {
	    Cudd_RecursiveDeref(dd, ctt);
	    Cudd_RecursiveDeref(dd, cee);
	    Cudd_RecursiveDeref(dd, cte);
	    Cudd_RecursiveDeref(dd, et);
	    return(NULL);
	}
	cuddRef(cet);
	Cudd_RecursiveDeref(dd, et);
	det += 1.0;
	minD = ddMin(minD, det);
    } else {
	cet = azero;
	cuddRef(cet);
	det = CUDD_CONST_INDEX + 1.0;
    }

    if (minD == dtt) {
	if (dtt == dee && ctt == cee) {
	    res = createResult(dd,CUDD_CONST_INDEX,1,ctt,dtt);
	} else {
	    res = createResult(dd,index,1,ctt,dtt);
	}
    } else if (minD == dee) {
	res = createResult(dd,index,0,cee,dee);
    } else if (minD == dte) {
#ifdef DD_DEBUG
	assert(topf == topg);
#endif
	res = createResult(dd,index,1,cte,dte);
    } else {
#ifdef DD_DEBUG
	assert(topf == topg);
#endif
	res = createResult(dd,index,0,cet,det);
    }
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, ctt);
	Cudd_RecursiveDeref(dd, cee);
	Cudd_RecursiveDeref(dd, cte);
	Cudd_RecursiveDeref(dd, cet);
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd, ctt);
    Cudd_RecursiveDeref(dd, cee);
    Cudd_RecursiveDeref(dd, cte);
    Cudd_RecursiveDeref(dd, cet);

    /* Only cache results that are different from azero to avoid
    ** storing results that depend on the value of the bound. */
    if ((F->ref != 1 || G->ref != 1) && res != azero)
	cuddCacheInsert2(dd,(DD_CTFP) Cudd_bddClosestCube, f, g, res);

    cuddDeref(res);
    return(res);

} /* end of cuddBddClosestCube */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_MinHammingDist.

  @details It is based on the following identity. Let H(f) be the
  minimum Hamming distance of the minterms of f from the reference
  minterm. Then:

      H(f) = min(H(f0)+h0,H(f1)+h1)

  where f0 and f1 are the two cofactors of f with respect to its top
  variable; h0 is 1 if the minterm assigns 1 to the top variable of f;
  h1 is 1 if the minterm assigns 0 to the top variable of f.
  The upper bound on the distance is used to bound the depth of the
  recursion.

  @return the minimum distance unless it exceeds the upper bound or
  computation fails.

  @sideeffect None

  @see Cudd_MinHammingDist

*/
static int
cuddMinHammingDistRecur(
  DdNode * f,
  int *minterm,
  DdHashTable * table,
  int upperBound)
{
    DdNode	*F, *Ft, *Fe;
    double	h, hT, hE;
    DdNode	*zero, *res;
    DdManager	*dd = table->manager;

    statLine(dd);
    if (upperBound == 0) return(0);

    F = Cudd_Regular(f);

    if (cuddIsConstant(F)) {
	zero = Cudd_Not(DD_ONE(dd));
	if (f == dd->background || f == zero) {
	    return(upperBound);
	} else {
	    return(0);
	}
    }
    if ((res = cuddHashTableLookup1(table,f)) != NULL) {
	h = cuddV(res);
	if (res->ref == 0) {
	    dd->dead++;
	    dd->constants.dead++;
	}
	return((int) h);
    }

    Ft = cuddT(F); Fe = cuddE(F);
    if (Cudd_IsComplement(f)) {
	Ft = Cudd_Not(Ft); Fe = Cudd_Not(Fe);
    }
    if (minterm[F->index] == 0) {
	DdNode *temp = Ft;
	Ft = Fe; Fe = temp;
    }

    hT = cuddMinHammingDistRecur(Ft,minterm,table,upperBound);
    if (hT == CUDD_OUT_OF_MEM) return(CUDD_OUT_OF_MEM);
    if (hT == 0) {
	hE = upperBound;
    } else {
	hE = cuddMinHammingDistRecur(Fe,minterm,table,upperBound - 1);
	if (hE == CUDD_OUT_OF_MEM) return(CUDD_OUT_OF_MEM);
    }
    h = ddMin(hT, hE + 1);

    if (F->ref != 1) {
	ptrint fanout = (ptrint) F->ref;
	cuddSatDec(fanout);
	res = cuddUniqueConst(dd, (CUDD_VALUE_TYPE) h);
	if (!cuddHashTableInsert1(table,f,res,fanout)) {
	    cuddRef(res); Cudd_RecursiveDeref(dd, res);
	    return(CUDD_OUT_OF_MEM);
	}
    }

    return((int) h);

} /* end of cuddMinHammingDistRecur */


/**
  @brief Separates cube from distance.

  @return the cube if successful; NULL otherwise.

  @sideeffect The distance is returned as a side effect.

  @see cuddBddClosestCube createResult

*/
static DdNode *
separateCube(
  DdManager *dd,
  DdNode *f,
  CUDD_VALUE_TYPE *distance)
{
    DdNode *cube, *t;

    /* One and zero are special cases because the distance is implied. */
    if (Cudd_IsConstantInt(f)) {
	*distance = (f == DD_ONE(dd)) ? 0.0 :
	    (1.0 + (CUDD_VALUE_TYPE) CUDD_CONST_INDEX);
	return(f);
    }

    /* Find out which branch points to the distance and replace the top
    ** node with one pointing to zero instead. */
    t = cuddT(f);
    if (Cudd_IsConstantInt(t) && cuddV(t) <= 0) {
#ifdef DD_DEBUG
	assert(!Cudd_IsConstantInt(cuddE(f)) || cuddE(f) == DD_ONE(dd));
#endif
	*distance = -cuddV(t);
	cube = cuddUniqueInter(dd, f->index, DD_ZERO(dd), cuddE(f));
    } else {
#ifdef DD_DEBUG
	assert(!Cudd_IsConstantInt(t) || t == DD_ONE(dd));
#endif
	*distance = -cuddV(cuddE(f));
	cube = cuddUniqueInter(dd, f->index, t, DD_ZERO(dd));
    }

    return(cube);

} /* end of separateCube */


/**
  @brief Builds a result for cache storage.

  @return a pointer to the resulting %ADD if successful; NULL
  otherwise.

  @sideeffect None

  @see cuddBddClosestCube separateCube

*/
static DdNode *
createResult(
  DdManager *dd,
  unsigned int index,
  unsigned int phase,
  DdNode *cube,
  CUDD_VALUE_TYPE distance)
{
    DdNode *res, *constant;

    /* Special case.  The cube is either one or zero, and we do not
    ** add any variables.  Hence, the result is also one or zero,
    ** and the distance remains implied by the value of the constant. */
    if (index == CUDD_CONST_INDEX && Cudd_IsConstantInt(cube)) return(cube);

    constant = cuddUniqueConst(dd,-distance);
    if (constant == NULL) return(NULL);
    cuddRef(constant);

    if (index == CUDD_CONST_INDEX) {
	/* Replace the top node. */
	if (cuddT(cube) == DD_ZERO(dd)) {
	    res = cuddUniqueInter(dd,cube->index,constant,cuddE(cube));
	} else {
	    res = cuddUniqueInter(dd,cube->index,cuddT(cube),constant);
	}
    } else {
	/* Add a new top node. */
#ifdef DD_DEBUG
	assert(cuddI(dd,index) < cuddI(dd,cube->index));
#endif
	if (phase) {
	    res = cuddUniqueInter(dd,index,cube,constant);
	} else {
	    res = cuddUniqueInter(dd,index,constant,cube);
	}
    }
    if (res == NULL) {
	Cudd_RecursiveDeref(dd, constant);
	return(NULL);
    }
    cuddDeref(constant); /* safe because constant is part of res */

    return(res);

} /* end of createResult */

cuddRead.c
16895
/**
  @file

  @ingroup cudd

  @brief Functions to read in a matrix

  @see cudd_addHarwell.c

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Reads in a sparse matrix.

  @details Reads in a sparse matrix specified in a simple format.
  The first line of the input contains the numbers of rows and columns.
  The remaining lines contain the elements of the matrix, one per line.
  Given a background value
  (specified by the background field of the manager), only the values
  different from it are explicitly listed.  Each foreground element is
  described by two integers, i.e., the row and column number, and a
  real number, i.e., the value.<p>
  Cudd_addRead produces an %ADD that depends on two sets of variables: x
  and y.  The x variables (x\[0\] ... x\[nx-1\]) encode the row index and
  the y variables (y\[0\] ... y\[ny-1\]) encode the column index.
  x\[0\] and y\[0\] are the most significant bits in the indices.
  The variables may already exist or may be created by the function.
  The index of x\[i\] is bx+i*sx, and the index of y\[i\] is by+i*sy.<p>
  On input, nx and ny hold the numbers
  of row and column variables already in existence. On output, they
  hold the numbers of row and column variables actually used by the
  matrix. When Cudd_addRead creates the variable arrays,
  the index of x\[i\] is bx+i*sx, and the index of y\[i\] is by+i*sy.
  When some variables already exist Cudd_addRead expects the indices
  of the existing x variables to be bx+i*sx, and the indices of the
  existing y variables to be by+i*sy.<p>
  m and n are set to the numbers of rows and columns of the
  matrix.  Their values on input are immaterial.
  The %ADD for the sparse matrix is returned in E, and its reference
  count is > 0.

  @return 1 in case of success; 0 otherwise.

  @sideeffect nx and ny are set to the numbers of row and column
  variables. m and n are set to the numbers of rows and columns. x and y
  are possibly extended to represent the array of row and column
  variables. Similarly for xn and yn_, which hold on return from
  Cudd_addRead the complements of the row and column variables.

  @see Cudd_addHarwell Cudd_bddRead

*/
int
Cudd_addRead(
  FILE * fp /**< input file pointer */,
  DdManager * dd /**< %DD manager */,
  DdNode ** E /**< characteristic function of the graph */,
  DdNode *** x /**< array of row variables */,
  DdNode *** y /**< array of column variables */,
  DdNode *** xn /**< array of complemented row variables */,
  DdNode *** yn_ /**< array of complemented column variables */,
  int * nx /**< number or row variables */,
  int * ny /**< number or column variables */,
  int * m /**< number of rows */,
  int * n /**< number of columns */,
  int  bx /**< first index of row variables */,
  int  sx /**< step of row variables */,
  int  by /**< first index of column variables */,
  int  sy /**< step of column variables */)
{
    DdNode *one, *zero;
    DdNode *w, *neW;
    DdNode *minterm1;
    int u, v, err, i, nv;
    int lnx, lny;
    CUDD_VALUE_TYPE val;
    DdNode **lx, **ly, **lxn, **lyn;

    one = DD_ONE(dd);
    zero = DD_ZERO(dd);

    err = fscanf(fp, "%d %d", &u, &v);
    if (err == EOF) {
	return(0);
    } else if (err != 2) {
	return(0);
    }

    *m = u;
    /* Compute the number of x variables. */
    lx = *x; lxn = *xn;
    u--; 	/* row and column numbers start from 0 */
    for (lnx=0; u > 0; lnx++) {
	u >>= 1;
    }
    /* Here we rely on the fact that REALLOC of a null pointer is
    ** translates to an ALLOC.
    */
    if (lnx > *nx) {
	*x = lx = REALLOC(DdNode *, *x, lnx);
	if (lx == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	*xn = lxn =  REALLOC(DdNode *, *xn, lnx);
	if (lxn == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
    }

    *n = v;
    /* Compute the number of y variables. */
    ly = *y; lyn = *yn_;
    v--; 	/* row and column numbers start from 0 */
    for (lny=0; v > 0; lny++) {
	v >>= 1;
    }
    /* Here we rely on the fact that REALLOC of a null pointer is
    ** translates to an ALLOC.
    */
    if (lny > *ny) {
	*y = ly = REALLOC(DdNode *, *y, lny);
	if (ly == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	*yn_ = lyn =  REALLOC(DdNode *, *yn_, lny);
	if (lyn == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
    }

    /* Create all new variables. */
    for (i = *nx, nv = bx + (*nx) * sx; i < lnx; i++, nv += sx) {
	do {
	    dd->reordered = 0;
	    lx[i] = cuddUniqueInter(dd, nv, one, zero);
	} while (dd->reordered == 1);
	if (lx[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
        cuddRef(lx[i]);
	do {
	    dd->reordered = 0;
	    lxn[i] = cuddUniqueInter(dd, nv, zero, one);
	} while (dd->reordered == 1);
	if (lxn[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
        cuddRef(lxn[i]);
    }
    for (i = *ny, nv = by + (*ny) * sy; i < lny; i++, nv += sy) {
	do {
	    dd->reordered = 0;
	    ly[i] = cuddUniqueInter(dd, nv, one, zero);
	} while (dd->reordered == 1);
	if (ly[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
	cuddRef(ly[i]);
	do {
	    dd->reordered = 0;
	    lyn[i] = cuddUniqueInter(dd, nv, zero, one);
	} while (dd->reordered == 1);
	if (lyn[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
	cuddRef(lyn[i]);
    }
    *nx = lnx;
    *ny = lny;

    *E = dd->background; /* this call will never cause reordering */
    cuddRef(*E);

    while (! feof(fp)) {
	err = fscanf(fp, "%d %d %lf", &u, &v, &val);
	if (err == EOF) {
	    break;
	} else if (err != 3) {
	    return(0);
	} else if (u >= *m || v >= *n || u < 0 || v < 0) {
	    return(0);
	}
 
	minterm1 = one; cuddRef(minterm1);

	/* Build minterm1 corresponding to this arc */
	for (i = lnx - 1; i>=0; i--) {
	    if (u & 1) {
		w = Cudd_addApply(dd, Cudd_addTimes, minterm1, lx[i]);
	    } else {
		w = Cudd_addApply(dd, Cudd_addTimes, minterm1, lxn[i]);
	    }
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, minterm1);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd, minterm1);
	    minterm1 = w;
	    u >>= 1;
	}
	for (i = lny - 1; i>=0; i--) {
	    if (v & 1) {
		w = Cudd_addApply(dd, Cudd_addTimes, minterm1, ly[i]);
	    } else {
		w = Cudd_addApply(dd, Cudd_addTimes, minterm1, lyn[i]);
	    }
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, minterm1);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd, minterm1);
	    minterm1 = w;
	    v >>= 1;
	}
	/* Create new constant node if necessary.
	** This call will never cause reordering.
	*/
	neW = cuddUniqueConst(dd, val);
	if (neW == NULL) {
	    Cudd_RecursiveDeref(dd, minterm1);
	    return(0);
	}
    	cuddRef(neW);

	w = Cudd_addIte(dd, minterm1, neW, *E);
	if (w == NULL) {
	    Cudd_RecursiveDeref(dd, minterm1);
	    Cudd_RecursiveDeref(dd, neW);
	    return(0);
	}
	cuddRef(w);
	Cudd_RecursiveDeref(dd, minterm1);
	Cudd_RecursiveDeref(dd, neW);
	Cudd_RecursiveDeref(dd, *E);
	*E = w;
    }
    return(1);

} /* end of Cudd_addRead */


/**
  @brief Reads in a graph (without labels) given as a list of arcs.

  @details Reads in a graph (without labels) given as an adjacency
  matrix.  The first line of the input contains the numbers of rows and
  columns of the adjacency matrix. The remaining lines contain the arcs
  of the graph, one per line. Each arc is described by two integers,
  i.e., the row and column number, or the indices of the two endpoints.
  Cudd_bddRead produces a %BDD that depends on two sets of variables: x
  and y.  The x variables (x\[0\] ... x\[nx-1\]) encode
  the row index and the y variables (y\[0\] ... y\[ny-1\]) encode the
  column index. x\[0\] and y\[0\] are the most significant bits in the
  indices.
  The variables may already exist or may be created by the function.
  The index of x\[i\] is bx+i*sx, and the index of y\[i\] is by+i*sy.<p>
  On input, nx and ny hold the numbers of row and column variables already
  in existence. On output, they hold the numbers of row and column
  variables actually used by the matrix. When Cudd_bddRead creates the
  variable arrays, the index of x\[i\] is bx+i*sx, and the index of
  y\[i\] is by+i*sy. When some variables already exist, Cudd_bddRead
  expects the indices of the existing x variables to be bx+i*sx, and the
  indices of the existing y variables to be by+i*sy.<p>
  m and n are set to the numbers of rows and columns of the
  matrix.  Their values on input are immaterial.  The %BDD for the graph
  is returned in E, and its reference count is > 0.

  @return 1 in case of success; 0 otherwise.

  @sideeffect nx and ny are set to the numbers of row and column
  variables. m and n are set to the numbers of rows and columns. x and y
  are possibly extended to represent the array of row and column
  variables.

  @see Cudd_addHarwell Cudd_addRead

*/
int
Cudd_bddRead(
  FILE * fp /**< input file pointer */,
  DdManager * dd /**< DD manager */,
  DdNode ** E /**< characteristic function of the graph */,
  DdNode *** x /**< array of row variables */,
  DdNode *** y /**< array of column variables */,
  int * nx /**< number or row variables */,
  int * ny /**< number or column variables */,
  int * m /**< number of rows */,
  int * n /**< number of columns */,
  int  bx /**< first index of row variables */,
  int  sx /**< step of row variables */,
  int  by /**< first index of column variables */,
  int  sy /**< step of column variables */)
{
    DdNode *one, *zero;
    DdNode *w;
    DdNode *minterm1;
    int u, v, err, i, nv;
    int lnx, lny;
    DdNode **lx, **ly;

    one = DD_ONE(dd);
    zero = Cudd_Not(one);

    err = fscanf(fp, "%d %d", &u, &v);
    if (err == EOF) {
	return(0);
    } else if (err != 2) {
	return(0);
    }

    *m = u;
    /* Compute the number of x variables. */
    lx = *x;
    u--; 	/* row and column numbers start from 0 */
    for (lnx=0; u > 0; lnx++) {
	u >>= 1;
    }
    if (lnx > *nx) {
	*x = lx = REALLOC(DdNode *, *x, lnx);
	if (lx == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
    }

    *n = v;
    /* Compute the number of y variables. */
    ly = *y;
    v--; 	/* row and column numbers start from 0 */
    for (lny=0; v > 0; lny++) {
	v >>= 1;
    }
    if (lny > *ny) {
	*y = ly = REALLOC(DdNode *, *y, lny);
	if (ly == NULL) {
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
    }

    /* Create all new variables. */
    for (i = *nx, nv = bx + (*nx) * sx; i < lnx; i++, nv += sx) {
	do {
	    dd->reordered = 0;
	    lx[i] = cuddUniqueInter(dd, nv, one, zero);
	} while (dd->reordered == 1);
	if (lx[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
        cuddRef(lx[i]);
    }
    for (i = *ny, nv = by + (*ny) * sy; i < lny; i++, nv += sy) {
	do {
	    dd->reordered = 0;
	    ly[i] = cuddUniqueInter(dd, nv, one, zero);
	} while (dd->reordered == 1);
	if (ly[i] == NULL) {
            if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
                dd->timeoutHandler(dd, dd->tohArg);
            }
            return(0);
        }
	cuddRef(ly[i]);
    }
    *nx = lnx;
    *ny = lny;

    *E = zero; /* this call will never cause reordering */
    cuddRef(*E);

    while (! feof(fp)) {
	err = fscanf(fp, "%d %d", &u, &v);
	if (err == EOF) {
	    break;
	} else if (err != 2) {
	    return(0);
	} else if (u >= *m || v >= *n || u < 0 || v < 0) {
	    return(0);
	}
 
	minterm1 = one; cuddRef(minterm1);

	/* Build minterm1 corresponding to this arc. */
	for (i = lnx - 1; i>=0; i--) {
	    if (u & 1) {
		w = Cudd_bddAnd(dd, minterm1, lx[i]);
	    } else {
		w = Cudd_bddAnd(dd, minterm1, Cudd_Not(lx[i]));
	    }
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, minterm1);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd,minterm1);
	    minterm1 = w;
	    u >>= 1;
	}
	for (i = lny - 1; i>=0; i--) {
	    if (v & 1) {
		w = Cudd_bddAnd(dd, minterm1, ly[i]);
	    } else {
		w = Cudd_bddAnd(dd, minterm1, Cudd_Not(ly[i]));
	    }
	    if (w == NULL) {
		Cudd_RecursiveDeref(dd, minterm1);
		return(0);
	    }
	    cuddRef(w);
	    Cudd_RecursiveDeref(dd, minterm1);
	    minterm1 = w;
	    v >>= 1;
	}

	w = Cudd_bddAnd(dd, Cudd_Not(minterm1), Cudd_Not(*E));
	if (w == NULL) {
	    Cudd_RecursiveDeref(dd, minterm1);
	    return(0);
	}
	w = Cudd_Not(w);
	cuddRef(w);
	Cudd_RecursiveDeref(dd, minterm1);
	Cudd_RecursiveDeref(dd, *E);
	*E = w;
    }
    return(1);

} /* end of Cudd_bddRead */

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


cuddRef.c
17072
/**
  @file

  @ingroup cudd

  @brief Functions that manipulate the reference counts.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Increases the reference count of a node, if it is not
  saturated.

  @sideeffect None

  @see Cudd_RecursiveDeref Cudd_Deref

*/
void
Cudd_Ref(
  DdNode * n)
{

    n = Cudd_Regular(n);

    cuddSatInc(n->ref);

} /* end of Cudd_Ref */


/**
  @brief Decreases the reference count of node n.

  @details If n dies, recursively decreases the reference counts of
  its children.  It is used to dispose of a DD that is no longer
  needed.

  @sideeffect None

  @see Cudd_Deref Cudd_Ref Cudd_RecursiveDerefZdd

*/
void
Cudd_RecursiveDeref(
  DdManager * table,
  DdNode * n)
{
    DdNode *N;
    int ord;
    DdNodePtr *stack = table->stack;
    int SP = 1;

    unsigned int live = table->keys - table->dead;
    if (live > table->peakLiveNodes) {
	table->peakLiveNodes = live;
    }

    N = Cudd_Regular(n);

    do {
#ifdef DD_DEBUG
	assert(N->ref != 0);
#endif

	if (N->ref == 1) {
	    N->ref = 0;
	    table->dead++;
#ifdef DD_STATS
	    table->nodesDropped++;
#endif
	    if (cuddIsConstant(N)) {
		table->constants.dead++;
		N = stack[--SP];
	    } else {
		ord = table->perm[N->index];
		stack[SP++] = Cudd_Regular(cuddE(N));
		table->subtables[ord].dead++;
		N = cuddT(N);
	    }
	} else {
	    cuddSatDec(N->ref);
	    N = stack[--SP];
	}
    } while (SP != 0);

} /* end of Cudd_RecursiveDeref */


/**
  @brief Decreases the reference count of %BDD node n.

  @details If n dies, recursively decreases the reference counts of
  its children.  It is used to dispose of a %BDD that is no longer
  needed. It is more efficient than Cudd_RecursiveDeref, but it cannot
  be used on ADDs. The greater efficiency comes from being able to
  assume that no constant node will ever die as a result of a call to
  this procedure.

  @sideeffect None

  @see Cudd_RecursiveDeref Cudd_DelayedDerefBdd

*/
void
Cudd_IterDerefBdd(
  DdManager * table,
  DdNode * n)
{
    DdNode *N;
    int ord;
    DdNodePtr *stack = table->stack;
    int SP = 1;

    unsigned int live = table->keys - table->dead;
    if (live > table->peakLiveNodes) {
	table->peakLiveNodes = live;
    }

    N = Cudd_Regular(n);

    do {
#ifdef DD_DEBUG
	assert(N->ref != 0);
#endif

	if (N->ref == 1) {
	    N->ref = 0;
	    table->dead++;
#ifdef DD_STATS
	    table->nodesDropped++;
#endif
	    ord = table->perm[N->index];
	    stack[SP++] = Cudd_Regular(cuddE(N));
	    table->subtables[ord].dead++;
	    N = cuddT(N);
	} else {
	    cuddSatDec(N->ref);
	    N = stack[--SP];
	}
    } while (SP != 0);

} /* end of Cudd_IterDerefBdd */


/**
  @brief Decreases the reference count of %BDD node n.

  @details Enqueues node n for later dereferencing. If the queue
  is full decreases the reference count of the oldest node N to make
  room for n. If N dies, recursively decreases the reference counts of
  its children.  It is used to dispose of a %BDD that is currently not
  needed, but may be useful again in the near future. The dereferencing
  proper is done as in Cudd_IterDerefBdd.

  @sideeffect None

  @see Cudd_RecursiveDeref Cudd_IterDerefBdd

*/
void
Cudd_DelayedDerefBdd(
  DdManager * table,
  DdNode * n)
{
    DdNode *N;
    int ord;
    DdNodePtr *stack;
    int SP;

    unsigned int live = table->keys - table->dead;
    if (live > table->peakLiveNodes) {
	table->peakLiveNodes = live;
    }

    n = Cudd_Regular(n);
#ifdef DD_DEBUG
    assert(n->ref != 0);
#endif

#ifdef DD_NO_DEATH_ROW
    N = n;
#else
    if (cuddIsConstant(n) || n->ref > 1) {
#ifdef DD_DEBUG
	assert(n->ref != 1 && (!cuddIsConstant(n) || n == DD_ONE(table)));
#endif
	cuddSatDec(n->ref);
	return;
    }

    N = table->deathRow[table->nextDead];

    if (N != NULL) {
#endif
#ifdef DD_DEBUG
	assert(!Cudd_IsComplement(N));
#endif
	stack = table->stack;
	SP = 1;
	do {
#ifdef DD_DEBUG
	    assert(N->ref != 0);
#endif
	    if (N->ref == 1) {
		N->ref = 0;
		table->dead++;
#ifdef DD_STATS
		table->nodesDropped++;
#endif
		ord = table->perm[N->index];
		stack[SP++] = Cudd_Regular(cuddE(N));
		table->subtables[ord].dead++;
		N = cuddT(N);
	    } else {
		cuddSatDec(N->ref);
		N = stack[--SP];
	    }
	} while (SP != 0);
#ifndef DD_NO_DEATH_ROW
    }
    table->deathRow[table->nextDead] = n;

    /* Udate insertion point. */
    table->nextDead++;
    table->nextDead &= table->deadMask;
#if 0
    if (table->nextDead == table->deathRowDepth) {
	if (table->deathRowDepth < table->looseUpTo / 2) {
	    extern void (*MMoutOfMemory)(size_t);
	    void (*saveHandler)(size_t) = MMoutOfMemory;
	    DdNodePtr *newRow;
	    MMoutOfMemory = table->outOfMemCallback;
	    newRow = REALLOC(DdNodePtr,table->deathRow,2*table->deathRowDepth);
	    MMoutOfMemory = saveHandler;
	    if (newRow == NULL) {
		table->nextDead = 0;
	    } else {
		int i;
		table->memused += table->deathRowDepth;
		i = table->deathRowDepth;
		table->deathRowDepth <<= 1;
		for (; i < table->deathRowDepth; i++) {
		    newRow[i] = NULL;
		}
		table->deadMask = table->deathRowDepth - 1;
		table->deathRow = newRow;
	    }
	} else {
	    table->nextDead = 0;
	}
    }
#endif
#endif

} /* end of Cudd_DelayedDerefBdd */


/**
  @brief Decreases the reference count of %ZDD node n.

  @details If n dies, recursively decreases the reference counts of
  its children.  It is used to dispose of a %ZDD that is no longer
  needed.

  @sideeffect None

  @see Cudd_Deref Cudd_Ref Cudd_RecursiveDeref

*/
void
Cudd_RecursiveDerefZdd(
  DdManager * table,
  DdNode * n)
{
    DdNode *N;
    int ord;
    DdNodePtr *stack = table->stack;
    int SP = 1;

    N = n;

    do {
#ifdef DD_DEBUG
	assert(N->ref != 0);
#endif

	cuddSatDec(N->ref);
    
	if (N->ref == 0) {
	    table->deadZ++;
#ifdef DD_STATS
	    table->nodesDropped++;
#endif
#ifdef DD_DEBUG
	    assert(!cuddIsConstant(N));
#endif
	    ord = table->permZ[N->index];
	    stack[SP++] = cuddE(N);
	    table->subtableZ[ord].dead++;
	    N = cuddT(N);
	} else {
	    N = stack[--SP];
	}
    } while (SP != 0);

} /* end of Cudd_RecursiveDerefZdd */


/**
  @brief Decreases the reference count of node.

  @details It is primarily used in recursive procedures to decrease
  the ref count of a result node before returning it. This
  accomplishes the goal of removing the protection applied by a
  previous Cudd_Ref.

  @sideeffect None

  @see Cudd_RecursiveDeref Cudd_RecursiveDerefZdd Cudd_Ref

*/
void
Cudd_Deref(
  DdNode * node)
{
    node = Cudd_Regular(node);
    cuddSatDec(node->ref);

} /* end of Cudd_Deref */


/**
  @brief Checks the unique table for nodes with non-zero reference
  counts.

  @details It is normally called before Cudd_Quit to make sure that
  there are no memory leaks due to missing Cudd_RecursiveDeref's.
  Takes into account that reference counts may saturate and that the
  basic constants and the projection functions are referenced by the
  manager.

  @return the number of nodes with non-zero reference count.
  (Except for the cases mentioned above.)

  @sideeffect None

*/
int
Cudd_CheckZeroRef(
  DdManager * manager)
{
    int size;
    int i, j;
    int remain;	/* the expected number of remaining references to one */
    DdNodePtr *nodelist;
    DdNode *node;
    DdNode *sentinel = &(manager->sentinel);
    DdSubtable *subtable;
    int count = 0;
    int index;

#ifndef DD_NO_DEATH_ROW
    cuddClearDeathRow(manager);
#endif

    /* First look at the BDD/ADD subtables. */
    remain = 1; /* reference from the manager */
    size = manager->size;
    remain += 2 * size;	/* reference from the BDD projection functions */

    for (i = 0; i < size; i++) {
	subtable = &(manager->subtables[i]);
	nodelist = subtable->nodelist;
	for (j = 0; (unsigned) j < subtable->slots; j++) {
	    node = nodelist[j];
	    while (node != sentinel) {
		if (node->ref != 0 && node->ref != DD_MAXREF) {
		    index = (int) node->index;
		    if (node != manager->vars[index]) {
			count++;
		    } else {
			if (node->ref != 1) {
			    count++;
			}
		    }
		}
		node = node->next;
	    }
	}
    }

    /* Then look at the ZDD subtables. */
    size = manager->sizeZ;
    if (size) /* references from ZDD universe */
	remain += 2;

    for (i = 0; i < size; i++) {
	subtable = &(manager->subtableZ[i]);
	nodelist = subtable->nodelist;
	for (j = 0; (unsigned) j < subtable->slots; j++) {
	    node = nodelist[j];
	    while (node != NULL) {
		if (node->ref != 0 && node->ref != DD_MAXREF) {
		    index = (int) node->index;
		    if (node == manager->univ[manager->permZ[index]]) {
			if (node->ref > 2) {
			    count++;
			}
		    } else {
			count++;
		    }
		}
		node = node->next;
	    }
	}
    }

    /* Now examine the constant table. Plusinfinity, minusinfinity, and
    ** zero are referenced by the manager. One is referenced by the
    ** manager, by the ZDD universe, and by all projection functions.
    ** All other nodes should have no references.
    */
    nodelist = manager->constants.nodelist;
    for (j = 0; (unsigned) j < manager->constants.slots; j++) {
	node = nodelist[j];
	while (node != NULL) {
	    if (node->ref != 0 && node->ref != DD_MAXREF) {
		if (node == manager->one) {
		    if ((int) node->ref != remain) {
			count++;
		    }
		} else if (node == manager->zero ||
		node == manager->plusinfinity ||
		node == manager->minusinfinity) {
		    if (node->ref != 1) {
			count++;
		    }
		} else {
		    count++;
		}
	    }
	    node = node->next;
	}
    }
    return(count);

} /* end of Cudd_CheckZeroRef */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Brings children of a dead node back.

  @sideeffect None

  @see cuddReclaimZdd

*/
void
cuddReclaim(
  DdManager * table,
  DdNode * n)
{
    DdNode *N;
    int ord;
    DdNodePtr *stack = table->stack;
    int SP = 1;
    double initialDead = table->dead;

    N = Cudd_Regular(n);

#ifdef DD_DEBUG
    assert(N->ref == 0);
#endif

    do {
	if (N->ref == 0) {
	    N->ref = 1;
	    table->dead--;
	    if (cuddIsConstant(N)) {
		table->constants.dead--;
		N = stack[--SP];
	    } else {
		ord = table->perm[N->index];
		stack[SP++] = Cudd_Regular(cuddE(N));
		table->subtables[ord].dead--;
		N = cuddT(N);
	    }
	} else {
	    cuddSatInc(N->ref);
	    N = stack[--SP];
	}
    } while (SP != 0);

    N = Cudd_Regular(n);
    cuddSatDec(N->ref);
    table->reclaimed += initialDead - table->dead;

} /* end of cuddReclaim */


/**
  @brief Brings children of a dead %ZDD node back.

  @sideeffect None

  @see cuddReclaim

*/
void
cuddReclaimZdd(
  DdManager * table,
  DdNode * n)
{
    DdNode *N;
    int ord;
    DdNodePtr *stack = table->stack;
    int SP = 1;

    N = n;

#ifdef DD_DEBUG
    assert(N->ref == 0);
#endif

    do {
	cuddSatInc(N->ref);

	if (N->ref == 1) {
	    table->deadZ--;
	    table->reclaimed++;
#ifdef DD_DEBUG
	    assert(!cuddIsConstant(N));
#endif
	    ord = table->permZ[N->index];
	    stack[SP++] = cuddE(N);
	    table->subtableZ[ord].dead--;
	    N = cuddT(N);
	} else {
	    N = stack[--SP];
	}
    } while (SP != 0);

    cuddSatDec(n->ref);

} /* end of cuddReclaimZdd */


/**
  @brief Shrinks the death row.

  @details Shrinks the death row by a factor of four.

  @sideeffect None

  @see cuddClearDeathRow

*/
void
cuddShrinkDeathRow(
  DdManager *table)
{
#ifndef DD_NO_DEATH_ROW
    int i;

    if (table->deathRowDepth > 3) {
	for (i = table->deathRowDepth/4; i < table->deathRowDepth; i++) {
	    if (table->deathRow[i] == NULL) break;
	    Cudd_IterDerefBdd(table,table->deathRow[i]);
	    table->deathRow[i] = NULL;
	}
	table->deathRowDepth /= 4;
	table->deadMask = table->deathRowDepth - 1;
	if ((unsigned) table->nextDead > table->deadMask) {
	    table->nextDead = 0;
	}
	table->deathRow = REALLOC(DdNodePtr, table->deathRow,
				   table->deathRowDepth);
    }
#endif

} /* end of cuddShrinkDeathRow */


/**
  @brief Clears the death row.

  @sideeffect None

  @see Cudd_DelayedDerefBdd Cudd_IterDerefBdd Cudd_CheckZeroRef
  cuddGarbageCollect

*/
void
cuddClearDeathRow(
  DdManager *table)
{
#ifndef DD_NO_DEATH_ROW
    int i;

    for (i = 0; i < table->deathRowDepth; i++) {
	if (table->deathRow[i] == NULL) break;
	Cudd_IterDerefBdd(table,table->deathRow[i]);
	table->deathRow[i] = NULL;
    }
#ifdef DD_DEBUG
    for (; i < table->deathRowDepth; i++) {
	assert(table->deathRow[i] == NULL);
    }
#endif
    table->nextDead = 0;
#endif

} /* end of cuddClearDeathRow */


/**
  @brief Checks whether a node is in the death row.

  @return the position of the first occurrence if the node is present;
  -1 otherwise.

  @sideeffect None

  @see Cudd_DelayedDerefBdd cuddClearDeathRow

*/
int
cuddIsInDeathRow(
  DdManager *dd,
  DdNode *f)
{
#ifndef DD_NO_DEATH_ROW
    int i;

    for (i = 0; i < dd->deathRowDepth; i++) {
	if (f == dd->deathRow[i]) {
	    return(i);
	}
    }
#endif

    return(-1);

} /* end of cuddIsInDeathRow */


/**
  @brief Counts how many times a node is in the death row.

  @sideeffect None

  @see Cudd_DelayedDerefBdd cuddClearDeathRow cuddIsInDeathRow

*/
int
cuddTimesInDeathRow(
  DdManager *dd,
  DdNode *f)
{
    int count = 0;
#ifndef DD_NO_DEATH_ROW
    int i;

    for (i = 0; i < dd->deathRowDepth; i++) {
	count += f == dd->deathRow[i];
    }
#endif

    return(count);

} /* end of cuddTimesInDeathRow */

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

cuddReorder.c
54629
/**
  @file

  @ingroup cudd

  @brief Functions for dynamic variable reordering.

  @author Shipra Panda, Bernard Plessier, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int ddUniqueCompare (void const *ptrX, void const *ptrY);
static Move * ddSwapAny (DdManager *table, int x, int y);
static int ddSiftingAux (DdManager *table, int x, int xLow, int xHigh);
static Move * ddSiftingUp (DdManager *table, int y, int xLow);
static Move * ddSiftingDown (DdManager *table, int x, int xHigh);
static int ddSiftingBackward (DdManager *table, int size, Move *moves);
static int ddReorderPreprocess (DdManager *table);
static int ddReorderPostprocess (DdManager *table);
static int ddShuffle (DdManager *table, int *permutation);
static int ddSiftUp (DdManager *table, int x, int xLow);
static void bddFixTree (DdManager *table, MtrNode *treenode);
static int ddUpdateMtrTree (DdManager *table, MtrNode *treenode, int *perm, int *invperm);
static int ddCheckPermuation (DdManager *table, MtrNode *treenode, int *perm, int *invperm);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Main dynamic reordering routine.

  @details Calls one of the possible reordering procedures:
  <ul>
  <li>Swapping
  <li>Sifting
  <li>Symmetric Sifting
  <li>Group Sifting
  <li>Window Permutation
  <li>Simulated Annealing
  <li>Genetic Algorithm
  <li>Dynamic Programming (exact)
  </ul>
  For sifting, symmetric sifting, group sifting, and window
  permutation it is possible to request reordering to convergence.<p>
  The core of all methods is the reordering procedure
  cuddSwapInPlace() which swaps two adjacent variables and is based
  on Rudell's paper.

  @return 1 in case of success; 0 otherwise. In the case of symmetric
  sifting (with and without convergence) returns 1 plus the number of
  symmetric variables, in case of success.

  @sideeffect Changes the variable order for all diagrams and clears
  the cache.

*/
int
Cudd_ReduceHeap(
  DdManager * table /**< %DD manager */,
  Cudd_ReorderingType heuristic /**< method used for reordering */,
  int  minsize /**< bound below which no reordering occurs */)
{
    DdHook *hook;
    int	result;
    unsigned int nextDyn;
#ifdef DD_STATS
    unsigned int initialSize;
    unsigned int finalSize;
#endif
    unsigned long localTime;

    /* Don't reorder if there are too many dead nodes. */
    if (table->keys - table->dead < (unsigned) minsize)
	return(1);

    if (heuristic == CUDD_REORDER_SAME) {
	heuristic = table->autoMethod;
    }
    if (heuristic == CUDD_REORDER_NONE) {
	return(1);
    }

    /* This call to Cudd_ReduceHeap does initiate reordering. Therefore
    ** we count it.
    */
    table->reorderings++;

    localTime = util_cpu_time();

    /* Run the hook functions. */
    hook = table->preReorderingHook;
    while (hook != NULL) {
	int res = (hook->f)(table, "BDD", (void *)heuristic);
	if (res == 0) return(0);
	hook = hook->next;
    }

    if (!ddReorderPreprocess(table)) return(0);
    table->ddTotalNumberSwapping = 0;

    if (table->keys > table->peakLiveNodes) {
	table->peakLiveNodes = table->keys;
    }
#ifdef DD_STATS
    initialSize = (int) (table->keys - table->isolated);
    table->totalNISwaps = 0;

    switch(heuristic) {
    case CUDD_REORDER_RANDOM:
    case CUDD_REORDER_RANDOM_PIVOT:
	(void) fprintf(table->out,"#:I_RANDOM  ");
	break;
    case CUDD_REORDER_SIFT:
    case CUDD_REORDER_SIFT_CONVERGE:
    case CUDD_REORDER_SYMM_SIFT:
    case CUDD_REORDER_SYMM_SIFT_CONV:
    case CUDD_REORDER_GROUP_SIFT:
    case CUDD_REORDER_GROUP_SIFT_CONV:
	(void) fprintf(table->out,"#:I_SIFTING ");
	break;
    case CUDD_REORDER_WINDOW2:
    case CUDD_REORDER_WINDOW3:
    case CUDD_REORDER_WINDOW4:
    case CUDD_REORDER_WINDOW2_CONV:
    case CUDD_REORDER_WINDOW3_CONV:
    case CUDD_REORDER_WINDOW4_CONV:
	(void) fprintf(table->out,"#:I_WINDOW  ");
	break;
    case CUDD_REORDER_ANNEALING:
	(void) fprintf(table->out,"#:I_ANNEAL  ");
	break;
    case CUDD_REORDER_GENETIC:
	(void) fprintf(table->out,"#:I_GENETIC ");
	break;
    case CUDD_REORDER_LINEAR:
    case CUDD_REORDER_LINEAR_CONVERGE:
	(void) fprintf(table->out,"#:I_LINSIFT ");
	break;
    case CUDD_REORDER_EXACT:
	(void) fprintf(table->out,"#:I_EXACT   ");
	break;
    default:
	return(0);
    }
    (void) fprintf(table->out,"%8d: initial size",initialSize);
#endif

    /* See if we should use alternate threshold for maximum growth. */
    if (table->reordCycle && table->reorderings % table->reordCycle == 0) {
	double saveGrowth = table->maxGrowth;
	table->maxGrowth = table->maxGrowthAlt;
	result = cuddTreeSifting(table,heuristic);
	table->maxGrowth = saveGrowth;
    } else {
	result = cuddTreeSifting(table,heuristic);
    }

#ifdef DD_STATS
    (void) fprintf(table->out,"\n");
    finalSize = (int) (table->keys - table->isolated);
    (void) fprintf(table->out,"#:F_REORDER %8d: final size\n",finalSize);
    (void) fprintf(table->out,"#:T_REORDER %8g: total time (sec)\n",
		   ((double)(util_cpu_time() - localTime)/1000.0));
    (void) fprintf(table->out,"#:N_REORDER %8d: total swaps\n",
		   table->ddTotalNumberSwapping);
    (void) fprintf(table->out,"#:M_REORDER %8d: NI swaps\n",
                   table->totalNISwaps);
#endif

    if (result == 0)
	return(0);

    if (!ddReorderPostprocess(table))
	return(0);

    if (table->realign) {
	if (!cuddZddAlignToBdd(table))
	    return(0);
    }

    nextDyn = (table->keys - table->constants.keys + 1) *
	      DD_DYN_RATIO + table->constants.keys;
    if (table->reorderings < 20 || nextDyn > table->nextDyn)
	table->nextDyn = nextDyn;
    else
	table->nextDyn += 20;
    if (table->randomizeOrder != 0) {
        table->nextDyn += Cudd_Random(table) & table->randomizeOrder;
    }
    table->reordered = 1;

    /* Run hook functions. */
    hook = table->postReorderingHook;
    while (hook != NULL) {
	int res = (hook->f)(table, "BDD", (void *)(ptruint)localTime);
	if (res == 0) return(0);
	hook = hook->next;
    }
    /* Update cumulative reordering time. */
    table->reordTime += util_cpu_time() - localTime;

    return(result);

} /* end of Cudd_ReduceHeap */


/**
  @brief Reorders variables according to given permutation.

  @details The i-th entry of the permutation array contains the index
  of the variable that should be brought to the i-th level.  The size
  of the array should be equal or greater to the number of variables
  currently in use.

  @return 1 in case of success; 0 otherwise.

  @sideeffect Changes the variable order for all diagrams and clears
  the cache.

  @see Cudd_ReduceHeap

*/
int
Cudd_ShuffleHeap(
  DdManager * table /**< %DD manager */,
  int * permutation /**< required variable permutation */)
{

    int	result;
    int i;
    int identity = 1;
    int *perm;

    /* Don't waste time in case of identity permutation. */
    for (i = 0; i < table->size; i++) {
	if (permutation[i] != table->invperm[i]) {
	    identity = 0;
	    break;
	}
    }
    if (identity == 1) {
	return(1);
    }
    if (!ddReorderPreprocess(table)) return(0);
    if (table->keys > table->peakLiveNodes) {
	table->peakLiveNodes = table->keys;
    }

    perm = ALLOC(int, table->size);
    for (i = 0; i < table->size; i++)
	perm[permutation[i]] = i;
    if (!ddCheckPermuation(table,table->tree,perm,permutation)) {
	FREE(perm);
	return(0);
    }
    if (!ddUpdateMtrTree(table,table->tree,perm,permutation)) {
	FREE(perm);
	return(0);
    }
    FREE(perm);

    result = ddShuffle(table,permutation);

    if (!ddReorderPostprocess(table)) return(0);

    return(result);

} /* end of Cudd_ShuffleHeap */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Dynamically allocates a Node.

  @details This procedure is similar to cuddAllocNode in Cudd_Table.c,
  but it does not attempt garbage collection, because during
  reordering there are no dead nodes.

  @return a pointer to a new node if successful; NULL is memory is
  full.

  @sideeffect None

  @see cuddAllocNode

*/
DdNode *
cuddDynamicAllocNode(
  DdManager * table)
{
    int     i;
    DdNodePtr *mem;
    DdNode *list, *node;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    if (table->nextFree == NULL) {        /* free list is empty */
	/* Try to allocate a new block. */
	saveHandler = MMoutOfMemory;
	MMoutOfMemory = table->outOfMemCallback;
	mem = (DdNodePtr *) ALLOC(DdNode, DD_MEM_CHUNK + 1);
	MMoutOfMemory = saveHandler;
	if (mem == NULL && table->stash != NULL) {
	    FREE(table->stash);
	    table->stash = NULL;
	    /* Inhibit resizing of tables. */
	    table->maxCacheHard = table->cacheSlots - 1;
	    table->cacheSlack = - (int) (table->cacheSlots + 1);
	    for (i = 0; i < table->size; i++) {
		table->subtables[i].maxKeys <<= 2;
	    }
	    mem = (DdNodePtr *) ALLOC(DdNode,DD_MEM_CHUNK + 1);
	}
	if (mem == NULL) {
	    /* Out of luck. Call the default handler to do
	    ** whatever it specifies for a failed malloc.  If this
	    ** handler returns, then set error code, print
	    ** warning, and return. */
	    (*MMoutOfMemory)(sizeof(DdNode)*(DD_MEM_CHUNK + 1));
	    table->errorCode = CUDD_MEMORY_OUT;
#ifdef DD_VERBOSE
	    (void) fprintf(table->err,
			   "cuddDynamicAllocNode: out of memory");
	    (void) fprintf(table->err,"Memory in use = %lu\n",
			   table->memused);
#endif
	    return(NULL);
	} else {	/* successful allocation; slice memory */
	    size_t offset;
	    table->memused += (DD_MEM_CHUNK + 1) * sizeof(DdNode);
	    mem[0] = (DdNode *) table->memoryList;
	    table->memoryList = mem;

	    /* Here we rely on the fact that the size of a DdNode is a
	    ** power of 2 and a multiple of the size of a pointer.
	    ** If we align one node, all the others will be aligned
	    ** as well. */
	    offset = (size_t) mem & (sizeof(DdNode) - 1);
	    mem += (sizeof(DdNode) - offset) / sizeof(DdNodePtr);
#ifdef DD_DEBUG
	    assert(((size_t) mem & (sizeof(DdNode) - 1)) == 0);
#endif
	    list = (DdNode *) mem;

	    i = 1;
	    do {
		list[i - 1].ref = 0;
		list[i - 1].next = &list[i];
	    } while (++i < DD_MEM_CHUNK);

	    list[DD_MEM_CHUNK-1].ref = 0;
	    list[DD_MEM_CHUNK - 1].next = NULL;

	    table->nextFree = &list[0];
	}
    } /* if free list empty */

    node = table->nextFree;
    table->nextFree = node->next;
    return (node);

} /* end of cuddDynamicAllocNode */


/**
  @brief Implementation of Rudell's sifting algorithm.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the %DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddSifting(
  DdManager * table,
  int  lower,
  int  upper)
{
    int	i;
    IndexKey *var;
    int	size;
    int	x;
    int	result;
#ifdef DD_STATS
    int	previousSize;
#endif

    size = table->size;

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey,size);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto cuddSiftingOutOfMem;
    }

    for (i = 0; i < size; i++) {
	x = table->perm[i];
	var[i].index = i;
	var[i].keys = table->subtables[x].keys;
    }

    util_qsort(var,size,sizeof(IndexKey),ddUniqueCompare);

    /* Now sift. */
    for (i = 0; i < ddMin(table->siftMaxVar,size); i++) {
	if (table->ddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime + table->reordTime
            > table->timeLimit) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
	x = table->perm[var[i].index];

	if (x < lower || x > upper || table->subtables[x].bindVar == 1)
	    continue;
#ifdef DD_STATS
	previousSize = (int) (table->keys - table->isolated);
#endif
	result = ddSiftingAux(table, x, lower, upper);
	if (!result) goto cuddSiftingOutOfMem;
#ifdef DD_STATS
	if (table->keys < (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"-");
	} else if (table->keys > (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	    (void) fprintf(table->err,"\nSize increased from %d to %u while sifting variable %d\n", previousSize, table->keys - table->isolated, var[i].index);
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
    }

    FREE(var);

    return(1);

cuddSiftingOutOfMem:

    if (var != NULL) FREE(var);

    return(0);

} /* end of cuddSifting */


/**
  @brief Reorders variables by a sequence of (non-adjacent) swaps.

  @details Implementation of Plessier's algorithm that reorders
  variables by a sequence of (non-adjacent) swaps.
    <ol>
    <li> Select two variables (RANDOM or HEURISTIC).
    <li> Permute these variables.
    <li> If the nodes have decreased accept the permutation.
    <li> Otherwise reconstruct the original heap.
    <li> Loop.
    </ol>

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
cuddSwapping(
  DdManager * table,
  int lower,
  int upper,
  Cudd_ReorderingType heuristic)
{
    int	i, j;
    int	max, keys;
    int	nvars;
    int	x, y;
    int	iterate;
    int previousSize;
    Move *moves, *move;
    int	pivot = 0;
    int	modulo;
    int result;

#ifdef DD_DEBUG
    /* Sanity check */
    assert(lower >= 0 && upper < table->size && lower <= upper);
#endif

    nvars = upper - lower + 1;
    iterate = nvars;

    for (i = 0; i < iterate; i++) {
	if (table->ddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
	if (heuristic == CUDD_REORDER_RANDOM_PIVOT) {
	    max = -1;
	    for (j = lower; j <= upper; j++) {
		if ((keys = table->subtables[j].keys) > max) {
		    max = keys;
		    pivot = j;
		}
	    }

	    modulo = upper - pivot;
	    if (modulo == 0) {
		y = pivot;
	    } else{
		y = pivot + 1 + ((int) Cudd_Random(table) % modulo);
	    }

	    modulo = pivot - lower - 1;
	    if (modulo < 1) {
		x = lower;
	    } else{
		do {
		    x = (int) Cudd_Random(table) % modulo;
		} while (x == y);
	    }
	} else {
	    x = ((int) Cudd_Random(table) % nvars) + lower;
	    do {
		y = ((int) Cudd_Random(table) % nvars) + lower;
	    } while (x == y);
	}
	previousSize = (int) (table->keys - table->isolated);
	moves = ddSwapAny(table,x,y);
	if (moves == NULL) goto cuddSwappingOutOfMem;
	result = ddSiftingBackward(table,previousSize,moves);
	if (!result) goto cuddSwappingOutOfMem;
	while (moves != NULL) {
	    move = moves->next;
	    cuddDeallocMove(table, moves);
	    moves = move;
	}
#ifdef DD_STATS
	if (table->keys < (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"-");
	} else if (table->keys > (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
#if 0
	(void) fprintf(table->out,"#:t_SWAPPING %8d: tmp size\n",
		       table->keys - table->isolated);
#endif
    }

    return(1);

cuddSwappingOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }

    return(0);

} /* end of cuddSwapping */


/**
  @brief Finds the next subtable with a larger index.

  @return the index.

  @sideeffect None

  @see cuddNextLow

*/
int
cuddNextHigh(
  DdManager * table,
  int  x)
{
    (void) table; /* avoid warning */
    return(x+1);

} /* end of cuddNextHigh */


/**
  @brief Finds the next subtable with a smaller index.

  @return the index.

  @sideeffect None

  @see cuddNextHigh

*/
int
cuddNextLow(
  DdManager * table,
  int  x)
{
    (void) table; /* avoid warning */
    return(x-1);

} /* end of cuddNextLow */


/**
  @brief Swaps two adjacent variables.

  @details It assumes that no dead nodes are present on entry to this
  procedure.  The procedure then guarantees that no dead nodes will be
  present when it terminates.  cuddSwapInPlace assumes that x &lt; y.

  @return the number of keys in the table if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddSwapInPlace(
  DdManager * table,
  int  x,
  int  y)
{
    DdNodePtr *xlist, *ylist;
    int    xindex, yindex;
    int    xslots, yslots;
    int    xshift, yshift;
    int    oldxkeys, oldykeys;
    int    newxkeys, newykeys;
    int    comple, newcomplement;
    int    i;
    Cudd_VariableType varType;
    Cudd_LazyGroupType groupType;
    int    posn;
    int    isolated;
    DdNode *f,*f0,*f1,*f01,*f00,*f11,*f10,*newf1,*newf0;
    DdNode *g,*next;
    DdNodePtr *previousP;
    DdNode *tmp;
    DdNode *sentinel = &(table->sentinel);
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

#ifdef DD_DEBUG
    int    count,idcheck;
#endif

#ifdef DD_DEBUG
    assert(x < y);
    assert(cuddNextHigh(table,x) == y);
    assert(table->subtables[x].keys != 0);
    assert(table->subtables[y].keys != 0);
    assert(table->subtables[x].dead == 0);
    assert(table->subtables[y].dead == 0);
#endif

    table->ddTotalNumberSwapping++;

    /* Get parameters of x subtable. */
    xindex = table->invperm[x];
    xlist = table->subtables[x].nodelist;
    oldxkeys = table->subtables[x].keys;
    xslots = table->subtables[x].slots;
    xshift = table->subtables[x].shift;

    /* Get parameters of y subtable. */
    yindex = table->invperm[y];
    ylist = table->subtables[y].nodelist;
    oldykeys = table->subtables[y].keys;
    yslots = table->subtables[y].slots;
    yshift = table->subtables[y].shift;

    if (!cuddTestInteract(table,xindex,yindex)) {
#ifdef DD_STATS
	table->totalNISwaps++;
#endif
	newxkeys = oldxkeys;
	newykeys = oldykeys;
    } else {
	newxkeys = 0;
	newykeys = oldykeys;

	/* Check whether the two projection functions involved in this
	** swap are isolated. At the end, we'll be able to tell how many
	** isolated projection functions are there by checking only these
	** two functions again. This is done to eliminate the isolated
	** projection functions from the node count.
	*/
	isolated = - ((table->vars[xindex]->ref == 1) +
		     (table->vars[yindex]->ref == 1));

	/* The nodes in the x layer that do not depend on
	** y will stay there; the others are put in a chain.
	** The chain is handled as a LIFO; g points to the beginning.
	*/
	g = NULL;
	if ((oldxkeys >= xslots || (unsigned) xslots == table->initSlots) &&
	    oldxkeys <= DD_MAX_SUBTABLE_DENSITY * xslots) {
	    for (i = 0; i < xslots; i++) {
		previousP = &(xlist[i]);
		f = *previousP;
		while (f != sentinel) {
		    next = f->next;
		    f1 = cuddT(f); f0 = cuddE(f);
		    if (f1->index != (DdHalfWord) yindex &&
			Cudd_Regular(f0)->index != (DdHalfWord) yindex) {
			/* stays */
			newxkeys++;
			*previousP = f;
			previousP = &(f->next);
		    } else {
			f->index = yindex;
			f->next = g;
			g = f;
		    }
		    f = next;
		} /* while there are elements in the collision chain */
		*previousP = sentinel;
	    } /* for each slot of the x subtable */
	} else {		/* resize xlist */
	    DdNode *h = NULL;
	    DdNodePtr *newxlist;
	    unsigned int newxslots;
	    int newxshift;
	    /* Empty current xlist. Nodes that stay go to list h;
	    ** nodes that move go to list g. */
	    for (i = 0; i < xslots; i++) {
		f = xlist[i];
		while (f != sentinel) {
		    next = f->next;
		    f1 = cuddT(f); f0 = cuddE(f);
		    if (f1->index != (DdHalfWord) yindex &&
			Cudd_Regular(f0)->index != (DdHalfWord) yindex) {
			/* stays */
			f->next = h;
			h = f;
			newxkeys++;
		    } else {
			f->index = yindex;
			f->next = g;
			g = f;
		    }
		    f = next;
		} /* while there are elements in the collision chain */
	    } /* for each slot of the x subtable */
	    /* Decide size of new subtable. */
	    newxshift = xshift;
	    newxslots = xslots;
	    while ((unsigned) oldxkeys > DD_MAX_SUBTABLE_DENSITY * newxslots) {
		newxshift--;
		newxslots <<= 1;
	    }
	    while ((unsigned) oldxkeys < newxslots &&
		   newxslots > table->initSlots) {
		newxshift++;
		newxslots >>= 1;
	    }
	    /* Try to allocate new table. Be ready to back off. */
	    saveHandler = MMoutOfMemory;
	    MMoutOfMemory = table->outOfMemCallback;
	    newxlist = ALLOC(DdNodePtr, newxslots);
	    MMoutOfMemory = saveHandler;
	    if (newxlist == NULL) {
		(void) fprintf(table->err, "Unable to resize subtable %d for lack of memory\n", i);
	    } else {
		table->slots += ((int) newxslots - xslots);
		table->minDead = (unsigned)
		    (table->gcFrac * (double) table->slots);
		table->cacheSlack = (int)
		    ddMin(table->maxCacheHard, DD_MAX_CACHE_TO_SLOTS_RATIO
			  * table->slots) - 2 * (int) table->cacheSlots;
		table->memused +=
		    ((int) newxslots - xslots) * sizeof(DdNodePtr);
		FREE(xlist);
		xslots =  newxslots;
		xshift = newxshift;
		xlist = newxlist;
	    }
	    /* Initialize new subtable. */
	    for (i = 0; i < xslots; i++) {
		xlist[i] = sentinel;
	    }
	    /* Move nodes that were parked in list h to their new home. */
	    f = h;
	    while (f != NULL) {
		next = f->next;
		f1 = cuddT(f);
		f0 = cuddE(f);
		/* Check xlist for pair (f11,f01). */
		posn = ddHash(f1, f0, xshift);
		/* For each element tmp in collision list xlist[posn]. */
		previousP = &(xlist[posn]);
		tmp = *previousP;
		while (f1 < cuddT(tmp)) {
		    previousP = &(tmp->next);
		    tmp = *previousP;
		}
		while (f1 == cuddT(tmp) && f0 < cuddE(tmp)) {
		    previousP = &(tmp->next);
		    tmp = *previousP;
		}
		f->next = *previousP;
		*previousP = f;
		f = next;
	    }
	}

#ifdef DD_COUNT
	table->swapSteps += oldxkeys - newxkeys;
#endif
	/* Take care of the x nodes that must be re-expressed.
	** They form a linked list pointed by g. Their index has been
	** already changed to yindex.
	*/
	f = g;
	while (f != NULL) {
	    next = f->next;
	    /* Find f1, f0, f11, f10, f01, f00. */
	    f1 = cuddT(f);
#ifdef DD_DEBUG
	    assert(!(Cudd_IsComplement(f1)));
#endif
	    if ((int) f1->index == yindex) {
		f11 = cuddT(f1); f10 = cuddE(f1);
	    } else {
		f11 = f10 = f1;
	    }
#ifdef DD_DEBUG
	    assert(!(Cudd_IsComplement(f11)));
#endif
	    f0 = cuddE(f);
	    comple = Cudd_IsComplement(f0);
	    f0 = Cudd_Regular(f0);
	    if ((int) f0->index == yindex) {
		f01 = cuddT(f0); f00 = cuddE(f0);
	    } else {
		f01 = f00 = f0;
	    }
	    if (comple) {
		f01 = Cudd_Not(f01);
		f00 = Cudd_Not(f00);
	    }
	    /* Decrease ref count of f1. */
	    cuddSatDec(f1->ref);
	    /* Create the new T child. */
	    if (f11 == f01) {
		newf1 = f11;
		cuddSatInc(newf1->ref);
	    } else {
		/* Check xlist for triple (xindex,f11,f01). */
		posn = ddHash(f11, f01, xshift);
		/* For each element newf1 in collision list xlist[posn]. */
		previousP = &(xlist[posn]);
		newf1 = *previousP;
		while (f11 < cuddT(newf1)) {
		    previousP = &(newf1->next);
		    newf1 = *previousP;
		}
		while (f11 == cuddT(newf1) && f01 < cuddE(newf1)) {
		    previousP = &(newf1->next);
		    newf1 = *previousP;
		}
		if (cuddT(newf1) == f11 && cuddE(newf1) == f01) {
		    cuddSatInc(newf1->ref);
		} else { /* no match */
		    newf1 = cuddDynamicAllocNode(table);
		    if (newf1 == NULL)
			goto cuddSwapOutOfMem;
		    newf1->index = xindex; newf1->ref = 1;
		    cuddT(newf1) = f11;
		    cuddE(newf1) = f01;
		    /* Insert newf1 in the collision list xlist[posn];
		    ** increase the ref counts of f11 and f01.
		    */
		    newxkeys++;
		    newf1->next = *previousP;
		    *previousP = newf1;
		    cuddSatInc(f11->ref);
		    tmp = Cudd_Regular(f01);
		    cuddSatInc(tmp->ref);
		}
	    }
	    cuddT(f) = newf1;
#ifdef DD_DEBUG
	    assert(!(Cudd_IsComplement(newf1)));
#endif

	    /* Do the same for f0, keeping complement dots into account. */
	    /* Decrease ref count of f0. */
	    tmp = Cudd_Regular(f0);
	    cuddSatDec(tmp->ref);
	    /* Create the new E child. */
	    if (f10 == f00) {
		newf0 = f00;
		tmp = Cudd_Regular(newf0);
		cuddSatInc(tmp->ref);
	    } else {
		/* make sure f10 is regular */
		newcomplement = Cudd_IsComplement(f10);
		if (newcomplement) {
		    f10 = Cudd_Not(f10);
		    f00 = Cudd_Not(f00);
		}
		/* Check xlist for triple (xindex,f10,f00). */
		posn = ddHash(f10, f00, xshift);
		/* For each element newf0 in collision list xlist[posn]. */
		previousP = &(xlist[posn]);
		newf0 = *previousP;
		while (f10 < cuddT(newf0)) {
		    previousP = &(newf0->next);
		    newf0 = *previousP;
		}
		while (f10 == cuddT(newf0) && f00 < cuddE(newf0)) {
		    previousP = &(newf0->next);
		    newf0 = *previousP;
		}
		if (cuddT(newf0) == f10 && cuddE(newf0) == f00) {
		    cuddSatInc(newf0->ref);
		} else { /* no match */
		    newf0 = cuddDynamicAllocNode(table);
		    if (newf0 == NULL)
			goto cuddSwapOutOfMem;
		    newf0->index = xindex; newf0->ref = 1;
		    cuddT(newf0) = f10;
		    cuddE(newf0) = f00;
		    /* Insert newf0 in the collision list xlist[posn];
		    ** increase the ref counts of f10 and f00.
		    */
		    newxkeys++;
		    newf0->next = *previousP;
		    *previousP = newf0;
		    cuddSatInc(f10->ref);
		    tmp = Cudd_Regular(f00);
		    cuddSatInc(tmp->ref);
		}
		if (newcomplement) {
		    newf0 = Cudd_Not(newf0);
		}
	    }
	    cuddE(f) = newf0;

	    /* Insert the modified f in ylist.
	    ** The modified f does not already exists in ylist.
	    ** (Because of the uniqueness of the cofactors.)
	    */
	    posn = ddHash(newf1, newf0, yshift);
	    newykeys++;
	    previousP = &(ylist[posn]);
	    tmp = *previousP;
	    while (newf1 < cuddT(tmp)) {
		previousP = &(tmp->next);
		tmp = *previousP;
	    }
	    while (newf1 == cuddT(tmp) && newf0 < cuddE(tmp)) {
		previousP = &(tmp->next);
		tmp = *previousP;
	    }
	    f->next = *previousP;
	    *previousP = f;
	    f = next;
	} /* while f != NULL */

	/* GC the y layer. */

	/* For each node f in ylist. */
	for (i = 0; i < yslots; i++) {
	    previousP = &(ylist[i]);
	    f = *previousP;
	    while (f != sentinel) {
		next = f->next;
		if (f->ref == 0) {
		    tmp = cuddT(f);
		    cuddSatDec(tmp->ref);
		    tmp = Cudd_Regular(cuddE(f));
		    cuddSatDec(tmp->ref);
		    cuddDeallocNode(table,f);
		    newykeys--;
		} else {
		    *previousP = f;
		    previousP = &(f->next);
		}
		f = next;
	    } /* while f */
	    *previousP = sentinel;
	} /* for i */

#ifdef DD_DEBUG
#if 0
	(void) fprintf(table->out,"Swapping %d and %d\n",x,y);
#endif
	count = 0;
	idcheck = 0;
	for (i = 0; i < yslots; i++) {
	    f = ylist[i];
	    while (f != sentinel) {
		count++;
		if (f->index != (DdHalfWord) yindex)
		    idcheck++;
		f = f->next;
	    }
	}
	if (count != newykeys) {
	    (void) fprintf(table->out,
			   "Error in finding newykeys\toldykeys = %d\tnewykeys = %d\tactual = %d\n",
			   oldykeys,newykeys,count);
	}
	if (idcheck != 0)
	    (void) fprintf(table->out,
			   "Error in id's of ylist\twrong id's = %d\n",
			   idcheck);
	count = 0;
	idcheck = 0;
	for (i = 0; i < xslots; i++) {
	    f = xlist[i];
	    while (f != sentinel) {
		count++;
		if (f->index != (DdHalfWord) xindex)
		    idcheck++;
		f = f->next;
	    }
	}
	if (count != newxkeys) {
	    (void) fprintf(table->out,
			   "Error in finding newxkeys\toldxkeys = %d \tnewxkeys = %d \tactual = %d\n",
			   oldxkeys,newxkeys,count);
	}
	if (idcheck != 0)
	    (void) fprintf(table->out,
			   "Error in id's of xlist\twrong id's = %d\n",
			   idcheck);
#endif

	isolated += (table->vars[xindex]->ref == 1) +
		    (table->vars[yindex]->ref == 1);
	table->isolated += (unsigned int) isolated;
    }

    /* Set the appropriate fields in table. */
    table->subtables[x].nodelist = ylist;
    table->subtables[x].slots = yslots;
    table->subtables[x].shift = yshift;
    table->subtables[x].keys = newykeys;
    table->subtables[x].maxKeys = yslots * DD_MAX_SUBTABLE_DENSITY;
    i = table->subtables[x].bindVar;
    table->subtables[x].bindVar = table->subtables[y].bindVar;
    table->subtables[y].bindVar = i;
    /* Adjust fields for lazy sifting. */
    varType = table->subtables[x].varType;
    table->subtables[x].varType = table->subtables[y].varType;
    table->subtables[y].varType = varType;
    i = table->subtables[x].pairIndex;
    table->subtables[x].pairIndex = table->subtables[y].pairIndex;
    table->subtables[y].pairIndex = i;
    i = table->subtables[x].varHandled;
    table->subtables[x].varHandled = table->subtables[y].varHandled;
    table->subtables[y].varHandled = i;
    groupType = table->subtables[x].varToBeGrouped;
    table->subtables[x].varToBeGrouped = table->subtables[y].varToBeGrouped;
    table->subtables[y].varToBeGrouped = groupType;

    table->subtables[y].nodelist = xlist;
    table->subtables[y].slots = xslots;
    table->subtables[y].shift = xshift;
    table->subtables[y].keys = newxkeys;
    table->subtables[y].maxKeys = xslots * DD_MAX_SUBTABLE_DENSITY;

    table->perm[xindex] = y; table->perm[yindex] = x;
    table->invperm[x] = yindex; table->invperm[y] = xindex;

    table->keys += newxkeys + newykeys - oldxkeys - oldykeys;

    return((int)(table->keys - table->isolated));

cuddSwapOutOfMem:
    (void) fprintf(table->err,"Error: cuddSwapInPlace out of memory\n");

    return (0);

} /* end of cuddSwapInPlace */


/**
  @brief Reorders %BDD variables according to the order of the %ZDD
  variables.

  @details This function can be called at the end of %ZDD
  reordering to insure that the order of the %BDD variables is
  consistent with the order of the %ZDD variables. The number of %ZDD
  variables must be a multiple of the number of %BDD variables. Let
  <code>M</code> be the ratio of the two numbers. cuddBddAlignToZdd
  then considers the %ZDD variables from <code>M*i</code> to
  <code>(M+1)*i-1</code> as corresponding to %BDD variable
  <code>i</code>.  This function should be normally called from
  Cudd_zddReduceHeap, which clears the cache.

  @return 1 in case of success; 0 otherwise.

  @sideeffect Changes the %BDD variable order for all diagrams and performs
  garbage collection of the %BDD unique table.

  @see Cudd_ShuffleHeap Cudd_zddReduceHeap

*/
int
cuddBddAlignToZdd(
  DdManager * table /**< %DD manager */)
{
    int *invperm;		/* permutation array */
    int M;			/* ratio of ZDD variables to BDD variables */
    int i;			/* loop index */
    int result;			/* return value */

    /* We assume that a ratio of 0 is OK. */
    if (table->size == 0)
	return(1);

    M = table->sizeZ / table->size;
    /* Check whether the number of ZDD variables is a multiple of the
    ** number of BDD variables.
    */
    if (M * table->size != table->sizeZ)
	return(0);
    /* Create and initialize the inverse permutation array. */
    invperm = ALLOC(int,table->size);
    if (invperm == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (i = 0; i < table->sizeZ; i += M) {
	int indexZ = table->invpermZ[i];
	int index  = indexZ / M;
	invperm[i / M] = index;
    }
    /* Eliminate dead nodes. Do not scan the cache again, because we
    ** assume that Cudd_zddReduceHeap has already cleared it.
    */
    cuddGarbageCollect(table,0);

    /* Initialize number of isolated projection functions. */
    table->isolated = 0;
    for (i = 0; i < table->size; i++) {
	if (table->vars[i]->ref == 1) table->isolated++;
    }

    /* Initialize the interaction matrix. */
    result = cuddInitInteract(table);
    if (result == 0) return(0);

    result = ddShuffle(table, invperm);
    FREE(invperm);
    /* Free interaction matrix. */
    FREE(table->interact);
    /* Fix the BDD variable group tree. */
    bddFixTree(table,table->tree);
    return(result);

} /* end of cuddBddAlignToZdd */

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Comparison function used by qsort.

  @details Used to order the variables according to the number of keys
  in the subtables.

  @return the difference in number of keys between the two variables
  being compared.

  @sideeffect None

*/
static int
ddUniqueCompare(
  void const * ptrX,
  void const * ptrY)
{
    IndexKey const * pX = (IndexKey const *) ptrX;
    IndexKey const * pY = (IndexKey const *) ptrY;
#if 0
    /* This would make the order stable, which would be good because of
     * it would platform-independent, but instability often produces
     * smaller BDDs.
     */
    if (pY->keys == pX->keys) {
	return(pX->index - pY->index);
    }
#endif
    return(pY->keys - pX->keys);

} /* end of ddUniqueCompare */


/**
  @brief Swaps any two variables.

  @return the set of moves.

  @sideeffect None

*/
static Move *
ddSwapAny(
  DdManager * table,
  int  x,
  int  y)
{
    Move	*move, *moves;
    int		xRef,yRef;
    int		xNext,yNext;
    int		size;
    int		limitSize;
    int		tmp;

    if (x >y) {
	tmp = x; x = y; y = tmp;
    }

    xRef = x; yRef = y;

    xNext = cuddNextHigh(table,x);
    yNext = cuddNextLow(table,y);
    moves = NULL;
    limitSize = (int) (table->keys - table->isolated);

    for (;;) {
	if ( xNext == yNext) {
	    size = cuddSwapInPlace(table,x,xNext);
	    if (size == 0) goto ddSwapAnyOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = xNext;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    size = cuddSwapInPlace(table,yNext,y);
	    if (size == 0) goto ddSwapAnyOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSwapAnyOutOfMem;
	    move->x = yNext;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    size = cuddSwapInPlace(table,x,xNext);
	    if (size == 0) goto ddSwapAnyOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = xNext;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    tmp = x; x = y; y = tmp;

	} else if (x == yNext) {

	    size = cuddSwapInPlace(table,x,xNext);
	    if (size == 0) goto ddSwapAnyOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = xNext;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    tmp = x; x = y; y = tmp;

	} else {
	    size = cuddSwapInPlace(table,x,xNext);
	    if (size == 0) goto ddSwapAnyOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = xNext;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    size = cuddSwapInPlace(table,yNext,y);
	    if (size == 0) goto ddSwapAnyOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSwapAnyOutOfMem;
	    move->x = yNext;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    x = xNext;
	    y = yNext;
	}

	xNext = cuddNextHigh(table,x);
	yNext = cuddNextLow(table,y);
	if (xNext > yRef) break;

	if ((double) size > table->maxGrowth * (double) limitSize) break;
	if (size < limitSize) limitSize = size;
    }
    if (yNext>=xRef) {
	size = cuddSwapInPlace(table,yNext,y);
	if (size == 0) goto ddSwapAnyOutOfMem;
	move = (Move *) cuddDynamicAllocNode(table);
	if (move == NULL) goto ddSwapAnyOutOfMem;
	move->x = yNext;
	move->y = y;
	move->size = size;
	move->next = moves;
	moves = move;
    }

    return(moves);

ddSwapAnyOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(NULL);

} /* end of ddSwapAny */


/**
  @brief Given xLow <= x <= xHigh moves x up and down between the
  boundaries.

  @details Finds the best position and does the required changes.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddSiftingAux(
  DdManager * table,
  int  x,
  int  xLow,
  int  xHigh)
{

    Move	*move;
    Move	*moveUp;		/* list of up moves */
    Move	*moveDown;		/* list of down moves */
    int		initialSize;
    int		result;

    initialSize = (int) (table->keys - table->isolated);

    moveDown = NULL;
    moveUp = NULL;

    if (x == xLow) {
	moveDown = ddSiftingDown(table,x,xHigh);
	/* At this point x --> xHigh unless bounding occurred. */
	if (moveDown == (Move *) CUDD_OUT_OF_MEM) goto ddSiftingAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = ddSiftingBackward(table,initialSize,moveDown);
	if (!result) goto ddSiftingAuxOutOfMem;

    } else if (x == xHigh) {
	moveUp = ddSiftingUp(table,x,xLow);
	/* At this point x --> xLow unless bounding occurred. */
	if (moveUp == (Move *) CUDD_OUT_OF_MEM) goto ddSiftingAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = ddSiftingBackward(table,initialSize,moveUp);
	if (!result) goto ddSiftingAuxOutOfMem;

    } else if ((x - xLow) > (xHigh - x)) { /* must go down first: shorter */
	moveDown = ddSiftingDown(table,x,xHigh);
	/* At this point x --> xHigh unless bounding occurred. */
	if (moveDown == (Move *) CUDD_OUT_OF_MEM) goto ddSiftingAuxOutOfMem;
	if (moveDown != NULL) {
	    x = moveDown->y;
	}
	moveUp = ddSiftingUp(table,x,xLow);
	if (moveUp == (Move *) CUDD_OUT_OF_MEM) goto ddSiftingAuxOutOfMem;
	/* Move backward and stop at best position */
	result = ddSiftingBackward(table,initialSize,moveUp);
	if (!result) goto ddSiftingAuxOutOfMem;

    } else { /* must go up first: shorter */
	moveUp = ddSiftingUp(table,x,xLow);
	/* At this point x --> xLow unless bounding occurred. */
	if (moveUp == (Move *) CUDD_OUT_OF_MEM) goto ddSiftingAuxOutOfMem;
	if (moveUp != NULL) {
	    x = moveUp->x;
	}
	moveDown = ddSiftingDown(table,x,xHigh);
	if (moveDown == (Move *) CUDD_OUT_OF_MEM) goto ddSiftingAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = ddSiftingBackward(table,initialSize,moveDown);
	if (!result) goto ddSiftingAuxOutOfMem;
    }

    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(1);

ddSiftingAuxOutOfMem:
    if (moveDown != (Move *) CUDD_OUT_OF_MEM) {
	while (moveDown != NULL) {
	    move = moveDown->next;
	    cuddDeallocMove(table, moveDown);
	    moveDown = move;
	}
    }
    if (moveUp != (Move *) CUDD_OUT_OF_MEM) {
	while (moveUp != NULL) {
	    move = moveUp->next;
	    cuddDeallocMove(table, moveUp);
	    moveUp = move;
	}
    }

    return(0);

} /* end of ddSiftingAux */


/**
  @brief Sifts a variable up.

  @details Moves y up until either it reaches the bound (xLow) or the
  size of the %DD heap increases too much.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
ddSiftingUp(
  DdManager * table,
  int  y,
  int  xLow)
{
    Move	*moves;
    Move	*move;
    int		x;
    int		size;
    int		limitSize;
    int		xindex, yindex;
    int		isolated;
    int		L;	/* lower bound on DD size */
#ifdef DD_DEBUG
    int checkL;
    int z;
    int zindex;
#endif

    moves = NULL;
    yindex = table->invperm[y];

    /* Initialize the lower bound.
    ** The part of the DD below y will not change.
    ** The part of the DD above y that does not interact with y will not
    ** change. The rest may vanish in the best case, except for
    ** the nodes at level xLow, which will not vanish, regardless.
    */
    limitSize = L = (int) (table->keys - table->isolated);
    for (x = xLow + 1; x < y; x++) {
	xindex = table->invperm[x];
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[xindex]->ref == 1;
	    L -= table->subtables[x].keys - isolated;
	}
    }
    isolated = table->vars[yindex]->ref == 1;
    L -= (int) table->subtables[y].keys - isolated;

    x = cuddNextLow(table,y);
    while (x >= xLow && L <= limitSize) {
	xindex = table->invperm[x];
#ifdef DD_DEBUG
	checkL = (int) (table->keys - table->isolated);
	for (z = xLow + 1; z < y; z++) {
	    zindex = table->invperm[z];
	    if (cuddTestInteract(table,zindex,yindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkL -= (int) table->subtables[z].keys - isolated;
	    }
	}
	isolated = table->vars[yindex]->ref == 1;
	checkL -= (int) table->subtables[y].keys - isolated;
	assert(L == checkL);
#endif
	size = cuddSwapInPlace(table,x,y);
	if (size == 0) goto ddSiftingUpOutOfMem;
	/* Update the lower bound. */
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[xindex]->ref == 1;
	    L += (int) table->subtables[y].keys - isolated;
	}
	move = (Move *) cuddDynamicAllocNode(table);
	if (move == NULL) goto ddSiftingUpOutOfMem;
	move->x = x;
	move->y = y;
	move->size = size;
	move->next = moves;
	moves = move;
	if ((double) size > (double) limitSize * table->maxGrowth) break;
	if (size < limitSize) limitSize = size;
	y = x;
	x = cuddNextLow(table,y);
    }
    return(moves);

ddSiftingUpOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of ddSiftingUp */


/**
  @brief Sifts a variable down.

  @details Moves x down until either it reaches the bound (xHigh) or
  the size of the %DD heap increases too much.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
ddSiftingDown(
  DdManager * table,
  int  x,
  int  xHigh)
{
    Move	*moves;
    Move	*move;
    int		y;
    int		size;
    int		R;	/* upper bound on node decrease */
    int		limitSize;
    int		xindex, yindex;
    int		isolated;
#ifdef DD_DEBUG
    int		checkR;
    int		z;
    int		zindex;
#endif

    moves = NULL;
    /* Initialize R */
    xindex = table->invperm[x];
    limitSize = size = (int) (table->keys - table->isolated);
    R = 0;
    for (y = xHigh; y > x; y--) {
	yindex = table->invperm[y];
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[yindex]->ref == 1;
	    R += (int) table->subtables[y].keys - isolated;
	}
    }

    y = cuddNextHigh(table,x);
    while (y <= xHigh && size - R < limitSize) {
#ifdef DD_DEBUG
	checkR = 0;
	for (z = xHigh; z > x; z--) {
	    zindex = table->invperm[z];
	    if (cuddTestInteract(table,xindex,zindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkR += (int) table->subtables[z].keys - isolated;
	    }
	}
	assert(R == checkR);
#endif
	/* Update upper bound on node decrease. */
	yindex = table->invperm[y];
	if (cuddTestInteract(table,xindex,yindex)) {
	    isolated = table->vars[yindex]->ref == 1;
	    R -= (int) table->subtables[y].keys - isolated;
	}
	size = cuddSwapInPlace(table,x,y);
	if (size == 0) goto ddSiftingDownOutOfMem;
	move = (Move *) cuddDynamicAllocNode(table);
	if (move == NULL) goto ddSiftingDownOutOfMem;
	move->x = x;
	move->y = y;
	move->size = size;
	move->next = moves;
	moves = move;
	if ((double) size > (double) limitSize * table->maxGrowth) break;
	if (size < limitSize) limitSize = size;
	x = y;
	y = cuddNextHigh(table,x);
    }
    return(moves);

ddSiftingDownOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of ddSiftingDown */


/**
  @brief Given a set of moves, returns the %DD heap to the position
  giving the minimum size.

  @details In case of ties, returns to the closest position giving the
  minimum size.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddSiftingBackward(
  DdManager * table,
  int  size,
  Move * moves)
{
    Move *move;
    int	res;

    for (move = moves; move != NULL; move = move->next) {
	if (move->size < size) {
	    size = move->size;
	}
    }

    for (move = moves; move != NULL; move = move->next) {
	if (move->size == size) return(1);
	res = cuddSwapInPlace(table,(int)move->x,(int)move->y);
	if (!res) return(0);
    }

    return(1);

} /* end of ddSiftingBackward */


/**
  @brief Prepares the %DD heap for dynamic reordering.

  @details Does garbage collection, to guarantee that there are no
  dead nodes; clears the cache, which is invalidated by dynamic
  reordering; initializes the number of isolated projection functions;
  and initializes the interaction matrix.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddReorderPreprocess(
  DdManager * table)
{
    int i;
    int res;

    /* Clear the cache. */
    cuddCacheFlush(table);
    cuddLocalCacheClearAll(table);

    /* Eliminate dead nodes. Do not scan the cache again. */
    cuddGarbageCollect(table,0);

    /* Initialize number of isolated projection functions. */
    table->isolated = 0;
    for (i = 0; i < table->size; i++) {
	if (table->vars[i]->ref == 1) table->isolated++;
    }

    /* Initialize the interaction matrix. */
    res = cuddInitInteract(table);
    if (res == 0) return(0);

    return(1);

} /* end of ddReorderPreprocess */


/**
  @brief Cleans up at the end of reordering.

  @sideeffect None

*/
static int
ddReorderPostprocess(
  DdManager * table)
{

#ifdef DD_VERBOSE
    (void) fflush(table->out);
#endif

    /* Free interaction matrix. */
    FREE(table->interact);

    return(1);

} /* end of ddReorderPostprocess */


/**
  @brief Reorders variables according to a given permutation.

  @details The i-th permutation array contains the index of the
  variable that should be brought to the i-th level. ddShuffle assumes
  that no dead nodes are present and that the interaction matrix is
  properly initialized.  The reordering is achieved by a series of
  upward sifts.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddShuffle(
  DdManager * table,
  int * permutation)
{
    int		index;
    int		level;
    int		position;
    int		numvars;
    int		result;
#ifdef DD_STATS
    unsigned long localTime;
    int		initialSize;
    int		finalSize;
    int		previousSize;
#endif

    table->ddTotalNumberSwapping = 0;
#ifdef DD_STATS
    localTime = util_cpu_time();
    initialSize = table->keys - table->isolated;
    (void) fprintf(table->out,"#:I_SHUFFLE %8d: initial size\n",
		   initialSize);
    table->totalNISwaps = 0;
#endif

    numvars = table->size;

    for (level = 0; level < numvars; level++) {
	index = permutation[level];
	position = table->perm[index];
#ifdef DD_STATS
	previousSize = table->keys - table->isolated;
#endif
	result = ddSiftUp(table,position,level);
	if (!result) return(0);
#ifdef DD_STATS
	if (table->keys < (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"-");
	} else if (table->keys > (unsigned) previousSize + table->isolated) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
    }

#ifdef DD_STATS
    (void) fprintf(table->out,"\n");
    finalSize = table->keys - table->isolated;
    (void) fprintf(table->out,"#:F_SHUFFLE %8d: final size\n",finalSize);
    (void) fprintf(table->out,"#:T_SHUFFLE %8g: total time (sec)\n",
	((double)(util_cpu_time() - localTime)/1000.0));
    (void) fprintf(table->out,"#:N_SHUFFLE %8d: total swaps\n",
		   table->ddTotalNumberSwapping);
    (void) fprintf(table->out,"#:M_SHUFFLE %8d: NI swaps\n",
                   table->totalNISwaps);
#endif

    return(1);

} /* end of ddShuffle */


/**
  @brief Moves one variable up.

  @details Takes a variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.

  @return 1 if successful; 0 otherwise

  @sideeffect None

*/
static int
ddSiftUp(
  DdManager * table,
  int  x,
  int  xLow)
{
    int        y;
    int        size;

    y = cuddNextLow(table,x);
    while (y >= xLow) {
	size = cuddSwapInPlace(table,y,x);
	if (size == 0) {
	    return(0);
	}
	x = y;
	y = cuddNextLow(table,x);
    }
    return(1);

} /* end of ddSiftUp */


/**
  @brief Fixes the %BDD variable group tree after a shuffle.

  @details Assumes that the order of the variables in a terminal node
  has not been changed.

  @sideeffect Changes the %BDD variable group tree.

*/
static void
bddFixTree(
  DdManager * table,
  MtrNode * treenode)
{
    if (treenode == NULL) return;
    treenode->low = ((int) treenode->index < table->size) ?
	(MtrHalfWord) table->perm[treenode->index] : treenode->index;
    if (treenode->child != NULL) {
	bddFixTree(table, treenode->child);
    }
    if (treenode->younger != NULL)
	bddFixTree(table, treenode->younger);
    if (treenode->parent != NULL && treenode->low < treenode->parent->low) {
	treenode->parent->low = treenode->low;
	treenode->parent->index = treenode->index;
    }
    return;

} /* end of bddFixTree */


/**
  @brief Updates the %BDD variable group tree before a shuffle.

  @return 1 if successful; 0 otherwise.

  @sideeffect Changes the %BDD variable group tree.

*/
static int
ddUpdateMtrTree(
  DdManager * table,
  MtrNode * treenode,
  int * perm,
  int * invperm)
{
    unsigned int i, size;
    int index, level, minLevel, maxLevel, minIndex;

    if (treenode == NULL) return(1);

    minLevel = CUDD_MAXINDEX;
    maxLevel = 0;
    minIndex = -1;
    /* i : level */
    for (i = treenode->low; i < treenode->low + treenode->size; i++) {
	index = table->invperm[i];
	level = perm[index];
	if (level < minLevel) {
	    minLevel = level;
	    minIndex = index;
	}
	if (level > maxLevel)
	    maxLevel = level;
    }
    size = maxLevel - minLevel + 1;
    if (minIndex == -1) return(0);
    if (size == treenode->size) {
	treenode->low = minLevel;
	treenode->index = minIndex;
    } else {
	return(0);
    }

    if (treenode->child != NULL) {
	if (!ddUpdateMtrTree(table, treenode->child, perm, invperm))
	    return(0);
    }
    if (treenode->younger != NULL) {
	if (!ddUpdateMtrTree(table, treenode->younger, perm, invperm))
	    return(0);
    }
    return(1);
}


/**
  @brief Checks the %BDD variable group tree before a shuffle.

  @return 1 if successful; 0 otherwise.

  @sideeffect Changes the %BDD variable group tree.

*/
static int
ddCheckPermuation(
  DdManager * table,
  MtrNode * treenode,
  int * perm,
  int * invperm)
{
    unsigned int i, size;
    int index, level, minLevel, maxLevel;

    if (treenode == NULL) return(1);

    minLevel = table->size;
    maxLevel = 0;
    /* i : level */
    for (i = treenode->low; i < treenode->low + treenode->size; i++) {
	index = table->invperm[i];
	level = perm[index];
	if (level < minLevel)
	    minLevel = level;
	if (level > maxLevel)
	    maxLevel = level;
    }
    size = maxLevel - minLevel + 1;
    if (size != treenode->size)
	return(0);

    if (treenode->child != NULL) {
	if (!ddCheckPermuation(table, treenode->child, perm, invperm))
	    return(0);
    }
    if (treenode->younger != NULL) {
	if (!ddCheckPermuation(table, treenode->younger, perm, invperm))
	    return(0);
    }
    return(1);
}

cuddSat.c
45218
/**
  @file

  @ingroup cudd

  @brief Functions for the solution of satisfiability related problems.

  @author Seh-Woong Jeong, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define	DD_BIGGY	100000000

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
   @brief Type of item stored in memoization table.
*/
typedef struct cuddPathPair {
    int	pos;
    int	neg;
} cuddPathPair;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

#define WEIGHT(weight, col)	((weight) == NULL ? 1 : weight[col])

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static enum st_retval freePathPair (void *key, void *value, void *arg);
static cuddPathPair getShortest (DdManager *dd, DdNode *root, int *cost, int *support, st_table *visited);
static DdNode * getPath (DdManager *manager, st_table *visited, DdNode *f, int *weight, int cost);
static cuddPathPair getLargest (DdManager *dd, DdNode *root, st_table *visited);
static DdNode * getCube (DdManager *manager, st_table *visited, DdNode *f, int cost);
static DdNode * ddBddMaximallyExpand(DdManager *dd, DdNode *lb, DdNode *ub, DdNode *f);
static int ddBddShortestPathUnate(DdManager *dd, DdNode *f, int *phases, st_table *table);
static DdNode * ddGetLargestCubeUnate(DdManager *dd, DdNode *f, int *phases, st_table *table);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Returns the value of a %DD for a given variable assignment.

  @details The variable assignment is passed in an array of int's,
  that should specify a zero or a one for each variable in the support
  of the function.

  @return a pointer to a constant node. No new nodes are produced.

  @sideeffect None

  @see Cudd_bddLeq Cudd_addEvalConst

*/
DdNode *
Cudd_Eval(
  DdManager * dd,
  DdNode * f,
  int * inputs)
{
    int comple;
    DdNode *ptr;

    (void) dd; /* avoid warning */
    comple = Cudd_IsComplement(f);
    ptr = Cudd_Regular(f);

    while (!cuddIsConstant(ptr)) {
	if (inputs[ptr->index] == 1) {
	    ptr = cuddT(ptr);
	} else {
	    comple ^= Cudd_IsComplement(cuddE(ptr));
	    ptr = Cudd_Regular(cuddE(ptr));
	}
    }
    return(Cudd_NotCond(ptr,comple));

} /* end of Cudd_Eval */


/**
  @brief Finds a shortest path in a %DD.

  @details f is the %DD we want to get the shortest path for;
  weight\[i\] is the weight of the THEN arc coming from the node whose
  index is i. If weight is NULL, then unit weights are assumed for all
  THEN arcs. All ELSE arcs have 0 weight.  If non-NULL, both weight
  and support should point to arrays with at least as many entries as
  there are variables in the manager.

  @return the shortest path as the %BDD of a cube.

  @sideeffect support contains on return the true support of f.
  If support is NULL on entry, then Cudd_ShortestPath does not compute
  the true support info. length contains the length of the path.

  @see Cudd_ShortestLength Cudd_LargestCube

*/
DdNode *
Cudd_ShortestPath(
  DdManager * manager,
  DdNode * f,
  int * weight,
  int * support,
  int * length)
{
    DdNode	*F;
    st_table	*visited;
    DdNode	*sol;
    cuddPathPair *rootPair;
    int		complement, cost;
    int		i;

    DdNode *one = DD_ONE(manager);
    DdNode *zero = DD_ZERO(manager);

    /* Initialize support. Support does not depend on variable order.
    ** Hence, it does not need to be reinitialized if reordering occurs.
    */
    if (support) {
      for (i = 0; i < manager->size; i++) {
	support[i] = 0;
      }
    }

    if (f == Cudd_Not(one) || f == zero) {
      *length = DD_BIGGY;
      return(Cudd_Not(one));
    }
    /* From this point on, a path exists. */

    do {
	manager->reordered = 0;

	/* Initialize visited table. */
	visited = st_init_table(st_ptrcmp, st_ptrhash);

	/* Now get the length of the shortest path(s) from f to 1. */
	(void) getShortest(manager, f, weight, support, visited);

	complement = Cudd_IsComplement(f);

	F = Cudd_Regular(f);

	if (!st_lookup(visited, F, (void **) &rootPair)) return(NULL);

	if (complement) {
	  cost = rootPair->neg;
	} else {
	  cost = rootPair->pos;
	}

	/* Recover an actual shortest path. */
	sol = getPath(manager,visited,f,weight,cost);

	st_foreach(visited, freePathPair, NULL);
	st_free_table(visited);

    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    *length = cost;
    return(sol);

} /* end of Cudd_ShortestPath */


/**
  @brief Finds a largest cube in a %DD.

  @details f is the %DD we want to get the largest cube for. The
  problem is translated into the one of finding a shortest path in f,
  when both THEN and ELSE arcs are assumed to have unit length. This
  yields a largest cube in the disjoint cover corresponding to the
  %DD. Therefore, it is not necessarily the largest implicant of f.

  @return the largest cube as a %BDD.

  @sideeffect The number of literals of the cube is returned in the location
  pointed by length if it is non-null.

  @see Cudd_ShortestPath

*/
DdNode *
Cudd_LargestCube(
  DdManager * manager,
  DdNode * f,
  int * length)
{
    DdNode	*F;
    st_table	*visited;
    DdNode	*sol;
    cuddPathPair *rootPair;
    int		complement, cost;

    DdNode *one = DD_ONE(manager);
    DdNode *zero = DD_ZERO(manager);

    if (f == Cudd_Not(one) || f == zero) {
	if (length != NULL) {
            *length = DD_BIGGY;
        }
	return(Cudd_Not(one));
    }
    /* From this point on, a path exists. */

    do {
	manager->reordered = 0;

	/* Initialize visited table. */
	visited = st_init_table(st_ptrcmp, st_ptrhash);

	/* Now get the length of the shortest path(s) from f to 1. */
	(void) getLargest(manager, f, visited);

	complement = Cudd_IsComplement(f);

	F = Cudd_Regular(f);

	if (!st_lookup(visited, F, (void **) &rootPair)) return(NULL);

	if (complement) {
	  cost = rootPair->neg;
	} else {
	  cost = rootPair->pos;
	}

	/* Recover an actual shortest path. */
	sol = getCube(manager,visited,f,cost);

	st_foreach(visited, freePathPair, NULL);
	st_free_table(visited);

    } while (manager->reordered == 1);

    if (length != NULL) {
        *length = cost;
    }
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }
    return(sol);

} /* end of Cudd_LargestCube */


/**
  @brief Find the length of the shortest path(s) in a %DD.

  @details f is the %DD we want to get the shortest path for;
  weight\[i\] is the weight of the THEN edge coming from the node
  whose index is i. All ELSE edges have 0 weight.

  @return the length of the shortest path(s) if such a path is found;
  a large number if the function is identically 0, and CUDD_OUT_OF_MEM
  in case of failure.

  @sideeffect None

  @see Cudd_ShortestPath

*/
int
Cudd_ShortestLength(
  DdManager * manager,
  DdNode * f,
  int * weight)
{
    DdNode	*F;
    st_table	*visited;
    cuddPathPair *my_pair;
    int		complement, cost;

    DdNode *one = DD_ONE(manager);
    DdNode *zero = DD_ZERO(manager);

    if (f == Cudd_Not(one) || f == zero) {
	return(DD_BIGGY);
    }

    /* From this point on, a path exists. */
    /* Initialize visited table and support. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);

    /* Now get the length of the shortest path(s) from f to 1. */
    (void) getShortest(manager, f, weight, NULL, visited);

    complement = Cudd_IsComplement(f);

    F = Cudd_Regular(f);

    if (!st_lookup(visited, F, (void **) &my_pair)) return(CUDD_OUT_OF_MEM);
    
    if (complement) {
	cost = my_pair->neg;
    } else {
	cost = my_pair->pos;
    }

    st_foreach(visited, freePathPair, NULL);
    st_free_table(visited);

    return(cost);

} /* end of Cudd_ShortestLength */


/**
  @brief Checks whether a %BDD is negative unate in a
  variable.

  @details Determines whether the function represented by %BDD f is
  negative unate (monotonic decreasing) in variable i.  This function
  does not generate any new nodes.

  @return the constant one is f is unate and the (logical) constant
  zero if it is not.

  @sideeffect None

  @see Cudd_Increasing

*/
DdNode *
Cudd_Decreasing(
  DdManager * dd,
  DdNode * f,
  int  i)
{
    int topf, level;
    DdNode *F, *fv, *fvn, *res;
    DD_CTFP cacheOp;

    statLine(dd);
#ifdef DD_DEBUG
    assert(0 <= i && i < dd->size);
#endif

    F = Cudd_Regular(f);
    topf = cuddI(dd,F->index);

    /* Check terminal case. If topf > i, f does not depend on var.
    ** Therefore, f is unate in i.
    */
    level = (unsigned) dd->perm[i];
    if (topf > level) {
	return(DD_ONE(dd));
    }

    /* From now on, f is not constant. */

    /* Check cache. */
    cacheOp = (DD_CTFP) Cudd_Decreasing;
    res = cuddCacheLookup2(dd,cacheOp,f,dd->vars[i]);
    if (res != NULL) {
	return(res);
    }

    checkWhetherToGiveUp(dd);

    /* Compute cofactors. */
    fv = cuddT(F); fvn = cuddE(F);
    if (F != f) {
	fv = Cudd_Not(fv);
	fvn = Cudd_Not(fvn);
    }

    if (topf == level) {
	/* Special case: if fv is regular, fv(1,...,1) = 1;
	** If in addition fvn is complemented, fvn(1,...,1) = 0.
	** But then f(1,1,...,1) > f(0,1,...,1). Hence f is not
	** monotonic decreasing in i.
	*/
	if (!Cudd_IsComplement(fv) && Cudd_IsComplement(fvn)) {
	    return(Cudd_Not(DD_ONE(dd)));
	}
	res = Cudd_bddLeq(dd,fv,fvn) ? DD_ONE(dd) : Cudd_Not(DD_ONE(dd));
    } else {
	res = Cudd_Decreasing(dd,fv,i);
	if (res == DD_ONE(dd)) {
	    res = Cudd_Decreasing(dd,fvn,i);
	}
    }

    cuddCacheInsert2(dd,cacheOp,f,dd->vars[i],res);
    return(res);

} /* end of Cudd_Decreasing */


/**
  @brief Checks whether a %BDD is positive unate in a variable.

  @details Determines whether the function represented by %BDD f is
  positive unate (monotonic increasing) in variable i. It is based on
  Cudd_Decreasing and the fact that f is monotonic increasing in i if
  and only if its complement is monotonic decreasing in i.

  @sideeffect None

  @see Cudd_Decreasing

*/
DdNode *
Cudd_Increasing(
  DdManager * dd,
  DdNode * f,
  int  i)
{
    return(Cudd_Decreasing(dd,Cudd_Not(f),i));

} /* end of Cudd_Increasing */


/**
  @brief Tells whether F and G are identical wherever D is 0.

  @details F and G are either two ADDs or two BDDs.  D is either a 0-1
  %ADD or a %BDD.  No new nodes are created.

  @return 1 if F and G are equivalent, and 0 otherwise.

  @sideeffect None

  @see Cudd_bddLeqUnless

*/
int
Cudd_EquivDC(
  DdManager * dd,
  DdNode * F,
  DdNode * G,
  DdNode * D)
{
    DdNode *tmp, *One, *Gr, *Dr;
    DdNode *Fv, *Fvn, *Gv, *Gvn, *Dv, *Dvn;
    int res;
    int flevel, glevel, dlevel, top;

    One = DD_ONE(dd);

    statLine(dd);
    /* Check terminal cases. */
    if (D == One || F == G) return(1);
    if (D == Cudd_Not(One) || D == DD_ZERO(dd) || F == Cudd_Not(G)) return(0);

    /* From now on, D is non-constant. */

    /* Normalize call to increase cache efficiency. */
    if (F > G) {
	tmp = F;
	F = G;
	G = tmp;
    }
    if (Cudd_IsComplement(F)) {
	F = Cudd_Not(F);
	G = Cudd_Not(G);
    }

    /* From now on, F is regular. */

    /* Check cache. */
    tmp = cuddCacheLookup(dd,DD_EQUIV_DC_TAG,F,G,D);
    if (tmp != NULL) return(tmp == One);

    /* Find splitting variable. */
    flevel = cuddI(dd,F->index);
    Gr = Cudd_Regular(G);
    glevel = cuddI(dd,Gr->index);
    top = ddMin(flevel,glevel);
    Dr = Cudd_Regular(D);
    dlevel = dd->perm[Dr->index];
    top = ddMin(top,dlevel);

    /* Compute cofactors. */
    if (top == flevel) {
	Fv = cuddT(F);
	Fvn = cuddE(F);
    } else {
	Fv = Fvn = F;
    }
    if (top == glevel) {
	Gv = cuddT(Gr);
	Gvn = cuddE(Gr);
	if (G != Gr) {
	    Gv = Cudd_Not(Gv);
	    Gvn = Cudd_Not(Gvn);
	}
    } else {
	Gv = Gvn = G;
    }
    if (top == dlevel) {
	Dv = cuddT(Dr);
	Dvn = cuddE(Dr);
	if (D != Dr) {
	    Dv = Cudd_Not(Dv);
	    Dvn = Cudd_Not(Dvn);
	}
    } else {
	Dv = Dvn = D;
    }

    /* Solve recursively. */
    res = Cudd_EquivDC(dd,Fv,Gv,Dv);
    if (res != 0) {
	res = Cudd_EquivDC(dd,Fvn,Gvn,Dvn);
    }
    cuddCacheInsert(dd,DD_EQUIV_DC_TAG,F,G,D,(res) ? One : Cudd_Not(One));

    return(res);

} /* end of Cudd_EquivDC */


/**
  @brief Tells whether f is less than of equal to G unless D is 1.

  @details f, g, and D are BDDs.  No new nodes are created.

  @return 1 if f is less than of equal to G, and 0 otherwise.

  @sideeffect None

  @see Cudd_EquivDC Cudd_bddLeq Cudd_bddIteConstant

*/
int
Cudd_bddLeqUnless(
  DdManager *dd,
  DdNode *f,
  DdNode *g,
  DdNode *D)
{
    DdNode *tmp, *One, *F, *G;
    DdNode *Ft, *Fe, *Gt, *Ge, *Dt, *De;
    int res;
    int flevel, glevel, dlevel, top;

    statLine(dd);

    One = DD_ONE(dd);

    /* Check terminal cases. */
    if (f == g || g == One || f == Cudd_Not(One) || D == One ||
	D == f || D == Cudd_Not(g)) return(1);
    /* Check for two-operand cases. */
    if (D == Cudd_Not(One) || D == g || D == Cudd_Not(f))
	return(Cudd_bddLeq(dd,f,g));
    if (g == Cudd_Not(One) || g == Cudd_Not(f)) return(Cudd_bddLeq(dd,f,D));
    if (f == One) return(Cudd_bddLeq(dd,Cudd_Not(g),D));

    /* From now on, f, g, and D are non-constant, distinct, and
    ** non-complementary. */

    /* Normalize call to increase cache efficiency.  We rely on the
    ** fact that f <= g unless D is equivalent to not(g) <= not(f)
    ** unless D and to f <= D unless g.  We make sure that D is
    ** regular, and that at most one of f and g is complemented.  We also
    ** ensure that when two operands can be swapped, the one with the
    ** lowest address comes first. */

    if (Cudd_IsComplement(D)) {
	if (Cudd_IsComplement(g)) {
	    /* Special case: if f is regular and g is complemented,
	    ** f(1,...,1) = 1 > 0 = g(1,...,1).  If D(1,...,1) = 0, return 0.
	    */
	    if (!Cudd_IsComplement(f)) return(0);
	    /* !g <= D unless !f  or  !D <= g unless !f */
	    tmp = D;
	    D = Cudd_Not(f);
	    if (g < tmp) {
		f = Cudd_Not(g);
		g = tmp;
	    } else {
		f = Cudd_Not(tmp);
	    }
	} else {
	    if (Cudd_IsComplement(f)) {
		/* !D <= !f unless g  or  !D <= g unless !f */
		tmp = f;
		f = Cudd_Not(D);
		if (tmp < g) {
		    D = g;
		    g = Cudd_Not(tmp);
		} else {
		    D = Cudd_Not(tmp);
		}
	    } else {
		/* f <= D unless g  or  !D <= !f unless g */
		tmp = D;
		D = g;
		if (tmp < f) {
		    g = Cudd_Not(f);
		    f = Cudd_Not(tmp);
		} else {
		    g = tmp;
		}
	    }
	}
    } else {
	if (Cudd_IsComplement(g)) {
	    if (Cudd_IsComplement(f)) {
		/* !g <= !f unless D  or  !g <= D unless !f */
		tmp = f;
		f = Cudd_Not(g);
		if (D < tmp) {
		    g = D;
		    D = Cudd_Not(tmp);
		} else {
		    g = Cudd_Not(tmp);
		}
	    } else {
		/* f <= g unless D  or  !g <= !f unless D */
		if (g < f) {
		    tmp = g;
		    g = Cudd_Not(f);
		    f = Cudd_Not(tmp);
		}
	    }
	} else {
	    /* f <= g unless D  or  f <= D unless g */
	    if (D < g) {
		tmp = D;
		D = g;
		g = tmp;
	    }
	}
    }

    /* From now on, D is regular. */

    /* Check cache. */
    tmp = cuddCacheLookup(dd,DD_BDD_LEQ_UNLESS_TAG,f,g,D);
    if (tmp != NULL) return(tmp == One);

    /* Find splitting variable. */
    F = Cudd_Regular(f);
    flevel = dd->perm[F->index];
    G = Cudd_Regular(g);
    glevel = dd->perm[G->index];
    top = ddMin(flevel,glevel);
    dlevel = dd->perm[D->index];
    top = ddMin(top,dlevel);

    /* Compute cofactors. */
    if (top == flevel) {
	Ft = cuddT(F);
	Fe = cuddE(F);
	if (F != f) {
	    Ft = Cudd_Not(Ft);
	    Fe = Cudd_Not(Fe);
	}
    } else {
	Ft = Fe = f;
    }
    if (top == glevel) {
	Gt = cuddT(G);
	Ge = cuddE(G);
	if (G != g) {
	    Gt = Cudd_Not(Gt);
	    Ge = Cudd_Not(Ge);
	}
    } else {
	Gt = Ge = g;
    }
    if (top == dlevel) {
	Dt = cuddT(D);
	De = cuddE(D);
    } else {
	Dt = De = D;
    }

    /* Solve recursively. */
    res = Cudd_bddLeqUnless(dd,Ft,Gt,Dt);
    if (res != 0) {
	res = Cudd_bddLeqUnless(dd,Fe,Ge,De);
    }
    cuddCacheInsert(dd,DD_BDD_LEQ_UNLESS_TAG,f,g,D,Cudd_NotCond(One,!res));

    return(res);

} /* end of Cudd_bddLeqUnless */


/**
  @brief Compares two ADDs for equality within tolerance.

  @details Two ADDs are reported to be equal if the maximum difference
  between them (the sup norm of their difference) is less than or
  equal to the tolerance parameter.  If parameter <code>pr</code> is
  positive the first failure is reported to the standard output.

  @return 1 if the two ADDs are equal (within tolerance); 0 otherwise.

  @sideeffect None

*/
int
Cudd_EqualSupNorm(
  DdManager * dd /**< manager */,
  DdNode * f /**< first %ADD */,
  DdNode * g /**< second %ADD */,
  CUDD_VALUE_TYPE  tolerance /**< maximum allowed difference */,
  int  pr /**< verbosity level */)
{
    DdNode *fv, *fvn, *gv, *gvn, *r;
    int topf, topg;

    statLine(dd);
    /* Check terminal cases. */
    if (f == g) return(1);
    if (cuddIsConstant(f) && cuddIsConstant(g)) {
	if (ddEqualVal(cuddV(f),cuddV(g),tolerance)) {
	    return(1);
	} else {
	    if (pr>0) {
		(void) fprintf(dd->out,"Offending nodes:\n");
		(void) fprintf(dd->out,
			       "f: address = %p\t value = %40.30f\n",
			       (void *) f, cuddV(f));
		(void) fprintf(dd->out,
			       "g: address = %p\t value = %40.30f\n",
			       (void *) g, cuddV(g));
	    }
	    return(0);
	}
    }

    /* We only insert the result in the cache if the comparison is
    ** successful. Therefore, if we hit we return 1. */
    r = cuddCacheLookup2(dd,(DD_CTFP)Cudd_EqualSupNorm,f,g);
    if (r != NULL) {
	return(1);
    }

    /* Compute the cofactors and solve the recursive subproblems. */
    topf = cuddI(dd,f->index);
    topg = cuddI(dd,g->index);

    if (topf <= topg) {fv = cuddT(f); fvn = cuddE(f);} else {fv = fvn = f;}
    if (topg <= topf) {gv = cuddT(g); gvn = cuddE(g);} else {gv = gvn = g;}

    if (!Cudd_EqualSupNorm(dd,fv,gv,tolerance,pr)) return(0);
    if (!Cudd_EqualSupNorm(dd,fvn,gvn,tolerance,pr)) return(0);

    cuddCacheInsert2(dd,(DD_CTFP)Cudd_EqualSupNorm,f,g,DD_ONE(dd));

    return(1);

} /* end of Cudd_EqualSupNorm */


/**
  @brief Expands cube to a prime implicant of f.

  @return the prime if successful; NULL otherwise.  In particular,
  NULL is returned if cube is not a real cube or is not an implicant
  of f.

  @sideeffect None

  @see Cudd_bddMaximallyExpand

*/
DdNode *
Cudd_bddMakePrime(
  DdManager *dd /**< manager */,
  DdNode *cube /**< cube to be expanded */,
  DdNode *f /**< function of which the cube is to be made a prime */)
{
    DdNode *res;

    if (!Cudd_bddLeq(dd,cube,f)) return(NULL);

    do {
	dd->reordered = 0;
	res = cuddBddMakePrime(dd,cube,f);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddMakePrime */


/**
  @brief Expands lb to prime implicants of (f and ub).

  @details Expands lb to all prime implicants of (f and ub) that
  contain lb.  Assumes that lb is contained in ub.

  @return the disjunction of the primes if lb is contained in f;
  returns the zero %BDD if lb is not contained in f; returns NULL in
  case of failure.  In particular, NULL is returned if cube is not a
  real cube or is not an implicant of f.  Returning the disjunction of
  all prime implicants works because the resulting function is unate.

  @sideeffect None

  @see Cudd_bddMakePrime

*/
DdNode *
Cudd_bddMaximallyExpand(
  DdManager *dd /**< manager */,
  DdNode *lb /**< cube to be expanded */,
  DdNode *ub /**< upper bound cube */,
  DdNode *f /**< function against which to expand */)
{
    DdNode *res;

    if (!Cudd_bddLeq(dd,lb,ub)) return(NULL);

    do {
	dd->reordered = 0;
	res = ddBddMaximallyExpand(dd,lb,ub,f);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddMaximallyExpand */


/**
  @brief Find a largest prime implicant of a unate function.

  @details The behavior is undefined if f is not unate.  The third
  argument is used to determine whether f is unate positive
  (increasing) or negative (decreasing) in each of the variables in
  its support.

  @return the %BDD for the prime if succesful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddMaximallyExpand

*/
DdNode *
Cudd_bddLargestPrimeUnate(
  DdManager *dd /**< manager */,
  DdNode *f /**< unate function */,
  DdNode *phaseBdd /**< cube of the phases */)
{
    DdNode *res;
    int *phases;
    int retval;
    st_table *table;

    /* Extract phase vector for quick access. */
    phases = ALLOC(int, dd->size);
    if (phases == NULL) return(NULL);
    retval = Cudd_BddToCubeArray(dd, phaseBdd, phases);
    if (retval == 0) {
        FREE(phases);
        return(NULL);
    }
    do {
        dd->reordered = 0;
        table = st_init_table(st_ptrcmp,st_ptrhash);
        if (table == NULL) {
            FREE(phases);
            return(NULL);
        }
	(void) ddBddShortestPathUnate(dd, f, phases, table);
        res = ddGetLargestCubeUnate(dd, f, phases, table);
        st_free_table(table);
    } while (dd->reordered == 1);

    FREE(phases);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddLargestPrimeUnate */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_bddMakePrime.

  @return the prime if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
cuddBddMakePrime(
  DdManager *dd /**< manager */,
  DdNode *cube /**< cube to be expanded */,
  DdNode *f /**< function of which the cube is to be made a prime */)
{
    DdNode *scan;
    DdNode *t, *e;
    DdNode *res = cube;
    DdNode *lzero = Cudd_Not(DD_ONE(dd));

    Cudd_Ref(res);
    scan = cube;
    while (!Cudd_IsConstantInt(scan)) {
	DdNode *reg = Cudd_Regular(scan);
	DdNode *var = dd->vars[reg->index];
	DdNode *expanded = Cudd_bddExistAbstract(dd,res,var);
	if (expanded == NULL) {
            Cudd_RecursiveDeref(dd,res);
	    return(NULL);
	}
	Cudd_Ref(expanded);
	if (Cudd_bddLeq(dd,expanded,f)) {
	    Cudd_RecursiveDeref(dd,res);
	    res = expanded;
	} else {
	    Cudd_RecursiveDeref(dd,expanded);
	}
	cuddGetBranches(scan,&t,&e);
	if (t == lzero) {
	    scan = e;
	} else if (e == lzero) {
	    scan = t;
	} else {
	    Cudd_RecursiveDeref(dd,res);
	    return(NULL);	/* cube is not a cube */
	}
    }

    if (scan == DD_ONE(dd)) {
	Cudd_Deref(res);
	return(res);
    } else {
	Cudd_RecursiveDeref(dd,res);
	return(NULL);
    }

} /* end of cuddBddMakePrime */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Frees the entries of the visited symbol table.

  @return ST_CONTINUE.

  @sideeffect None

*/
static enum st_retval
freePathPair(
  void * key,
  void * value,
  void * arg)
{
    cuddPathPair *pair = (cuddPathPair *) value;

    (void) key; /* avoid warning */
    (void) arg; /* avoid warning */
    FREE(pair);
    return(ST_CONTINUE);

} /* end of freePathPair */


/**
  @brief Finds the length of the shortest path(s) in a %DD.

  @details Uses a local symbol table to store the lengths for each
  node. Only the lengths for the regular nodes are entered in the
  table, because those for the complement nodes are simply obtained by
  swapping the two lenghts.

  @return a pair of lengths: the length of the shortest path to 1; and
  the length of the shortest path to 0. This is done so as to take
  complement arcs into account.

  @sideeffect Accumulates the support of the %DD in support.

*/
static cuddPathPair
getShortest(
  DdManager * dd,
  DdNode * root,
  int * cost,
  int * support,
  st_table * visited)
{
    cuddPathPair *my_pair, res_pair, pair_T, pair_E;
    DdNode	*my_root, *T, *E;
    int		weight;
    DdNode	*zero = DD_ZERO(dd);

    my_root = Cudd_Regular(root);

    if (st_lookup(visited, my_root, (void **) &my_pair)) {
	if (Cudd_IsComplement(root)) {
	    res_pair.pos = my_pair->neg;
	    res_pair.neg = my_pair->pos;
	} else {
	    res_pair.pos = my_pair->pos;
	    res_pair.neg = my_pair->neg;
	}
	return(res_pair);
    }

    /* In the case of a BDD the following test is equivalent to
    ** testing whether the BDD is the constant 1. This formulation,
    ** however, works for ADDs as well, by assuming the usual
    ** dichotomy of 0 and != 0.
    */
    if (cuddIsConstant(my_root)) {
	if (my_root != zero) {
	    res_pair.pos = 0;
	    res_pair.neg = DD_BIGGY;
	} else {
	    res_pair.pos = DD_BIGGY;
	    res_pair.neg = 0;
	}
    } else {
	T = cuddT(my_root);
	E = cuddE(my_root);

	pair_T = getShortest(dd, T, cost, support, visited);
	pair_E = getShortest(dd, E, cost, support, visited);
	weight = WEIGHT(cost, my_root->index);
	res_pair.pos = ddMin(pair_T.pos+weight, pair_E.pos);
	res_pair.neg = ddMin(pair_T.neg+weight, pair_E.neg);

	/* Update support. */
	if (support != NULL) {
	    support[my_root->index] = 1;
	}
    }

    my_pair = ALLOC(cuddPathPair, 1);
    if (my_pair == NULL) {
	if (Cudd_IsComplement(root)) {
	    int tmp = res_pair.pos;
	    res_pair.pos = res_pair.neg;
	    res_pair.neg = tmp;
	}
	return(res_pair);
    }
    my_pair->pos = res_pair.pos;
    my_pair->neg = res_pair.neg;

    st_insert(visited, my_root, my_pair);
    if (Cudd_IsComplement(root)) {
	res_pair.pos = my_pair->neg;
	res_pair.neg = my_pair->pos;
    } else {
	res_pair.pos = my_pair->pos;
	res_pair.neg = my_pair->neg;
    }
    return(res_pair);

} /* end of getShortest */


/**
  @brief Build a %BDD for a shortest path of f.

  @details Given the minimum length from the root, and the minimum
  lengths for each node (in visited), apply triangulation at each
  node.  Of the two children of each node on a shortest path, at least
  one is on a shortest path. In case of ties the procedure chooses the
  THEN children.

  @return a pointer to the cube %BDD representing the path if
  successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
getPath(
  DdManager * manager,
  st_table * visited,
  DdNode * f,
  int * weight,
  int  cost)
{
    DdNode	*sol, *tmp;
    DdNode	*my_dd, *T, *E;
    cuddPathPair *T_pair, *E_pair;
    int		Tcost, Ecost;
    int		complement;

    my_dd = Cudd_Regular(f);
    complement = Cudd_IsComplement(f);

    sol = DD_ONE(manager);
    cuddRef(sol);

    while (!cuddIsConstant(my_dd)) {
	Tcost = cost - WEIGHT(weight, my_dd->index);
	Ecost = cost;

	T = cuddT(my_dd);
	E = cuddE(my_dd);

	if (complement) {T = Cudd_Not(T); E = Cudd_Not(E);}

	st_lookup(visited, Cudd_Regular(T), (void **) &T_pair);
	if ((Cudd_IsComplement(T) && T_pair->neg == Tcost) ||
	(!Cudd_IsComplement(T) && T_pair->pos == Tcost)) {
	    tmp = cuddBddAndRecur(manager,manager->vars[my_dd->index],sol);
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(manager,sol);
		return(NULL);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(manager,sol);
	    sol = tmp;

	    complement =  Cudd_IsComplement(T);
	    my_dd = Cudd_Regular(T);
	    cost = Tcost;
	    continue;
	}
	st_lookup(visited, Cudd_Regular(E), (void **) &E_pair);
	if ((Cudd_IsComplement(E) && E_pair->neg == Ecost) ||
	(!Cudd_IsComplement(E) && E_pair->pos == Ecost)) {
	    tmp = cuddBddAndRecur(manager,Cudd_Not(manager->vars[my_dd->index]),sol);
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(manager,sol);
		return(NULL);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(manager,sol);
	    sol = tmp;
	    complement = Cudd_IsComplement(E);
	    my_dd = Cudd_Regular(E);
	    cost = Ecost;
	    continue;
	}
	(void) fprintf(manager->err,"We shouldn't be here!!\n");
	manager->errorCode = CUDD_INTERNAL_ERROR;
	return(NULL);
    }

    cuddDeref(sol);
    return(sol);

} /* end of getPath */


/**
  @brief Finds the size of the largest cube(s) in a %DD.

  @details This problem is translated into finding the shortest paths
  from a node when both THEN and ELSE arcs have unit lengths.  Uses a
  local symbol table to store the lengths for each node. Only the
  lengths for the regular nodes are entered in the table, because
  those for the complement nodes are simply obtained by swapping the
  two lenghts.

  @return a pair of lengths: the length of the shortest path to 1; and
  the length of the shortest path to 0. This is done so as to take
  complement arcs into account.

  @sideeffect none

*/
static cuddPathPair
getLargest(
  DdManager * dd,
  DdNode * root,
  st_table * visited)
{
    cuddPathPair *my_pair, res_pair, pair_T, pair_E;
    DdNode	*my_root, *T, *E;
    DdNode	*zero = DD_ZERO(dd);

    my_root = Cudd_Regular(root);

    if (st_lookup(visited, my_root, (void **) &my_pair)) {
	if (Cudd_IsComplement(root)) {
	    res_pair.pos = my_pair->neg;
	    res_pair.neg = my_pair->pos;
	} else {
	    res_pair.pos = my_pair->pos;
	    res_pair.neg = my_pair->neg;
	}
	return(res_pair);
    }

    /* In the case of a BDD the following test is equivalent to
    ** testing whether the BDD is the constant 1. This formulation,
    ** however, works for ADDs as well, by assuming the usual
    ** dichotomy of 0 and != 0.
    */
    if (cuddIsConstant(my_root)) {
	if (my_root != zero) {
	    res_pair.pos = 0;
	    res_pair.neg = DD_BIGGY;
	} else {
	    res_pair.pos = DD_BIGGY;
	    res_pair.neg = 0;
	}
    } else {
	T = cuddT(my_root);
	E = cuddE(my_root);

	pair_T = getLargest(dd, T, visited);
	pair_E = getLargest(dd, E, visited);
	res_pair.pos = ddMin(pair_T.pos, pair_E.pos) + 1;
	res_pair.neg = ddMin(pair_T.neg, pair_E.neg) + 1;
    }

    my_pair = ALLOC(cuddPathPair, 1);
    if (my_pair == NULL) {	/* simply do not cache this result */
	if (Cudd_IsComplement(root)) {
	    int tmp = res_pair.pos;
	    res_pair.pos = res_pair.neg;
	    res_pair.neg = tmp;
	}
	return(res_pair);
    }
    my_pair->pos = res_pair.pos;
    my_pair->neg = res_pair.neg;

    /* Caching may fail without affecting correctness. */
    st_insert(visited, my_root, my_pair);
    if (Cudd_IsComplement(root)) {
	res_pair.pos = my_pair->neg;
	res_pair.neg = my_pair->pos;
    } else {
	res_pair.pos = my_pair->pos;
	res_pair.neg = my_pair->neg;
    }
    return(res_pair);

} /* end of getLargest */


/**
  @brief Build a %BDD for a largest cube of f.

  @details Given the minimum length from the root, and the minimum
  lengths for each node (in visited), apply triangulation at each
  node.  Of the two children of each node on a shortest path, at least
  one is on a shortest path. In case of ties the procedure chooses the
  THEN children.

  @return a pointer to the cube %BDD representing the path if
  successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
getCube(
  DdManager * manager,
  st_table * visited,
  DdNode * f,
  int  cost)
{
    DdNode	*sol, *tmp;
    DdNode	*my_dd, *T, *E;
    cuddPathPair *T_pair, *E_pair;
    int		Tcost, Ecost;
    int		complement;

    my_dd = Cudd_Regular(f);
    complement = Cudd_IsComplement(f);

    sol = DD_ONE(manager);
    cuddRef(sol);

    while (!cuddIsConstant(my_dd)) {
	Tcost = cost - 1;
	Ecost = cost - 1;

	T = cuddT(my_dd);
	E = cuddE(my_dd);

	if (complement) {T = Cudd_Not(T); E = Cudd_Not(E);}

	if (!st_lookup(visited, Cudd_Regular(T), (void **)&T_pair)) return(NULL);
	if ((Cudd_IsComplement(T) && T_pair->neg == Tcost) ||
	(!Cudd_IsComplement(T) && T_pair->pos == Tcost)) {
	    tmp = cuddBddAndRecur(manager,manager->vars[my_dd->index],sol);
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(manager,sol);
		return(NULL);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(manager,sol);
	    sol = tmp;

	    complement =  Cudd_IsComplement(T);
	    my_dd = Cudd_Regular(T);
	    cost = Tcost;
	    continue;
	}
	if (!st_lookup(visited, Cudd_Regular(E), (void **)&E_pair)) return(NULL);
	if ((Cudd_IsComplement(E) && E_pair->neg == Ecost) ||
	(!Cudd_IsComplement(E) && E_pair->pos == Ecost)) {
	    tmp = cuddBddAndRecur(manager,Cudd_Not(manager->vars[my_dd->index]),sol);
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(manager,sol);
		return(NULL);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(manager,sol);
	    sol = tmp;
	    complement = Cudd_IsComplement(E);
	    my_dd = Cudd_Regular(E);
	    cost = Ecost;
	    continue;
	}
	(void) fprintf(manager->err,"We shouldn't be here!\n");
	manager->errorCode = CUDD_INTERNAL_ERROR;
	return(NULL);
    }

    cuddDeref(sol);
    return(sol);

} /* end of getCube */


/**
  @brief Performs the recursive step of Cudd_bddMaximallyExpand.

  @details On entry to this function, ub and lb should be different
  from the zero %BDD.  The function then maintains this invariant.

  @return set of primes or zero %BDD if successful; NULL otherwise.

  @sideeffect None

*/
static DdNode *
ddBddMaximallyExpand(
  DdManager *dd /**< manager */,
  DdNode *lb /**< cube to be expanded */,
  DdNode *ub /**< upper bound cube */,
  DdNode *f /**< function against which to expand */)
{
    DdNode *lone, *lzero, *lbv, *lbvn, *lbnx, *ubv, *ubvn, *fv, *fvn, *res;
    DdNode *F, *UB, *LB, *t, *e;
    int top, toplb, topub, topf;
    unsigned int index;

    statLine(dd);
    /* Terminal cases. */
    lone = DD_ONE(dd);
    lzero = Cudd_Not(lone);
    assert(ub != lzero && lb != lzero);
    /** There are three major terminal cases in theory:
     **   ub -> f     : return ub
     **   lb == f     : return lb
     **   not(lb -> f): return zero
     ** Only the second case can be checked exactly in constant time.
     ** For the others, we check for sufficient conditions.
     */
    if (ub == f || f == lone) return(ub);
    if (lb == f) return(lb);
    if (f == lzero || ub == Cudd_Not(f) || lb == lone || lb == Cudd_Not(f))
        return(lzero);
    if (!Cudd_IsComplement(lb) && Cudd_IsComplement(f)) return(lzero);

    /* Here lb and f are not constant. */

    /* Check cache.  Since lb and ub are cubes, their local reference counts
    ** are always 1.  Hence, we only check the reference count of f.
    */
    F = Cudd_Regular(f);
    if (F->ref != 1) {
        DdNode *tmp = cuddCacheLookup(dd, DD_BDD_MAX_EXP_TAG, lb, ub, f);
        if (tmp != NULL) {
            return(tmp);
        }
    }

    checkWhetherToGiveUp(dd);

    /* Compute cofactors.  For lb we use the non-zero one in
    ** both branches of the recursion.
    */
    LB = Cudd_Regular(lb);
    UB = Cudd_Regular(ub);
    topf = dd->perm[F->index];
    toplb = dd->perm[LB->index];
    topub = (ub == lone) ? CUDD_CONST_INDEX : (unsigned int) dd->perm[UB->index];
    assert(toplb <= topub);
    top = ddMin(topf,toplb);
    if (toplb == top) {
	index = LB->index;
        lbv = cuddT(LB);
        lbvn = cuddE(LB);
        if (lb != LB) {
            lbv = Cudd_Not(lbv);
            lbvn = Cudd_Not(lbvn);
        }
        if (lbv == lzero) {
            lbnx = lbvn;
        } else {
            lbnx = lbv;
        }
    } else {
	index = F->index;
        lbnx = lbv = lbvn = lb;
    }
    if (topub == top) {
        ubv = cuddT(UB);
        ubvn = cuddE(UB);
        if (ub != UB) {
            ubv = Cudd_Not(ubv);
            ubvn = Cudd_Not(ubvn);
        }
    } else {
        ubv = ubvn = ub;
    }
    if (topf == top) {
        fv = cuddT(F);
        fvn = cuddE(F);
        if (f != F) {
            fv = Cudd_Not(fv);
            fvn = Cudd_Not(fvn);
        }
    } else {
        fv = fvn = f;
    }

    /* Recursive calls. */
    if (ubv != lzero) {
        t = ddBddMaximallyExpand(dd, lbnx, ubv, fv);
        if (t == NULL) return(NULL);
    } else {
        assert(topub == toplb && topub == top && lbv == lzero);
        t = lzero;
    }
    cuddRef(t);

    /* If the top variable appears only in lb, the positive and negative
    ** cofactors of each operand are the same.  We want to avoid a
    ** needless recursive call, which would force us to give up the
    ** cache optimization trick based on reference counts.
    */
    if (ubv == ubvn && fv == fvn) {
        res = t;
    } else {
        if (ubvn != lzero) {
            e = ddBddMaximallyExpand(dd, lbnx, ubvn, fvn);
            if (e == NULL) {
                Cudd_IterDerefBdd(dd,t);
                return(NULL);
            }
        } else {
            assert(topub == toplb && topub == top && lbvn == lzero);
            e = lzero;
        }

        if (t == e) {
            res = t;
        } else {
            cuddRef(e);

            if (toplb == top) {
                if (lbv == lzero) {
                    /* Top variable appears in negative phase. */
                    if (t != lone) {
                        DdNode *newT;
                        if (Cudd_IsComplement(t)) {
                            newT = cuddUniqueInter(dd, index, Cudd_Not(t), lzero);
                            if (newT == NULL) {
                                Cudd_IterDerefBdd(dd,t);
                                Cudd_IterDerefBdd(dd,e);
                                return(NULL);
                            }
                            newT = Cudd_Not(newT);
                        } else {
                            newT = cuddUniqueInter(dd, index, t, lone);
                            if (newT == NULL) {
                                Cudd_IterDerefBdd(dd,t);
                                Cudd_IterDerefBdd(dd,e);
                                return(NULL);
                            }
                        }
                        cuddRef(newT);
                        cuddDeref(t);
                        t = newT;
                    }
                } else if (lbvn == lzero) {
                    /* Top variable appears in positive phase. */
                    if (e != lone) {
                        DdNode *newE;
                        newE = cuddUniqueInter(dd, index, lone, e);
                        if (newE == NULL) {
                            Cudd_IterDerefBdd(dd,t);
                            Cudd_IterDerefBdd(dd,e);
                            return(NULL);
                        }
                        cuddRef(newE);
                        cuddDeref(e);
                        e = newE;
                    }
                } else {
                    /* Not a cube. */
                    Cudd_IterDerefBdd(dd,t);
                    Cudd_IterDerefBdd(dd,e);
                    return(NULL);
                }
            }

            /* Combine results. */
            res = cuddBddAndRecur(dd, t, e);
            if (res == NULL) {
                Cudd_IterDerefBdd(dd,t);
                Cudd_IterDerefBdd(dd,e);
                return(NULL);
            }
            cuddRef(res);
            Cudd_IterDerefBdd(dd,t);
            Cudd_IterDerefBdd(dd,e);
        }
    }

    /* Cache result and return. */
    if (F->ref != 1) {
        cuddCacheInsert(dd, DD_BDD_MAX_EXP_TAG, lb, ub, f, res);
    }
    cuddDeref(res);
    return(res);

} /* end of ddBddMaximallyExpand */


/**
  @brief Performs shortest path computation on a unate function.

  @details This function is based on the observation that in the %BDD
  of a unate function no node except the constant is reachable from
  the root via paths of different parity.

  @return the length of the shortest path to one if successful;
  CUDD_OUT_OF_MEM otherwise.

  @sideeffect None

  @see getShortest

*/
static int
ddBddShortestPathUnate(
  DdManager *dd,
  DdNode *f,
  int *phases,
  st_table *table)
{
    int positive, l, lT, lE;
    DdNode *lone = DD_ONE(dd);
    DdNode *lzero = Cudd_Not(lone);
    DdNode *F, *fv, *fvn;

    if (st_lookup_int(table, f, &l)) {
        return(l);
    }
    if (f == lone) {
        l = 0;
    } else if (f == lzero) {
        l = DD_BIGGY;
    } else {
        F = Cudd_Regular(f);
        fv = cuddT(F);
        fvn = cuddE(F);
        if (f != F) {
            fv = Cudd_Not(fv);
            fvn = Cudd_Not(fvn);
        }
        lT = ddBddShortestPathUnate(dd, fv, phases, table);
        lE = ddBddShortestPathUnate(dd, fvn, phases, table);
        positive = phases[F->index];
        l = positive ? ddMin(lT+1, lE) : ddMin(lT, lE+1);
    }
    if (st_insert(table, f, (void *)(ptrint) l) == ST_OUT_OF_MEM) {
        return(CUDD_OUT_OF_MEM);
    }
    return(l);

} /* end of ddShortestPathUnate */


/**
  @brief Extracts largest prime of a unate function.

  @return the %BDD of the prime if successful; NULL otherwise.

  @sideeffect None

  @see getPath

*/
static DdNode *
ddGetLargestCubeUnate(
  DdManager *dd,
  DdNode *f,
  int *phases,
  st_table *table)
{
    DdNode *res, *scan;
    int cost;

    res = DD_ONE(dd);
    cuddRef(res);
    scan = f;
    st_lookup_int(table, scan, &cost);

    while (!Cudd_IsConstantInt(scan)) {
        int Pcost, Ncost, Tcost;
        DdNode *tmp, *T, *E;
        DdNode *rscan = Cudd_Regular(scan);
        unsigned int index = rscan->index;
        assert(phases[index] == 0 || phases[index] == 1);
        int positive = phases[index] == 1;
        Pcost = positive ? cost - 1 : cost;
        Ncost = positive ? cost : cost - 1;
        T = cuddT(rscan);
        E = cuddE(rscan);
        if (rscan != scan) {
            T = Cudd_Not(T);
            E = Cudd_Not(E);
        }
        tmp = res;
        st_lookup_int(table, T, &Tcost);
        if (Tcost == Pcost) {
            cost = Pcost;
            scan = T;
            if (positive) {
                tmp = cuddBddAndRecur(dd, dd->vars[index], res);
            }
        } else {
            cost = Ncost;
            scan = E;
            if (!positive) {
                tmp = cuddBddAndRecur(dd, Cudd_Not(dd->vars[index]), res);
            }
        }
        if (tmp == NULL) {
            Cudd_IterDerefBdd(dd, res);
            return(NULL);
        }
        cuddRef(tmp);
        Cudd_IterDerefBdd(dd, res);
        res = tmp;
    }

    cuddDeref(res);
    return(res);

} /* end of ddGetLargestCubeUnate */

cuddSign.c
9094
/**
  @file

  @ingroup cudd

  @brief Computation of signatures.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static double * ddCofMintermAux (DdManager *dd, DdNode *node, st_table *table);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Computes the fraction of minterms in the on-set of all the
  positive cofactors of a %BDD or %ADD.

  @details The array has as many positions as there are %BDD variables
  in the manager plus one. The last position of the array contains the
  fraction of the minterms in the ON-set of the function represented
  by the %BDD or %ADD. The other positions of the array hold the
  variable signatures.

  @return the pointer to an array of doubles if successful; NULL
  otherwise.

  @sideeffect None

*/
double *
Cudd_CofMinterm(
  DdManager * dd,
  DdNode * node)
{
    st_table	*table;
    double	*values;
    double	*result = NULL;
    int		i, firstLevel;
    int		size;

#ifdef DD_STATS
    unsigned long startTime;
    startTime = util_cpu_time();
    dd->num_calls = 0;
#endif

    table = st_init_table(st_ptrcmp, st_ptrhash);
    if (table == NULL) {
	(void) fprintf(dd->err,
		       "out-of-memory, couldn't measure DD cofactors.\n");
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    size = dd->size;
    values = ddCofMintermAux(dd, node, table);
    if (values != NULL) {
	result = ALLOC(double,size + 1);
	if (result != NULL) {
	    if (Cudd_IsConstantInt(node))
		firstLevel = 1;
	    else
		firstLevel = cuddI(dd,Cudd_Regular(node)->index);
	    for (i = 0; i < size; i++) {
		if (i >= cuddI(dd,Cudd_Regular(node)->index)) {
		    result[dd->invperm[i]] = values[i - firstLevel];
		} else {
		    result[dd->invperm[i]] = values[size - firstLevel];
		}
	    }
	    result[size] = values[size - firstLevel];
	} else {
	    dd->errorCode = CUDD_MEMORY_OUT;
	}
    }

    if (Cudd_Regular(node)->ref == 1) FREE(values);
    st_foreach(table, cuddStCountfree, NULL);
    st_free_table(table);
#ifdef DD_STATS
    (void) fprintf(dd->out,"Number of calls: %d\n", dd->num_calls);
    (void) fprintf(dd->out,"Time to compute measures: %s\n",
		  util_print_time(util_cpu_time() - startTime));
#endif
    if (result == NULL) {
	(void) fprintf(dd->out,
		       "out-of-memory, couldn't measure DD cofactors.\n");
	dd->errorCode = CUDD_MEMORY_OUT;
    }
    return(result);

} /* end of Cudd_CofMinterm */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Recursive Step for Cudd_CofMinterm function.

  @details Traverses the %DD node and computes the fraction of minterms
  in the on-set of all positive cofactors simultaneously.  It
  allocates an array with two more entries than there are variables
  below the one labeling the node.  One extra entry (the first in the
  array) is for the variable labeling the node. The other entry (the
  last one in the array) holds the fraction of minterms of the
  function rooted at node.  Each other entry holds the value for one
  cofactor. The array is put in a symbol table, to avoid repeated
  computation, and its address is returned by the procedure, for use
  by the caller.

  @return a pointer to the array of cofactor measures.

  @sideeffect None

*/
static double *
ddCofMintermAux(
  DdManager * dd,
  DdNode * node,
  st_table * table)
{
    DdNode	*N;		/* regular version of node */
    DdNode	*Nv, *Nnv;
    double	*values;
    double	*valuesT, *valuesE;
    int		i;
    int		localSize, localSizeT, localSizeE;
    double	vT, vE;
    int		size = dd->size;

    statLine(dd);
#ifdef DD_STATS
    dd->num_calls++;
#endif

    if (st_lookup(table, node, (void **) &values)) {
	return(values);
    }

    N = Cudd_Regular(node);
    if (cuddIsConstant(N)) {
	localSize = 1;
    } else {
	localSize = size - cuddI(dd,N->index) + 1;
    }
    values = ALLOC(double, localSize);
    if (values == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    if (cuddIsConstant(N)) {
	if (node == DD_ZERO(dd) || node == Cudd_Not(DD_ONE(dd))) {
	    values[0] = 0.0;
	} else {
	    values[0] = 1.0;
	}
    } else {
	Nv = Cudd_NotCond(cuddT(N),N!=node);
	Nnv = Cudd_NotCond(cuddE(N),N!=node);

	valuesT = ddCofMintermAux(dd, Nv, table);
	if (valuesT == NULL) return(NULL);
	valuesE = ddCofMintermAux(dd, Nnv, table);
	if (valuesE == NULL) return(NULL);

	if (Cudd_IsConstantInt(Nv)) {
	    localSizeT = 1;
	} else {
	    localSizeT = size - cuddI(dd,Cudd_Regular(Nv)->index) + 1;
	}
	if (Cudd_IsConstantInt(Nnv)) {
	    localSizeE = 1;
	} else {
	    localSizeE = size - cuddI(dd,Cudd_Regular(Nnv)->index) + 1;
	}
	values[0] = valuesT[localSizeT - 1];
	for (i = 1; i < localSize; i++) {
	    if (i >= cuddI(dd,Cudd_Regular(Nv)->index) - cuddI(dd,N->index)) {
		vT = valuesT[i - cuddI(dd,Cudd_Regular(Nv)->index) +
			    cuddI(dd,N->index)];
	    } else {
		vT = valuesT[localSizeT - 1];
	    }
	    if (i >= cuddI(dd,Cudd_Regular(Nnv)->index) - cuddI(dd,N->index)) {
		vE = valuesE[i - cuddI(dd,Cudd_Regular(Nnv)->index) +
			    cuddI(dd,N->index)];
	    } else {
		vE = valuesE[localSizeE - 1];
	    }
	    values[i] = (vT + vE) / 2.0;
	}
	if (Cudd_Regular(Nv)->ref == 1) FREE(valuesT);
	if (Cudd_Regular(Nnv)->ref == 1) FREE(valuesE);
    }

    if (N->ref > 1) {
	if (st_add_direct(table, node, values) == ST_OUT_OF_MEM) {
	    FREE(values);
	    return(NULL);
	}
    }
    return(values);

} /* end of ddCofMintermAux */

cuddSolve.c
9722
/**
  @file

  @ingroup cudd

  @brief Boolean equation solver and related functions.

  @author Balakrishna Kumthekar

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Structure declarations                                                    */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the solution of F(x,y) = 0.

  @details The return value is the consistency condition. The y
  variables are the unknowns and the remaining variables are the
  parameters.  Cudd_SolveEqn allocates an array and fills it with the
  indices of the unknowns. This array is used by Cudd_VerifySol.

  @return the consistency condition if successful; NULL otherwise.

  @sideeffect The solution is returned in G; the indices of the y
  variables are returned in yIndex.

  @see Cudd_VerifySol

*/
DdNode *
Cudd_SolveEqn(
  DdManager *  bdd /**< CUDD manager */,
  DdNode * F /**< the left-hand side of the equation */,
  DdNode * Y /**< the cube of the y variables */,
  DdNode ** G /**< the array of solutions (return parameter) */,
  int ** yIndex /**< index of y variables */,
  int  n /**< numbers of unknowns */)
{
    DdNode *res;
    int *temp;

    *yIndex = temp = ALLOC(int, n);
    if (temp == NULL) {
	bdd->errorCode = CUDD_MEMORY_OUT;
	(void) fprintf(bdd->out,
		       "Cudd_SolveEqn: Out of memory for yIndex\n");
	return(NULL);
    }

    do {
	bdd->reordered = 0;
	res = cuddSolveEqnRecur(bdd, F, Y, G, n, temp, 0);
    } while (bdd->reordered == 1);
    if (bdd->errorCode == CUDD_TIMEOUT_EXPIRED && bdd->timeoutHandler) {
        bdd->timeoutHandler(bdd, bdd->tohArg);
    }

    return(res);

} /* end of Cudd_SolveEqn */


/**
  @brief Checks the solution of F(x,y) = 0.

  @details This procedure substitutes the solution components for the
  unknowns of F and returns the resulting %BDD for F.

  @sideeffect Frees the memory pointed by yIndex.

  @see Cudd_SolveEqn

*/
DdNode *
Cudd_VerifySol(
  DdManager *  bdd /**< CUDD manager */,
  DdNode * F /**< the left-hand side of the equation */,
  DdNode ** G /**< the array of solutions */,
  int * yIndex /**< index of y variables */,
  int  n /**< numbers of unknowns */)
{
    DdNode *res;

    do {
	bdd->reordered = 0;
	res = cuddVerifySol(bdd, F, G, yIndex, n);
    } while (bdd->reordered == 1);

    FREE(yIndex);
    if (bdd->errorCode == CUDD_TIMEOUT_EXPIRED && bdd->timeoutHandler) {
        bdd->timeoutHandler(bdd, bdd->tohArg);
    }

    return(res);

} /* end of Cudd_VerifySol */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Implements the recursive step of Cudd_SolveEqn.

  @return NULL if the intermediate solution blows up or reordering
  occurs.

  @sideeffect The parametric solutions are stored in the array G.

  @see Cudd_SolveEqn, Cudd_VerifySol

*/
DdNode *
cuddSolveEqnRecur(
  DdManager * bdd /**< CUDD manager */,
  DdNode * F /**< the left-hand side of the equation */,
  DdNode * Y /**< the cube of remaining y variables */,
  DdNode ** G /**< the array of solutions */,
  int  n /**< number of unknowns */,
  int * yIndex /**< array holding the y variable indices */,
  int  i /**< level of recursion */)
{
    DdNode *Fn, *Fm1, *Fv, *Fvbar, *T, *w, *nextY, *one;
    DdNodePtr *variables;

    int j;

    statLine(bdd);
    variables = bdd->vars;
    one = DD_ONE(bdd);

    /* Base condition. */
    if (Y == one) {
	return F;
    }

    /* Cofactor of Y. */
    yIndex[i] = Y->index;
    nextY = Cudd_T(Y);

    /* Universal abstraction of F with respect to the top variable index. */
    Fm1 = cuddBddExistAbstractRecur(bdd, Cudd_Not(F), variables[yIndex[i]]);
    if (Fm1) {
	Fm1 = Cudd_Not(Fm1);
	cuddRef(Fm1);
    } else {
	return(NULL);
    }

    Fn = cuddSolveEqnRecur(bdd, Fm1, nextY, G, n, yIndex, i+1);
    if (Fn) {
	cuddRef(Fn);
    } else {
	Cudd_RecursiveDeref(bdd, Fm1);
	return(NULL);
    }

    Fv = cuddCofactorRecur(bdd, F, variables[yIndex[i]]);
    if (Fv) {
	cuddRef(Fv);
    } else {
	Cudd_RecursiveDeref(bdd, Fm1);
	Cudd_RecursiveDeref(bdd, Fn);
	return(NULL);
    }

    Fvbar = cuddCofactorRecur(bdd, F, Cudd_Not(variables[yIndex[i]]));
    if (Fvbar) {
	cuddRef(Fvbar);
    } else {
	Cudd_RecursiveDeref(bdd, Fm1);
	Cudd_RecursiveDeref(bdd, Fn);
	Cudd_RecursiveDeref(bdd, Fv);
	return(NULL);
    }

    /* Build i-th component of the solution. */
    w = cuddBddIteRecur(bdd, variables[yIndex[i]], Cudd_Not(Fv), Fvbar);
    if (w) {
	cuddRef(w);
    } else {
	Cudd_RecursiveDeref(bdd, Fm1);
	Cudd_RecursiveDeref(bdd, Fn);
	Cudd_RecursiveDeref(bdd, Fv);
	Cudd_RecursiveDeref(bdd, Fvbar);
	return(NULL);
    }

    T = cuddBddRestrictRecur(bdd, w, Cudd_Not(Fm1));
    if(T) {
	cuddRef(T);
    } else {
	Cudd_RecursiveDeref(bdd, Fm1);
	Cudd_RecursiveDeref(bdd, Fn);
	Cudd_RecursiveDeref(bdd, Fv);
	Cudd_RecursiveDeref(bdd, Fvbar);
	Cudd_RecursiveDeref(bdd, w);
	return(NULL);
    }

    Cudd_RecursiveDeref(bdd,Fm1);
    Cudd_RecursiveDeref(bdd,w);
    Cudd_RecursiveDeref(bdd,Fv);
    Cudd_RecursiveDeref(bdd,Fvbar);

    /* Substitute components of solution already found into solution. */
    for (j = n-1; j > i; j--) {
	w = cuddBddComposeRecur(bdd,T, G[j], variables[yIndex[j]]);
	if(w) {
	    cuddRef(w);
	} else {
	    Cudd_RecursiveDeref(bdd, Fn);
	    Cudd_RecursiveDeref(bdd, T);
	    return(NULL);
	}
	Cudd_RecursiveDeref(bdd,T);
	T = w;
    }
    G[i] = T;

    Cudd_Deref(Fn);

    return(Fn);

} /* end of cuddSolveEqnRecur */


/**
  @brief Implements the recursive step of Cudd_VerifySol. 

  @sideeffect none

  @see Cudd_VerifySol

*/
DdNode *
cuddVerifySol(
  DdManager * bdd /**< CUDD manager */,
  DdNode * F /**< the left-hand side of the equation */,
  DdNode ** G /**< the array of solutions */,
  int * yIndex /**< array holding the y variable indices */,
  int  n /**< number of unknowns */)
{
    DdNode *w, *R;

    int j;

    R = F;
    cuddRef(R);
    for(j = n - 1; j >= 0; j--) {
	 w = Cudd_bddCompose(bdd, R, G[j], yIndex[j]);
	if (w) {
	    cuddRef(w);
	} else {
	    return(NULL); 
	}
	Cudd_RecursiveDeref(bdd,R);
	R = w;
    }

    cuddDeref(R);

    return(R);

} /* end of cuddVerifySol */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


cuddSplit.c
17869
/**
  @file

  @ingroup cudd

  @brief Returns a subset of minterms from a boolean function.

  @author Balakrishna Kumthekar

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Structure declarations                                                    */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * selectMintermsFromUniverse (DdManager *manager, int *varSeen, double n);
static DdNode * mintermsFromUniverse (DdManager *manager, DdNode **vars, int numVars, double n, int index);
static double bddAnnotateMintermCount (DdManager *manager, DdNode *node, double max, st_table *table);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Returns m minterms from a %BDD.

  @details Returns <code>m</code> minterms from a %BDD whose
  support has <code>n</code> variables at most.  The procedure tries
  to create as few extra nodes as possible. The function represented
  by <code>S</code> depends on at most <code>n</code> of the variables
  in <code>xVars</code>.

  @return a %BDD with <code>m</code> minterms of the on-set of S if
  successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_SplitSet(
  DdManager * manager,
  DdNode * S,
  DdNode ** xVars,
  int  n,
  double  m)
{
    DdNode *result;
    DdNode *zero, *one;
    double  max, num;
    st_table *mtable;
    int *varSeen;
    int i,index, size;

    size = manager->size;
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* Trivial cases. */
    if (m == 0.0) {
	return(zero);
    }
    if (S == zero) {
	return(NULL);
    }

    max = pow(2.0,(double)n);
    if (m > max)
	return(NULL);

    do {
	manager->reordered = 0;
	/* varSeen is used to mark the variables that are encountered
	** while traversing the BDD S.
	*/
	varSeen = ALLOC(int, size);
	if (varSeen == NULL) {
	    manager->errorCode = CUDD_MEMORY_OUT;
	    return(NULL);
	}
	for (i = 0; i < size; i++) {
	    varSeen[i] = -1;
	}
	for (i = 0; i < n; i++) {
	    index = (xVars[i])->index;
	    varSeen[manager->invperm[index]] = 0;
	}

	if (S == one) {
	    if (m == max) {
		FREE(varSeen);
		return(S);
	    }
	    result = selectMintermsFromUniverse(manager,varSeen,m);
	    if (result)
		cuddRef(result);
	    FREE(varSeen);
	} else {
	    mtable = st_init_table(st_ptrcmp,st_ptrhash);
	    if (mtable == NULL) {
		(void) fprintf(manager->out,
			       "Cudd_SplitSet: out-of-memory.\n");
		FREE(varSeen);
		manager->errorCode = CUDD_MEMORY_OUT;
		return(NULL);
	    }
	    /* The nodes of BDD S are annotated by the number of minterms
	    ** in their onset. The node and the number of minterms in its
	    ** onset are stored in mtable.
	    */
	    num = bddAnnotateMintermCount(manager,S,max,mtable);
	    if (m == num) {
		st_foreach(mtable,cuddStCountfree,NIL(void));
		st_free_table(mtable);
		FREE(varSeen);
		return(S);
	    }
	    
	    result = cuddSplitSetRecur(manager,mtable,varSeen,S,m,max,0);
	    if (result)
		cuddRef(result);
	    st_foreach(mtable,cuddStCountfree,NULL);
	    st_free_table(mtable);
	    FREE(varSeen);
	}
    } while (manager->reordered == 1);
    if (manager->errorCode == CUDD_TIMEOUT_EXPIRED && manager->timeoutHandler) {
        manager->timeoutHandler(manager, manager->tohArg);
    }

    cuddDeref(result);
    return(result);

} /* end of Cudd_SplitSet */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Implements the recursive step of Cudd_SplitSet.

  @details The procedure recursively traverses the %BDD and checks to
  see if any node satisfies the minterm requirements as specified by
  'n'. At any node X, n is compared to the number of minterms in the
  onset of X's children. If either of the child nodes have exactly n
  minterms, then that node is returned; else, if n is greater than the
  onset of one of the child nodes, that node is retained and the
  difference in the number of minterms is extracted from the other
  child. In case n minterms can be extracted from constant 1, the
  algorithm returns the result with at most log(n) nodes.

  @sideeffect The array 'varSeen' is updated at every recursive call
  to set the variables traversed by the procedure.

*/
DdNode*
cuddSplitSetRecur(
  DdManager * manager,
  st_table * mtable,
  int * varSeen,
  DdNode * p,
  double  n,
  double  max,
  int  index)
{
    DdNode *one, *zero, *N, *Nv;
    DdNode *Nnv, *q, *r, *v;
    DdNode *result;
    double *dummy, numT, numE;
    int variable, positive;
  
    statLine(manager);
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* If p is constant, extract n minterms from constant 1.  The procedure by
    ** construction guarantees that minterms will not be extracted from
    ** constant 0.
    */
    if (Cudd_IsConstantInt(p)) {
	q = selectMintermsFromUniverse(manager,varSeen,n);
	return(q);
    }

    N = Cudd_Regular(p);

    /* Set variable as seen. */
    variable = N->index;
    varSeen[manager->invperm[variable]] = -1;

    Nv = cuddT(N);
    Nnv = cuddE(N);
    if (Cudd_IsComplement(p)) {
	Nv = Cudd_Not(Nv);
	Nnv = Cudd_Not(Nnv);
    }

    /* If both the children of 'p' are constants, extract n minterms from a
    ** constant node.
    */
    if (Cudd_IsConstantInt(Nv) && Cudd_IsConstantInt(Nnv)) {
	q = selectMintermsFromUniverse(manager,varSeen,n);
	if (q == NULL) {
	    return(NULL);
	}
	cuddRef(q);
	r = cuddBddAndRecur(manager,p,q);
	if (r == NULL) {
	    Cudd_RecursiveDeref(manager,q);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_RecursiveDeref(manager,q);
	cuddDeref(r);
	return(r);
    }
  
    /* Lookup the # of minterms in the onset of the node from the table. */
    if (!Cudd_IsConstantInt(Nv)) {
      if (!st_lookup(mtable, Nv, (void **) &dummy)) return(NULL);
	numT = *dummy/(2*(1U<<index));
    } else if (Nv == one) {
	numT = max/(2*(1U<<index));
    } else {
	numT = 0;
    }
  
    if (!Cudd_IsConstantInt(Nnv)) {
      if (!st_lookup(mtable, Nnv, (void **) &dummy)) return(NULL);
	numE = *dummy/(2*(1U<<index));
    } else if (Nnv == one) {
	numE = max/(2*(1U<<index));
    } else {
	numE = 0;
    }

    v = cuddUniqueInter(manager,variable,one,zero);
    cuddRef(v);

    /* If perfect match. */
    if (numT == n) {
	q = cuddBddAndRecur(manager,v,Nv);
	if (q == NULL) {
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(q);
	Cudd_RecursiveDeref(manager,v);
	cuddDeref(q);
	return(q);
    }
    if (numE == n) {
	q = cuddBddAndRecur(manager,Cudd_Not(v),Nnv);
	if (q == NULL) {
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(q);
	Cudd_RecursiveDeref(manager,v);
	cuddDeref(q);
	return(q);
    }
    /* If n is greater than numT, extract the difference from the ELSE child
    ** and retain the function represented by the THEN branch.
    */
    if (numT < n) {
	q = cuddSplitSetRecur(manager,mtable,varSeen,
			      Nnv,(n-numT),max,index+1);
	if (q == NULL) {
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(q);
	r = cuddBddIteRecur(manager,v,Nv,q);
	if (r == NULL) {
	    Cudd_RecursiveDeref(manager,q);
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_RecursiveDeref(manager,q);
	Cudd_RecursiveDeref(manager,v);
	cuddDeref(r);
	return(r);
    }
    /* If n is greater than numE, extract the difference from the THEN child
    ** and retain the function represented by the ELSE branch.
    */
    if (numE < n) {
	q = cuddSplitSetRecur(manager,mtable,varSeen,
			      Nv, (n-numE),max,index+1);
	if (q == NULL) {
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(q);
	r = cuddBddIteRecur(manager,v,q,Nnv);
	if (r == NULL) {
	    Cudd_RecursiveDeref(manager,q);
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_RecursiveDeref(manager,q);
	Cudd_RecursiveDeref(manager,v);
	cuddDeref(r);    
	return(r);
    }

    /* None of the above cases; (n < numT and n < numE) and either of
    ** the Nv, Nnv or both are not constants. If possible extract the
    ** required minterms the constant branch.
    */
    if (Cudd_IsConstantInt(Nv) && !Cudd_IsConstantInt(Nnv)) {
	q = selectMintermsFromUniverse(manager,varSeen,n);
	if (q == NULL) {
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(q);
	result = cuddBddAndRecur(manager,v,q);
	if (result == NULL) {
	    Cudd_RecursiveDeref(manager,q);
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(result);
	Cudd_RecursiveDeref(manager,q);
	Cudd_RecursiveDeref(manager,v);
	cuddDeref(result);
	return(result);
    } else if (!Cudd_IsConstantInt(Nv) && Cudd_IsConstantInt(Nnv)) {
	q = selectMintermsFromUniverse(manager,varSeen,n);
	if (q == NULL) {
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(q);
	result = cuddBddAndRecur(manager,Cudd_Not(v),q);
	if (result == NULL) {
	    Cudd_RecursiveDeref(manager,q);
	    Cudd_RecursiveDeref(manager,v);
	    return(NULL);
	}
	cuddRef(result);
	Cudd_RecursiveDeref(manager,q);
	Cudd_RecursiveDeref(manager,v);
	cuddDeref(result);
	return(result);
    }

    /* Both Nv and Nnv are not constants. So choose the one which
    ** has fewer minterms in its onset.
    */
    positive = 0;
    if (numT < numE) {
	q = cuddSplitSetRecur(manager,mtable,varSeen,
			      Nv,n,max,index+1);
	positive = 1;
    } else {
	q = cuddSplitSetRecur(manager,mtable,varSeen,
			      Nnv,n,max,index+1);
    }

    if (q == NULL) {
	Cudd_RecursiveDeref(manager,v);
	return(NULL);
    }
    cuddRef(q);

    if (positive) {
	result = cuddBddAndRecur(manager,v,q);
    } else {
	result = cuddBddAndRecur(manager,Cudd_Not(v),q);
    }
    if (result == NULL) {
	Cudd_RecursiveDeref(manager,q);
	Cudd_RecursiveDeref(manager,v);
	return(NULL);
    }
    cuddRef(result);
    Cudd_RecursiveDeref(manager,q);
    Cudd_RecursiveDeref(manager,v);
    cuddDeref(result);

    return(result);

} /* end of cuddSplitSetRecur */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
  @brief This function prepares an array of variables which have not been
  encountered so far when traversing the procedure cuddSplitSetRecur.

  @details This array is then used to extract the required number of
  minterms from a constant 1.  The algorithm guarantees that the size
  of %BDD will be at most log(n).

  @sideeffect None

*/
static DdNode *
selectMintermsFromUniverse(
  DdManager * manager,
  int * varSeen,
  double  n)
{
    int numVars;
    int i, size, j;
     DdNode *one, *zero, *result;
    DdNode **vars;

    numVars = 0;
    size = manager->size;
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    /* Count the number of variables not encountered so far in procedure
    ** cuddSplitSetRecur.
    */
    for (i = size-1; i >= 0; i--) {
	if(varSeen[i] == 0)
	    numVars++;
    }
    vars = ALLOC(DdNode *, numVars);
    if (!vars) {
	manager->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    j = 0;
    for (i = size-1; i >= 0; i--) {
	if(varSeen[i] == 0) {
	    vars[j] = cuddUniqueInter(manager,manager->perm[i],one,zero);
	    cuddRef(vars[j]);
	    j++;
	}
    }

    /* Compute a function which has n minterms and depends on at most
    ** numVars variables.
    */
    result = mintermsFromUniverse(manager,vars,numVars,n, 0);
    if (result) 
	cuddRef(result);

    for (i = 0; i < numVars; i++)
	Cudd_RecursiveDeref(manager,vars[i]);
    FREE(vars);

    return(result);

} /* end of selectMintermsFromUniverse */


/**
  @brief Recursive procedure to extract n mintems from constant 1.

  @sideeffect None

*/
static DdNode *
mintermsFromUniverse(
  DdManager * manager,
  DdNode ** vars,
  int  numVars,
  double  n,
  int  index)
{
    DdNode *one, *zero;
    DdNode *q, *result;
    double max, max2;
    
    statLine(manager);
    one = DD_ONE(manager);
    zero = Cudd_Not(one);

    max = pow(2.0, (double)numVars);
    max2 = max / 2.0;

    if (n == max)
	return(one);
    if (n == 0.0)
	return(zero);
    /* if n == 2^(numVars-1), return a single variable */
    if (n == max2)
	return vars[index];
    else if (n > max2) {
	/* When n > 2^(numVars-1), a single variable vars[index]
	** contains 2^(numVars-1) minterms. The rest are extracted
	** from a constant with 1 less variable.
	*/
	q = mintermsFromUniverse(manager,vars,numVars-1,(n-max2),index+1);
	if (q == NULL)
	    return(NULL);
	cuddRef(q);
	result = cuddBddIteRecur(manager,vars[index],one,q);
    } else {
	/* When n < 2^(numVars-1), a literal of variable vars[index]
	** is selected. The required n minterms are extracted from a
	** constant with 1 less variable.
	*/
	q = mintermsFromUniverse(manager,vars,numVars-1,n,index+1);
	if (q == NULL)
	    return(NULL);
	cuddRef(q);
	result = cuddBddAndRecur(manager,vars[index],q);
    }
    
    if (result == NULL) {
	Cudd_RecursiveDeref(manager,q);
	return(NULL);
    }
    cuddRef(result);
    Cudd_RecursiveDeref(manager,q);
    cuddDeref(result);
    return(result);

} /* end of mintermsFromUniverse */


/**
  @brief Annotates every node in the %BDD node with its minterm count.

  @details In this function, every node and the minterm count
  represented by it are stored in a hash table.

  @sideeffect Fills up 'table' with the pair <node,minterm_count>.

*/
static double
bddAnnotateMintermCount(
  DdManager * manager,
  DdNode * node,
  double  max,
  st_table * table)
{

    DdNode *N,*Nv,*Nnv;
    double min_v,min_nv;
    double min_N;
    double *pmin;
    double *dummy;

    statLine(manager);
    N = Cudd_Regular(node);
    if (cuddIsConstant(N)) {
	if (node == DD_ONE(manager)) {
	    return(max);
	} else {
	    return(0.0);
	}
    }

    if (st_lookup(table, node, (void **) &dummy)) {
	return(*dummy);
    }	
  
    Nv = cuddT(N);
    Nnv = cuddE(N);
    if (N != node) {
	Nv = Cudd_Not(Nv);
	Nnv = Cudd_Not(Nnv);
    }

    /* Recur on the two branches. */
    min_v  = bddAnnotateMintermCount(manager,Nv,max,table) / 2.0;
    if (min_v == (double)CUDD_OUT_OF_MEM)
	return ((double)CUDD_OUT_OF_MEM);
    min_nv = bddAnnotateMintermCount(manager,Nnv,max,table) / 2.0;
    if (min_nv == (double)CUDD_OUT_OF_MEM)
	return ((double)CUDD_OUT_OF_MEM);
    min_N  = min_v + min_nv;

    pmin = ALLOC(double,1);
    if (pmin == NULL) {
	manager->errorCode = CUDD_MEMORY_OUT;
	return((double)CUDD_OUT_OF_MEM);
    }
    *pmin = min_N;

    if (st_insert(table, node, pmin) == ST_OUT_OF_MEM) {
	FREE(pmin);
	return((double)CUDD_OUT_OF_MEM);
    }
    
    return(min_N);

} /* end of bddAnnotateMintermCount */

cuddSubsetHB.c
40719
/**
  @file

  @ingroup cudd

  @brief Procedure to subset the given %BDD by choosing the heavier
  branches.

  @see cuddSubsetSP.c

  @author Kavita Ravi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifdef __STDC__
#include <float.h>
#else
#define DBL_MAX_EXP 1024
#endif
#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define	DEFAULT_PAGE_SIZE 2048
#define	DEFAULT_NODE_DATA_PAGE_SIZE 1024
#define INITIAL_PAGES 128

#undef max

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef struct NodeData NodeData_t;

typedef struct SubsetInfo SubsetInfo_t;

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief Data structure to store the information on each node.

 * @details It keeps the number of minterms represented by the DAG
 * rooted at this node in terms of the number of variables specified
 * by the user, number of nodes in this DAG and the number of nodes of
 * its child with lesser number of minterms that are not shared by the
 * child with more minterms.
 */
struct NodeData {
    double *mintermPointer;
    int *nodesPointer;
    int *lightChildNodesPointer;
};

/**
 * @brief Miscellaneous info.
 */
struct SubsetInfo {
    DdNode	*zero, *one; /**< constant functions */
    double	**mintermPages;	/**< pointers to the pages */
    int		**nodePages; /**< pointers to the pages */
    int		**lightNodePages; /**< pointers to the pages */
    double	*currentMintermPage; /**< pointer to the current page */
    double	max; /**< to store the 2^n value of the number of variables */
    int		*currentNodePage; /**< pointer to the current page */
    int		*currentLightNodePage; /**< pointer to the current page */
    int		pageIndex; /**< index to next element */
    int		page; /**< index to current page */
    int		pageSize; /**< page size */
    int         maxPages; /**< number of page pointers */
    NodeData_t	*currentNodeDataPage; /**< pointer to the current page */
    int		nodeDataPage; /**< index to next element */
    int		nodeDataPageIndex; /**< index to next element */
    NodeData_t	**nodeDataPages; /**< index to current page */
    int		nodeDataPageSize; /**< page size */
    int         maxNodeDataPages; /**< number of page pointers */
    int memOut;
#ifdef DEBUG
    int		num_calls;
#endif
};

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void ResizeNodeDataPages (SubsetInfo_t * info);
static void ResizeCountMintermPages (SubsetInfo_t * info);
static void ResizeCountNodePages (SubsetInfo_t * info);
static double SubsetCountMintermAux (DdNode *node, double max, st_table *table, SubsetInfo_t * info);
static st_table * SubsetCountMinterm (DdNode *node, int nvars, SubsetInfo_t * info);
static int SubsetCountNodesAux (DdNode *node, st_table *table, double max, SubsetInfo_t * info);
static int SubsetCountNodes (DdNode *node, st_table *table, int nvars, SubsetInfo_t * info);
static void StoreNodes (st_table *storeTable, DdManager *dd, DdNode *node);
static DdNode * BuildSubsetBdd (DdManager *dd, DdNode *node, int *size, st_table *visitedTable, int threshold, st_table *storeTable, st_table *approxTable, SubsetInfo_t * info);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Extracts a dense subset from a %BDD with the heavy branch
  heuristic.

  @details This procedure builds a subset by throwing away one of the
  children of each node, starting from the root, until the result is
  small enough. The child that is eliminated from the result is the
  one that contributes the fewer minterms.  The parameter numVars is
  the maximum number of variables to be used in minterm calculation
  and node count calculation.  The optimal number should be as close
  as possible to the size of the support of f.  However, it is safe to
  pass the value returned by Cudd_ReadSize for numVars when the number
  of variables is under 1023.  If numVars is larger than 1023, it will
  overflow. If a 0 parameter is passed then the procedure will compute
  a value which will avoid overflow but will cause underflow with 2046
  variables or more.

  @return a pointer to the %BDD of the subset if successful. NULL if
  the procedure runs out of memory.

  @sideeffect None

  @see Cudd_SubsetShortPaths Cudd_SupersetHeavyBranch Cudd_ReadSize

*/
DdNode *
Cudd_SubsetHeavyBranch(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be subset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< maximum number of nodes in the subset */)
{
    DdNode *subset;

    do {
	dd->reordered = 0;
	subset = cuddSubsetHeavyBranch(dd, f, numVars, threshold);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(subset);

} /* end of Cudd_SubsetHeavyBranch */


/**
  @brief Extracts a dense superset from a %BDD with the heavy branch
  heuristic.

  @details The procedure is identical to the subset procedure except
  for the fact that it receives the complement of the given
  function. Extracting the subset of the complement function is
  equivalent to extracting the superset of the function. This
  procedure builds a superset by throwing away one of the children of
  each node starting from the root of the complement function, until
  the result is small enough. The child that is eliminated from the
  result is the one that contributes the fewer minterms.  The
  parameter numVars is the maximum number of variables to be used in
  minterm calculation and node count calculation.  The optimal number
  should be as close as possible to the size of the support of f.
  However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023.  If numVars is
  larger than 1023, it will overflow. If a 0 parameter is passed then
  the procedure will compute a value which will avoid overflow but
  will cause underflow with 2046 variables or more.

  @return a pointer to the %BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory.

  @sideeffect None

  @see Cudd_SubsetHeavyBranch Cudd_SupersetShortPaths Cudd_ReadSize

*/
DdNode *
Cudd_SupersetHeavyBranch(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be superset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< maximum number of nodes in the superset */)
{
    DdNode *subset, *g;

    g = Cudd_Not(f);
    do {
	dd->reordered = 0;
	subset = cuddSubsetHeavyBranch(dd, g, numVars, threshold);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(Cudd_NotCond(subset, (subset != NULL)));

} /* end of Cudd_SupersetHeavyBranch */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief The main procedure that returns a subset by choosing the heavier
  branch in the %BDD.

  @details Here a subset %BDD is built by throwing away one of the
  children. Starting at root, annotate each node with the number of
  minterms (in terms of the total number of variables specified -
  numVars), number of nodes taken by the DAG rooted at this node and
  number of additional nodes taken by the child that has the lesser
  minterms. The child with the lower number of minterms is thrown away
  and a dyanmic count of the nodes of the subset is kept. Once the
  threshold is reached the subset is returned to the calling
  procedure.

  @sideeffect None

  @see Cudd_SubsetHeavyBranch

*/
DdNode *
cuddSubsetHeavyBranch(
  DdManager * dd /**< %DD manager */,
  DdNode * f /**< current %DD */,
  int  numVars /**< maximum number of variables */,
  int  threshold /**< threshold size for the subset */)
{

    int i, *size;
    st_table *visitedTable;
    int numNodes;
    NodeData_t *currNodeQual;
    DdNode *subset;
    st_table *storeTable, *approxTable;
    DdNode *key, *value;
    st_generator *stGen;
    SubsetInfo_t info;

    if (f == NULL) {
	fprintf(dd->err, "Cannot subset, nil object\n");
	dd->errorCode = CUDD_INVALID_ARG;
	return(NULL);
    }

    /* If user does not know numVars value, set it to the maximum
     * exponent that the pow function can take. The -1 is due to the
     * discrepancy in the value that pow takes and the value that
     * log gives.
     */
    if (numVars == 0) {
	/* set default value */
	numVars = DBL_MAX_EXP - 1;
    }

    if (Cudd_IsConstantInt(f)) {
	return(f);
    }

    info.one  = Cudd_ReadOne(dd);
    info.zero = Cudd_Not(info.one);
    info.mintermPages = NULL;
    info.nodePages = info.lightNodePages = NULL;
    info.currentMintermPage = NULL;
    info.max = pow(2.0, (double)numVars);
    info.currentNodePage = info.currentLightNodePage = NULL;
    info.pageIndex = info.page = 0;
    info.pageSize = DEFAULT_PAGE_SIZE;
    info.maxPages = 0;
    info.currentNodeDataPage = NULL;
    info.nodeDataPage = info.nodeDataPageIndex = 0;
    info.nodeDataPages = NULL;
    info.nodeDataPageSize = DEFAULT_NODE_DATA_PAGE_SIZE;
    info.maxNodeDataPages = 0;
    info.memOut = 0;
#ifdef DEBUG
    info.num_calls = 0;
#endif

    /* Create visited table where structures for node data are allocated and
       stored in a st_table */
    visitedTable = SubsetCountMinterm(f, numVars, &info);
    if ((visitedTable == NULL) || info.memOut) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	dd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    numNodes = SubsetCountNodes(f, visitedTable, numVars, &info);
    if (info.memOut) {
	(void) fprintf(dd->err, "Out-of-memory; Cannot subset\n");
	dd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }

    if (st_lookup(visitedTable, f, (void **) &currNodeQual) == 0) {
	fprintf(dd->err,
		"Something is wrong, ought to be node quality table\n");
	dd->errorCode = CUDD_INTERNAL_ERROR;
    }

    size = ALLOC(int, 1);
    if (size == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    *size = numNodes;

    /* table to store nodes being created. */
    storeTable = st_init_table(st_ptrcmp, st_ptrhash);
    /* insert the constant */
    cuddRef(info.one);
    if (st_insert(storeTable, Cudd_ReadOne(dd), NULL) ==
	ST_OUT_OF_MEM) {
	fprintf(dd->out, "Something wrong, st_table insert failed\n");
    }
    /* table to store approximations of nodes */
    approxTable = st_init_table(st_ptrcmp, st_ptrhash);
    subset = (DdNode *)BuildSubsetBdd(dd, f, size, visitedTable, threshold,
				      storeTable, approxTable, &info);
    if (subset != NULL) {
	cuddRef(subset);
    }

    if (info.memOut) {
        dd->errorCode = CUDD_MEMORY_OUT;
        dd->reordered = 0;
    }

    stGen = st_init_gen(approxTable);
    if (stGen == NULL) {
	st_free_table(approxTable);
	return(NULL);
    }
    while(st_gen(stGen, (void **) &key, (void **) &value)) {
	Cudd_RecursiveDeref(dd, value);
    }
    st_free_gen(stGen); stGen = NULL;
    st_free_table(approxTable);

    stGen = st_init_gen(storeTable);
    if (stGen == NULL) {
	st_free_table(storeTable);
	return(NULL);
    }
    while(st_gen(stGen, (void **) &key, (void **) &value)) {
	Cudd_RecursiveDeref(dd, key);
    }
    st_free_gen(stGen); stGen = NULL;
    st_free_table(storeTable);

    for (i = 0; i <= info.page; i++) {
	FREE(info.mintermPages[i]);
    }
    FREE(info.mintermPages);
    for (i = 0; i <= info.page; i++) {
	FREE(info.nodePages[i]);
    }
    FREE(info.nodePages);
    for (i = 0; i <= info.page; i++) {
	FREE(info.lightNodePages[i]);
    }
    FREE(info.lightNodePages);
    for (i = 0; i <= info.nodeDataPage; i++) {
	FREE(info.nodeDataPages[i]);
    }
    FREE(info.nodeDataPages);
    st_free_table(visitedTable);
    FREE(size);
#if 0
    (void) Cudd_DebugCheck(dd);
    (void) Cudd_CheckKeys(dd);
#endif

    if (subset != NULL) {
#ifdef DD_DEBUG
      if (!Cudd_bddLeq(dd, subset, f)) {
	    fprintf(dd->err, "Wrong subset\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    return(NULL);
      }
#endif
	cuddDeref(subset);
    }
    return(subset);

} /* end of cuddSubsetHeavyBranch */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Resize the number of pages allocated to store the node data.

  @details The procedure moves the counter to the next page when the
  end of the page is reached and allocates new pages when necessary.

  @sideeffect Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out. 

*/
static void
ResizeNodeDataPages(SubsetInfo_t * info)
{
    int i;
    NodeData_t **newNodeDataPages;

    info->nodeDataPage++;
    /* If the current page index is larger than the number of pages
     * allocated, allocate a new page array. Page numbers are incremented by
     * INITIAL_PAGES
     */
    if (info->nodeDataPage == info->maxNodeDataPages) {
	newNodeDataPages = ALLOC(NodeData_t *, info->maxNodeDataPages + INITIAL_PAGES);
	if (newNodeDataPages == NULL) {
	    for (i = 0; i < info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	    FREE(info->nodeDataPages);
	    info->memOut = 1;
	    return;
	} else {
	    for (i = 0; i < info->maxNodeDataPages; i++) {
		newNodeDataPages[i] = info->nodeDataPages[i];
	    }
	    /* Increase total page count */
	    info->maxNodeDataPages += INITIAL_PAGES;
	    FREE(info->nodeDataPages);
	    info->nodeDataPages = newNodeDataPages;
	}
    }
    /* Allocate a new page */
    info->currentNodeDataPage = info->nodeDataPages[info->nodeDataPage] =
	ALLOC(NodeData_t ,info->nodeDataPageSize);
    if (info->currentNodeDataPage == NULL) {
	for (i = 0; i < info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	FREE(info->nodeDataPages);
	info->memOut = 1;
	return;
    }
    /* reset page index */
    info->nodeDataPageIndex = 0;
    return;

} /* end of ResizeNodeDataPages */


/**
  @brief Resize the number of pages allocated to store the minterm
  counts. 

  @details The procedure  moves the counter to the next page when the
  end of the page is reached and allocates new pages when necessary.

  @sideeffect Changes the size of minterm pages, page, page index, maximum
  number of pages freeing stuff in case of memory out. 

*/
static void
ResizeCountMintermPages(SubsetInfo_t * info)
{
    int i;
    double **newMintermPages;

    info->page++;
    /* If the current page index is larger than the number of pages
     * allocated, allocate a new page array. Page numbers are incremented by
     * INITIAL_PAGES
     */
    if (info->page == info->maxPages) {
	newMintermPages = ALLOC(double *, info->maxPages + INITIAL_PAGES);
	if (newMintermPages == NULL) {
	    for (i = 0; i < info->page; i++) FREE(info->mintermPages[i]);
	    FREE(info->mintermPages);
	    info->memOut = 1;
	    return;
	} else {
	    for (i = 0; i < info->maxPages; i++) {
		newMintermPages[i] = info->mintermPages[i];
	    }
	    /* Increase total page count */
	    info->maxPages += INITIAL_PAGES;
	    FREE(info->mintermPages);
	    info->mintermPages = newMintermPages;
	}
    }
    /* Allocate a new page */
    info->currentMintermPage = info->mintermPages[info->page] = ALLOC(double,info->pageSize);
    if (info->currentMintermPage == NULL) {
	for (i = 0; i < info->page; i++) FREE(info->mintermPages[i]);
	FREE(info->mintermPages);
	info->memOut = 1;
	return;
    }
    /* reset page index */
    info->pageIndex = 0;
    return;

} /* end of ResizeCountMintermPages */


/**
  @brief Resize the number of pages allocated to store the node counts.

  @details The procedure moves the counter to the next page when the
  end of the page is reached and allocates new pages when necessary.

  @sideeffect Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.

*/
static void
ResizeCountNodePages(SubsetInfo_t * info)
{
    int i;
    int **newNodePages;

    info->page++;

    /* If the current page index is larger than the number of pages
     * allocated, allocate a new page array. The number of pages is incremented
     * by INITIAL_PAGES.
     */
    if (info->page == info->maxPages) {
	newNodePages = ALLOC(int *, info->maxPages + INITIAL_PAGES);
	if (newNodePages == NULL) {
	    for (i = 0; i < info->page; i++) FREE(info->nodePages[i]);
	    FREE(info->nodePages);
	    for (i = 0; i < info->page; i++) FREE(info->lightNodePages[i]);
	    FREE(info->lightNodePages);
	    info->memOut = 1;
	    return;
	} else {
	    for (i = 0; i < info->maxPages; i++) {
		newNodePages[i] = info->nodePages[i];
	    }
	    FREE(info->nodePages);
	    info->nodePages = newNodePages;
	}

	newNodePages = ALLOC(int *, info->maxPages + INITIAL_PAGES);
	if (newNodePages == NULL) {
	    for (i = 0; i < info->page; i++) FREE(info->nodePages[i]);
	    FREE(info->nodePages);
	    for (i = 0; i < info->page; i++) FREE(info->lightNodePages[i]);
	    FREE(info->lightNodePages);
	    info->memOut = 1;
	    return;
	} else {
	    for (i = 0; i < info->maxPages; i++) {
		newNodePages[i] = info->lightNodePages[i];
	    }
	    FREE(info->lightNodePages);
	    info->lightNodePages = newNodePages;
	}
	/* Increase total page count */
	info->maxPages += INITIAL_PAGES;
    }
    /* Allocate a new page */
    info->currentNodePage = info->nodePages[info->page] = ALLOC(int,info->pageSize);
    if (info->currentNodePage == NULL) {
	for (i = 0; i < info->page; i++) FREE(info->nodePages[i]);
	FREE(info->nodePages);
	for (i = 0; i < info->page; i++) FREE(info->lightNodePages[i]);
	FREE(info->lightNodePages);
	info->memOut = 1;
	return;
    }
    /* Allocate a new page */
    info->currentLightNodePage = info->lightNodePages[info->page]
        = ALLOC(int,info->pageSize);
    if (info->currentLightNodePage == NULL) {
	for (i = 0; i <= info->page; i++) FREE(info->nodePages[i]);
	FREE(info->nodePages);
	for (i = 0; i < info->page; i++) FREE(info->lightNodePages[i]);
	FREE(info->lightNodePages);
	info->memOut = 1;
	return;
    }
    /* reset page index */
    info->pageIndex = 0;
    return;

} /* end of ResizeCountNodePages */


/**
  @brief Recursively counts minterms of each node in the DAG.

  @details Similar to the cuddCountMintermAux which recursively counts
  the number of minterms for the dag rooted at each node in terms of
  the total number of variables (max). This procedure creates the node
  data structure and stores the minterm count as part of the node data
  structure.

  @sideeffect Creates structures of type node quality and fills the st_table

  @see SubsetCountMinterm

*/
static double
SubsetCountMintermAux(
  DdNode * node /**< function to analyze */,
  double  max /**< number of minterms of constant 1 */,
  st_table * table /**< visitedTable table */,
  SubsetInfo_t * info /**< miscellaneous info */)
{

    DdNode	*N,*Nv,*Nnv; /* nodes to store cofactors  */
    double	min,*pmin; /* minterm count */
    double	min1, min2; /* minterm count */
    NodeData_t *dummy;
    NodeData_t *newEntry;
    int i;

#ifdef DEBUG
    info->num_calls++;
#endif

    /* Constant case */
    if (Cudd_IsConstantInt(node)) {
	if (node == info->zero) {
	    return(0.0);
	} else {
	    return(max);
	}
    } else {

	/* check if entry for this node exists */
        if (st_lookup(table, node, (void **) &dummy)) {
	    min = *(dummy->mintermPointer);
	    return(min);
	}

	/* Make the node regular to extract cofactors */
	N = Cudd_Regular(node);

	/* store the cofactors */
	Nv = Cudd_T(N);
	Nnv = Cudd_E(N);

	Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
	Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

	min1 =  SubsetCountMintermAux(Nv, max,table,info)/2.0;
	if (info->memOut) return(0.0);
	min2 =  SubsetCountMintermAux(Nnv,max,table,info)/2.0;
	if (info->memOut) return(0.0);
	min = (min1+min2);

	/* if page index is at the bottom, then create a new page */
	if (info->pageIndex == info->pageSize) ResizeCountMintermPages(info);
	if (info->memOut) {
	    for (i = 0; i <= info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	    FREE(info->nodeDataPages);
	    st_free_table(table);
	    return(0.0);
	}

	/* point to the correct location in the page */
	pmin = info->currentMintermPage + info->pageIndex;
	info->pageIndex++;

	/* store the minterm count of this node in the page */
	*pmin = min;

	/* Note I allocate the struct here. Freeing taken care of later */
	if (info->nodeDataPageIndex == info->nodeDataPageSize)
            ResizeNodeDataPages(info);
	if (info->memOut) {
	    for (i = 0; i <= info->page; i++) FREE(info->mintermPages[i]);
	    FREE(info->mintermPages);
	    st_free_table(table);
	    return(0.0);
	}

	newEntry = info->currentNodeDataPage + info->nodeDataPageIndex;
	info->nodeDataPageIndex++;

	/* points to the correct location in the page */
	newEntry->mintermPointer = pmin;
	/* initialize this field of the Node Quality structure */
	newEntry->nodesPointer = NULL;

	/* insert entry for the node in the table */
	if (st_insert(table,node, newEntry) == ST_OUT_OF_MEM) {
	    info->memOut = 1;
	    for (i = 0; i <= info->page; i++) FREE(info->mintermPages[i]);
	    FREE(info->mintermPages);
	    for (i = 0; i <= info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	    FREE(info->nodeDataPages);
	    st_free_table(table);
	    return(0.0);
	}
	return(min);
    }

} /* end of SubsetCountMintermAux */


/**
  @brief Counts minterms of each node in the DAG

  @details Similar to the Cudd_CountMinterm procedure except this
  returns the minterm count for all the nodes in the bdd in an
  st_table.

  @sideeffect none

  @see SubsetCountMintermAux

*/
static st_table *
SubsetCountMinterm(
  DdNode * node /**< function to be analyzed */,
  int nvars /**< number of variables node depends on */,
  SubsetInfo_t * info /**< miscellaneous info */)
{
    st_table	*table;
    int i;


#ifdef DEBUG
    info->num_calls = 0;
#endif

    info->max = pow(2.0,(double) nvars);
    table = st_init_table(st_ptrcmp,st_ptrhash);
    if (table == NULL) goto OUT_OF_MEM;
    info->maxPages = INITIAL_PAGES;
    info->mintermPages = ALLOC(double *,info->maxPages);
    if (info->mintermPages == NULL) {
	st_free_table(table);
	goto OUT_OF_MEM;
    }
    info->page = 0;
    info->currentMintermPage = ALLOC(double,info->pageSize);
    info->mintermPages[info->page] = info->currentMintermPage;
    if (info->currentMintermPage == NULL) {
	FREE(info->mintermPages);
	st_free_table(table);
	goto OUT_OF_MEM;
    }
    info->pageIndex = 0;
    info->maxNodeDataPages = INITIAL_PAGES;
    info->nodeDataPages = ALLOC(NodeData_t *, info->maxNodeDataPages);
    if (info->nodeDataPages == NULL) {
	for (i = 0; i <= info->page ; i++) FREE(info->mintermPages[i]);
	FREE(info->mintermPages);
	st_free_table(table);
	goto OUT_OF_MEM;
    }
    info->nodeDataPage = 0;
    info->currentNodeDataPage = ALLOC(NodeData_t ,info->nodeDataPageSize);
    info->nodeDataPages[info->nodeDataPage] = info->currentNodeDataPage;
    if (info->currentNodeDataPage == NULL) {
	for (i = 0; i <= info->page ; i++) FREE(info->mintermPages[i]);
	FREE(info->mintermPages);
	FREE(info->nodeDataPages);
	st_free_table(table);
	goto OUT_OF_MEM;
    }
    info->nodeDataPageIndex = 0;

    (void) SubsetCountMintermAux(node,info->max,table,info);
    if (info->memOut) goto OUT_OF_MEM;
    return(table);

OUT_OF_MEM:
    info->memOut = 1;
    return(NULL);

} /* end of SubsetCountMinterm */


/**
  @brief Recursively counts the number of nodes under the dag.
  Also counts the number of nodes under the lighter child of
  this node.

  @details Note that the same dag may be the lighter child of two
  different nodes and have different counts. As with the minterm
  counts, the node counts are stored in pages to be space efficient
  and the address for these node counts are stored in an st_table
  associated to each node.

  @sideeffect Updates the node data table with node counts

  @see SubsetCountNodes

*/
static int
SubsetCountNodesAux(
  DdNode * node /**< current node */,
  st_table * table /**< table to update node count, also serves as visited table. */,
  double  max /**< maximum number of variables */,
  SubsetInfo_t * info)
{
    int tval, eval, i;
    DdNode *N, *Nv, *Nnv;
    double minNv, minNnv;
    NodeData_t *dummyN, *dummyNv, *dummyNnv, *dummyNBar;
    int *pmin, *pminBar, *val;

    if ((node == NULL) || Cudd_IsConstantInt(node))
	return(0);

    /* if this node has been processed do nothing */
    if (st_lookup(table, node, (void **) &dummyN) == 1) {
	val = dummyN->nodesPointer;
	if (val != NULL)
	    return(0);
    } else {
	return(0);
    }

    N  = Cudd_Regular(node);
    Nv = Cudd_T(N);
    Nnv = Cudd_E(N);

    Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
    Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

    /* find the minterm counts for the THEN and ELSE branches */
    if (Cudd_IsConstantInt(Nv)) {
	if (Nv == info->zero) {
	    minNv = 0.0;
	} else {
	    minNv = max;
	}
    } else {
	if (st_lookup(table, Nv, (void **) &dummyNv) == 1)
	    minNv = *(dummyNv->mintermPointer);
	else {
	    return(0);
	}
    }
    if (Cudd_IsConstantInt(Nnv)) {
	if (Nnv == info->zero) {
	    minNnv = 0.0;
	} else {
	    minNnv = max;
	}
    } else {
	if (st_lookup(table, Nnv, (void **) &dummyNnv) == 1) {
	    minNnv = *(dummyNnv->mintermPointer);
	}
	else {
	    return(0);
	}
    }


    /* recur based on which has larger minterm, */
    if (minNv >= minNnv) {
	tval = SubsetCountNodesAux(Nv, table, max, info);
	if (info->memOut) return(0);
	eval = SubsetCountNodesAux(Nnv, table, max, info);
	if (info->memOut) return(0);

	/* store the node count of the lighter child. */
	if (info->pageIndex == info->pageSize) ResizeCountNodePages(info);
	if (info->memOut) {
	    for (i = 0; i <= info->page; i++) FREE(info->mintermPages[i]);
	    FREE(info->mintermPages);
	    for (i = 0; i <= info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	    FREE(info->nodeDataPages);
	    st_free_table(table);
	    return(0);
	}
	pmin = info->currentLightNodePage + info->pageIndex;
	*pmin = eval; /* Here the ELSE child is lighter */
	dummyN->lightChildNodesPointer = pmin;

    } else {
	eval = SubsetCountNodesAux(Nnv, table, max, info);
	if (info->memOut) return(0);
	tval = SubsetCountNodesAux(Nv, table, max, info);
	if (info->memOut) return(0);

	/* store the node count of the lighter child. */
	if (info->pageIndex == info->pageSize) ResizeCountNodePages(info);
	if (info->memOut) {
	    for (i = 0; i <= info->page; i++) FREE(info->mintermPages[i]);
	    FREE(info->mintermPages);
	    for (i = 0; i <= info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	    FREE(info->nodeDataPages);
	    st_free_table(table);
	    return(0);
	}
	pmin = info->currentLightNodePage + info->pageIndex;
	*pmin = tval; /* Here the THEN child is lighter */
	dummyN->lightChildNodesPointer = pmin;

    }
    /* updating the page index for node count storage. */
    pmin = info->currentNodePage + info->pageIndex;
    *pmin = tval + eval + 1;
    dummyN->nodesPointer = pmin;

    /* pageIndex is parallel page index for count_nodes and count_lightNodes */
    info->pageIndex++;

    /* if this node has been reached first, it belongs to a heavier
       branch. Its complement will be reached later on a lighter branch.
       Hence the complement has zero node count. */

    if (st_lookup(table, Cudd_Not(node), (void **) &dummyNBar) == 1)  {
	if (info->pageIndex == info->pageSize) ResizeCountNodePages(info);
	if (info->memOut) {
	    for (i = 0; i < info->page; i++) FREE(info->mintermPages[i]);
	    FREE(info->mintermPages);
	    for (i = 0; i < info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	    FREE(info->nodeDataPages);
	    st_free_table(table);
	    return(0);
	}
	pminBar = info->currentLightNodePage + info->pageIndex;
	*pminBar = 0;
	dummyNBar->lightChildNodesPointer = pminBar;
	/* The lighter child has less nodes than the parent.
	 * So if parent 0 then lighter child zero
	 */
	if (info->pageIndex == info->pageSize) ResizeCountNodePages(info);
	if (info->memOut) {
	    for (i = 0; i < info->page; i++) FREE(info->mintermPages[i]);
	    FREE(info->mintermPages);
	    for (i = 0; i < info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	    FREE(info->nodeDataPages);
	    st_free_table(table);
	    return(0);
	}
	pminBar = info->currentNodePage + info->pageIndex;
	*pminBar = 0;
	dummyNBar->nodesPointer = pminBar ; /* maybe should point to zero */

	info->pageIndex++;
    }
    return(*pmin);
} /*end of SubsetCountNodesAux */


/**
  @brief Counts the nodes under the current node and its lighter child.

  @details Calls a recursive procedure to count the number of nodes of
  a DAG rooted at a particular node and the number of nodes taken by
  its lighter child.

  @sideeffect None

  @see SubsetCountNodesAux

*/
static int
SubsetCountNodes(
  DdNode * node /**< function to be analyzed */,
  st_table * table /**< node quality table */,
  int  nvars /**< number of variables node depends on */,
  SubsetInfo_t * info /**< miscellaneous info */)
{
    int	num;
    int i;

#ifdef DEBUG
    info->num_calls = 0;
#endif

    info->max = pow(2.0,(double) nvars);
    info->maxPages = INITIAL_PAGES;
    info->nodePages = ALLOC(int *, info->maxPages);
    if (info->nodePages == NULL)  {
	goto OUT_OF_MEM;
    }

    info->lightNodePages = ALLOC(int *, info->maxPages);
    if (info->lightNodePages == NULL) {
	for (i = 0; i <= info->page; i++) FREE(info->mintermPages[i]);
	FREE(info->mintermPages);
	for (i = 0; i <= info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	FREE(info->nodeDataPages);
	FREE(info->nodePages);
	goto OUT_OF_MEM;
    }

    info->page = 0;
    info->currentNodePage = info->nodePages[info->page] =
        ALLOC(int,info->pageSize);
    if (info->currentNodePage == NULL) {
	for (i = 0; i <= info->page; i++) FREE(info->mintermPages[i]);
	FREE(info->mintermPages);
	for (i = 0; i <= info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	FREE(info->nodeDataPages);
	FREE(info->lightNodePages);
	FREE(info->nodePages);
	goto OUT_OF_MEM;
    }

    info->currentLightNodePage = info->lightNodePages[info->page] =
        ALLOC(int,info->pageSize);
    if (info->currentLightNodePage == NULL) {
	for (i = 0; i <= info->page; i++) FREE(info->mintermPages[i]);
	FREE(info->mintermPages);
	for (i = 0; i <= info->nodeDataPage; i++) FREE(info->nodeDataPages[i]);
	FREE(info->nodeDataPages);
	FREE(info->currentNodePage);
	FREE(info->lightNodePages);
	FREE(info->nodePages);
	goto OUT_OF_MEM;
    }

    info->pageIndex = 0;
    num = SubsetCountNodesAux(node,table,info->max,info);
    if (info->memOut) goto OUT_OF_MEM;
    return(num);

OUT_OF_MEM:
    info->memOut = 1;
    return(0);

} /* end of SubsetCountNodes */


/**
  @brief Procedure to recursively store nodes that are retained in the subset.

  @sideeffect None

  @see StoreNodes

*/
static void
StoreNodes(
  st_table * storeTable,
  DdManager * dd,
  DdNode * node)
{
    DdNode *N, *Nt, *Ne;
    if (Cudd_IsConstantInt(dd)) {
	return;
    }
    N = Cudd_Regular(node);
    if (st_is_member(storeTable, N)) {
	return;
    }
    cuddRef(N);
    if (st_insert(storeTable, N, NULL) == ST_OUT_OF_MEM) {
	fprintf(dd->err,"Something wrong, st_table insert failed\n");
    }

    Nt = Cudd_T(N);
    Ne = Cudd_E(N);

    StoreNodes(storeTable, dd, Nt);
    StoreNodes(storeTable, dd, Ne);
    return;

}


/**
  @brief Builds the subset %BDD using the heavy branch method.

  @details The procedure carries out the building of the subset %BDD
  starting at the root. Using the three different counts labelling each node,
  the procedure chooses the heavier branch starting from the root and keeps
  track of the number of nodes it discards at each step, thus keeping count
  of the size of the subset %BDD dynamically. Once the threshold is satisfied,
  the procedure then calls ITE to build the %BDD.

  @sideeffect None

*/
static DdNode *
BuildSubsetBdd(
  DdManager * dd /**< %DD manager */,
  DdNode * node /**< current node */,
  int * size /**< current size of the subset */,
  st_table * visitedTable /**< visited table storing all node data */,
  int threshold /**< subsetting threshold */,
  st_table * storeTable /**< store table */,
  st_table * approxTable /**< approximation table */,
  SubsetInfo_t * info /**< miscellaneous info */)
{

    DdNode *Nv, *Nnv, *N, *topv, *neW;
    double minNv, minNnv;
    NodeData_t *currNodeQual;
    NodeData_t *currNodeQualT;
    NodeData_t *currNodeQualE;
    DdNode *ThenBranch, *ElseBranch;
    int topid;
    void *dummy;

#ifdef DEBUG
    info->num_calls++;
#endif
    /*If the size of the subset is below the threshold, dont do
      anything. */
    if ((*size) <= threshold) {
      /* store nodes below this, so we can recombine if possible */
      StoreNodes(storeTable, dd, node);
      return(node);
    }

    if (Cudd_IsConstantInt(node))
	return(node);

    /* Look up minterm count for this node. */
    if (!st_lookup(visitedTable, node, (void **) &currNodeQual)) {
	fprintf(dd->err,
		"Something is wrong, ought to be in node quality table\n");
    }

    /* Get children. */
    N = Cudd_Regular(node);
    Nv = Cudd_T(N);
    Nnv = Cudd_E(N);

    /* complement if necessary */
    Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
    Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

    if (!Cudd_IsConstantInt(Nv)) {
	/* find out minterms and nodes contributed by then child */
	if (!st_lookup(visitedTable, Nv, (void **) &currNodeQualT)) {
		fprintf(dd->out,"Something wrong, couldnt find nodes in node quality table\n");
		dd->errorCode = CUDD_INTERNAL_ERROR;
		return(NULL);
	    }
	else {
	    minNv = *(((NodeData_t *)currNodeQualT)->mintermPointer);
	}
    } else {
	if (Nv == info->zero) {
	    minNv = 0;
	} else  {
	    minNv = info->max;
	}
    }
    if (!Cudd_IsConstantInt(Nnv)) {
	/* find out minterms and nodes contributed by else child */
	if (!st_lookup(visitedTable, Nnv, (void **) &currNodeQualE)) {
	    fprintf(dd->out,"Something wrong, couldnt find nodes in node quality table\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    return(NULL);
	} else {
	    minNnv = *(((NodeData_t *)currNodeQualE)->mintermPointer);
	}
    } else {
	if (Nnv == info->zero) {
	    minNnv = 0;
	} else {
	    minNnv = info->max;
	}
    }

    /* keep track of size of subset by subtracting the number of
     * differential nodes contributed by lighter child
     */
    *size = (*(size)) - (int)*(currNodeQual->lightChildNodesPointer);
    if (minNv >= minNnv) { /*SubsetCountNodesAux procedure takes
			     the Then branch in case of a tie */

	/* recur with the Then branch */
	ThenBranch = (DdNode *)BuildSubsetBdd(dd, Nv, size, visitedTable,
                                              threshold, storeTable,
                                              approxTable, info);
	if (ThenBranch == NULL) {
	    return(NULL);
	}
	cuddRef(ThenBranch);
	/* The Else branch is either a node that already exists in the
	 * subset, or one whose approximation has been computed, or
	 * Zero.
	 */
	if (st_lookup(storeTable, Cudd_Regular(Nnv), &dummy)) {
            ElseBranch = Nnv;
            cuddRef(ElseBranch);
	} else {
            if (st_lookup(approxTable, Nnv, &dummy)) {
                ElseBranch = (DdNode *)dummy;
                cuddRef(ElseBranch);
            } else {
                ElseBranch = info->zero;
                cuddRef(ElseBranch);
            }
	}

    }
    else {
	/* recur with the Else branch */
	ElseBranch = (DdNode *)BuildSubsetBdd(dd, Nnv, size, visitedTable,
                                              threshold, storeTable,
                                              approxTable, info);
	if (ElseBranch == NULL) {
	    return(NULL);
	}
	cuddRef(ElseBranch);
	/* The Then branch is either a node that already exists in the
	 * subset, or one whose approximation has been computed, or
	 * Zero.
	 */
	if (st_lookup(storeTable, Cudd_Regular(Nv), &dummy)) {
            ThenBranch = Nv;
            cuddRef(ThenBranch);
	} else {
            if (st_lookup(approxTable, Nv, &dummy)) {
                ThenBranch = (DdNode *)dummy;
                cuddRef(ThenBranch);
            } else {
                ThenBranch = info->zero;
                cuddRef(ThenBranch);
            }
	}
    }

    /* construct the Bdd with the top variable and the two children */
    topid = Cudd_NodeReadIndex(N);
    topv = Cudd_ReadVars(dd, topid);
    cuddRef(topv);
    neW =  cuddBddIteRecur(dd, topv, ThenBranch, ElseBranch);
    if (neW != NULL) {
      cuddRef(neW);
    }
    Cudd_RecursiveDeref(dd, topv);
    Cudd_RecursiveDeref(dd, ThenBranch);
    Cudd_RecursiveDeref(dd, ElseBranch);


    if (neW == NULL)
	return(NULL);
    else {
	/* store this node in the store table */
	if (!st_lookup(storeTable, Cudd_Regular(neW), &dummy)) {
            cuddRef(neW);
            if (st_insert(storeTable, Cudd_Regular(neW), NULL) ==
                ST_OUT_OF_MEM)
                return (NULL);
	}
	/* store the approximation for this node */
	if (N !=  Cudd_Regular(neW)) {
	    if (st_lookup(approxTable, node, &dummy)) {
		fprintf(dd->err, "This node should not be in the approximated table\n");
	    } else {
		cuddRef(neW);
		if (st_insert(approxTable, node, neW) ==
                    ST_OUT_OF_MEM)
		    return(NULL);
	    }
	}
	cuddDeref(neW);
	return(neW);
    }
} /* end of BuildSubsetBdd */

cuddSubsetSP.c
53495
/**
  @file

  @ingroup cudd

  @brief Procedure to subset the given %BDD choosing the shortest paths
  (largest cubes) in the %BDD.

  @see cuddSubsetHB.c

  @author Kavita Ravi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define DEFAULT_PAGE_SIZE 2048 /* page size to store the BFS queue element type */
#define DEFAULT_NODE_DIST_PAGE_SIZE 2048 /*  page size to store NodeDist_t type */
#define MAXSHORTINT	((DdHalfWord) ~0) /* constant defined to store
					   * maximum distance of a node
					   * from the root or the constant
					   */
#define INITIAL_PAGES 128 /* number of initial pages for the
			   * queue/NodeDist_t type */

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief structure created to store subset results for each node and
 * distances with odd and even parity of the node from the root and
 * sink.
 *
 * Main data structure in this procedure.
 */
struct NodeDist {
    DdHalfWord oddTopDist;
    DdHalfWord evenTopDist;
    DdHalfWord oddBotDist;
    DdHalfWord evenBotDist;
    DdNode *regResult;
    DdNode *compResult;
};

/**
   @brief assorted information needed by the BuildSubsetBdd procedure.
*/
struct AssortedInfo {
    unsigned int maxpath;
    int findShortestPath;
    int thresholdReached;
    st_table *maxpathTable;
    int threshold;
};

/**
 * @brief Bookkeeping data structure for subsetting algorithm.
 */
struct GlobalInfo {
    struct NodeDist **nodeDistPages; /**< pointers to the pages */
    int		nodeDistPageIndex; /**< index to next element */
    int		nodeDistPage; /**< index to current page */
    int		nodeDistPageSize; /**< page size */
    int		maxNodeDistPages; /**< number of page pointers */
    struct NodeDist *currentNodeDistPage; /**< current page */
    DdNode      ***queuePages; /**< pointers to the pages */
    int		queuePageIndex;	/**< index to next element */
    int		queuePage; /**< index to current page */
    int		queuePageSize; /**< page size */
    int		maxQueuePages; /**< number of page pointers */
    DdNode      **currentQueuePage; /**< current page */
#ifdef DD_DEBUG
    int         numCalls;
    int         hits;
    int         thishit;
#endif
};

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef struct NodeDist NodeDist_t;
typedef struct GlobalInfo GlobalInfo_t;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void ResizeNodeDistPages (DdManager *dd, GlobalInfo_t *gInfo);
static void ResizeQueuePages (DdManager *dd, GlobalInfo_t *gInfo);
static void CreateTopDist (DdManager *dd, GlobalInfo_t *gInfo, st_table *pathTable, int parentPage, int parentQueueIndex, int topLen, DdNode **childPage, int childQueueIndex, int numParents, FILE *fp);
static int CreateBotDist (DdNode *node, st_table *pathTable, unsigned int *pathLengthArray, FILE *fp);
static st_table * CreatePathTable (DdManager *dd, GlobalInfo_t *gInfo, DdNode *node, unsigned int *pathLengthArray, FILE *fp);
static unsigned int AssessPathLength (unsigned int *pathLengthArray, int threshold, int numVars, unsigned int *excess, FILE *fp);
static DdNode * BuildSubsetBdd (DdManager *dd, GlobalInfo_t *gInfo, st_table *pathTable, DdNode *node, struct AssortedInfo *info, st_table *subsetNodeTable);
static enum st_retval stPathTableDdFree (void *key, void *value, void *arg);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of Exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Extracts a dense subset from a %BDD with the shortest paths
  heuristic.

  @details This procedure tries to preserve the shortest paths of the
  input %BDD, because they give many minterms and contribute few nodes.
  This procedure may increase the number of nodes in trying to create
  the subset or reduce the number of nodes due to recombination as
  compared to the original %BDD. Hence the threshold may not be
  strictly adhered to. In practice, recombination overshadows the
  increase in the number of nodes and results in small BDDs as
  compared to the threshold. The hardlimit specifies whether threshold
  needs to be strictly adhered to. If it is set to 1, the procedure
  ensures that result is never larger than the specified limit but may
  be considerably less than the threshold.  The value for numVars
  should be as close as possible to the size of the support of f for
  better efficiency. However, it is safe to pass the value returned by
  Cudd_ReadSize for numVars. If 0 is passed, then the value returned
  by Cudd_ReadSize is used.

  @return a pointer to the %BDD for the subset if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_SupersetShortPaths Cudd_SubsetHeavyBranch Cudd_ReadSize

*/
DdNode *
Cudd_SubsetShortPaths(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be subset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< maximum number of nodes in the subset */,
  int  hardlimit /**< flag: 1 if threshold is a hard limit */)
{
    DdNode *subset;

    do {
	dd->reordered = 0;
	subset = cuddSubsetShortPaths(dd, f, numVars, threshold, hardlimit);
    } while(dd->reordered == 1);

    return(subset);

} /* end of Cudd_SubsetShortPaths */


/**
  @brief Extracts a dense superset from a %BDD with the shortest paths
  heuristic.

  @details The procedure is identical to the subset procedure except
  for the fact that it receives the complement of the given
  function. Extracting the subset of the complement function is
  equivalent to extracting the superset of the function.  This
  procedure tries to preserve the shortest paths of the complement
  %BDD, because they give many minterms and contribute few nodes.  This
  procedure may increase the number of nodes in trying to create the
  superset or reduce the number of nodes due to recombination as
  compared to the original %BDD. Hence the threshold may not be
  strictly adhered to. In practice, recombination overshadows the
  increase in the number of nodes and results in small BDDs as
  compared to the threshold.  The hardlimit specifies whether
  threshold needs to be strictly adhered to. If it is set to 1, the
  procedure ensures that result is never larger than the specified
  limit but may be considerably less than the threshold.  The value
  for numVars should be as close as possible to the size of the
  support of f for better efficiency.  However, it is safe to pass the
  value returned by Cudd_ReadSize for numVar.  If 0 is passed, then
  the value returned by Cudd_ReadSize is used.

  @return a pointer to the %BDD for the superset if successful; NULL
  otherwise.
  
  @sideeffect None

  @see Cudd_SubsetShortPaths Cudd_SupersetHeavyBranch Cudd_ReadSize

*/
DdNode *
Cudd_SupersetShortPaths(
  DdManager * dd /**< manager */,
  DdNode * f /**< function to be superset */,
  int  numVars /**< number of variables in the support of f */,
  int  threshold /**< maximum number of nodes in the subset */,
  int  hardlimit /**< flag: 1 if threshold is a hard limit */)
{
    DdNode *subset, *g;

    g = Cudd_Not(f);
    do {
	dd->reordered = 0;
	subset = cuddSubsetShortPaths(dd, g, numVars, threshold, hardlimit);
    } while(dd->reordered == 1);

    return(Cudd_NotCond(subset, (subset != NULL)));

} /* end of Cudd_SupersetShortPaths */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief The outermost procedure to return a subset of the given %BDD
  with the shortest path lengths.

  @details The path lengths are calculated, the maximum allowable path
  length is determined and the number of nodes of this path length
  that can be used to build a subset. If the threshold is larger than
  the size of the original %BDD, the original %BDD is returned.

  @sideeffect None

  @see Cudd_SubsetShortPaths

*/
DdNode *
cuddSubsetShortPaths(
  DdManager * dd /**< %DD manager */,
  DdNode * f /**< function to be subset */,
  int  numVars /**< total number of variables in consideration */,
  int  threshold /**< maximum number of nodes allowed in the subset */,
  int  hardlimit /**< flag determining whether threshold should be respected strictly */)
{
    GlobalInfo_t gInfo;
    st_table *pathTable;
    DdNode *N, *subset;

    unsigned int  *pathLengthArray;
    unsigned int maxpath, oddLen, evenLen, pathLength, *excess;
    int i;
    NodeDist_t	*nodeStat;
    struct AssortedInfo *info;
    st_table *subsetNodeTable;

    gInfo.nodeDistPageSize = DEFAULT_NODE_DIST_PAGE_SIZE;
    gInfo.queuePageSize = DEFAULT_PAGE_SIZE;

    if (numVars == 0) {
      /* set default value */
      numVars = Cudd_ReadSize(dd);
    }

    if (threshold > numVars) {
	threshold = threshold - numVars;
    }
    if (f == NULL) {
	fprintf(dd->err, "Cannot partition, nil object\n");
	dd->errorCode = CUDD_INVALID_ARG;
	return(NULL);
    }
    if (Cudd_IsConstantInt(f))
	return (f);

    pathLengthArray = ALLOC(unsigned int, numVars+1);
    for (i = 0; i < numVars+1; i++) pathLengthArray[i] = 0;


#ifdef DD_DEBUG
    gInfo.numCalls = 0;
#endif

    pathTable = CreatePathTable(dd, &gInfo, f, pathLengthArray, dd->err);

    if ((pathTable == NULL) || (dd->errorCode == CUDD_MEMORY_OUT)) {
	if (pathTable != NULL)
	    st_free_table(pathTable);
	FREE(pathLengthArray);
	return (NIL(DdNode));
    }

    excess = ALLOC(unsigned int, 1);
    *excess = 0;
    maxpath = AssessPathLength(pathLengthArray, threshold, numVars, excess,
			       dd->err);

    if (maxpath != (unsigned) (numVars + 1)) {

	info = ALLOC(struct AssortedInfo, 1);
	info->maxpath = maxpath;
	info->findShortestPath = 0;
	info->thresholdReached = *excess;
	info->maxpathTable = st_init_table(st_ptrcmp, st_ptrhash);
	info->threshold = threshold;

#ifdef DD_DEBUG
	(void) fprintf(dd->out, "Path length array\n");
	for (i = 0; i < (numVars+1); i++) {
	    if (pathLengthArray[i])
		(void) fprintf(dd->out, "%d ",i);
	}
	(void) fprintf(dd->out, "\n");
	for (i = 0; i < (numVars+1); i++) {
	    if (pathLengthArray[i])
		(void) fprintf(dd->out, "%d ",pathLengthArray[i]);
	}
	(void) fprintf(dd->out, "\n");
	(void) fprintf(dd->out, "Maxpath  = %d, Thresholdreached = %d\n",
		       maxpath, info->thresholdReached);
#endif

	N = Cudd_Regular(f);
	if (!st_lookup(pathTable, N, (void **) &nodeStat)) {
	    fprintf(dd->err, "Something wrong, root node must be in table\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    FREE(excess);
	    FREE(info);
	    return(NULL);
	} else {
	    if ((nodeStat->oddTopDist != MAXSHORTINT) &&
		(nodeStat->oddBotDist != MAXSHORTINT))
		oddLen = (nodeStat->oddTopDist + nodeStat->oddBotDist);
	    else
		oddLen = MAXSHORTINT;

	    if ((nodeStat->evenTopDist != MAXSHORTINT) &&
		(nodeStat->evenBotDist != MAXSHORTINT))
		evenLen = (nodeStat->evenTopDist +nodeStat->evenBotDist);
	    else
		evenLen = MAXSHORTINT;

	    pathLength = (oddLen <= evenLen) ? oddLen : evenLen;
	    if (pathLength > maxpath) {
		(void) fprintf(dd->err, "All computations are bogus, since root has path length greater than max path length within threshold %u, %u\n", maxpath, pathLength);
		dd->errorCode = CUDD_INTERNAL_ERROR;
		return(NULL);
	    }
	}

#ifdef DD_DEBUG
	gInfo.numCalls = 0;
	gInfo.hits = 0;
	gInfo.thishit = 0;
#endif
	/* initialize a table to store computed nodes */
	if (hardlimit) {
	    subsetNodeTable = st_init_table(st_ptrcmp, st_ptrhash);
	} else {
	    subsetNodeTable = NIL(st_table);
	}
	subset = BuildSubsetBdd(dd, &gInfo, pathTable, f, info, subsetNodeTable);
	if (subset != NULL) {
	    cuddRef(subset);
	}
	/* record the number of times a computed result for a node is hit */

#ifdef DD_DEBUG
	(void) fprintf(dd->out, "Hits = %d, New==Node = %d, NumCalls = %d\n",
		gInfo.hits, gInfo.thishit, gInfo.numCalls);
#endif

	if (subsetNodeTable != NIL(st_table)) {
	    st_free_table(subsetNodeTable);
	}
	st_free_table(info->maxpathTable);
	st_foreach(pathTable, stPathTableDdFree, (void *)dd);

	FREE(info);

    } else {/* if threshold larger than size of dd */
	subset = f;
	cuddRef(subset);
    }
    FREE(excess);
    st_free_table(pathTable);
    FREE(pathLengthArray);
    for (i = 0; i <= gInfo.nodeDistPage; i++) FREE(gInfo.nodeDistPages[i]);
    FREE(gInfo.nodeDistPages);

#ifdef DD_DEBUG
    /* check containment of subset in f */
    if (subset != NULL) {
	if (!Cudd_bddLeq(dd, subset, f)) {
	    (void) fprintf(dd->err, "Wrong partition\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    return(NULL);
	}
    }
#endif

    if (subset != NULL) {
	cuddDeref(subset);
	return(subset);
    } else {
	return(NULL);
    }

} /* end of cuddSubsetShortPaths */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Resize the number of pages allocated to store the distances
  related to each node.

  @details The procedure moves the counter to the next page when the
  end of the page is reached and allocates new pages when necessary.

  @sideeffect Changes the size of  pages, page, page index, maximum
  number of pages freeing stuff in case of memory out. 

*/
static void
ResizeNodeDistPages(
  DdManager *dd /**< %DD manager */,
  GlobalInfo_t *gInfo /**< global information */)
{
    int i;
    NodeDist_t **newNodeDistPages;

    /* move to next page */
    gInfo->nodeDistPage++;

    /* If the current page index is larger than the number of pages
     * allocated, allocate a new page array. Page numbers are incremented by
     * INITIAL_PAGES
     */
    if (gInfo->nodeDistPage == gInfo->maxNodeDistPages) {
	newNodeDistPages = ALLOC(NodeDist_t *,gInfo->maxNodeDistPages + INITIAL_PAGES);
	if (newNodeDistPages == NULL) {
	    for (i = 0; i < gInfo->nodeDistPage; i++) FREE(gInfo->nodeDistPages[i]);
	    FREE(gInfo->nodeDistPages);
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return;
	} else {
	    for (i = 0; i < gInfo->maxNodeDistPages; i++) {
		newNodeDistPages[i] = gInfo->nodeDistPages[i];
	    }
	    /* Increase total page count */
	    gInfo->maxNodeDistPages += INITIAL_PAGES;
	    FREE(gInfo->nodeDistPages);
	    gInfo->nodeDistPages = newNodeDistPages;
	}
    }
    /* Allocate a new page */
    gInfo->currentNodeDistPage = gInfo->nodeDistPages[gInfo->nodeDistPage] =
        ALLOC(NodeDist_t, gInfo->nodeDistPageSize);
    if (gInfo->currentNodeDistPage == NULL) {
	for (i = 0; i < gInfo->nodeDistPage; i++) FREE(gInfo->nodeDistPages[i]);
	FREE(gInfo->nodeDistPages);
	dd->errorCode = CUDD_MEMORY_OUT;
	return;
    }
    /* reset page index */
    gInfo->nodeDistPageIndex = 0;
    return;

} /* end of ResizeNodeDistPages */


/**
  @brief Resize the number of pages allocated to store nodes in the BFS
  traversal of the %BDD.

  @details The procedure moves the counter to the next page when the
  end of the page is reached and allocates new pages when necessary.

  @sideeffect Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out. 

*/
static void
ResizeQueuePages(
  DdManager *dd /**< %DD manager */,
  GlobalInfo_t *gInfo /**< global information */)
{
    int i;
    DdNode ***newQueuePages;

    gInfo->queuePage++;
    /* If the current page index is larger than the number of pages
     * allocated, allocate a new page array. Page numbers are incremented by
     * INITIAL_PAGES
     */
    if (gInfo->queuePage == gInfo->maxQueuePages) {
	newQueuePages = ALLOC(DdNode **,gInfo->maxQueuePages + INITIAL_PAGES);
	if (newQueuePages == NULL) {
	    for (i = 0; i < gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
	    FREE(gInfo->queuePages);
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return;
	} else {
	    for (i = 0; i < gInfo->maxQueuePages; i++) {
		newQueuePages[i] = gInfo->queuePages[i];
	    }
	    /* Increase total page count */
	    gInfo->maxQueuePages += INITIAL_PAGES;
	    FREE(gInfo->queuePages);
	    gInfo->queuePages = newQueuePages;
	}
    }
    /* Allocate a new page */
    gInfo->currentQueuePage = gInfo->queuePages[gInfo->queuePage] =
        ALLOC(DdNode *,gInfo->queuePageSize);
    if (gInfo->currentQueuePage == NULL) {
	for (i = 0; i < gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
	FREE(gInfo->queuePages);
	dd->errorCode = CUDD_MEMORY_OUT;
	return;
    }
    /* reset page index */
    gInfo->queuePageIndex = 0;
    return;

} /* end of ResizeQueuePages */


/**
  @brief Labels each node with its shortest distance from the root.

  @details This is done in a BFS search of the %BDD. The nodes are
  processed in a queue implemented as pages(array) to reduce memory
  fragmentation.  An entry is created for each node visited. The
  distance from the root to the node with the corresponding parity is
  updated. The procedure is called recursively each recusion level
  handling nodes at a given level from the root.

  @sideeffect Creates entries in the pathTable

  @see CreatePathTable CreateBotDist

*/
static void
CreateTopDist(
  DdManager *dd /**< %DD manager */,
  GlobalInfo_t *gInfo /**< global information */,
  st_table * pathTable /**< hash table to store path lengths */,
  int  parentPage /**< the pointer to the page on which the first parent in the queue is to be found. */,
  int  parentQueueIndex /**< pointer to the first parent on the page */,
  int  topLen /**< current distance from the root */,
  DdNode ** childPage /**< pointer to the page on which the first child is to be added. */,
  int  childQueueIndex /**< pointer to the first child */,
  int  numParents /**< number of parents to process in this recursive call */,
  FILE *fp /**< where to write messages */)
{
    NodeDist_t *nodeStat;
    DdNode *N, *Nv, *Nnv, *node, *child, *regChild;
    int  i;
    int processingDone, childrenCount;

#ifdef DD_DEBUG
    gInfo->numCalls++;

    /* assume this procedure comes in with only the root node*/
    /* set queue index to the next available entry for addition */
    /* set queue page to page of addition */
    if ((gInfo->queuePages[parentPage] == childPage) && (parentQueueIndex ==
						  childQueueIndex)) {
	fprintf(fp, "Should not happen that they are equal\n");
    }
    assert(gInfo->queuePageIndex == childQueueIndex);
    assert(gInfo->currentQueuePage == childPage);
#endif
    /* number children added to queue is initialized , needed for
     * numParents in the next call
     */
    childrenCount = 0;
    /* process all the nodes in this level */
    while (numParents) {
	numParents--;
	if (parentQueueIndex == gInfo->queuePageSize) {
	    parentPage++;
	    parentQueueIndex = 0;
	}
	/* a parent to process */
	node = *(gInfo->queuePages[parentPage] + parentQueueIndex);
	parentQueueIndex++;
	/* get its children */
	N = Cudd_Regular(node);
	Nv = Cudd_T(N);
	Nnv = Cudd_E(N);

	Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
	Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

	processingDone = 2;
	while (processingDone) {
	    /* processing the THEN and the ELSE children, the THEN
	     * child first
	     */
	    if (processingDone == 2) {
		child = Nv;
	    } else {
		child = Nnv;
	    }

	    regChild = Cudd_Regular(child);
	    /* dont process if the child is a constant */
	    if (!Cudd_IsConstantInt(child)) {
		/* check is already visited, if not add a new entry in
		 * the path Table
		 */
                if (!st_lookup(pathTable, regChild, (void **) &nodeStat)) {
		    /* if not in table, has never been visited */
		    /* create entry for table */
		    if (gInfo->nodeDistPageIndex == gInfo->nodeDistPageSize)
			ResizeNodeDistPages(dd, gInfo);
		    if (dd->errorCode == CUDD_MEMORY_OUT) {
			for (i = 0; i <= gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
			FREE(gInfo->queuePages);
			st_free_table(pathTable);
			return;
		    }
		    /* New entry for child in path Table is created here */
		    nodeStat = gInfo->currentNodeDistPage + gInfo->nodeDistPageIndex;
		    gInfo->nodeDistPageIndex++;

		    /* Initialize fields of the node data */
		    nodeStat->oddTopDist = MAXSHORTINT;
		    nodeStat->evenTopDist = MAXSHORTINT;
		    nodeStat->evenBotDist = MAXSHORTINT;
		    nodeStat->oddBotDist = MAXSHORTINT;
		    nodeStat->regResult = NULL;
		    nodeStat->compResult = NULL;
		    /* update the table entry element, the distance keeps
		     * track of the parity of the path from the root
		     */
		    if (Cudd_IsComplement(child)) {
			nodeStat->oddTopDist = (DdHalfWord) topLen + 1;
		    } else {
			nodeStat->evenTopDist = (DdHalfWord) topLen + 1;
		    }

		    /* insert entry element for child in the table */
		    if (st_insert(pathTable, regChild,
				  nodeStat) == ST_OUT_OF_MEM) {
			dd->errorCode = CUDD_MEMORY_OUT;
			for (i = 0; i <= gInfo->nodeDistPage; i++)
			    FREE(gInfo->nodeDistPages[i]);
			FREE(gInfo->nodeDistPages);
			for (i = 0; i <= gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
			FREE(gInfo->queuePages);
			st_free_table(pathTable);
			return;
		    }

		    /* Create list element for this child to process its children.
		     * If this node has been processed already, then it appears
		     * in the path table and hence is never added to the list
		     * again.
		     */

		    if (gInfo->queuePageIndex == gInfo->queuePageSize) ResizeQueuePages(dd, gInfo);
		    if (dd->errorCode == CUDD_MEMORY_OUT) {
			for (i = 0; i <= gInfo->nodeDistPage; i++)
			    FREE(gInfo->nodeDistPages[i]);
			FREE(gInfo->nodeDistPages);
			st_free_table(pathTable);
			return;
		    }
		    *(gInfo->currentQueuePage + gInfo->queuePageIndex) = child;
		    gInfo->queuePageIndex++;

		    childrenCount++;
		} else {
		    /* if not been met in a path with this parity before */
		    /* put in list */
		    if (((Cudd_IsComplement(child)) && (nodeStat->oddTopDist ==
			  MAXSHORTINT)) || ((!Cudd_IsComplement(child)) &&
				  (nodeStat->evenTopDist == MAXSHORTINT))) {

			if (gInfo->queuePageIndex == gInfo->queuePageSize) ResizeQueuePages(dd, gInfo);
			if (dd->errorCode == CUDD_MEMORY_OUT) {
			    for (i = 0; i <= gInfo->nodeDistPage; i++)
				FREE(gInfo->nodeDistPages[i]);
			    FREE(gInfo->nodeDistPages);
			    st_free_table(pathTable);
			    return;

			}
			*(gInfo->currentQueuePage + gInfo->queuePageIndex) = child;
			gInfo->queuePageIndex++;

			/* update the distance with the appropriate parity */
			if (Cudd_IsComplement(child)) {
			    nodeStat->oddTopDist = (DdHalfWord) topLen + 1;
			} else {
			    nodeStat->evenTopDist = (DdHalfWord) topLen + 1;
			}
			childrenCount++;
		    }

		} /* end of else (not found in st_table) */
	    } /*end of if Not constant child */
	    processingDone--;
	} /*end of while processing Nv, Nnv */
    }  /*end of while numParents */

#ifdef DD_DEBUG
    assert(gInfo->queuePages[parentPage] == childPage);
    assert(parentQueueIndex == childQueueIndex);
#endif

    if (childrenCount != 0) {
	topLen++;
	childPage = gInfo->currentQueuePage;
	childQueueIndex = gInfo->queuePageIndex;
	CreateTopDist(dd, gInfo, pathTable, parentPage, parentQueueIndex, topLen,
		      childPage, childQueueIndex, childrenCount, fp);
    }

    return;

} /* end of CreateTopDist */


/**
  @brief Labels each node with the shortest distance from the constant.

  @details This is done in a DFS search of the %BDD. Each node has an
  odd and even parity distance from the sink (since there exists paths
  to both zero and one) which is less than MAXSHORTINT. At each node
  these distances are updated using the minimum distance of its
  children from the constant.  SInce now both the length from the root
  and child is known, the minimum path length(length of the shortest
  path between the root and the constant that this node lies on) of
  this node can be calculated and used to update the pathLengthArray.

  @sideeffect Updates Path Table and path length array

  @see CreatePathTable CreateTopDist AssessPathLength

*/
static int
CreateBotDist(
  DdNode * node /* current node */,
  st_table * pathTable /* path table with path lengths */,
  unsigned int * pathLengthArray /* array that stores number of nodes belonging to a particular path length. */,
  FILE *fp /* where to write messages */)
{
    DdNode *N, *Nv, *Nnv;
    DdNode *realChild;
    DdNode *child, *regChild;
    NodeDist_t *nodeStat, *nodeStatChild;
    unsigned int  oddLen, evenLen, pathLength;
    DdHalfWord botDist;
    int processingDone;

    if (Cudd_IsConstantInt(node))
	return(1);
    N = Cudd_Regular(node);
    /* each node has one table entry */
    /* update as you go down the min dist of each node from
       the root in each (odd and even) parity */
    if (!st_lookup(pathTable, N, (void **) &nodeStat)) {
	fprintf(fp, "Something wrong, the entry doesn't exist\n");
	return(0);
    }

    /* compute length of odd parity distances */
    if ((nodeStat->oddTopDist != MAXSHORTINT) &&
	(nodeStat->oddBotDist != MAXSHORTINT))
	oddLen = (nodeStat->oddTopDist + nodeStat->oddBotDist);
    else
	oddLen = MAXSHORTINT;

    /* compute length of even parity distances */
    if (!((nodeStat->evenTopDist == MAXSHORTINT) ||
	  (nodeStat->evenBotDist == MAXSHORTINT)))
	evenLen = (nodeStat->evenTopDist +nodeStat->evenBotDist);
    else
	evenLen = MAXSHORTINT;

    /* assign pathlength to minimum of the two */
    pathLength = (oddLen <= evenLen) ? oddLen : evenLen;

    Nv = Cudd_T(N);
    Nnv = Cudd_E(N);

    /* process each child */
    processingDone = 0;
    while (processingDone != 2) {
	if (!processingDone) {
	    child = Nv;
	} else {
	    child = Nnv;
	}

	realChild = Cudd_NotCond(child, Cudd_IsComplement(node));
	regChild = Cudd_Regular(child);
	if (Cudd_IsConstantInt(realChild)) {
	    /* Found a minterm; count parity and shortest distance
	    ** from the constant.
	    */
	    if (Cudd_IsComplement(child))
		nodeStat->oddBotDist = 1;
	    else
		nodeStat->evenBotDist = 1;
	} else {
	    /* If node not in table, recur. */
            if (!st_lookup(pathTable, regChild, (void **) &nodeStatChild)) {
		fprintf(fp, "Something wrong, node in table should have been created in top dist proc.\n");
		return(0);
	    }

	    if (nodeStatChild->oddBotDist == MAXSHORTINT) {
		if (nodeStatChild->evenBotDist == MAXSHORTINT) {
		    if (!CreateBotDist(realChild, pathTable, pathLengthArray, fp))
			return(0);
		} else {
		    fprintf(fp, "Something wrong, both bot nodeStats should be there\n");
		    return(0);
		}
	    }

	    /* Update shortest distance from the constant depending on
	    **  parity. */

	    if (Cudd_IsComplement(child)) {
		/* If parity on the edge then add 1 to even distance
		** of child to get odd parity distance and add 1 to
		** odd distance of child to get even parity
		** distance. Change distance of current node only if
		** the calculated distance is less than existing
		** distance. */
		if (nodeStatChild->oddBotDist != MAXSHORTINT)
		    botDist = nodeStatChild->oddBotDist + 1;
		else
		    botDist = MAXSHORTINT;
		if (nodeStat->evenBotDist > botDist )
		    nodeStat->evenBotDist = botDist;

		if (nodeStatChild->evenBotDist != MAXSHORTINT)
		    botDist = nodeStatChild->evenBotDist + 1;
		else
		    botDist = MAXSHORTINT;
		if (nodeStat->oddBotDist > botDist)
		    nodeStat->oddBotDist = botDist;

	    } else {
		/* If parity on the edge then add 1 to even distance
		** of child to get even parity distance and add 1 to
		** odd distance of child to get odd parity distance.
		** Change distance of current node only if the
		** calculated distance is lesser than existing
		** distance. */
		if (nodeStatChild->evenBotDist != MAXSHORTINT)
		    botDist = nodeStatChild->evenBotDist + 1;
		else
		    botDist = MAXSHORTINT;
		if (nodeStat->evenBotDist > botDist)
		    nodeStat->evenBotDist = botDist;

		if (nodeStatChild->oddBotDist != MAXSHORTINT)
		    botDist = nodeStatChild->oddBotDist + 1;
		else
		    botDist = MAXSHORTINT;
		if (nodeStat->oddBotDist > botDist)
		    nodeStat->oddBotDist = botDist;
	    }
	} /* end of else (if not constant child ) */
	processingDone++;
    } /* end of while processing Nv, Nnv */

    /* Compute shortest path length on the fly. */
    if ((nodeStat->oddTopDist != MAXSHORTINT) &&
	(nodeStat->oddBotDist != MAXSHORTINT))
	oddLen = (nodeStat->oddTopDist + nodeStat->oddBotDist);
    else
	oddLen = MAXSHORTINT;

    if ((nodeStat->evenTopDist != MAXSHORTINT) &&
	(nodeStat->evenBotDist != MAXSHORTINT))
	evenLen = (nodeStat->evenTopDist +nodeStat->evenBotDist);
    else
	evenLen = MAXSHORTINT;

    /* Update path length array that has number of nodes of a particular
    ** path length. */
    if (oddLen < pathLength ) {
	if (pathLength != MAXSHORTINT)
	    pathLengthArray[pathLength]--;
	if (oddLen != MAXSHORTINT)
	    pathLengthArray[oddLen]++;
	pathLength = oddLen;
    }
    if (evenLen < pathLength ) {
	if (pathLength != MAXSHORTINT)
	    pathLengthArray[pathLength]--;
	if (evenLen != MAXSHORTINT)
	    pathLengthArray[evenLen]++;
    }

    return(1);

} /*end of CreateBotDist */


/**
  @brief The outer procedure to label each node with its shortest
  distance from the root and constant

  @details Calls CreateTopDist and CreateBotDist.  The basis for
  computing the distance between root and constant is that the
  distance may be the sum of even distances from the node to the root
  and constant or the sum of odd distances from the node to the root
  and constant.  Both CreateTopDist and CreateBotDist create the odd
  and even parity distances from the root and constant respectively.

  @sideeffect None

  @see CreateTopDist CreateBotDist

*/
static st_table *
CreatePathTable(
  DdManager *dd /**< %DD manager */,
  GlobalInfo_t *gInfo /**< global information */,
  DdNode * node /**< root of function */,
  unsigned int * pathLengthArray /**< array of path lengths to store nodes labeled with the various path lengths */,
  FILE *fp /**< where to write messages */)
{
    st_table *pathTable;
    NodeDist_t *nodeStat;
    DdHalfWord topLen;
    DdNode *N;
    int i, numParents;
    int insertValue;
    DdNode **childPage;
    int parentPage;
    int childQueueIndex, parentQueueIndex;

    /* Creating path table for storing data about nodes */
    pathTable = st_init_table(st_ptrcmp,st_ptrhash);

    /* Initializing pages for info about each node */
    gInfo->maxNodeDistPages = INITIAL_PAGES;
    gInfo->nodeDistPages = ALLOC(NodeDist_t *, gInfo->maxNodeDistPages);
    if (gInfo->nodeDistPages == NULL) {
	goto OUT_OF_MEM;
    }
    assert(gInfo->nodeDistPageSize > 0);
    gInfo->nodeDistPage = 0;
    gInfo->currentNodeDistPage = gInfo->nodeDistPages[gInfo->nodeDistPage] =
	ALLOC(NodeDist_t, gInfo->nodeDistPageSize);
    if (gInfo->currentNodeDistPage == NULL) {
	for (i = 0; i <= gInfo->nodeDistPage; i++) FREE(gInfo->nodeDistPages[i]);
	FREE(gInfo->nodeDistPages);
	goto OUT_OF_MEM;
    }
    gInfo->nodeDistPageIndex = 0;

    /* Initializing pages for the BFS search queue, implemented as an array. */
    gInfo->maxQueuePages = INITIAL_PAGES;
    gInfo->queuePages = ALLOC(DdNode **, gInfo->maxQueuePages);
    if (gInfo->queuePages == NULL) {
	goto OUT_OF_MEM;
    }
    assert(gInfo->queuePageSize > 0);
    gInfo->queuePage = 0;
    gInfo->currentQueuePage  = gInfo->queuePages[gInfo->queuePage] =
        ALLOC(DdNode *, gInfo->queuePageSize);
    if (gInfo->currentQueuePage == NULL) {
	for (i = 0; i <= gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
	FREE(gInfo->queuePages);
	goto OUT_OF_MEM;
    }
    gInfo->queuePageIndex = 0;

    /* Enter the root node into the queue to start with. */
    parentPage = gInfo->queuePage;
    parentQueueIndex = gInfo->queuePageIndex;
    topLen = 0;
    *(gInfo->currentQueuePage + gInfo->queuePageIndex) = node;
    gInfo->queuePageIndex++;
    childPage = gInfo->currentQueuePage;
    childQueueIndex = gInfo->queuePageIndex;

    N = Cudd_Regular(node);

    if (gInfo->nodeDistPageIndex == gInfo->nodeDistPageSize)
        ResizeNodeDistPages(dd, gInfo);
    if (dd->errorCode == CUDD_MEMORY_OUT) {
        if (gInfo->nodeDistPages != NULL) {
            for (i = 0; i <= gInfo->nodeDistPage; i++)
                FREE(gInfo->nodeDistPages[i]);
            FREE(gInfo->nodeDistPages);
        }
	for (i = 0; i <= gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
	FREE(gInfo->queuePages);
	st_free_table(pathTable);
	goto OUT_OF_MEM;
    }

    nodeStat = gInfo->currentNodeDistPage + gInfo->nodeDistPageIndex;
    gInfo->nodeDistPageIndex++;

    nodeStat->oddTopDist = MAXSHORTINT;
    nodeStat->evenTopDist = MAXSHORTINT;
    nodeStat->evenBotDist = MAXSHORTINT;
    nodeStat->oddBotDist = MAXSHORTINT;
    nodeStat->regResult = NULL;
    nodeStat->compResult = NULL;

    insertValue = st_insert(pathTable, N, nodeStat);
    if (insertValue == ST_OUT_OF_MEM) {
	dd->errorCode = CUDD_MEMORY_OUT;
	for (i = 0; i <= gInfo->nodeDistPage; i++) FREE(gInfo->nodeDistPages[i]);
	FREE(gInfo->nodeDistPages);
	for (i = 0; i <= gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
	FREE(gInfo->queuePages);
	st_free_table(pathTable);
	goto OUT_OF_MEM;
    } else if (insertValue == 1) {
	fprintf(fp, "Something wrong, the entry exists but didnt show up in st_lookup\n");
	return(NULL);
    }

    if (Cudd_IsComplement(node)) {
	nodeStat->oddTopDist = 0;
    } else {
	nodeStat->evenTopDist = 0;
    }
    numParents = 1;
    /* call the function that counts the distance of each node from the
     * root
     */
#ifdef DD_DEBUG
    gInfo->numCalls = 0;
#endif
    CreateTopDist(dd, gInfo, pathTable, parentPage, parentQueueIndex, (int) topLen,
		  childPage, childQueueIndex, numParents, fp);
    if (dd->errorCode == CUDD_MEMORY_OUT) {
	fprintf(fp, "Out of Memory and cant count path lengths\n");
	goto OUT_OF_MEM;
    }

#ifdef DD_DEBUG
    gInfo->numCalls = 0;
#endif
    /* call the function that counts the distance of each node from the
     * constant
     */
    if (!CreateBotDist(node, pathTable, pathLengthArray, fp)) return(NULL);

    /* free BFS queue pages as no longer required */
    for (i = 0; i <= gInfo->queuePage; i++) FREE(gInfo->queuePages[i]);
    FREE(gInfo->queuePages);
    return(pathTable);

OUT_OF_MEM:
    (void) fprintf(fp, "Out of Memory, cannot allocate pages\n");
    dd->errorCode = CUDD_MEMORY_OUT;
    return(NULL);

} /*end of CreatePathTable */


/**
  @brief Chooses the maximum allowable path length of nodes under the
  threshold.

  @details The corner cases are when the threshold is larger than the
  number of nodes in the %BDD iself, in which case 'numVars + 1' is
  returned.  If all nodes of a particular path length are needed, then
  the maxpath returned is the next one with excess nodes = 0.

  @sideeffect None

*/
static unsigned int
AssessPathLength(
  unsigned int * pathLengthArray /* array determining number of nodes belonging to the different path lengths */,
  int  threshold /* threshold to determine maximum allowable nodes in the subset */,
  int  numVars /* maximum number of variables */,
  unsigned int * excess /* number of nodes labeled maxpath required in the subset */,
  FILE *fp /* where to write messages */)
{
    unsigned int i, maxpath;
    int temp;

    temp = threshold;
    i = 0;
    maxpath = 0;
    /* quit loop if i reaches max number of variables or if temp reaches
     * below zero
     */
    while ((i < (unsigned) numVars+1) && (temp > 0)) {
	if (pathLengthArray[i] > 0) {
	    maxpath = i;
	    temp = temp - pathLengthArray[i];
	}
	i++;
    }
    /* if all nodes of max path are needed */
    if (temp >= 0) {
	maxpath++; /* now maxpath  becomes the next maxppath or max number
		      of variables */
	*excess = 0;
    } else { /* normal case when subset required is less than size of
		original BDD */
	*excess = temp + pathLengthArray[maxpath];
    }

    if (maxpath == 0) {
	fprintf(fp, "Path Length array seems to be all zeroes, check\n");
    }
    return(maxpath);

} /* end of AssessPathLength */


/**
  @brief Builds the %BDD with nodes labeled with path length less than
  or equal to maxpath.

  @details Builds the %BDD with nodes labeled with path length
  under maxpath and as many nodes labeled maxpath as determined by the
  threshold. The procedure uses the path table to determine which nodes
  in the original bdd need to be retained. This procedure picks a
  shortest path (tie break decided by taking the child with the shortest
  distance to the constant) and recurs down the path till it reaches the
  constant. the procedure then starts building the subset upward from
  the constant. All nodes labeled by path lengths less than the given
  maxpath are used to build the subset.  However, in the case of nodes
  that have label equal to maxpath, as many are chosen as required by
  the threshold. This number is stored in the info structure in the
  field thresholdReached. This field is decremented whenever a node
  labeled maxpath is encountered and the nodes labeled maxpath are
  aggregated in a maxpath table. As soon as the thresholdReached count
  goes to 0, the shortest path from this node to the constant is found.
  The extraction of nodes with the above labeling is based on the fact
  that each node, labeled with a path length, P, has at least one child
  labeled P or less. So extracting all nodes labeled a given path length
  P ensures complete paths between the root and the constant. Extraction
  of a partial number of nodes with a given path length may result in
  incomplete paths and hence the additional number of nodes are grabbed
  to complete the path. Since the Bdd is built bottom-up, other nodes
  labeled maxpath do lie on complete paths.  The procedure may cause the
  subset to have a larger or smaller number of nodes than the specified
  threshold. The increase in the number of nodes is caused by the
  building of a subset and the reduction by recombination. However in
  most cases, the recombination overshadows the increase and the
  procedure returns a result with lower number of nodes than specified.
  The subsetNodeTable is NIL when there is no hard limit on the number
  of nodes. Further efforts towards keeping the subset closer to the
  threshold number were abandoned in favour of keeping the procedure
  simple and fast.

  @sideeffect SubsetNodeTable is changed if it is not NIL.

*/
static DdNode *
BuildSubsetBdd(
  DdManager * dd /**< %DD manager */,
  GlobalInfo_t *gInfo /**< global information */,
  st_table * pathTable /**< path table with path lengths and computed results */,
  DdNode * node /**< current node */,
  struct AssortedInfo * info /**< assorted information structure */,
  st_table * subsetNodeTable /**< table storing computed results */)
{
    DdNode *N, *Nv, *Nnv;
    DdNode *ThenBranch, *ElseBranch, *childBranch;
    DdNode *child = NULL, *regChild = NULL, *regNnv = NULL, *regNv = NULL;
    NodeDist_t *nodeStatNv, *nodeStat, *nodeStatNnv;
    DdNode *neW, *topv, *regNew;
    char *entry;
    int topid;
    unsigned int childPathLength, oddLen, evenLen;
    unsigned int NnvPathLength = 0, NvPathLength = 0;
    unsigned int NvBotDist, NnvBotDist;
    int tiebreakChild;
    int  processingDone, thenDone;

    DdNode *zero = Cudd_Not(DD_ONE(dd));
#ifdef DD_DEBUG
    gInfo->numCalls++;
#endif
    if (Cudd_IsConstantInt(node))
	return(node);

    N = Cudd_Regular(node);
    /* Find node in table. */
    if (!st_lookup(pathTable, N, (void **) &nodeStat)) {
	(void) fprintf(dd->err, "Something wrong, node must be in table \n");
	dd->errorCode = CUDD_INTERNAL_ERROR;
	return(NULL);
    }
    /* If the node in the table has been visited, then return the corresponding
    ** Dd. Since a node can become a subset of itself, its
    ** complement (that is te same node reached by a different parity) will
    ** become a superset of the original node and result in some minterms
    ** that were not in the original set. Hence two different results are
    ** maintained, corresponding to the odd and even parities.
    */

    /* If this node is reached with an odd parity, get odd parity results. */
    if (Cudd_IsComplement(node)) {
	if  (nodeStat->compResult != NULL) {
#ifdef DD_DEBUG
	    gInfo->hits++;
#endif
	    return(nodeStat->compResult);
	}
    } else {
	/* if this node is reached with an even parity, get even parity
	 * results
	 */
	if (nodeStat->regResult != NULL) {
#ifdef DD_DEBUG
	    gInfo->hits++;
#endif
	    return(nodeStat->regResult);
	}
    }


    /* get children */
    Nv = Cudd_T(N);
    Nnv = Cudd_E(N);

    Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
    Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));

    /* no child processed */
    processingDone = 0;
    /* then child not processed */
    thenDone = 0;
    ThenBranch = NULL;
    /* else child not processed */
    ElseBranch = NULL;
    /* if then child constant, branch is the child */
    if (Cudd_IsConstantInt(Nv)) {
	/*shortest path found */
	if ((Nv == DD_ONE(dd)) && (info->findShortestPath)) {
	    info->findShortestPath = 0;
	}

	ThenBranch = Nv;
	cuddRef(ThenBranch);
	if (ThenBranch == NULL) {
	    return(NULL);
	}

	thenDone++;
	processingDone++;
	NvBotDist = MAXSHORTINT;
    } else {
	/* Derive regular child for table lookup. */
	regNv = Cudd_Regular(Nv);
	/* Get node data for shortest path length. */
	if (!st_lookup(pathTable, regNv, (void **) &nodeStatNv) ) {
	    (void) fprintf(dd->err, "Something wrong, node must be in table\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    return(NULL);
	}
	/* Derive shortest path length for child. */
	if ((nodeStatNv->oddTopDist != MAXSHORTINT) &&
	    (nodeStatNv->oddBotDist != MAXSHORTINT)) {
	    oddLen = (nodeStatNv->oddTopDist + nodeStatNv->oddBotDist);
	} else {
	    oddLen = MAXSHORTINT;
	}

	if ((nodeStatNv->evenTopDist != MAXSHORTINT) &&
	    (nodeStatNv->evenBotDist != MAXSHORTINT)) {
	    evenLen = (nodeStatNv->evenTopDist +nodeStatNv->evenBotDist);
	} else {
	    evenLen = MAXSHORTINT;
	}

	NvPathLength = (oddLen <= evenLen) ? oddLen : evenLen;
	NvBotDist = (oddLen <= evenLen) ? nodeStatNv->oddBotDist:
						   nodeStatNv->evenBotDist;
    }
    /* if else child constant, branch is the child */
    if (Cudd_IsConstantInt(Nnv)) {
	/*shortest path found */
	if ((Nnv == DD_ONE(dd)) && (info->findShortestPath)) {
	    info->findShortestPath = 0;
	}

	ElseBranch = Nnv;
	cuddRef(ElseBranch);
	if (ElseBranch == NULL) {
	    return(NULL);
	}

	processingDone++;
	NnvBotDist = MAXSHORTINT;
    } else {
	/* Derive regular child for table lookup. */
	regNnv = Cudd_Regular(Nnv);
	/* Get node data for shortest path length. */
	if (!st_lookup(pathTable, regNnv, (void **) &nodeStatNnv) ) {
	    (void) fprintf(dd->err, "Something wrong, node must be in table\n");
	    dd->errorCode = CUDD_INTERNAL_ERROR;
	    return(NULL);
	}
	/* Derive shortest path length for child. */
	if ((nodeStatNnv->oddTopDist != MAXSHORTINT) &&
	    (nodeStatNnv->oddBotDist != MAXSHORTINT)) {
	    oddLen = (nodeStatNnv->oddTopDist + nodeStatNnv->oddBotDist);
	} else {
	    oddLen = MAXSHORTINT;
	}

	if ((nodeStatNnv->evenTopDist != MAXSHORTINT) &&
	    (nodeStatNnv->evenBotDist != MAXSHORTINT)) {
	    evenLen = (nodeStatNnv->evenTopDist +nodeStatNnv->evenBotDist);
	} else {
	    evenLen = MAXSHORTINT;
	}

	NnvPathLength = (oddLen <= evenLen) ? oddLen : evenLen;
	NnvBotDist = (oddLen <= evenLen) ? nodeStatNnv->oddBotDist :
						   nodeStatNnv->evenBotDist;
    }

    tiebreakChild = (NvBotDist <= NnvBotDist) ? 1 : 0;
    /* while both children not processed */
    while (processingDone != 2) {
	if (!processingDone) {
	    /* if no child processed */
	    /* pick the child with shortest path length and record which one
	     * picked
	     */
	    if ((NvPathLength < NnvPathLength) ||
		((NvPathLength == NnvPathLength) && (tiebreakChild == 1))) {
		child = Nv;
		regChild = regNv;
		thenDone = 1;
		childPathLength = NvPathLength;
	    } else {
		child = Nnv;
		regChild = regNnv;
		childPathLength = NnvPathLength;
	    } /* then path length less than else path length */
	} else {
	    /* if one child processed, process the other */
	    if (thenDone) {
		child = Nnv;
		regChild = regNnv;
		childPathLength = NnvPathLength;
	    } else {
		child = Nv;
		regChild = regNv;
		thenDone = 1;
		childPathLength = NvPathLength;
	    } /* end of else pick the Then child if ELSE child processed */
	} /* end of else one child has been processed */

	/* ignore (replace with constant 0) all nodes which lie on paths larger
	 * than the maximum length of the path required
	 */
	if (childPathLength > info->maxpath) {
	    /* record nodes visited */
	    childBranch = zero;
	} else {
	    if (childPathLength < info->maxpath) {
		if (info->findShortestPath) {
		    info->findShortestPath = 0;
		}
		childBranch = BuildSubsetBdd(dd, gInfo, pathTable, child, info,
					     subsetNodeTable);

	    } else { /* Case: path length of node = maxpath */
		/* If the node labeled with maxpath is found in the
		** maxpathTable, use it to build the subset BDD.  */
		if (st_lookup(info->maxpathTable, regChild, (void **) &entry)) {
		    /* When a node that is already been chosen is hit,
		    ** the quest for a complete path is over.  */
		    if (info->findShortestPath) {
			info->findShortestPath = 0;
		    }
		    childBranch = BuildSubsetBdd(dd, gInfo, pathTable, child, info,
						 subsetNodeTable);
		} else {
		    /* If node is not found in the maxpathTable and
		    ** the threshold has been reached, then if the
		    ** path needs to be completed, continue. Else
		    ** replace the node with a zero.  */
		    if (info->thresholdReached <= 0) {
			if (info->findShortestPath) {
			    if (st_insert(info->maxpathTable, regChild,
					  NULL) == ST_OUT_OF_MEM) {
				dd->errorCode = CUDD_MEMORY_OUT;
				(void) fprintf(dd->err, "OUT of memory\n");
				info->thresholdReached = 0;
				childBranch = zero;
			    } else {
				info->thresholdReached--;
				childBranch = BuildSubsetBdd(dd, gInfo, pathTable,
						    child, info,subsetNodeTable);
			    }
			} else { /* not find shortest path, we dont need this
				    node */
			    childBranch = zero;
			}
		    } else { /* Threshold hasn't been reached,
			     ** need the node. */
			if (st_insert(info->maxpathTable, regChild,
				      NULL) == ST_OUT_OF_MEM) {
			    dd->errorCode = CUDD_MEMORY_OUT;
			    (void) fprintf(dd->err, "OUT of memory\n");
			    info->thresholdReached = 0;
			    childBranch = zero;
			} else {
			    info->thresholdReached--;
			    if (info->thresholdReached <= 0) {
				info->findShortestPath = 1;
			    }
			    childBranch = BuildSubsetBdd(dd, gInfo, pathTable,
						 child, info, subsetNodeTable);

			} /* end of st_insert successful */
		    } /* end of threshold hasnt been reached yet */
		} /* end of else node not found in maxpath table */
	    } /* end of if (path length of node = maxpath) */
	} /* end if !(childPathLength > maxpath) */
	if (childBranch == NULL) {
	    /* deref other stuff incase reordering has taken place */
	    if (ThenBranch != NULL) {
		Cudd_RecursiveDeref(dd, ThenBranch);
		ThenBranch = NULL;
	    }
	    if (ElseBranch != NULL) {
		Cudd_RecursiveDeref(dd, ElseBranch);
		ElseBranch = NULL;
	    }
	    return(NULL);
	}

	cuddRef(childBranch);

	if (child == Nv) {
	    ThenBranch = childBranch;
	} else {
	    ElseBranch = childBranch;
	}
	processingDone++;

    } /*end of while processing Nv, Nnv */

    info->findShortestPath = 0;
    topid = Cudd_NodeReadIndex(N);
    topv = Cudd_ReadVars(dd, topid);
    cuddRef(topv);
    neW = cuddBddIteRecur(dd, topv, ThenBranch, ElseBranch);
    if (neW != NULL) {
	cuddRef(neW);
    }
    Cudd_RecursiveDeref(dd, topv);
    Cudd_RecursiveDeref(dd, ThenBranch);
    Cudd_RecursiveDeref(dd, ElseBranch);


    if (neW == NULL) {
	return(NULL);
    } else {

        /* Hard Limit of threshold has been imposed */
        if (subsetNodeTable != NIL(st_table)) {
            /* check if a new node is created */
            regNew = Cudd_Regular(neW);
            /* subset node table keeps all new nodes that have been created to
             * keep a running count of how many nodes have been built in the
             * subset.
             */
            if (!st_lookup(subsetNodeTable, regNew, (void **) &entry)) {
                if (!Cudd_IsConstantInt(regNew)) {
                    if (st_insert(subsetNodeTable, regNew,
                                  NULL) == ST_OUT_OF_MEM) {
                        (void) fprintf(dd->err, "Out of memory\n");
                        return (NULL);
                    }
                    if (st_count(subsetNodeTable) > info->threshold) {
                        info->thresholdReached = 0;
                    }
                }
            }
        }

	/*store computed result in regular form*/
	if (Cudd_IsComplement(node)) {
	    nodeStat->compResult = neW;
	    cuddRef(nodeStat->compResult);
	    /* if the new node is the same as the corresponding node in the
	     * original bdd then its complement need not be computed as it
	     * cannot be larger than the node itself
	     */
	    if (neW == node) {
#ifdef DD_DEBUG
		gInfo->thishit++;
#endif
		/* if a result for the node has already been computed, then
		 * it can only be smaller than teh node itself. hence store
		 * the node result in order not to break recombination
		 */
		if (nodeStat->regResult != NULL) {
		    Cudd_RecursiveDeref(dd, nodeStat->regResult);
		}
		nodeStat->regResult = Cudd_Not(neW);
		cuddRef(nodeStat->regResult);
	    }

	} else {
	    nodeStat->regResult = neW;
	    cuddRef(nodeStat->regResult);
	    if (neW == node) {
#ifdef DD_DEBUG
		gInfo->thishit++;
#endif
		if (nodeStat->compResult != NULL) {
		    Cudd_RecursiveDeref(dd, nodeStat->compResult);
		}
		nodeStat->compResult = Cudd_Not(neW);
		cuddRef(nodeStat->compResult);
	    }
	}

	cuddDeref(neW);
	return(neW);
    } /* end of else i.e. Subset != NULL */
} /* end of BuildSubsetBdd */


/**
  @brief Procedure to free the result dds stored in the NodeDist pages.

  @sideeffect None

*/
static enum st_retval
stPathTableDdFree(
  void * key,
  void * value,
  void * arg)
{
    NodeDist_t *nodeStat = (NodeDist_t *) value;
    DdManager *dd = (DdManager *) arg;

    (void) key; /* avoid warning */
    if (nodeStat->regResult != NULL) {
	Cudd_RecursiveDeref(dd, nodeStat->regResult);
    }
    if (nodeStat->compResult != NULL) {
	Cudd_RecursiveDeref(dd, nodeStat->compResult);
    }
    return(ST_CONTINUE);

} /* end of stPathTableFree */

cuddSymmetry.c
46846
/**
  @file

  @ingroup cudd

  @brief Functions for symmetry-based variable reordering.

  @author Shipra Panda, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define MV_OOM (Move *)1

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int ddSymmUniqueCompare (void const *ptrX, void const *ptrY);
static int ddSymmSiftingAux (DdManager *table, int x, int xLow, int xHigh);
static int ddSymmSiftingConvAux (DdManager *table, int x, int xLow, int xHigh);
static Move * ddSymmSiftingUp (DdManager *table, int y, int xLow);
static Move * ddSymmSiftingDown (DdManager *table, int x, int xHigh);
static int ddSymmGroupMove (DdManager *table, int x, int y, Move **moves);
static int ddSymmGroupMoveBackward (DdManager *table, int x, int y);
static int ddSymmSiftingBackward (DdManager *table, Move *moves, int size);
static void ddSymmSummary (DdManager *table, int lower, int upper, int *symvars, int *symgroups);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints statistics on symmetric variables.

  @details The information is accurate only if this function is called
  right after reordering with methods CUDD_REORDER_SYMM_SIFT or
  CUDD_REORDER_SYMM_SIFT_CONV.

  @sideeffect None

*/
void
Cudd_SymmProfile(
  DdManager * table,
  int  lower,
  int  upper)
{
    int i,x,gbot;
    int TotalSymm = 0;
    int TotalSymmGroups = 0;

    for (i = lower; i <= upper; i++) {
	if (table->subtables[i].next != (unsigned) i) {
	    x = i;
	    (void) fprintf(table->out,"Group:");
	    do {
		(void) fprintf(table->out,"  %d",table->invperm[x]);
		TotalSymm++;
		gbot = x;
		x = table->subtables[x].next;
	    } while (x != i);
	    TotalSymmGroups++;
#ifdef DD_DEBUG
	    assert(table->subtables[gbot].next == (unsigned) i);
#endif
	    i = gbot;
	    (void) fprintf(table->out,"\n");
	}
    }
    (void) fprintf(table->out,"Total Symmetric = %d\n",TotalSymm);
    (void) fprintf(table->out,"Total Groups = %d\n",TotalSymmGroups);

} /* end of Cudd_SymmProfile */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Checks for symmetry of x and y.

  @details Ignores projection functions, unless they are isolated.

  @return 1 in case of symmetry; 0 otherwise.

  @sideeffect None

*/
int
cuddSymmCheck(
  DdManager * table,
  int  x,
  int  y)
{
    DdNode *f,*f0,*f1,*f01,*f00,*f11,*f10;
    int comple;		/* f0 is complemented */
    int xsymmy;		/* x and y may be positively symmetric */
    int xsymmyp;	/* x and y may be negatively symmetric */
    int arccount;	/* number of arcs from layer x to layer y */
    int TotalRefCount;	/* total reference count of layer y minus 1 */
    int yindex;
    int i;
    DdNodePtr *list;
    int slots;
    DdNode *sentinel = &(table->sentinel);
#ifdef DD_DEBUG
    int xindex;
#endif

    /* Checks that x and y are not the projection functions.
    ** For x it is sufficient to check whether there is only one
    ** node; indeed, if there is one node, it is the projection function
    ** and it cannot point to y. Hence, if y isn't just the projection
    ** function, it has one arc coming from a layer different from x.
    */
    if (table->subtables[x].keys == 1) {
	return(0);
    }
    yindex = table->invperm[y];
    if (table->subtables[y].keys == 1) {
	if (table->vars[yindex]->ref == 1)
	    return(0);
    }

    xsymmy = xsymmyp = 1;
    arccount = 0;
    slots = table->subtables[x].slots;
    list = table->subtables[x].nodelist;
    for (i = 0; i < slots; i++) {
	f = list[i];
	while (f != sentinel) {
	    /* Find f1, f0, f11, f10, f01, f00. */
	    f1 = cuddT(f);
	    f0 = Cudd_Regular(cuddE(f));
	    comple = Cudd_IsComplement(cuddE(f));
	    if ((int) f1->index == yindex) {
		arccount++;
		f11 = cuddT(f1); f10 = cuddE(f1);
	    } else {
		if ((int) f0->index != yindex) {
		    /* If f is an isolated projection function it is
		    ** allowed to bypass layer y.
		    */
		    if (f1 != DD_ONE(table) || f0 != DD_ONE(table) || f->ref != 1)
			return(0); /* f bypasses layer y */
		}
		f11 = f10 = f1;
	    }
	    if ((int) f0->index == yindex) {
		arccount++;
		f01 = cuddT(f0); f00 = cuddE(f0);
	    } else {
		f01 = f00 = f0;
	    }
	    if (comple) {
		f01 = Cudd_Not(f01);
		f00 = Cudd_Not(f00);
	    }

	    if (f1 != DD_ONE(table) || f0 != DD_ONE(table) || f->ref != 1) {
		xsymmy &= f01 == f10;
		xsymmyp &= f11 == f00;
		if ((xsymmy == 0) && (xsymmyp == 0))
		    return(0);
	    }

	    f = f->next;
	} /* while */
    } /* for */

    /* Calculate the total reference counts of y */
    TotalRefCount = -1; /* -1 for projection function */
    slots = table->subtables[y].slots;
    list = table->subtables[y].nodelist;
    for (i = 0; i < slots; i++) {
	f = list[i];
	while (f != sentinel) {
	    TotalRefCount += f->ref;
	    f = f->next;
	}
    }

#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    if (arccount == TotalRefCount) {
	xindex = table->invperm[x];
	(void) fprintf(table->out,
		       "Found symmetry! x =%d\ty = %d\tPos(%d,%d)\n",
		       xindex,yindex,x,y);
    }
#endif

    return(arccount == TotalRefCount);

} /* end of cuddSymmCheck */


/**
  @brief Symmetric sifting algorithm.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the DD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>

  @return 1 plus the number of symmetric variables if successful; 0
  otherwise.

  @sideeffect None

  @see cuddSymmSiftingConv

*/
int
cuddSymmSifting(
  DdManager * table,
  int  lower,
  int  upper)
{
    int		i;
    IndexKey	*var;
    int		size;
    int		x;
    int		result;
    int		symvars;
    int		symgroups;
#ifdef DD_STATS
    int		previousSize;
#endif

    size = table->size;

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey,size);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto ddSymmSiftingOutOfMem;
    }

    for (i = 0; i < size; i++) {
	x = table->perm[i];
	var[i].index = i;
	var[i].keys = table->subtables[x].keys;
    }

    util_qsort(var,size,sizeof(IndexKey),ddSymmUniqueCompare);

    /* Initialize the symmetry of each subtable to itself. */
    for (i = lower; i <= upper; i++) {
	table->subtables[i].next = i;
    }

    for (i = 0; i < ddMin(table->siftMaxVar,size); i++) {
	if (table->ddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime > table->timeLimit) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
	x = table->perm[var[i].index];
#ifdef DD_STATS
	previousSize = (int) (table->keys - table->isolated);
#endif
	if (x < lower || x > upper) continue;
	if (table->subtables[x].next == (unsigned) x) {
	    result = ddSymmSiftingAux(table,x,lower,upper);
	    if (!result) goto ddSymmSiftingOutOfMem;
#ifdef DD_STATS
	    if (table->keys < (unsigned) previousSize + table->isolated) {
		(void) fprintf(table->out,"-");
	    } else if (table->keys > (unsigned) previousSize +
		       table->isolated) {
		(void) fprintf(table->out,"+"); /* should never happen */
	    } else {
		(void) fprintf(table->out,"=");
	    }
	    fflush(table->out);
#endif
	}
    }

    FREE(var);

    ddSymmSummary(table, lower, upper, &symvars, &symgroups);

#ifdef DD_STATS
    (void) fprintf(table->out, "\n#:S_SIFTING %8d: symmetric variables\n",
		   symvars);
    (void) fprintf(table->out, "#:G_SIFTING %8d: symmetric groups",
		   symgroups);
#endif

    return(1+symvars);

ddSymmSiftingOutOfMem:

    if (var != NULL) FREE(var);

    return(0);

} /* end of cuddSymmSifting */


/**
  @brief Symmetric sifting to convergence algorithm.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the %DD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    <li> Repeat 1-4 until no further improvement.
    </ol>

  @return 1 plus the number of symmetric variables if successful; 0
  otherwise.

  @sideeffect None

  @see cuddSymmSifting

*/
int
cuddSymmSiftingConv(
  DdManager * table,
  int  lower,
  int  upper)
{
    int		i;
    IndexKey	*var;
    int		size;
    int		x;
    int		result;
    int		symvars;
    int		symgroups;
    int		classes;
    int		initialSize;
#ifdef DD_STATS
    int		previousSize;
#endif

    initialSize = (int) (table->keys - table->isolated);

    size = table->size;

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey,size);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto ddSymmSiftingConvOutOfMem;
    }

    for (i = 0; i < size; i++) {
	x = table->perm[i];
	var[i].index = i;
	var[i].keys = table->subtables[x].keys;
    }

    util_qsort(var,size,sizeof(IndexKey),ddSymmUniqueCompare);

    /* Initialize the symmetry of each subtable to itself
    ** for first pass of converging symmetric sifting.
    */
    for (i = lower; i <= upper; i++) {
	table->subtables[i].next = i;
    }

    for (i = 0; i < ddMin(table->siftMaxVar, table->size); i++) {
	if (table->ddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime > table->timeLimit) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDyn = 0; /* prevent further reordering */
            break;
        }
	x = table->perm[var[i].index];
	if (x < lower || x > upper) continue;
	/* Only sift if not in symmetry group already. */
	if (table->subtables[x].next == (unsigned) x) {
#ifdef DD_STATS
          previousSize = (int) (table->keys - table->isolated);
#endif
	    result = ddSymmSiftingAux(table,x,lower,upper);
	    if (!result) goto ddSymmSiftingConvOutOfMem;
#ifdef DD_STATS
	    if (table->keys < (unsigned) previousSize + table->isolated) {
		(void) fprintf(table->out,"-");
	    } else if (table->keys > (unsigned) previousSize +
		       table->isolated) {
		(void) fprintf(table->out,"+");
	    } else {
		(void) fprintf(table->out,"=");
	    }
	    fflush(table->out);
#endif
	}
    }

    /* Sifting now until convergence. */
    while ((unsigned) initialSize > table->keys - table->isolated) {
      initialSize = (int) (table->keys - table->isolated);
#ifdef DD_STATS
	(void) fprintf(table->out,"\n");
#endif
	/* Here we consider only one representative for each symmetry class. */
	for (x = lower, classes = 0; x <= upper; x++, classes++) {
	    while ((unsigned) x < table->subtables[x].next) {
		x = table->subtables[x].next;
	    }
	    /* Here x is the largest index in a group.
	    ** Groups consist of adjacent variables.
	    ** Hence, the next increment of x will move it to a new group.
	    */
	    i = table->invperm[x];
	    var[classes].keys = table->subtables[x].keys;
	    var[classes].index = i;
	}

	util_qsort(var,classes,sizeof(IndexKey),ddSymmUniqueCompare);

	/* Now sift. */
	for (i = 0; i < ddMin(table->siftMaxVar,classes); i++) {
	    if (table->ddTotalNumberSwapping >= table->siftMaxSwap)
		break;
            if (util_cpu_time() - table->startTime > table->timeLimit) {
              table->autoDyn = 0; /* prevent further reordering */
              break;
            }
            if (table->terminationCallback != NULL &&
                table->terminationCallback(table->tcbArg)) {
                table->autoDyn = 0; /* prevent further reordering */
                break;
            }
	    x = table->perm[var[i].index];
	    if ((unsigned) x >= table->subtables[x].next) {
#ifdef DD_STATS
              previousSize = (int) (table->keys - table->isolated);
#endif
		result = ddSymmSiftingConvAux(table,x,lower,upper);
		if (!result ) goto ddSymmSiftingConvOutOfMem;
#ifdef DD_STATS
		if (table->keys < (unsigned) previousSize + table->isolated) {
		    (void) fprintf(table->out,"-");
		} else if (table->keys > (unsigned) previousSize +
			   table->isolated) {
		    (void) fprintf(table->out,"+");
		} else {
		    (void) fprintf(table->out,"=");
		}
		fflush(table->out);
#endif
	    }
	} /* for */
    }

    ddSymmSummary(table, lower, upper, &symvars, &symgroups);

#ifdef DD_STATS
    (void) fprintf(table->out, "\n#:S_SIFTING %8d: symmetric variables\n",
		   symvars);
    (void) fprintf(table->out, "#:G_SIFTING %8d: symmetric groups",
		   symgroups);
#endif

    FREE(var);

    return(1+symvars);

ddSymmSiftingConvOutOfMem:

    if (var != NULL) FREE(var);

    return(0);

} /* end of cuddSymmSiftingConv */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Comparison function used by qsort.

  @details Used to order the variables according to the number of keys
  in the subtables.

  @return the difference in number of keys between the two variables
  being compared.

  @sideeffect None

*/
static int
ddSymmUniqueCompare(
  void const * ptrX,
  void const * ptrY)
{
    IndexKey const * pX = (IndexKey const *) ptrX;
    IndexKey const * pY = (IndexKey const *) ptrY;
#if 0
    if (pY->keys == pX->keys) {
	return(pX->index - pY->index);
    }
#endif
    return(pY->keys - pX->keys);

} /* end of ddSymmUniqueCompare */


/**
  @brief Given xLow <= x <= xHigh moves x up and down between the
  boundaries.

  @details Finds the best position and does the required changes.
  Assumes that x is not part of a symmetry group.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddSymmSiftingAux(
  DdManager * table,
  int  x,
  int  xLow,
  int  xHigh)
{
    Move *move;
    Move *moveUp;	/* list of up moves */
    Move *moveDown;	/* list of down moves */
    int	 initialSize;
    int	 result;
    int  i;
    int  topbot;	/* index to either top or bottom of symmetry group */
    int  initGroupSize, finalGroupSize;


#ifdef DD_DEBUG
    /* check for previously detected symmetry */
    assert(table->subtables[x].next == (unsigned) x);
#endif

    initialSize = (int) (table->keys - table->isolated);

    moveDown = NULL;
    moveUp = NULL;

    if ((x - xLow) > (xHigh - x)) {
	/* Will go down first, unless x == xHigh:
	** Look for consecutive symmetries above x.
	*/
	for (i = x; i > xLow; i--) {
	    if (!cuddSymmCheck(table,i-1,i))
		break;
	    topbot = table->subtables[i-1].next; /* find top of i-1's group */
	    table->subtables[i-1].next = i;
	    table->subtables[x].next = topbot; /* x is bottom of group so its */
					       /* next is top of i-1's group */
	    i = topbot + 1; /* add 1 for i--; new i is top of symm group */
	}
    } else {
	/* Will go up first unless x == xlow:
	** Look for consecutive symmetries below x.
	*/
	for (i = x; i < xHigh; i++) {
	    if (!cuddSymmCheck(table,i,i+1))
		break;
	    /* find bottom of i+1's symm group */
	    topbot = i + 1;
	    while ((unsigned) topbot < table->subtables[topbot].next) {
		topbot = table->subtables[topbot].next;
	    }
	    table->subtables[topbot].next = table->subtables[i].next;
	    table->subtables[i].next = i + 1;
	    i = topbot - 1; /* subtract 1 for i++; new i is bottom of group */
	}
    }

    /* Now x may be in the middle of a symmetry group.
    ** Find bottom of x's symm group.
    */
    while ((unsigned) x < table->subtables[x].next)
	x = table->subtables[x].next;

    if (x == xLow) { /* Sift down */

#ifdef DD_DEBUG
	/* x must be a singleton */
	assert((unsigned) x == table->subtables[x].next);
#endif
	if (x == xHigh) return(1);	/* just one variable */

	initGroupSize = 1;

	moveDown = ddSymmSiftingDown(table,x,xHigh);
	    /* after this point x --> xHigh, unless early term */
	if (moveDown == MV_OOM) goto ddSymmSiftingAuxOutOfMem;
	if (moveDown == NULL) return(1);

	x = moveDown->y;
	/* Find bottom of x's group */
	i = x;
	while ((unsigned) i < table->subtables[i].next) {
	    i = table->subtables[i].next;
	}
#ifdef DD_DEBUG
	/* x should be the top of the symmetry group and i the bottom */
	assert((unsigned) i >= table->subtables[i].next);
	assert((unsigned) x == table->subtables[i].next);
#endif
	finalGroupSize = i - x + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetry groups detected, return to best position */
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	} else {
          initialSize = (int) (table->keys - table->isolated);
	    moveUp = ddSymmSiftingUp(table,x,xLow);
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	}
	if (!result) goto ddSymmSiftingAuxOutOfMem;

    } else if (cuddNextHigh(table,x) > xHigh) { /* Sift up */
	/* Find top of x's symm group */
	i = x;				/* bottom */
	x = table->subtables[x].next;	/* top */

	if (x == xLow) return(1); /* just one big group */

	initGroupSize = i - x + 1;

	moveUp = ddSymmSiftingUp(table,x,xLow);
	    /* after this point x --> xLow, unless early term */
	if (moveUp == MV_OOM) goto ddSymmSiftingAuxOutOfMem;
	if (moveUp == NULL) return(1);

	x = moveUp->x;
	/* Find top of x's group */
	i = table->subtables[x].next;
#ifdef DD_DEBUG
	/* x should be the bottom of the symmetry group and i the top */
	assert((unsigned) x >= table->subtables[x].next);
	assert((unsigned) i == table->subtables[x].next);
#endif
	finalGroupSize = x - i + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetry groups detected, return to best position */
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	} else {
          initialSize = (int) (table->keys - table->isolated);
	    moveDown = ddSymmSiftingDown(table,x,xHigh);
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	}
	if (!result) goto ddSymmSiftingAuxOutOfMem;

    } else if ((x - xLow) > (xHigh - x)) { /* must go down first: shorter */

	moveDown = ddSymmSiftingDown(table,x,xHigh);
	/* at this point x == xHigh, unless early term */
	if (moveDown == MV_OOM) goto ddSymmSiftingAuxOutOfMem;

	if (moveDown != NULL) {
	    x = moveDown->y;	/* x is top here */
	    i = x;
	    while ((unsigned) i < table->subtables[i].next) {
		i = table->subtables[i].next;
	    }
	} else {
	    i = x;
	    while ((unsigned) i < table->subtables[i].next) {
		i = table->subtables[i].next;
	    }
	    x = table->subtables[i].next;
	}
#ifdef DD_DEBUG
	/* x should be the top of the symmetry group and i the bottom */
	assert((unsigned) i >= table->subtables[i].next);
	assert((unsigned) x == table->subtables[i].next);
#endif
	initGroupSize = i - x + 1;

	moveUp = ddSymmSiftingUp(table,x,xLow);
	if (moveUp == MV_OOM) goto ddSymmSiftingAuxOutOfMem;

	if (moveUp != NULL) {
	    x = moveUp->x;
	    i = table->subtables[x].next;
	} else {
	    i = x;
	    while ((unsigned) x < table->subtables[x].next)
		x = table->subtables[x].next;
	}
#ifdef DD_DEBUG
	/* x should be the bottom of the symmetry group and i the top */
	assert((unsigned) x >= table->subtables[x].next);
	assert((unsigned) i == table->subtables[x].next);
#endif
	finalGroupSize = x - i + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetry groups detected, return to best position */
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	} else {
	    while (moveDown != NULL) {
		move = moveDown->next;
		cuddDeallocMove(table, moveDown);
		moveDown = move;
	    }
	    initialSize = (int) (table->keys - table->isolated);
	    moveDown = ddSymmSiftingDown(table,x,xHigh);
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	}
	if (!result) goto ddSymmSiftingAuxOutOfMem;

    } else { /* moving up first: shorter */
	/* Find top of x's symmetry group */
	x = table->subtables[x].next;

	moveUp = ddSymmSiftingUp(table,x,xLow);
	/* at this point x == xHigh, unless early term */
	if (moveUp == MV_OOM) goto ddSymmSiftingAuxOutOfMem;

	if (moveUp != NULL) {
	    x = moveUp->x;
	    i = table->subtables[x].next;
	} else {
	    while ((unsigned) x < table->subtables[x].next)
		x = table->subtables[x].next;
	    i = table->subtables[x].next;
	}
#ifdef DD_DEBUG
	/* x is bottom of the symmetry group and i is top */
	assert((unsigned) x >= table->subtables[x].next);
	assert((unsigned) i == table->subtables[x].next);
#endif
	initGroupSize = x - i + 1;

	moveDown = ddSymmSiftingDown(table,x,xHigh);
	if (moveDown == MV_OOM) goto ddSymmSiftingAuxOutOfMem;

	if (moveDown != NULL) {
	    x = moveDown->y;
	    i = x;
	    while ((unsigned) i < table->subtables[i].next) {
		i = table->subtables[i].next;
	    }
	} else {
	    i = x;
	    x = table->subtables[x].next;
	}
#ifdef DD_DEBUG
	/* x should be the top of the symmetry group and i the bottom */
	assert((unsigned) i >= table->subtables[i].next);
	assert((unsigned) x == table->subtables[i].next);
#endif
	finalGroupSize = i - x + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetries detected, go back to best position */
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	} else {
	    while (moveUp != NULL) {
		move = moveUp->next;
		cuddDeallocMove(table, moveUp);
		moveUp = move;
	    }
	    initialSize = (int) (table->keys - table->isolated);
	    moveUp = ddSymmSiftingUp(table,x,xLow);
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	}
	if (!result) goto ddSymmSiftingAuxOutOfMem;
    }

    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(1);

ddSymmSiftingAuxOutOfMem:
    if (moveDown != MV_OOM) {
	while (moveDown != NULL) {
	    move = moveDown->next;
	    cuddDeallocMove(table, moveDown);
	    moveDown = move;
	}
    }
    if (moveUp != MV_OOM) {
	while (moveUp != NULL) {
	    move = moveUp->next;
	    cuddDeallocMove(table, moveUp);
	    moveUp = move;
	}
    }

    return(0);

} /* end of ddSymmSiftingAux */


/**
  @brief Given xLow <= x <= xHigh moves x up and down between the
  boundaries.

  @details Finds the best position and does the required changes.
  Assumes that x is either an isolated variable, or it is the bottom of
  a symmetry group. All symmetries may not have been found, because of
  exceeded growth limit.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddSymmSiftingConvAux(
  DdManager * table,
  int  x,
  int  xLow,
  int  xHigh)
{
    Move *move;
    Move *moveUp;	/* list of up moves */
    Move *moveDown;	/* list of down moves */
    int	 initialSize;
    int	 result;
    int  i;
    int  initGroupSize, finalGroupSize;


    initialSize = (int) (table->keys - table->isolated);

    moveDown = NULL;
    moveUp = NULL;

    if (x == xLow) { /* Sift down */
#ifdef DD_DEBUG
	/* x is bottom of symmetry group */
	assert((unsigned) x >= table->subtables[x].next);
#endif
	i = table->subtables[x].next;
	initGroupSize = x - i + 1;

	moveDown = ddSymmSiftingDown(table,x,xHigh);
	/* at this point x == xHigh, unless early term */
	if (moveDown == MV_OOM) goto ddSymmSiftingConvAuxOutOfMem;
	if (moveDown == NULL) return(1);

	x = moveDown->y;
	i = x;
	while ((unsigned) i < table->subtables[i].next) {
	    i = table->subtables[i].next;
	}
#ifdef DD_DEBUG
	/* x should be the top of the symmetric group and i the bottom */
	assert((unsigned) i >= table->subtables[i].next);
	assert((unsigned) x == table->subtables[i].next);
#endif
	finalGroupSize = i - x + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetries detected, go back to best position */
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	} else {
          initialSize = (int) (table->keys - table->isolated);
	    moveUp = ddSymmSiftingUp(table,x,xLow);
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	}
	if (!result) goto ddSymmSiftingConvAuxOutOfMem;

    } else if (cuddNextHigh(table,x) > xHigh) { /* Sift up */
	/* Find top of x's symm group */
	while ((unsigned) x < table->subtables[x].next)
	    x = table->subtables[x].next;
	i = x;				/* bottom */
	x = table->subtables[x].next;	/* top */

	if (x == xLow) return(1);

	initGroupSize = i - x + 1;

	moveUp = ddSymmSiftingUp(table,x,xLow);
	    /* at this point x == xLow, unless early term */
	if (moveUp == MV_OOM) goto ddSymmSiftingConvAuxOutOfMem;
	if (moveUp == NULL) return(1);

	x = moveUp->x;
	i = table->subtables[x].next;
#ifdef DD_DEBUG
	/* x should be the bottom of the symmetry group and i the top */
	assert((unsigned) x >= table->subtables[x].next);
	assert((unsigned) i == table->subtables[x].next);
#endif
	finalGroupSize = x - i + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetry groups detected, return to best position */
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	} else {
          initialSize = (int) (table->keys - table->isolated);
	    moveDown = ddSymmSiftingDown(table,x,xHigh);
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	}
	if (!result)
	    goto ddSymmSiftingConvAuxOutOfMem;

    } else if ((x - xLow) > (xHigh - x)) { /* must go down first: shorter */
	moveDown = ddSymmSiftingDown(table,x,xHigh);
	    /* at this point x == xHigh, unless early term */
	if (moveDown == MV_OOM) goto ddSymmSiftingConvAuxOutOfMem;

	if (moveDown != NULL) {
	    x = moveDown->y;
	    i = x;
	    while ((unsigned) i < table->subtables[i].next) {
		i = table->subtables[i].next;
	    }
	} else {
	    while ((unsigned) x < table->subtables[x].next)
		x = table->subtables[x].next;
	    i = x;
	    x = table->subtables[x].next;
	}
#ifdef DD_DEBUG
	/* x should be the top of the symmetry group and i the bottom */
	assert((unsigned) i >= table->subtables[i].next);
	assert((unsigned) x == table->subtables[i].next);
#endif
	initGroupSize = i - x + 1;

	moveUp = ddSymmSiftingUp(table,x,xLow);
	if (moveUp == MV_OOM) goto ddSymmSiftingConvAuxOutOfMem;

	if (moveUp != NULL) {
	    x = moveUp->x;
	    i = table->subtables[x].next;
	} else {
	    i = x;
	    while ((unsigned) x < table->subtables[x].next)
		x = table->subtables[x].next;
	}
#ifdef DD_DEBUG
	/* x should be the bottom of the symmetry group and i the top */
	assert((unsigned) x >= table->subtables[x].next);
	assert((unsigned) i == table->subtables[x].next);
#endif
	finalGroupSize = x - i + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetry groups detected, return to best position */
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	} else {
	    while (moveDown != NULL) {
		move = moveDown->next;
		cuddDeallocMove(table, moveDown);
		moveDown = move;
	    }
	    initialSize = (int) (table->keys - table->isolated);
	    moveDown = ddSymmSiftingDown(table,x,xHigh);
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	}
	if (!result) goto ddSymmSiftingConvAuxOutOfMem;

    } else { /* moving up first: shorter */
	/* Find top of x's symmetry group */
	x = table->subtables[x].next;

	moveUp = ddSymmSiftingUp(table,x,xLow);
	/* at this point x == xHigh, unless early term */
	if (moveUp == MV_OOM) goto ddSymmSiftingConvAuxOutOfMem;

	if (moveUp != NULL) {
	    x = moveUp->x;
	    i = table->subtables[x].next;
	} else {
	    i = x;
	    while ((unsigned) x < table->subtables[x].next)
		x = table->subtables[x].next;
	}
#ifdef DD_DEBUG
	/* x is bottom of the symmetry group and i is top */
	assert((unsigned) x >= table->subtables[x].next);
	assert((unsigned) i == table->subtables[x].next);
#endif
	initGroupSize = x - i + 1;

	moveDown = ddSymmSiftingDown(table,x,xHigh);
	if (moveDown == MV_OOM) goto ddSymmSiftingConvAuxOutOfMem;

	if (moveDown != NULL) {
	    x = moveDown->y;
	    i = x;
	    while ((unsigned) i < table->subtables[i].next) {
		i = table->subtables[i].next;
	    }
	} else {
	    i = x;
	    x = table->subtables[x].next;
	}
#ifdef DD_DEBUG
	/* x should be the top of the symmetry group and i the bottom */
	assert((unsigned) i >= table->subtables[i].next);
	assert((unsigned) x == table->subtables[i].next);
#endif
	finalGroupSize = i - x + 1;

	if (initGroupSize == finalGroupSize) {
	    /* No new symmetries detected, go back to best position */
	    result = ddSymmSiftingBackward(table,moveDown,initialSize);
	} else {
	    while (moveUp != NULL) {
		move = moveUp->next;
		cuddDeallocMove(table, moveUp);
		moveUp = move;
	    }
	    initialSize = (int) (table->keys - table->isolated);
	    moveUp = ddSymmSiftingUp(table,x,xLow);
	    result = ddSymmSiftingBackward(table,moveUp,initialSize);
	}
	if (!result) goto ddSymmSiftingConvAuxOutOfMem;
    }

    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(1);

ddSymmSiftingConvAuxOutOfMem:
    if (moveDown != MV_OOM) {
	while (moveDown != NULL) {
	    move = moveDown->next;
	    cuddDeallocMove(table, moveDown);
	    moveDown = move;
	}
    }
    if (moveUp != MV_OOM) {
	while (moveUp != NULL) {
	    move = moveUp->next;
	    cuddDeallocMove(table, moveUp);
	    moveUp = move;
	}
    }

    return(0);

} /* end of ddSymmSiftingConvAux */


/**
  @brief Moves x up until either it reaches the bound (xLow) or
  the size of the %DD heap increases too much.

  @details Assumes that x is the top of a symmetry group.  Checks x
  for symmetry to the adjacent variables. If symmetry is found, the
  symmetry group of x is merged with the symmetry group of the other
  variable.

  @return the set of moves in case of success; MV_OOM if memory is
  full.

  @sideeffect None

*/
static Move *
ddSymmSiftingUp(
  DdManager * table,
  int  y,
  int  xLow)
{
    Move *moves;
    Move *move;
    int	 x;
    int	 size;
    int  i;
    int  gxtop,gybot;
    int  limitSize;
    int  xindex, yindex;
    int  zindex;
    int  z;
    int  isolated;
    int  L;	/* lower bound on DD size */
#ifdef DD_DEBUG
    int  checkL;
#endif


    moves = NULL;
    yindex = table->invperm[y];

    /* Initialize the lower bound.
    ** The part of the DD below the bottom of y' group will not change.
    ** The part of the DD above y that does not interact with y will not
    ** change. The rest may vanish in the best case, except for
    ** the nodes at level xLow, which will not vanish, regardless.
    */
    limitSize = L = (int) (table->keys - table->isolated);
    gybot = y;
    while ((unsigned) gybot < table->subtables[gybot].next)
	gybot = table->subtables[gybot].next;
    for (z = xLow + 1; z <= gybot; z++) {
	zindex = table->invperm[z];
	if (zindex == yindex || cuddTestInteract(table,zindex,yindex)) {
	    isolated = table->vars[zindex]->ref == 1;
	    L -= (int) table->subtables[z].keys - isolated;
	}
    }

    x = cuddNextLow(table,y);
    while (x >= xLow && L <= limitSize) {
#ifdef DD_DEBUG
	gybot = y;
	while ((unsigned) gybot < table->subtables[gybot].next)
	    gybot = table->subtables[gybot].next;
	checkL = (int) (table->keys - table->isolated);
	for (z = xLow + 1; z <= gybot; z++) {
	    zindex = table->invperm[z];
	    if (zindex == yindex || cuddTestInteract(table,zindex,yindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkL -= (int) table->subtables[z].keys - isolated;
	    }
	}
	assert(L == checkL);
#endif
	gxtop = table->subtables[x].next;
	if (cuddSymmCheck(table,x,y)) {
	    /* Symmetry found, attach symm groups */
	    table->subtables[x].next = y;
	    i = table->subtables[y].next;
	    while (table->subtables[i].next != (unsigned) y)
		i = table->subtables[i].next;
	    table->subtables[i].next = gxtop;
	} else if (table->subtables[x].next == (unsigned) x &&
		   table->subtables[y].next == (unsigned) y) {
	    /* x and y have self symmetry */
	    xindex = table->invperm[x];
	    size = cuddSwapInPlace(table,x,y);
#ifdef DD_DEBUG
	    assert(table->subtables[x].next == (unsigned) x);
	    assert(table->subtables[y].next == (unsigned) y);
#endif
	    if (size == 0) goto ddSymmSiftingUpOutOfMem;
	    /* Update the lower bound. */
	    if (cuddTestInteract(table,xindex,yindex)) {
		isolated = table->vars[xindex]->ref == 1;
		L += (int) table->subtables[y].keys - isolated;
	    }
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSymmSiftingUpOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(moves);
	    if (size < limitSize) limitSize = size;
	} else { /* Group move */
	    size = ddSymmGroupMove(table,x,y,&moves);
	    if (size == 0) goto ddSymmSiftingUpOutOfMem;
	    /* Update the lower bound. */
	    z = moves->y;
	    do {
		zindex = table->invperm[z];
		if (cuddTestInteract(table,zindex,yindex)) {
		    isolated = table->vars[zindex]->ref == 1;
		    L += (int) table->subtables[z].keys - isolated;
		}
		z = table->subtables[z].next;
	    } while (z != (int) moves->y);
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(moves);
	    if (size < limitSize) limitSize = size;
	}
	y = gxtop;
	x = cuddNextLow(table,y);
    }

    return(moves);

ddSymmSiftingUpOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(MV_OOM);

} /* end of ddSymmSiftingUp */


/**
  @brief Moves x down until either it reaches the bound (xHigh) or
  the size of the %DD heap increases too much.

  @details Assumes that x is the bottom of a symmetry group. Checks x
  for symmetry to the adjacent variables. If symmetry is found, the
  symmetry group of x is merged with the symmetry group of the other
  variable.

  @return the set of moves in case of success; MV_OOM if memory is
  full.

  @sideeffect None

*/
static Move *
ddSymmSiftingDown(
  DdManager * table,
  int  x,
  int  xHigh)
{
    Move *moves;
    Move *move;
    int	 y;
    int	 size;
    int  limitSize;
    int  gxtop,gybot;
    int  R;	/* upper bound on node decrease */
    int  xindex, yindex;
    int  isolated;
    int  z;
    int  zindex;
#ifdef DD_DEBUG
    int  checkR;
#endif

    moves = NULL;
    /* Initialize R */
    xindex = table->invperm[x];
    gxtop = table->subtables[x].next;
    limitSize = size = (int) (table->keys - table->isolated);
    R = 0;
    for (z = xHigh; z > gxtop; z--) {
	zindex = table->invperm[z];
	if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
	    isolated = table->vars[zindex]->ref == 1;
	    R += (int) table->subtables[z].keys - isolated;
	}
    }

    y = cuddNextHigh(table,x);
    while (y <= xHigh && size - R < limitSize) {
#ifdef DD_DEBUG
	gxtop = table->subtables[x].next;
	checkR = 0;
	for (z = xHigh; z > gxtop; z--) {
	    zindex = table->invperm[z];
	    if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
		isolated = table->vars[zindex]->ref == 1;
		checkR += (int) table->subtables[z].keys - isolated;
	    }
	}
	assert(R == checkR);
#endif
	gybot = table->subtables[y].next;
	while (table->subtables[gybot].next != (unsigned) y)
	    gybot = table->subtables[gybot].next;
	if (cuddSymmCheck(table,x,y)) {
	    /* Symmetry found, attach symm groups */
	    gxtop = table->subtables[x].next;
	    table->subtables[x].next = y;
	    table->subtables[gybot].next = gxtop;
	} else if (table->subtables[x].next == (unsigned) x &&
		   table->subtables[y].next == (unsigned) y) {
	    /* x and y have self symmetry */
	    /* Update upper bound on node decrease. */
	    yindex = table->invperm[y];
	    if (cuddTestInteract(table,xindex,yindex)) {
		isolated = table->vars[yindex]->ref == 1;
		R -= (int) table->subtables[y].keys - isolated;
	    }
	    size = cuddSwapInPlace(table,x,y);
#ifdef DD_DEBUG
	    assert(table->subtables[x].next == (unsigned) x);
	    assert(table->subtables[y].next == (unsigned) y);
#endif
	    if (size == 0) goto ddSymmSiftingDownOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto ddSymmSiftingDownOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(moves);
	    if (size < limitSize) limitSize = size;
	} else { /* Group move */
	    /* Update upper bound on node decrease: first phase. */
	    gxtop = table->subtables[x].next;
	    z = gxtop + 1;
	    do {
		zindex = table->invperm[z];
		if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
		    isolated = table->vars[zindex]->ref == 1;
		    R -= (int) table->subtables[z].keys - isolated;
		}
		z++;
	    } while (z <= gybot);
	    size = ddSymmGroupMove(table,x,y,&moves);
	    if (size == 0) goto ddSymmSiftingDownOutOfMem;
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(moves);
	    if (size < limitSize) limitSize = size;
	    /* Update upper bound on node decrease: second phase. */
	    gxtop = table->subtables[gybot].next;
	    for (z = gxtop + 1; z <= gybot; z++) {
		zindex = table->invperm[z];
		if (zindex == xindex || cuddTestInteract(table,xindex,zindex)) {
		    isolated = table->vars[zindex]->ref == 1;
		    R += (int) table->subtables[z].keys - isolated;
		}
	    }
	}
	x = gybot;
	y = cuddNextHigh(table,x);
    }

    return(moves);

ddSymmSiftingDownOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(MV_OOM);

} /* end of ddSymmSiftingDown */


/**
  @brief Swaps two groups.

  @details x is assumed to be the bottom variable of the first
  group. y is assumed to be the top variable of the second group.
  Updates the list of moves.

  @return the number of keys in the table if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddSymmGroupMove(
  DdManager * table,
  int  x,
  int  y,
  Move ** moves)
{
    Move *move;
    int	 size = 0;
    int  i,j;
    int  xtop,xbot,xsize,ytop,ybot,ysize,newxtop;
    int  swapx = 0, swapy = 0;

#ifdef DD_DEBUG
    assert(x < y);	/* we assume that x < y */
#endif
    /* Find top, bottom, and size for the two groups. */
    xbot = x;
    xtop = table->subtables[x].next;
    xsize = xbot - xtop + 1;
    ybot = y;
    while ((unsigned) ybot < table->subtables[ybot].next)
	ybot = table->subtables[ybot].next;
    ytop = y;
    ysize = ybot - ytop + 1;

    /* Sift the variables of the second group up through the first group. */
    for (i = 1; i <= ysize; i++) {
	for (j = 1; j <= xsize; j++) {
	    size = cuddSwapInPlace(table,x,y);
	    if (size == 0) return(0);
	    swapx = x; swapy = y;
	    y = x;
	    x = y - 1;
	}
	y = ytop + i;
	x = y - 1;
    }

    /* fix symmetries */
    y = xtop; /* ytop is now where xtop used to be */
    for (i = 0; i < ysize-1 ; i++) {
	table->subtables[y].next = y + 1;
	y = y + 1;
    }
    table->subtables[y].next = xtop; /* y is bottom of its group, join */
				     /* its symmetry to top of its group */
    x = y + 1;
    newxtop = x;
    for (i = 0; i < xsize - 1 ; i++) {
	table->subtables[x].next = x + 1;
	x = x + 1;
    }
    table->subtables[x].next = newxtop; /* x is bottom of its group, join */
					/* its symmetry to top of its group */
    /* Store group move */
    move = (Move *) cuddDynamicAllocNode(table);
    if (move == NULL) return(0);
    move->x = swapx;
    move->y = swapy;
    move->size = size;
    move->next = *moves;
    *moves = move;

    return(size);

} /* end of ddSymmGroupMove */


/**
  @brief Undoes the swap of two groups.

  @details x is assumed to be the bottom variable of the first
  group. y is assumed to be the top variable of the second group.

  @return the number of keys in the table if successful; 0 otherwise.

  @sideeffect None

*/
static int
ddSymmGroupMoveBackward(
  DdManager * table,
  int  x,
  int  y)
{
  int	size = (int) (table->keys - table->isolated);
    int i,j;
    int	xtop,xbot,xsize,ytop,ybot,ysize,newxtop;

#ifdef DD_DEBUG
    assert(x < y); /* We assume that x < y */
#endif

    /* Find top, bottom, and size for the two groups. */
    xbot = x;
    xtop = table->subtables[x].next;
    xsize = xbot - xtop + 1;
    ybot = y;
    while ((unsigned) ybot < table->subtables[ybot].next)
	ybot = table->subtables[ybot].next;
    ytop = y;
    ysize = ybot - ytop + 1;
#ifdef DD_DEBUG
    assert(xsize > 0);
    assert(ysize > 0);
#endif

    /* Sift the variables of the second group up through the first group. */
    for (i = 1; i <= ysize; i++) {
	for (j = 1; j <= xsize; j++) {
	    size = cuddSwapInPlace(table,x,y);
	    if (size == 0) return(0);
	    y = x;
	    x = cuddNextLow(table,y);
	}
	y = ytop + i;
	x = y - 1;
    }

    /* Fix symmetries. */
    y = xtop;
    for (i = 0; i < ysize-1 ; i++) {
	table->subtables[y].next = y + 1;
	y = y + 1;
    }
    table->subtables[y].next = xtop; /* y is bottom of its group, join */
				     /* its symmetry to top of its group */
    x = y + 1;
    newxtop = x;
    for (i = 0; i < xsize-1 ; i++) {
	table->subtables[x].next = x + 1;
	x = x + 1;
    }
    table->subtables[x].next = newxtop; /* x is bottom of its group, join */
					/* its symmetry to top of its group */

    return(size);

} /* end of ddSymmGroupMoveBackward */


/**
  @brief Given a set of moves, returns the %DD heap to the position
  giving the minimum size.

  @details In case of ties, returns to the closest position giving the
  minimum size.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddSymmSiftingBackward(
  DdManager * table,
  Move * moves,
  int  size)
{
    Move *move;
    int  res;

    for (move = moves; move != NULL; move = move->next) {
	if (move->size < size) {
	    size = move->size;
	}
    }

    for (move = moves; move != NULL; move = move->next) {
	if (move->size == size) return(1);
	if (table->subtables[move->x].next == move->x && table->subtables[move->y].next == move->y) {
	    res = cuddSwapInPlace(table,(int)move->x,(int)move->y);
#ifdef DD_DEBUG
	    assert(table->subtables[move->x].next == move->x);
	    assert(table->subtables[move->y].next == move->y);
#endif
	} else { /* Group move necessary */
	    res = ddSymmGroupMoveBackward(table,(int)move->x,(int)move->y);
	}
	if (!res) return(0);
    }

    return(1);

} /* end of ddSymmSiftingBackward */


/**
  @brief Counts numbers of symmetric variables and symmetry groups.

  @sideeffect None

*/
static void
ddSymmSummary(
  DdManager * table,
  int  lower,
  int  upper,
  int * symvars,
  int * symgroups)
{
    int i,x,gbot;
    int TotalSymm = 0;
    int TotalSymmGroups = 0;

    for (i = lower; i <= upper; i++) {
	if (table->subtables[i].next != (unsigned) i) {
	    TotalSymmGroups++;
	    x = i;
	    do {
		TotalSymm++;
		gbot = x;
		x = table->subtables[x].next;
	    } while (x != i);
#ifdef DD_DEBUG
	    assert(table->subtables[gbot].next == (unsigned) i);
#endif
	    i = gbot;
	}
    }
    *symvars = TotalSymm;
    *symgroups = TotalSymmGroups;

    return;

} /* end of ddSymmSummary */

cuddTable.c
92286
/**
  @file

  @ingroup cudd

  @brief Unique table management functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
/* Constants for red/black trees. */
#define DD_STACK_SIZE 128
#define DD_RED   0
#define DD_BLACK 1
#define DD_PAGE_SIZE 8192
#define DD_PAGE_MASK ~(DD_PAGE_SIZE - 1)
#endif
#endif

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief This is a hack for when CUDD_VALUE_TYPE is double
 */
typedef union hack {
    CUDD_VALUE_TYPE value;
    unsigned int bits[2];
} hack;

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
/* Macros for red/black trees. */
#define DD_INSERT_COMPARE(x,y) \
	(((ptruint) (x) & DD_PAGE_MASK) - ((ptruint) (y) & DD_PAGE_MASK))
#define DD_COLOR(p)  ((p)->index)
#define DD_IS_BLACK(p) ((p)->index == DD_BLACK)
#define DD_IS_RED(p) ((p)->index == DD_RED)
#define DD_LEFT(p) cuddT(p)
#define DD_RIGHT(p) cuddE(p)
#define DD_NEXT(p) ((p)->next)
#endif
#endif


/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static void ddRehashZdd (DdManager *unique, int i);
static int ddResizeTable (DdManager *unique, int index, int amount);
static int cuddFindParent (DdManager *table, DdNode *node);
static void ddFixLimits (DdManager *unique);
#ifdef DD_RED_BLACK_FREE_LIST
static void cuddOrderedInsert (DdNodePtr *root, DdNodePtr node);
static DdNode * cuddOrderedThread (DdNode *root, DdNode *list);
static void cuddRotateLeft (DdNodePtr *nodeP);
static void cuddRotateRight (DdNodePtr *nodeP);
static void cuddDoRebalance (DdNodePtr **stack, int stackN);
#endif
static void ddPatchTree (DdManager *dd, MtrNode *treenode);
#ifdef DD_DEBUG
static int cuddCheckCollisionOrdering (DdManager *unique, int i, int j);
#endif
static void ddReportRefMess (DdManager *unique, int i, const char *caller);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Returns the next prime &ge; p.

  @sideeffect None

*/
unsigned int
Cudd_Prime(
  unsigned int  p)
{
    unsigned int i, pn;

    p--;
    do {
	p++;
	if (p&1) {
	    pn = 1;
	    i = 3;
	    while ((unsigned) (i * i) <= p) {
		if (p % i == 0) {
		    pn = 0;
		    break;
		}
		i += 2;
	    }
	} else {
	    pn = 0;
	}
    } while (!pn);
    return(p);

} /* end of Cudd_Prime */


/**
  @brief Expand manager without creating variables.

  @details Expand a manager by a specified number of subtables without
  actually creating new variables.  This function can be used to reduce the
  frequency of resizing when an estimate of the number of variables is
  available.  One would call this function instead of passing the number
  of variables to Cudd_Init if variables should not be created right away
  of if the estimate on their number became available only after the manager
  has been created.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_Init

*/
int
Cudd_Reserve(
  DdManager *manager,
  int amount)
{
    int currentSize = manager->size;
    if (amount < 0)
        return(0);
    if (currentSize + amount < currentSize) /* overflow */
        return(0);
    if (amount <= manager->maxSize - manager->size)
        return(1);
    return ddResizeTable(manager, -1, amount);

} /* end of Cudd_Reserve */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Fast storage allocation for DdNodes in the table.

  @details The first 4 bytes of a chunk contain a pointer to the next
  block; the rest contains DD_MEM_CHUNK spaces for DdNodes.

  @return a pointer to a new node if successful; NULL is memory is
  full.

  @sideeffect None

  @see cuddDynamicAllocNode

*/
DdNode *
cuddAllocNode(
  DdManager * unique)
{
    int i;
    DdNodePtr *mem;
    DdNode *list, *node;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    if (unique->nextFree == NULL) {	/* free list is empty */
	/* Check for exceeded limits. */
        if (unique->terminationCallback != NULL &&
            unique->terminationCallback(unique->tcbArg)) {
            unique->errorCode = CUDD_TERMINATION;
            return(NULL);
        }
        if (util_cpu_time() - unique->startTime > unique->timeLimit) {
            unique->errorCode = CUDD_TIMEOUT_EXPIRED;
            return(NULL);
        }
	if ((unique->keys - unique->dead) + (unique->keysZ - unique->deadZ) >
	    unique->maxLive) {
	    unique->errorCode = CUDD_TOO_MANY_NODES;
	    return(NULL);
	}
	if (unique->stash == NULL || unique->memused > unique->maxmemhard) {
	    (void) cuddGarbageCollect(unique,1);
	    mem = NULL;
	}
	if (unique->nextFree == NULL) {
	    if (unique->memused > unique->maxmemhard) {
		unique->errorCode = CUDD_MAX_MEM_EXCEEDED;
		return(NULL);
	    }
	    /* Try to allocate a new block. */
	    saveHandler = MMoutOfMemory;
	    MMoutOfMemory = unique->outOfMemCallback;
	    mem = (DdNodePtr *) ALLOC(DdNode,DD_MEM_CHUNK + 1);
	    MMoutOfMemory = saveHandler;
	    if (mem == NULL) {
		/* No more memory: Try collecting garbage. If this succeeds,
		** we end up with mem still NULL, but unique->nextFree !=
		** NULL. */
		if (cuddGarbageCollect(unique,1) == 0) {
		    /* Last resort: Free the memory stashed away, if there
		    ** any. If this succeeeds, mem != NULL and
		    ** unique->nextFree still NULL. */
		    if (unique->stash != NULL) {
			FREE(unique->stash);
			unique->stash = NULL;
			/* Inhibit resizing of tables. */
			cuddSlowTableGrowth(unique);
			/* Now try again. */
			mem = (DdNodePtr *) ALLOC(DdNode,DD_MEM_CHUNK + 1);
		    }
		    if (mem == NULL) {
			/* Out of luck. Call the default handler to do
			** whatever it specifies for a failed malloc.
			** If this handler returns, then set error code,
			** print warning, and return. */
			(*MMoutOfMemory)(sizeof(DdNode)*(DD_MEM_CHUNK + 1));
			unique->errorCode = CUDD_MEMORY_OUT;
#ifdef DD_VERBOSE
			(void) fprintf(unique->err,
				       "cuddAllocNode: out of memory");
			(void) fprintf(unique->err, "Memory in use = %lu\n",
				       unique->memused);
#endif
			return(NULL);
		    }
		}
	    }
	    if (mem != NULL) {	/* successful allocation; slice memory */
		ptruint offset;
		unique->memused += (DD_MEM_CHUNK + 1) * sizeof(DdNode);
		mem[0] = (DdNodePtr) unique->memoryList;
		unique->memoryList = mem;

		/* Here we rely on the fact that a DdNode is as large
		** as 4 pointers.  */
		offset = (ptruint) mem & (sizeof(DdNode) - 1);
		mem += (sizeof(DdNode) - offset) / sizeof(DdNodePtr);
		assert(((ptruint) mem & (sizeof(DdNode) - 1)) == 0);
		list = (DdNode *) mem;

		i = 1;
		do {
		    list[i - 1].ref = 0;
		    list[i - 1].next = &list[i];
		} while (++i < DD_MEM_CHUNK);

		list[DD_MEM_CHUNK-1].ref = 0;
		list[DD_MEM_CHUNK-1].next = NULL;

		unique->nextFree = &list[0];
	    }
	}
    }
    unique->allocated++;
    node = unique->nextFree;
    unique->nextFree = node->next;
    return(node);

} /* end of cuddAllocNode */


/**
  @brief Creates and initializes the unique table.

  @return a pointer to the table if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_Init cuddFreeTable

*/
DdManager *
cuddInitTable(
  unsigned int numVars  /**< Initial number of %BDD variables (and subtables) */,
  unsigned int numVarsZ /**< Initial number of %ZDD variables (and subtables) */,
  unsigned int numSlots /**< Initial size of the %BDD subtables */,
  unsigned int looseUpTo /**< Limit for fast table growth */)
{
    DdManager	*unique = ALLOC(DdManager,1);
    int		i, j;
    DdNodePtr	*nodelist;
    DdNode	*sentinel;
    unsigned int slots;
    int shift;

    if (unique == NULL) {
	return(NULL);
    }
    sentinel = &(unique->sentinel);
    sentinel->ref = 0;
    sentinel->index = 0;
    cuddT(sentinel) = NULL;
    cuddE(sentinel) = NULL;
    sentinel->next = NULL;
    unique->epsilon = DD_EPSILON;
    unique->size = numVars;
    unique->sizeZ = numVarsZ;
    unique->maxSize = ddMax(DD_DEFAULT_RESIZE, numVars);
    unique->maxSizeZ = ddMax(DD_DEFAULT_RESIZE, numVarsZ);

    /* Adjust the requested number of slots to a power of 2. */
    slots = 8;
    while (slots < numSlots) {
	slots <<= 1;
    }
    unique->initSlots = slots;
    shift = sizeof(int) * 8 - cuddComputeFloorLog2(slots);

    unique->slots = (numVars + numVarsZ + 1) * slots;
    unique->keys = 0;
    unique->maxLive = ~0;	/* very large number */
    unique->keysZ = 0;
    unique->dead = 0;
    unique->deadZ = 0;
    unique->gcFrac = DD_GC_FRAC_HI;
    unique->minDead = (unsigned) (DD_GC_FRAC_HI * (double) unique->slots);
    unique->looseUpTo = looseUpTo;
    unique->gcEnabled = 1;
    unique->allocated = 0;
    unique->reclaimed = 0;
    unique->subtables = ALLOC(DdSubtable,unique->maxSize);
    if (unique->subtables == NULL) {
	FREE(unique);
	return(NULL);
    }
    unique->subtableZ = ALLOC(DdSubtable,unique->maxSizeZ);
    if (unique->subtableZ == NULL) {
	FREE(unique->subtables);
	FREE(unique);
	return(NULL);
    }
    unique->perm = ALLOC(int,unique->maxSize);
    if (unique->perm == NULL) {
	FREE(unique->subtables);
	FREE(unique->subtableZ);
	FREE(unique);
	return(NULL);
    }
    unique->invperm = ALLOC(int,unique->maxSize);
    if (unique->invperm == NULL) {
	FREE(unique->subtables);
	FREE(unique->subtableZ);
	FREE(unique->perm);
	FREE(unique);
	return(NULL);
    }
    unique->permZ = ALLOC(int,unique->maxSizeZ);
    if (unique->permZ == NULL) {
	FREE(unique->subtables);
	FREE(unique->subtableZ);
	FREE(unique->perm);
	FREE(unique->invperm);
	FREE(unique);
	return(NULL);
    }
    unique->invpermZ = ALLOC(int,unique->maxSizeZ);
    if (unique->invpermZ == NULL) {
	FREE(unique->subtables);
	FREE(unique->subtableZ);
	FREE(unique->perm);
	FREE(unique->invperm);
	FREE(unique->permZ);
	FREE(unique);
	return(NULL);
    }
    unique->map = NULL;
    unique->stack = ALLOC(DdNodePtr,ddMax(unique->maxSize,unique->maxSizeZ)+1);
    if (unique->stack == NULL) {
	FREE(unique->subtables);
	FREE(unique->subtableZ);
	FREE(unique->perm);
	FREE(unique->invperm);
	FREE(unique->permZ);
	FREE(unique->invpermZ);
	FREE(unique);
	return(NULL);
    }
    unique->stack[0] = NULL; /* to suppress harmless UMR */

#ifndef DD_NO_DEATH_ROW
    unique->deathRowDepth = 1U << cuddComputeFloorLog2(unique->looseUpTo >> 2);
    unique->deathRow = ALLOC(DdNodePtr,unique->deathRowDepth);
    if (unique->deathRow == NULL) {
	FREE(unique->subtables);
	FREE(unique->subtableZ);
	FREE(unique->perm);
	FREE(unique->invperm);
	FREE(unique->permZ);
	FREE(unique->invpermZ);
	FREE(unique->stack);
	FREE(unique);
	return(NULL);
    }
    for (i = 0; i < unique->deathRowDepth; i++) {
	unique->deathRow[i] = NULL;
    }
    unique->nextDead = 0;
    unique->deadMask = unique->deathRowDepth - 1;
#endif

    for (i = 0; (unsigned) i < numVars; i++) {
	unique->subtables[i].slots = slots;
	unique->subtables[i].shift = shift;
	unique->subtables[i].keys = 0;
	unique->subtables[i].dead = 0;
        unique->subtables[i].next = i;
	unique->subtables[i].maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;
	unique->subtables[i].bindVar = 0;
	unique->subtables[i].varType = CUDD_VAR_PRIMARY_INPUT;
	unique->subtables[i].pairIndex = 0;
	unique->subtables[i].varHandled = 0;
	unique->subtables[i].varToBeGrouped = CUDD_LAZY_NONE;

	nodelist = unique->subtables[i].nodelist = ALLOC(DdNodePtr,slots);
	if (nodelist == NULL) {
	    for (j = 0; j < i; j++) {
		FREE(unique->subtables[j].nodelist);
	    }
	    FREE(unique->subtables);
	    FREE(unique->subtableZ);
	    FREE(unique->perm);
	    FREE(unique->invperm);
	    FREE(unique->permZ);
	    FREE(unique->invpermZ);
	    FREE(unique->stack);
	    FREE(unique);
	    return(NULL);
	}
	for (j = 0; (unsigned) j < slots; j++) {
	    nodelist[j] = sentinel;
	}
	unique->perm[i] = i;
	unique->invperm[i] = i;
    }
    for (i = 0; (unsigned) i < numVarsZ; i++) {
	unique->subtableZ[i].slots = slots;
	unique->subtableZ[i].shift = shift;
	unique->subtableZ[i].keys = 0;
	unique->subtableZ[i].dead = 0;
        unique->subtableZ[i].next = i;
	unique->subtableZ[i].maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;
	nodelist = unique->subtableZ[i].nodelist = ALLOC(DdNodePtr,slots);
	if (nodelist == NULL) {
	    for (j = 0; (unsigned) j < numVars; j++) {
		FREE(unique->subtables[j].nodelist);
	    }
	    FREE(unique->subtables);
	    for (j = 0; j < i; j++) {
		FREE(unique->subtableZ[j].nodelist);
	    }
	    FREE(unique->subtableZ);
	    FREE(unique->perm);
	    FREE(unique->invperm);
	    FREE(unique->permZ);
	    FREE(unique->invpermZ);
	    FREE(unique->stack);
	    FREE(unique);
	    return(NULL);
	}
	for (j = 0; (unsigned) j < slots; j++) {
	    nodelist[j] = NULL;
	}
	unique->permZ[i] = i;
	unique->invpermZ[i] = i;
    }
    unique->constants.slots = slots;
    unique->constants.shift = shift;
    unique->constants.keys = 0;
    unique->constants.dead = 0;
    unique->constants.next = 0;
    unique->constants.bindVar = 0;
    unique->constants.varType = CUDD_VAR_PRIMARY_INPUT;
    unique->constants.pairIndex = 0;
    unique->constants.varHandled = 0;
    unique->constants.varToBeGrouped = CUDD_LAZY_NONE;
    unique->constants.maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;
    nodelist = unique->constants.nodelist = ALLOC(DdNodePtr,slots);
    if (nodelist == NULL) {
	for (j = 0; (unsigned) j < numVars; j++) {
	    FREE(unique->subtables[j].nodelist);
	}
	FREE(unique->subtables);
	for (j = 0; (unsigned) j < numVarsZ; j++) {
	    FREE(unique->subtableZ[j].nodelist);
	}
	FREE(unique->subtableZ);
	FREE(unique->perm);
	FREE(unique->invperm);
	FREE(unique->permZ);
	FREE(unique->invpermZ);
	FREE(unique->stack);
	FREE(unique);
	return(NULL);
    }
    for (j = 0; (unsigned) j < slots; j++) {
	nodelist[j] = NULL;
    }

    unique->memoryList = NULL;
    unique->nextFree = NULL;

    unique->memused = sizeof(DdManager) + (unique->maxSize + unique->maxSizeZ)
	* (sizeof(DdSubtable) + 2 * sizeof(int)) + (numVars + 1) *
	slots * sizeof(DdNodePtr) +
	(ddMax(unique->maxSize,unique->maxSizeZ) + 1) * sizeof(DdNodePtr);
#ifndef DD_NO_DEATH_ROW
    unique->memused += unique->deathRowDepth * sizeof(DdNodePtr);
#endif

    /* Initialize fields concerned with automatic dynamic reordering. */
    unique->reordered = 0;
    unique->reorderings = 0;
    unique->maxReorderings = ~0;
    unique->siftMaxVar = DD_SIFT_MAX_VAR;
    unique->siftMaxSwap = DD_SIFT_MAX_SWAPS;
    unique->maxGrowth = DD_MAX_REORDER_GROWTH;
    unique->maxGrowthAlt = 2.0 * DD_MAX_REORDER_GROWTH;
    unique->reordCycle = 0;	/* do not use alternate threshold */
    unique->autoDyn = 0;	/* initially disabled */
    unique->autoDynZ = 0;	/* initially disabled */
    unique->autoMethod = CUDD_REORDER_SIFT;
    unique->autoMethodZ = CUDD_REORDER_SIFT;
    unique->realign = 0;	/* initially disabled */
    unique->realignZ = 0;	/* initially disabled */
    unique->nextDyn = DD_FIRST_REORDER;
    unique->countDead = ~0;
    unique->tree = NULL;
    unique->treeZ = NULL;
    unique->groupcheck = CUDD_GROUP_CHECK7;
    unique->recomb = DD_DEFAULT_RECOMB;
    unique->symmviolation = 0;
    unique->arcviolation = 0;
    unique->populationSize = 0;
    unique->numberXovers = 0;
    unique->randomizeOrder = 0;
    unique->linear = NULL;
    unique->originalSize = 0;
    unique->linearSize = 0;

    /* Initialize ZDD universe. */
    unique->univ = (DdNodePtr *)NULL;

    /* Initialize auxiliary fields. */
    unique->localCaches = NULL;
    unique->preGCHook = NULL;
    unique->postGCHook = NULL;
    unique->preReorderingHook = NULL;
    unique->postReorderingHook = NULL;
    unique->out = stdout;
    unique->err = stderr;
    unique->errorCode = CUDD_NO_ERROR;
    unique->startTime = util_cpu_time();
    unique->timeLimit = ~0UL;
    unique->terminationCallback = NULL;
    unique->tcbArg = NULL;
    unique->outOfMemCallback = Cudd_OutOfMem;
    unique->timeoutHandler = NULL;

    /* Initialize statistical counters. */
    unique->maxmemhard = ~ (size_t) 0;
    unique->garbageCollections = 0;
    unique->GCTime = 0;
    unique->reordTime = 0;
    unique->peakLiveNodes = 0;
    unique->cuddRand = 0;
#ifdef DD_STATS
    unique->nodesDropped = 0;
    unique->nodesFreed = 0;
#endif
#ifdef DD_UNIQUE_PROFILE
    unique->uniqueLookUps = 0;
    unique->uniqueLinks = 0;
#endif
#ifdef DD_COUNT
    unique->recursiveCalls = 0;
    unique->swapSteps = 0;
#ifdef DD_STATS
    unique->nextSample = 250000;
#endif
#endif
#ifdef DD_DEBUG
    unique->enableExtraDebug = 0;
#endif

    return(unique);

} /* end of cuddInitTable */


/**
  @brief Frees the resources associated to a unique table.

  @sideeffect None

  @see cuddInitTable

*/
void
cuddFreeTable(
  DdManager * unique)
{
    DdNodePtr *next;
    DdNodePtr *memlist = unique->memoryList;
    int i;

    if (unique->stash != NULL) FREE(unique->stash);
    if (unique->univ != NULL) cuddZddFreeUniv(unique);
    while (memlist != NULL) {
	next = (DdNodePtr *) memlist[0];	/* link to next block */
	FREE(memlist);
	memlist = next;
    }
    unique->nextFree = NULL;
    unique->memoryList = NULL;

    for (i = 0; i < unique->size; i++) {
	FREE(unique->subtables[i].nodelist);
    }
    for (i = 0; i < unique->sizeZ; i++) {
	FREE(unique->subtableZ[i].nodelist);
    }
    FREE(unique->constants.nodelist);
    FREE(unique->subtables);
    FREE(unique->subtableZ);
    FREE(unique->acache);
    FREE(unique->perm);
    FREE(unique->permZ);
    FREE(unique->invperm);
    FREE(unique->invpermZ);
    FREE(unique->vars);
    if (unique->map != NULL) FREE(unique->map);
    FREE(unique->stack);
#ifndef DD_NO_DEATH_ROW
    FREE(unique->deathRow);
#endif
    if (unique->tree != NULL) Mtr_FreeTree(unique->tree);
    if (unique->treeZ != NULL) Mtr_FreeTree(unique->treeZ);
    if (unique->linear != NULL) FREE(unique->linear);
    while (unique->preGCHook != NULL)
	Cudd_RemoveHook(unique,unique->preGCHook->f,CUDD_PRE_GC_HOOK);
    while (unique->postGCHook != NULL)
	Cudd_RemoveHook(unique,unique->postGCHook->f,CUDD_POST_GC_HOOK);
    while (unique->preReorderingHook != NULL)
	Cudd_RemoveHook(unique,unique->preReorderingHook->f,
			CUDD_PRE_REORDERING_HOOK);
    while (unique->postReorderingHook != NULL)
	Cudd_RemoveHook(unique,unique->postReorderingHook->f,
			CUDD_POST_REORDERING_HOOK);
    FREE(unique);

} /* end of cuddFreeTable */


/**
  @brief Performs garbage collection on the %BDD and %ZDD unique tables.

  @details If clearCache is 0, the cache is not cleared. This should
  only be specified if the cache has been cleared right before calling
  cuddGarbageCollect. (As in the case of dynamic reordering.)

  @return the total number of deleted nodes.

  @sideeffect None

*/
int
cuddGarbageCollect(
  DdManager * unique,
  int clearCache)
{
    DdHook	*hook;
    DdCache	*cache = unique->cache;
    DdNode	*sentinel = &(unique->sentinel);
    DdNodePtr	*nodelist;
    int		i, j, deleted, totalDeleted, totalDeletedZ;
    DdCache	*c;
    DdNode	*node,*next;
    DdNodePtr	*lastP;
    int		slots;
    unsigned long localTime;
#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
    DdNodePtr	tree;
#else
    DdNodePtr *memListTrav, *nxtNode;
    DdNode *downTrav, *sentry;
    int k;
#endif
#endif

    if (util_cpu_time() - unique->startTime > unique->timeLimit) {
        unique->errorCode = CUDD_TIMEOUT_EXPIRED;
        return(0);
    }

#ifndef DD_NO_DEATH_ROW
    cuddClearDeathRow(unique);
#endif

    hook = unique->preGCHook;
    while (hook != NULL) {
	int res = (hook->f)(unique,"DD",NULL);
	if (res == 0) return(0);
	hook = hook->next;
    }

    if (unique->dead + unique->deadZ == 0) {
	hook = unique->postGCHook;
	while (hook != NULL) {
	    int res = (hook->f)(unique,"DD",NULL);
	    if (res == 0) return(0);
	    hook = hook->next;
	}
	return(0);
    }

    /* If many nodes are being reclaimed, we want to resize the tables
    ** more aggressively, to reduce the frequency of garbage collection.
    */
    if (clearCache && unique->gcFrac == DD_GC_FRAC_LO &&
	unique->slots <= unique->looseUpTo && unique->stash != NULL) {
	unique->minDead = (unsigned) (DD_GC_FRAC_HI * (double) unique->slots);
#ifdef DD_VERBOSE
	(void) fprintf(unique->err,"GC fraction = %.2f\t", DD_GC_FRAC_HI);
	(void) fprintf(unique->err,"minDead = %d\n", unique->minDead);
#endif
	unique->gcFrac = DD_GC_FRAC_HI;
	return(0);
    }

    localTime = util_cpu_time();

    unique->garbageCollections++;
#ifdef DD_VERBOSE
    (void) fprintf(unique->err,
		   "garbage collecting (%d dead BDD nodes out of %d, min %d)...",
		   unique->dead, unique->keys, unique->minDead);
    (void) fprintf(unique->err,
		   "                   (%d dead ZDD nodes out of %d)...",
		   unique->deadZ, unique->keysZ);
#endif

    /* Remove references to garbage collected nodes from the cache. */
    if (clearCache) {
	slots = unique->cacheSlots;
	for (i = 0; i < slots; i++) {
	    c = &cache[i];
	    if (c->data != NULL) {
		if (cuddClean(c->f)->ref == 0 ||
		cuddClean(c->g)->ref == 0 ||
		(((ptruint)c->f & 0x2) && Cudd_Regular(c->h)->ref == 0) ||
		(c->data != DD_NON_CONSTANT &&
		Cudd_Regular(c->data)->ref == 0)) {
		    c->data = NULL;
		    unique->cachedeletions++;
		}
	    }
	}
	cuddLocalCacheClearDead(unique);
    }

    /* Now return dead nodes to free list. Count them for sanity check. */
    totalDeleted = 0;
#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
    tree = NULL;
#endif
#endif

    for (i = 0; i < unique->size; i++) {
	if (unique->subtables[i].dead == 0) continue;
	nodelist = unique->subtables[i].nodelist;

	deleted = 0;
	slots = unique->subtables[i].slots;
	for (j = 0; j < slots; j++) {
	    lastP = &(nodelist[j]);
	    node = *lastP;
	    while (node != sentinel) {
		next = node->next;
		if (node->ref == 0) {
		    deleted++;
#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
		    cuddOrderedInsert(&tree,node);
#endif
#else
		    cuddDeallocNode(unique,node);
#endif
		} else {
		    *lastP = node;
		    lastP = &(node->next);
		}
		node = next;
	    }
	    *lastP = sentinel;
	}
	if ((unsigned) deleted != unique->subtables[i].dead) {
	    ddReportRefMess(unique, i, "cuddGarbageCollect");
	}
	totalDeleted += deleted;
	unique->subtables[i].keys -= deleted;
	unique->subtables[i].dead = 0;
    }
    if (unique->constants.dead != 0) {
	nodelist = unique->constants.nodelist;
	deleted = 0;
	slots = unique->constants.slots;
	for (j = 0; j < slots; j++) {
	    lastP = &(nodelist[j]);
	    node = *lastP;
	    while (node != NULL) {
		next = node->next;
		if (node->ref == 0) {
		    deleted++;
#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
		    cuddOrderedInsert(&tree,node);
#endif
#else
		    cuddDeallocNode(unique,node);
#endif
		} else {
		    *lastP = node;
		    lastP = &(node->next);
		}
		node = next;
	    }
	    *lastP = NULL;
	}
	if ((unsigned) deleted != unique->constants.dead) {
	    ddReportRefMess(unique, CUDD_CONST_INDEX, "cuddGarbageCollect");
	}
	totalDeleted += deleted;
	unique->constants.keys -= deleted;
	unique->constants.dead = 0;
    }
    if ((unsigned) totalDeleted != unique->dead) {
	ddReportRefMess(unique, -1, "cuddGarbageCollect");
    }
    unique->keys -= totalDeleted;
    unique->dead = 0;
#ifdef DD_STATS
    unique->nodesFreed += (double) totalDeleted;
#endif

    totalDeletedZ = 0;

    for (i = 0; i < unique->sizeZ; i++) {
	if (unique->subtableZ[i].dead == 0) continue;
	nodelist = unique->subtableZ[i].nodelist;

	deleted = 0;
	slots = unique->subtableZ[i].slots;
	for (j = 0; j < slots; j++) {
	    lastP = &(nodelist[j]);
	    node = *lastP;
	    while (node != NULL) {
		next = node->next;
		if (node->ref == 0) {
		    deleted++;
#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
		    cuddOrderedInsert(&tree,node);
#endif
#else
		    cuddDeallocNode(unique,node);
#endif
		} else {
		    *lastP = node;
		    lastP = &(node->next);
		}
		node = next;
	    }
	    *lastP = NULL;
	}
	if ((unsigned) deleted != unique->subtableZ[i].dead) {
	    ddReportRefMess(unique, i, "cuddGarbageCollect");
	}
	totalDeletedZ += deleted;
	unique->subtableZ[i].keys -= deleted;
	unique->subtableZ[i].dead = 0;
    }

    /* No need to examine the constant table for ZDDs.
    ** If we did we should be careful not to count whatever dead
    ** nodes we found there among the dead ZDD nodes. */
    if ((unsigned) totalDeletedZ != unique->deadZ) {
	ddReportRefMess(unique, -1, "cuddGarbageCollect");
    }
    unique->keysZ -= totalDeletedZ;
    unique->deadZ = 0;
#ifdef DD_STATS
    unique->nodesFreed += (double) totalDeletedZ;
#endif


#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
    unique->nextFree = cuddOrderedThread(tree,unique->nextFree);
#else
    memListTrav = unique->memoryList;
    sentry = NULL;
    while (memListTrav != NULL) {
	ptruint offset;
	nxtNode = (DdNodePtr *)memListTrav[0];
	offset = (ptruint) memListTrav & (sizeof(DdNode) - 1);
	memListTrav += (sizeof(DdNode) - offset) / sizeof(DdNodePtr);
	downTrav = (DdNode *)memListTrav;
	k = 0;
	do {
	    if (downTrav[k].ref == 0) {
		if (sentry == NULL) {
		    unique->nextFree = sentry = &downTrav[k];
		} else {
		    /* First hook sentry->next to the dead node and then
		    ** reassign sentry to the dead node. */
		    sentry = (sentry->next = &downTrav[k]);
		}
	    }
	} while (++k < DD_MEM_CHUNK);
	memListTrav = nxtNode;
    }
    sentry->next = NULL;
#endif
#endif

    unique->GCTime += util_cpu_time() - localTime;

    hook = unique->postGCHook;
    while (hook != NULL) {
	int res = (hook->f)(unique,"DD",NULL);
	if (res == 0) return(0);
	hook = hook->next;
    }

#ifdef DD_VERBOSE
    (void) fprintf(unique->err," done\n");
#endif

    return(totalDeleted+totalDeletedZ);

} /* end of cuddGarbageCollect */


/**
  @brief Wrapper for cuddUniqueInterZdd.

  @details It applies the %ZDD reduction rule.

  @return a pointer to the result node under normal conditions; NULL
  if reordering occurred or memory was exhausted.

  @sideeffect None

  @see cuddUniqueInterZdd

*/
DdNode *
cuddZddGetNode(
  DdManager * zdd,
  int  id,
  DdNode * T,
  DdNode * E)
{
    DdNode	*node;

    if (T == DD_ZERO(zdd))
	return(E);
    node = cuddUniqueInterZdd(zdd, id, T, E);
    return(node);

} /* end of cuddZddGetNode */


/**
  @brief Wrapper for cuddUniqueInterZdd that is independent of variable
  ordering.

  @details Wrapper for cuddUniqueInterZdd that is independent of
  variable ordering (IVO). This function does not require parameter
  index to precede the indices of the top nodes of g and h in the
  variable order.

  @return a pointer to the result node under normal conditions; NULL
  if reordering occurred or memory was exhausted.

  @sideeffect None

  @see cuddZddGetNode cuddZddIsop

*/
DdNode *
cuddZddGetNodeIVO(
  DdManager * dd,
  int  index,
  DdNode * g,
  DdNode * h)
{
    DdNode	*f, *r, *t;
    DdNode	*zdd_one = DD_ONE(dd);
    DdNode	*zdd_zero = DD_ZERO(dd);

    f = cuddUniqueInterZdd(dd, index, zdd_one, zdd_zero);
    if (f == NULL) {
	return(NULL);
    }
    cuddRef(f);
    t = cuddZddProduct(dd, f, g);
    if (t == NULL) {
	Cudd_RecursiveDerefZdd(dd, f);
	return(NULL);
    }
    cuddRef(t);
    Cudd_RecursiveDerefZdd(dd, f);
    r = cuddZddUnion(dd, t, h);
    if (r == NULL) {
	Cudd_RecursiveDerefZdd(dd, t);
	return(NULL);
    }
    cuddRef(r);
    Cudd_RecursiveDerefZdd(dd, t);

    cuddDeref(r);
    return(r);

} /* end of cuddZddGetNodeIVO */


/**
  @brief Checks the unique table for the existence of an internal node.

  @details If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  For a newly
  created node, increments the reference counts of what T and E point
  to.

  @return a pointer to the new node if successful; NULL if memory is
  exhausted, if a termination request was detected, if a timeout expired,
  or if reordering took place.

  @sideeffect None

  @see cuddUniqueInterZdd

*/
DdNode *
cuddUniqueInter(
  DdManager * unique,
  int  index,
  DdNode * T,
  DdNode * E)
{
    int pos;
    unsigned int level;
    int retval;
    DdNodePtr *nodelist;
    DdNode *looking;
    DdNodePtr *previousP;
    DdSubtable *subtable;
    int gcNumber;

#ifdef DD_UNIQUE_PROFILE
    unique->uniqueLookUps++;
#endif

    if (((int64_t) 0x1ffff & (int64_t) unique->cacheMisses) == 0) {
        if (unique->terminationCallback != NULL &&
            unique->terminationCallback(unique->tcbArg)) {
            unique->errorCode = CUDD_TERMINATION;
            return(NULL);
        }
        if (util_cpu_time() - unique->startTime > unique->timeLimit) {
            unique->errorCode = CUDD_TIMEOUT_EXPIRED;
            return(NULL);
        }
    }
    if (index >= unique->size) {
        int amount = ddMax(DD_DEFAULT_RESIZE,unique->size/20);
        if (!ddResizeTable(unique,index,amount)) return(NULL);
    }

    level = unique->perm[index];
    subtable = &(unique->subtables[level]);

#ifdef DD_DEBUG
    assert(level < (unsigned) cuddI(unique,T->index));
    assert(level < (unsigned) cuddI(unique,Cudd_Regular(E)->index));
#endif

    pos = ddHash(T, E, subtable->shift);
    nodelist = subtable->nodelist;
    previousP = &(nodelist[pos]);
    looking = *previousP;

    while (T < cuddT(looking)) {
	previousP = &(looking->next);
	looking = *previousP;
#ifdef DD_UNIQUE_PROFILE
	unique->uniqueLinks++;
#endif
    }
    while (T == cuddT(looking) && E < cuddE(looking)) {
	previousP = &(looking->next);
	looking = *previousP;
#ifdef DD_UNIQUE_PROFILE
	unique->uniqueLinks++;
#endif
    }
    if (T == cuddT(looking) && E == cuddE(looking)) {
	if (looking->ref == 0) {
	    cuddReclaim(unique,looking);
	}
	return(looking);
    }

    /* countDead is 0 if deads should be counted and ~0 if they should not. */
    if (unique->autoDyn &&
        unique->keys - (unique->dead & unique->countDead) >= unique->nextDyn &&
        unique->maxReorderings > 0) {
        unsigned long cpuTime;
#ifdef DD_DEBUG
	retval = Cudd_DebugCheck(unique);
	if (retval != 0) return(NULL);
	retval = Cudd_CheckKeys(unique);
	if (retval != 0) return(NULL);
#endif
	retval = Cudd_ReduceHeap(unique,unique->autoMethod,10); /* 10 = whatever */
        unique->maxReorderings--;
	if (retval == 0) {
            unique->reordered = 2;
        } else if (unique->terminationCallback != NULL &&
            unique->terminationCallback(unique->tcbArg)) {
            unique->errorCode = CUDD_TERMINATION;
            unique->reordered = 0;
        } else if ((cpuTime = util_cpu_time()) - unique->startTime >
                   unique->timeLimit) {
            unique->errorCode = CUDD_TIMEOUT_EXPIRED;
            unique->reordered = 0;
        } else if (unique->timeLimit - (cpuTime - unique->startTime)
                   < unique->reordTime) {
            /* No risk of overflow because here unique->timeLimit is known
             * to be greater than or equal to (cpuTime - unique->startTime).
             * If the remaining time is less than the time spent on
             * reordering so far, we disable reordering.  */
            unique->autoDyn = 0;
        }
#ifdef DD_DEBUG
	retval = Cudd_DebugCheck(unique);
	if (retval != 0) unique->reordered = 2;
	retval = Cudd_CheckKeys(unique);
	if (retval != 0) unique->reordered = 2;
#endif
	return(NULL);
    }

    if (subtable->keys > subtable->maxKeys) {
	if (unique->gcEnabled &&
	    ((unique->dead > unique->minDead) ||
	    ((unique->dead > unique->minDead / 2) &&
	    (subtable->dead > subtable->keys * 0.95)))) { /* too many dead */
            if (unique->terminationCallback != NULL &&
                unique->terminationCallback(unique->tcbArg)) {
                unique->errorCode = CUDD_TERMINATION;
                return(NULL);
            }
            if (util_cpu_time() - unique->startTime > unique->timeLimit) {
                unique->errorCode = CUDD_TIMEOUT_EXPIRED;
                return(NULL);
            }
	    (void) cuddGarbageCollect(unique,1);
	} else {
	    cuddRehash(unique,(int)level);
	}
	/* Update pointer to insertion point. In the case of rehashing,
	** the slot may have changed. In the case of garbage collection,
	** the predecessor may have been dead. */
	pos = ddHash(T, E, subtable->shift);
	nodelist = subtable->nodelist;
	previousP = &(nodelist[pos]);
	looking = *previousP;

	while (T < cuddT(looking)) {
	    previousP = &(looking->next);
	    looking = *previousP;
#ifdef DD_UNIQUE_PROFILE
	    unique->uniqueLinks++;
#endif
	}
	while (T == cuddT(looking) && E < cuddE(looking)) {
	    previousP = &(looking->next);
	    looking = *previousP;
#ifdef DD_UNIQUE_PROFILE
	    unique->uniqueLinks++;
#endif
	}
    }

    gcNumber = unique->garbageCollections;
    looking = cuddAllocNode(unique);
    if (looking == NULL) {
	return(NULL);
    }
    unique->keys++;
    subtable->keys++;

    if (gcNumber != unique->garbageCollections) {
	DdNode *looking2;
	pos = ddHash(T, E, subtable->shift);
	nodelist = subtable->nodelist;
	previousP = &(nodelist[pos]);
	looking2 = *previousP;

	while (T < cuddT(looking2)) {
	    previousP = &(looking2->next);
	    looking2 = *previousP;
#ifdef DD_UNIQUE_PROFILE
	    unique->uniqueLinks++;
#endif
	}
	while (T == cuddT(looking2) && E < cuddE(looking2)) {
	    previousP = &(looking2->next);
	    looking2 = *previousP;
#ifdef DD_UNIQUE_PROFILE
	    unique->uniqueLinks++;
#endif
	}
    }
    looking->index = index;
    cuddT(looking) = T;
    cuddE(looking) = E;
    looking->next = *previousP;
    *previousP = looking;
    cuddSatInc(T->ref);		/* we know T is a regular pointer */
    cuddRef(E);

#ifdef DD_DEBUG
    cuddCheckCollisionOrdering(unique,level,pos);
#endif

    return(looking);

} /* end of cuddUniqueInter */


/**
  @brief Wrapper for cuddUniqueInter that is independent of variable
  ordering.

  @details Wrapper for cuddUniqueInter that is independent of
  variable ordering (IVO). This function does not require parameter
  index to precede the indices of the top nodes of T and E in the
  variable order.

  @return a pointer to the result node under normal conditions; NULL
  if reordering occurred or memory was exhausted.

  @sideeffect None

  @see cuddUniqueInter Cudd_MakeBddFromZddCover

*/
DdNode *
cuddUniqueInterIVO(
  DdManager * unique,
  int  index,
  DdNode * T,
  DdNode * E)
{
    DdNode *result;
    DdNode *v;

    v = cuddUniqueInter(unique, index, DD_ONE(unique),
			Cudd_Not(DD_ONE(unique)));
    if (v == NULL)
	return(NULL);
    /* Since v is a projection function, we can skip the call to cuddRef. */
    result = cuddBddIteRecur(unique, v, T, E);
    return(result);

} /* end of cuddUniqueInterIVO */


/**
  @brief Checks the unique table for the existence of an internal
  %ZDD node.

  @details If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  For a newly
  created node, increments the reference counts of what T and E point
  to.

  @return a pointer to the new node if successful; NULL if memory is
  exhausted, if a termination request was detected, if a timeout expired,
  or if reordering took place.

  @sideeffect None

  @see cuddUniqueInter

*/
DdNode *
cuddUniqueInterZdd(
  DdManager * unique,
  int  index,
  DdNode * T,
  DdNode * E)
{
    int pos;
    unsigned int level;
    int retval;
    DdNodePtr *nodelist;
    DdNode *looking;
    DdSubtable *subtable;

#ifdef DD_UNIQUE_PROFILE
    unique->uniqueLookUps++;
#endif

    if (((int64_t) 0x1ffff & (int64_t) unique->cacheMisses) == 0) {
        if (unique->terminationCallback != NULL &&
            unique->terminationCallback(unique->tcbArg)) {
            unique->errorCode = CUDD_TERMINATION;
            return(NULL);
        }
        if (util_cpu_time() - unique->startTime > unique->timeLimit) {
            unique->errorCode = CUDD_TIMEOUT_EXPIRED;
            return(NULL);
        }
    }
    if (index >= unique->sizeZ) {
	if (!cuddResizeTableZdd(unique,index)) return(NULL);
    }

    level = unique->permZ[index];
    subtable = &(unique->subtableZ[level]);

#ifdef DD_DEBUG
    assert(level < (unsigned) cuddIZ(unique,T->index));
    assert(level < (unsigned) cuddIZ(unique,Cudd_Regular(E)->index));
#endif

    if (subtable->keys > subtable->maxKeys) {
	if (unique->gcEnabled && ((unique->deadZ > unique->minDead) ||
	(10 * subtable->dead > 9 * subtable->keys))) {	/* too many dead */
            if (unique->terminationCallback != NULL &&
                unique->terminationCallback(unique->tcbArg)) {
                unique->errorCode = CUDD_TERMINATION;
                return(NULL);
            }
            if (util_cpu_time() - unique->startTime > unique->timeLimit) {
                unique->errorCode = CUDD_TIMEOUT_EXPIRED;
                return(NULL);
            }
	    (void) cuddGarbageCollect(unique,1);
	} else {
	    ddRehashZdd(unique,(int)level);
	}
    }

    pos = ddHash(T, E, subtable->shift);
    nodelist = subtable->nodelist;
    looking = nodelist[pos];

    while (looking != NULL) {
	if (cuddT(looking) == T && cuddE(looking) == E) {
	    if (looking->ref == 0) {
		cuddReclaimZdd(unique,looking);
	    }
	    return(looking);
	}
	looking = looking->next;
#ifdef DD_UNIQUE_PROFILE
	unique->uniqueLinks++;
#endif
    }

    /* countDead is 0 if deads should be counted and ~0 if they should not. */
    if (unique->autoDynZ &&
        unique->keysZ - (unique->deadZ & unique->countDead) >= unique->nextDyn) {
#ifdef DD_DEBUG
	retval = Cudd_DebugCheck(unique);
	if (retval != 0) return(NULL);
	retval = Cudd_CheckKeys(unique);
	if (retval != 0) return(NULL);
#endif
	retval = Cudd_zddReduceHeap(unique,unique->autoMethodZ,10); /* 10 = whatever */
	if (retval == 0) {
            unique->reordered = 2;
        } else if (unique->terminationCallback != NULL &&
            unique->terminationCallback(unique->tcbArg)) {
            unique->errorCode = CUDD_TERMINATION;
            unique->reordered = 0;
        } else if (util_cpu_time() - unique->startTime > unique->timeLimit) {
            unique->errorCode = CUDD_TIMEOUT_EXPIRED;
            unique->reordered = 0;
        }
#ifdef DD_DEBUG
	retval = Cudd_DebugCheck(unique);
	if (retval != 0) unique->reordered = 2;
	retval = Cudd_CheckKeys(unique);
	if (retval != 0) unique->reordered = 2;
#endif
	return(NULL);
    }

    unique->keysZ++;
    subtable->keys++;

    looking = cuddAllocNode(unique);
    if (looking == NULL) return(NULL);
    looking->index = index;
    cuddT(looking) = T;
    cuddE(looking) = E;
    looking->next = nodelist[pos];
    nodelist[pos] = looking;
    cuddRef(T);
    cuddRef(E);

    return(looking);

} /* end of cuddUniqueInterZdd */


/**
  @brief Checks the unique table for the existence of a constant node.

  @details If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.

  @return a pointer to the new node.

  @sideeffect None

*/
DdNode *
cuddUniqueConst(
  DdManager * unique,
  CUDD_VALUE_TYPE  value)
{
    int pos;
    DdNodePtr *nodelist;
    DdNode *looking;
    hack split;

#ifdef DD_UNIQUE_PROFILE
    unique->uniqueLookUps++;
#endif

    if (unique->constants.keys > unique->constants.maxKeys) {
	if (unique->gcEnabled && ((unique->dead > unique->minDead) ||
	(10 * unique->constants.dead > 9 * unique->constants.keys))) {	/* too many dead */
            if (unique->terminationCallback != NULL &&
                unique->terminationCallback(unique->tcbArg)) {
                unique->errorCode = CUDD_TERMINATION;
                return(NULL);
            }
            if (util_cpu_time() - unique->startTime > unique->timeLimit) {
                unique->errorCode = CUDD_TIMEOUT_EXPIRED;
                return(NULL);
            }
	    (void) cuddGarbageCollect(unique,1);
	} else {
	    cuddRehash(unique,CUDD_CONST_INDEX);
	}
    }

    cuddAdjust(value); /* for the case of crippled infinities */

    if (ddAbs(value) < unique->epsilon) {
	value = 0.0;
    }
    split.value = value;

    pos = ddHash(split.bits[0], split.bits[1], unique->constants.shift);
    nodelist = unique->constants.nodelist;
    looking = nodelist[pos];

    /* Here we compare values both for equality and for difference less
     * than epsilon. The first comparison is required when values are
     * infinite, since Infinity - Infinity is NaN and NaN < X is 0 for
     * every X.
     */
    while (looking != NULL) {
	if (looking->type.value == value ||
	ddEqualVal(looking->type.value,value,unique->epsilon)) {
	    if (looking->ref == 0) {
		cuddReclaim(unique,looking);
	    }
	    return(looking);
	}
	looking = looking->next;
#ifdef DD_UNIQUE_PROFILE
	unique->uniqueLinks++;
#endif
    }

    unique->keys++;
    unique->constants.keys++;

    looking = cuddAllocNode(unique);
    if (looking == NULL) return(NULL);
    looking->index = CUDD_CONST_INDEX;
    looking->type.value = value;
    looking->next = nodelist[pos];
    nodelist[pos] = looking;

    return(looking);

} /* end of cuddUniqueConst */


/**
  @brief Rehashes a unique subtable.

  @details Doubles the size of a unique subtable and rehashes its
  contents.

  @sideeffect None

*/
void
cuddRehash(
  DdManager * unique,
  int i)
{
    unsigned int slots, oldslots;
    int shift, oldshift;
    int j, pos;
    DdNodePtr *nodelist, *oldnodelist;
    DdNode *node, *next;
    DdNode *sentinel = &(unique->sentinel);
    hack split;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    if (unique->gcFrac == DD_GC_FRAC_HI && unique->slots > unique->looseUpTo) {
	unique->gcFrac = DD_GC_FRAC_LO;
	unique->minDead = (unsigned) (DD_GC_FRAC_LO * (double) unique->slots);
#ifdef DD_VERBOSE
	(void) fprintf(unique->err,"GC fraction = %.2f\t", DD_GC_FRAC_LO);
	(void) fprintf(unique->err,"minDead = %d\n", unique->minDead);
#endif
    }

    if (unique->gcFrac != DD_GC_FRAC_MIN && unique->memused > unique->maxmem) {
	unique->gcFrac = DD_GC_FRAC_MIN;
	unique->minDead = (unsigned) (DD_GC_FRAC_MIN * (double) unique->slots);
#ifdef DD_VERBOSE
	(void) fprintf(unique->err,"GC fraction = %.2f\t", DD_GC_FRAC_MIN);
	(void) fprintf(unique->err,"minDead = %d\n", unique->minDead);
#endif
	cuddShrinkDeathRow(unique);
	if (cuddGarbageCollect(unique,1) > 0) return;
    }

    if (i != CUDD_CONST_INDEX) {
	oldslots = unique->subtables[i].slots;
	oldshift = unique->subtables[i].shift;
	oldnodelist = unique->subtables[i].nodelist;

	/* Compute the new size of the subtable. */
	slots = oldslots << 1;
	shift = oldshift - 1;

	saveHandler = MMoutOfMemory;
	MMoutOfMemory = unique->outOfMemCallback;
	nodelist = ALLOC(DdNodePtr, slots);
	MMoutOfMemory = saveHandler;
	if (nodelist == NULL) {
	    (void) fprintf(unique->err,
			   "Unable to resize subtable %d for lack of memory\n",
			   i);
	    /* Prevent frequent resizing attempts. */
	    (void) cuddGarbageCollect(unique,1);
	    if (unique->stash != NULL) {
		FREE(unique->stash);
		unique->stash = NULL;
		/* Inhibit resizing of tables. */
		cuddSlowTableGrowth(unique);
	    }
	    return;
	}
	unique->subtables[i].nodelist = nodelist;
	unique->subtables[i].slots = slots;
	unique->subtables[i].shift = shift;
	unique->subtables[i].maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;

	/* Move the nodes from the old table to the new table.
	** This code depends on the type of hash function.
	** It assumes that the effect of doubling the size of the table
	** is to retain one more bit of the 32-bit hash value.
	** The additional bit is the LSB. */
	for (j = 0; (unsigned) j < oldslots; j++) {
	    DdNodePtr *evenP, *oddP;
	    node = oldnodelist[j];
	    evenP = &(nodelist[j<<1]);
	    oddP = &(nodelist[(j<<1)+1]);
	    while (node != sentinel) {
		next = node->next;
		pos = ddHash(cuddT(node), cuddE(node), shift);
		if (pos & 1) {
		    *oddP = node;
		    oddP = &(node->next);
		} else {
		    *evenP = node;
		    evenP = &(node->next);
		}
		node = next;
	    }
	    *evenP = *oddP = sentinel;
	}
	FREE(oldnodelist);

#ifdef DD_VERBOSE
	(void) fprintf(unique->err,
		       "rehashing layer %d: keys %d dead %d new size %d\n",
		       i, unique->subtables[i].keys,
		       unique->subtables[i].dead, slots);
#endif
    } else {
	oldslots = unique->constants.slots;
	oldshift = unique->constants.shift;
	oldnodelist = unique->constants.nodelist;

	/* The constant subtable is never subjected to reordering.
	** Therefore, when it is resized, it is because it has just
	** reached the maximum load. We can safely just double the size,
	** with no need for the loop we use for the other tables.
	*/
	slots = oldslots << 1;
	shift = oldshift - 1;
	saveHandler = MMoutOfMemory;
	MMoutOfMemory = unique->outOfMemCallback;
	nodelist = ALLOC(DdNodePtr, slots);
	MMoutOfMemory = saveHandler;
	if (nodelist == NULL) {
	    (void) fprintf(unique->err,
			   "Unable to resize constant subtable for lack of memory\n");
	    (void) cuddGarbageCollect(unique,1);
	    for (j = 0; j < unique->size; j++) {
		unique->subtables[j].maxKeys <<= 1;
	    }
	    unique->constants.maxKeys <<= 1;
	    return;
	}
	unique->constants.slots = slots;
	unique->constants.shift = shift;
	unique->constants.maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;
	unique->constants.nodelist = nodelist;
	for (j = 0; (unsigned) j < slots; j++) {
	    nodelist[j] = NULL;
	}
	for (j = 0; (unsigned) j < oldslots; j++) {
	    node = oldnodelist[j];
	    while (node != NULL) {
		next = node->next;
		split.value = cuddV(node);
		pos = ddHash(split.bits[0], split.bits[1], shift);
		node->next = nodelist[pos];
		nodelist[pos] = node;
		node = next;
	    }
	}
	FREE(oldnodelist);

#ifdef DD_VERBOSE
	(void) fprintf(unique->err,
		       "rehashing constants: keys %d dead %d new size %d\n",
		       unique->constants.keys,unique->constants.dead,slots);
#endif
    }

    /* Update global data */

    unique->memused += (slots - oldslots) * sizeof(DdNodePtr);
    unique->slots += (slots - oldslots);
    ddFixLimits(unique);

} /* end of cuddRehash */


/**
  @brief Shrinks a subtable.

  @sideeffect None

  @see cuddRehash

*/
void
cuddShrinkSubtable(
  DdManager *unique,
  int i)
{
    int j;
    int shift, posn;
    DdNodePtr *nodelist, *oldnodelist;
    DdNode *node, *next;
    DdNode *sentinel = &(unique->sentinel);
    unsigned int slots, oldslots;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    oldnodelist = unique->subtables[i].nodelist;
    oldslots = unique->subtables[i].slots;
    slots = oldslots >> 1;
    saveHandler = MMoutOfMemory;
    MMoutOfMemory = unique->outOfMemCallback;
    nodelist = ALLOC(DdNodePtr, slots);
    MMoutOfMemory = saveHandler;
    if (nodelist == NULL) {
	return;
    }
    unique->subtables[i].nodelist = nodelist;
    unique->subtables[i].slots = slots;
    unique->subtables[i].shift++;
    unique->subtables[i].maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;
#ifdef DD_VERBOSE
    (void) fprintf(unique->err,
		   "shrunk layer %d (%d keys) from %d to %d slots\n",
		   i, unique->subtables[i].keys, oldslots, slots);
#endif

    for (j = 0; (unsigned) j < slots; j++) {
	nodelist[j] = sentinel;
    }
    shift = unique->subtables[i].shift;
    for (j = 0; (unsigned) j < oldslots; j++) {
	node = oldnodelist[j];
	while (node != sentinel) {
	    DdNode *looking, *T, *E;
	    DdNodePtr *previousP;
	    next = node->next;
	    posn = ddHash(cuddT(node), cuddE(node), shift);
	    previousP = &(nodelist[posn]);
	    looking = *previousP;
	    T = cuddT(node);
	    E = cuddE(node);
	    while (T < cuddT(looking)) {
		previousP = &(looking->next);
		looking = *previousP;
#ifdef DD_UNIQUE_PROFILE
		unique->uniqueLinks++;
#endif
	    }
	    while (T == cuddT(looking) && E < cuddE(looking)) {
		previousP = &(looking->next);
		looking = *previousP;
#ifdef DD_UNIQUE_PROFILE
		unique->uniqueLinks++;
#endif
	    }
	    node->next = *previousP;
	    *previousP = node;
	    node = next;
	}
    }
    FREE(oldnodelist);

    unique->memused += ((long) slots - (long) oldslots) * sizeof(DdNode *);
    unique->slots += slots - oldslots;
    unique->minDead = (unsigned) (unique->gcFrac * (double) unique->slots);
    unique->cacheSlack = (int)
	ddMin(unique->maxCacheHard,DD_MAX_CACHE_TO_SLOTS_RATIO * unique->slots)
	- 2 * (int) unique->cacheSlots;

} /* end of cuddShrinkSubtable */


/**
  @brief Inserts n new subtables in a unique table at level.

  @details The number n should be positive, and level should be an
  existing level.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see cuddDestroySubtables

*/
int
cuddInsertSubtables(
  DdManager * unique,
  int  n,
  int  level)
{
    DdSubtable *newsubtables;
    DdNodePtr *newnodelist;
    DdNodePtr *newvars;
    DdNode *sentinel = &(unique->sentinel);
    int oldsize,newsize;
    int i,j,index,reorderSave;
    unsigned int numSlots = unique->initSlots;
    int *newperm, *newinvperm, *newmap = NULL;
    DdNode *one, *zero;

#ifdef DD_DEBUG
    assert(n > 0 && level < unique->size);
#endif

    oldsize = unique->size;
    /* Easy case: there is still room in the current table. */
    if (oldsize + n <= unique->maxSize) {
	/* Shift the tables at and below level. */
	for (i = oldsize - 1; i >= level; i--) {
	    unique->subtables[i+n].slots    = unique->subtables[i].slots;
	    unique->subtables[i+n].shift    = unique->subtables[i].shift;
	    unique->subtables[i+n].keys     = unique->subtables[i].keys;
	    unique->subtables[i+n].maxKeys  = unique->subtables[i].maxKeys;
	    unique->subtables[i+n].dead     = unique->subtables[i].dead;
            unique->subtables[i+n].next     = i+n;
	    unique->subtables[i+n].nodelist = unique->subtables[i].nodelist;
	    unique->subtables[i+n].bindVar  = unique->subtables[i].bindVar;
	    unique->subtables[i+n].varType  = unique->subtables[i].varType;
	    unique->subtables[i+n].pairIndex  = unique->subtables[i].pairIndex;
	    unique->subtables[i+n].varHandled = unique->subtables[i].varHandled;
	    unique->subtables[i+n].varToBeGrouped =
		unique->subtables[i].varToBeGrouped;

	    index                           = unique->invperm[i];
	    unique->invperm[i+n]            = index;
	    unique->perm[index]            += n;
	}
	/* Create new subtables. */
	for (i = 0; i < n; i++) {
	    unique->subtables[level+i].slots = numSlots;
	    unique->subtables[level+i].shift = sizeof(int) * 8 -
		cuddComputeFloorLog2(numSlots);
	    unique->subtables[level+i].keys = 0;
	    unique->subtables[level+i].maxKeys = numSlots * DD_MAX_SUBTABLE_DENSITY;
	    unique->subtables[level+i].dead = 0;
            unique->subtables[level+i].next = level+i;
	    unique->subtables[level+i].bindVar = 0;
	    unique->subtables[level+i].varType = CUDD_VAR_PRIMARY_INPUT;
	    unique->subtables[level+i].pairIndex = 0;
	    unique->subtables[level+i].varHandled = 0;
	    unique->subtables[level+i].varToBeGrouped = CUDD_LAZY_NONE;

	    unique->perm[oldsize+i] = level + i;
	    unique->invperm[level+i] = oldsize + i;
	    newnodelist = unique->subtables[level+i].nodelist =
		ALLOC(DdNodePtr, numSlots);
	    if (newnodelist == NULL) {
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    for (j = 0; (unsigned) j < numSlots; j++) {
		newnodelist[j] = sentinel;
	    }
	}
	if (unique->map != NULL) {
	    for (i = 0; i < n; i++) {
		unique->map[oldsize+i] = oldsize + i;
	    }
	}
    } else {
	/* The current table is too small: we need to allocate a new,
	** larger one; move all old subtables, and initialize the new
	** subtables.
	*/
	newsize = oldsize + n + DD_DEFAULT_RESIZE;
#ifdef DD_VERBOSE
	(void) fprintf(unique->err,
		       "Increasing the table size from %d to %d\n",
	    unique->maxSize, newsize);
#endif
	/* Allocate memory for new arrays (except nodelists). */
	newsubtables = ALLOC(DdSubtable,newsize);
	if (newsubtables == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	newvars = ALLOC(DdNodePtr,newsize);
	if (newvars == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    FREE(newsubtables);
	    return(0);
	}
	newperm = ALLOC(int,newsize);
	if (newperm == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    FREE(newsubtables);
	    FREE(newvars);
	    return(0);
	}
	newinvperm = ALLOC(int,newsize);
	if (newinvperm == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    FREE(newsubtables);
	    FREE(newvars);
	    FREE(newperm);
	    return(0);
	}
	if (unique->map != NULL) {
	    newmap = ALLOC(int,newsize);
	    if (newmap == NULL) {
		unique->errorCode = CUDD_MEMORY_OUT;
		FREE(newsubtables);
		FREE(newvars);
		FREE(newperm);
		FREE(newinvperm);
		return(0);
	    }
	    unique->memused += (newsize - unique->maxSize) * sizeof(int);
	}
	unique->memused += (newsize - unique->maxSize) * ((numSlots+1) *
	    sizeof(DdNode *) + 2 * sizeof(int) + sizeof(DdSubtable));
	/* Copy levels before insertion points from old tables. */
	for (i = 0; i < level; i++) {
	    newsubtables[i].slots = unique->subtables[i].slots;
	    newsubtables[i].shift = unique->subtables[i].shift;
	    newsubtables[i].keys = unique->subtables[i].keys;
	    newsubtables[i].maxKeys = unique->subtables[i].maxKeys;
	    newsubtables[i].dead = unique->subtables[i].dead;
            newsubtables[i].next = i;
	    newsubtables[i].nodelist = unique->subtables[i].nodelist;
	    newsubtables[i].bindVar = unique->subtables[i].bindVar;
	    newsubtables[i].varType = unique->subtables[i].varType;
	    newsubtables[i].pairIndex = unique->subtables[i].pairIndex;
	    newsubtables[i].varHandled = unique->subtables[i].varHandled;
	    newsubtables[i].varToBeGrouped = unique->subtables[i].varToBeGrouped;

	    newvars[i] = unique->vars[i];
	    newperm[i] = unique->perm[i];
	    newinvperm[i] = unique->invperm[i];
	}
	/* Finish initializing permutation for new table to old one. */
	for (i = level; i < oldsize; i++) {
	    newperm[i] = unique->perm[i];
	}
	/* Initialize new levels. */
	for (i = level; i < level + n; i++) {
	    newsubtables[i].slots = numSlots;
	    newsubtables[i].shift = sizeof(int) * 8 -
		cuddComputeFloorLog2(numSlots);
	    newsubtables[i].keys = 0;
	    newsubtables[i].maxKeys = numSlots * DD_MAX_SUBTABLE_DENSITY;
	    newsubtables[i].dead = 0;
            newsubtables[i].next = i;
	    newsubtables[i].bindVar = 0;
	    newsubtables[i].varType = CUDD_VAR_PRIMARY_INPUT;
	    newsubtables[i].pairIndex = 0;
	    newsubtables[i].varHandled = 0;
	    newsubtables[i].varToBeGrouped = CUDD_LAZY_NONE;

	    newperm[oldsize + i - level] = i;
	    newinvperm[i] = oldsize + i - level;
	    newnodelist = newsubtables[i].nodelist = ALLOC(DdNodePtr, numSlots);
	    if (newnodelist == NULL) {
		/* We are going to leak some memory.  We should clean up. */
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    for (j = 0; (unsigned) j < numSlots; j++) {
		newnodelist[j] = sentinel;
	    }
	}
	/* Copy the old tables for levels past the insertion point. */
	for (i = level; i < oldsize; i++) {
	    newsubtables[i+n].slots    = unique->subtables[i].slots;
	    newsubtables[i+n].shift    = unique->subtables[i].shift;
	    newsubtables[i+n].keys     = unique->subtables[i].keys;
	    newsubtables[i+n].maxKeys  = unique->subtables[i].maxKeys;
	    newsubtables[i+n].dead     = unique->subtables[i].dead;
            newsubtables[i+n].next     = i+n;
	    newsubtables[i+n].nodelist = unique->subtables[i].nodelist;
	    newsubtables[i+n].bindVar  = unique->subtables[i].bindVar;
	    newsubtables[i+n].varType  = unique->subtables[i].varType;
	    newsubtables[i+n].pairIndex  = unique->subtables[i].pairIndex;
	    newsubtables[i+n].varHandled  = unique->subtables[i].varHandled;
	    newsubtables[i+n].varToBeGrouped  =
		unique->subtables[i].varToBeGrouped;

	    newvars[i]                 = unique->vars[i];
	    index                      = unique->invperm[i];
	    newinvperm[i+n]            = index;
	    newperm[index]            += n;
	}
	/* Update the map. */
	if (unique->map != NULL) {
	    for (i = 0; i < oldsize; i++) {
		newmap[i] = unique->map[i];
	    }
	    for (i = oldsize; i < oldsize + n; i++) {
		newmap[i] = i;
	    }
	    FREE(unique->map);
	    unique->map = newmap;
	}
	/* Install the new tables and free the old ones. */
	FREE(unique->subtables);
	unique->subtables = newsubtables;
	unique->maxSize = newsize;
	FREE(unique->vars);
	unique->vars = newvars;
	FREE(unique->perm);
	unique->perm = newperm;
	FREE(unique->invperm);
	unique->invperm = newinvperm;
	/* Update the stack for iterative procedures. */
	if (newsize > unique->maxSizeZ) {
	    FREE(unique->stack);
	    unique->stack = ALLOC(DdNodePtr,newsize + 1);
	    if (unique->stack == NULL) {
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    unique->stack[0] = NULL; /* to suppress harmless UMR */
	    unique->memused +=
		(newsize - ddMax(unique->maxSize,unique->maxSizeZ))
		* sizeof(DdNode *);
	}
    }
    /* Update manager parameters to account for the new subtables. */
    unique->slots += n * numSlots;
    ddFixLimits(unique);
    unique->size += n;

    /* Now that the table is in a coherent state, create the new
    ** projection functions. We need to temporarily disable reordering,
    ** because we cannot reorder without projection functions in place.
    **/
    one = unique->one;
    zero = Cudd_Not(one);

    reorderSave = unique->autoDyn;
    unique->autoDyn = 0;
    for (i = oldsize; i < oldsize + n; i++) {
	unique->vars[i] = cuddUniqueInter(unique,i,one,zero);
	if (unique->vars[i] == NULL) {
	    unique->autoDyn = reorderSave;
	    /* Shift everything back so table remains coherent. */
	    for (j = oldsize; j < i; j++) {
		Cudd_IterDerefBdd(unique,unique->vars[j]);
		cuddDeallocNode(unique,unique->vars[j]);
		unique->vars[j] = NULL;
	    }
	    for (j = level; j < oldsize; j++) {
		unique->subtables[j].slots    = unique->subtables[j+n].slots;
		unique->subtables[j].slots    = unique->subtables[j+n].slots;
		unique->subtables[j].shift    = unique->subtables[j+n].shift;
		unique->subtables[j].keys     = unique->subtables[j+n].keys;
		unique->subtables[j].maxKeys  =
		    unique->subtables[j+n].maxKeys;
		unique->subtables[j].dead     = unique->subtables[j+n].dead;
                unique->subtables[j].next     = j;
		FREE(unique->subtables[j].nodelist);
		unique->subtables[j].nodelist =
		    unique->subtables[j+n].nodelist;
		unique->subtables[j+n].nodelist = NULL;
		unique->subtables[j].bindVar  =
		    unique->subtables[j+n].bindVar;
		unique->subtables[j].varType  =
		    unique->subtables[j+n].varType;
		unique->subtables[j].pairIndex =
		    unique->subtables[j+n].pairIndex;
		unique->subtables[j].varHandled =
		    unique->subtables[j+n].varHandled;
		unique->subtables[j].varToBeGrouped =
		    unique->subtables[j+n].varToBeGrouped;
		index                         = unique->invperm[j+n];
		unique->invperm[j]            = index;
		unique->perm[index]          -= n;
	    }
	    unique->size = oldsize;
	    unique->slots -= n * numSlots;
	    ddFixLimits(unique);
	    (void) Cudd_DebugCheck(unique);
	    return(0);
	}
	cuddRef(unique->vars[i]);
    }
    if (unique->tree != NULL) {
	unique->tree->size += n;
	unique->tree->index = unique->invperm[0];
	ddPatchTree(unique,unique->tree);
    }
    unique->autoDyn = reorderSave;

    return(1);

} /* end of cuddInsertSubtables */


/**
  @brief Destroys the n most recently created subtables in a unique table.

  @details n should be positive. The subtables should not contain any live
  nodes, except the (isolated) projection function. The projection
  functions are freed.

  @return 1 if successful; 0 otherwise.

  @sideeffect The variable map used for fast variable substitution is
  destroyed if it exists. In this case the cache is also cleared.

  @see cuddInsertSubtables Cudd_SetVarMap

*/
int
cuddDestroySubtables(
  DdManager * unique,
  int  n)
{
    DdSubtable *subtables;
    DdNodePtr *nodelist;
    DdNodePtr *vars;
    int firstIndex, lastIndex;
    int index, level, newlevel;
    int lowestLevel;
    int shift;
    int found;

    /* Sanity check and set up. */
    if (n <= 0) return(0);
    if (n > unique->size) n = unique->size;

    subtables = unique->subtables;
    vars = unique->vars;
    firstIndex = unique->size - n;
    lastIndex  = unique->size;

    /* Check for nodes labeled by the variables being destroyed
    ** that may still be in use.  It is allowed to destroy a variable
    ** only if there are no such nodes. Also, find the lowest level
    ** among the variables being destroyed. This will make further
    ** processing more efficient.
    */
    lowestLevel = unique->size;
    for (index = firstIndex; index < lastIndex; index++) {
	level = unique->perm[index];
	if (level < lowestLevel) lowestLevel = level;
	if (subtables[level].keys - subtables[level].dead != 1) return(0);
	/* The projection function should be isolated. If the ref count
	** is 1, everything is OK. If the ref count is saturated, then
	** we need to make sure that there are no nodes pointing to it.
	** As for the external references, we assume the application is
	** responsible for them.
	*/
	if (vars[index]->ref != 1) {
	    if (vars[index]->ref != DD_MAXREF) return(0);
	    found = cuddFindParent(unique,vars[index]);
	    if (found) {
		return(0);
	    } else {
		vars[index]->ref = 1;
	    }
	}
	Cudd_RecursiveDeref(unique,vars[index]);
    }

    /* Collect garbage, because we cannot afford having dead nodes pointing
    ** to the dead nodes in the subtables being destroyed.
    */
    (void) cuddGarbageCollect(unique,1);

    /* Here we know we can destroy our subtables. */
    for (index = firstIndex; index < lastIndex; index++) {
	level = unique->perm[index];
	nodelist = subtables[level].nodelist;
#ifdef DD_DEBUG
	assert(subtables[level].keys == 0);
#endif
	FREE(nodelist);
	unique->memused -= sizeof(DdNodePtr) * subtables[level].slots;
	unique->slots -= subtables[level].slots;
	unique->dead -= subtables[level].dead;
    }

    /* Here all subtables to be destroyed have their keys field == 0 and
    ** their hash tables have been freed.
    ** We now scan the subtables from level lowestLevel + 1 to level size - 1,
    ** shifting the subtables as required. We keep a running count of
    ** how many subtables have been moved, so that we know by how many
    ** positions each subtable should be shifted.
    */
    shift = 1;
    for (level = lowestLevel + 1; level < unique->size; level++) {
	if (subtables[level].keys == 0) {
	    shift++;
	    continue;
	}
	newlevel = level - shift;
	subtables[newlevel].slots = subtables[level].slots;
	subtables[newlevel].shift = subtables[level].shift;
	subtables[newlevel].keys = subtables[level].keys;
	subtables[newlevel].maxKeys = subtables[level].maxKeys;
	subtables[newlevel].dead = subtables[level].dead;
        subtables[newlevel].next = newlevel;
	subtables[newlevel].nodelist = subtables[level].nodelist;
	index = unique->invperm[level];
	unique->perm[index] = newlevel;
	unique->invperm[newlevel]  = index;
	subtables[newlevel].bindVar = subtables[level].bindVar;
	subtables[newlevel].varType = subtables[level].varType;
	subtables[newlevel].pairIndex = subtables[level].pairIndex;
	subtables[newlevel].varHandled = subtables[level].varHandled;
	subtables[newlevel].varToBeGrouped = subtables[level].varToBeGrouped;
    }
    /* Destroy the map. If a surviving variable is
    ** mapped to a dying variable, and the map were used again,
    ** an out-of-bounds access to unique->vars would result. */
    if (unique->map != NULL) {
	cuddCacheFlush(unique);
	FREE(unique->map);
	unique->map = NULL;
    }

    unique->minDead = (unsigned) (unique->gcFrac * (double) unique->slots);
    unique->size -= n;

    return(1);

} /* end of cuddDestroySubtables */


/**
  @brief Increases the number of %ZDD subtables in a unique table so
  that it meets or exceeds index.

  @details When new %ZDD variables are created, it is possible to
  preserve the functions unchanged, or it is possible to preserve the
  covers unchanged, but not both. cuddResizeTableZdd preserves the
  covers.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see ddResizeTable

*/
int
cuddResizeTableZdd(
  DdManager * unique,
  int  index)
{
    DdSubtable *newsubtables;
    DdNodePtr *newnodelist;
    int oldsize,newsize;
    int i,j,reorderSave;
    unsigned int numSlots = unique->initSlots;
    int *newperm, *newinvperm;

    oldsize = unique->sizeZ;
    /* Easy case: there is still room in the current table. */
    if (index < unique->maxSizeZ) {
	for (i = oldsize; i <= index; i++) {
	    unique->subtableZ[i].slots = numSlots;
	    unique->subtableZ[i].shift = sizeof(int) * 8 -
		cuddComputeFloorLog2(numSlots);
	    unique->subtableZ[i].keys = 0;
	    unique->subtableZ[i].maxKeys = numSlots * DD_MAX_SUBTABLE_DENSITY;
	    unique->subtableZ[i].dead = 0;
            unique->subtableZ[i].next = i;
	    unique->permZ[i] = i;
	    unique->invpermZ[i] = i;
	    newnodelist = unique->subtableZ[i].nodelist =
		ALLOC(DdNodePtr, numSlots);
	    if (newnodelist == NULL) {
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    for (j = 0; (unsigned) j < numSlots; j++) {
		newnodelist[j] = NULL;
	    }
	}
    } else {
	/* The current table is too small: we need to allocate a new,
	** larger one; move all old subtables, and initialize the new
	** subtables up to index included.
	*/
	newsize = index + DD_DEFAULT_RESIZE;
#ifdef DD_VERBOSE
	(void) fprintf(unique->err,
		       "Increasing the ZDD table size from %d to %d\n",
	    unique->maxSizeZ, newsize);
#endif
	newsubtables = ALLOC(DdSubtable,newsize);
	if (newsubtables == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	newperm = ALLOC(int,newsize);
	if (newperm == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	newinvperm = ALLOC(int,newsize);
	if (newinvperm == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	unique->memused += (newsize - unique->maxSizeZ) * ((numSlots+1) *
	    sizeof(DdNode *) + 2 * sizeof(int) + sizeof(DdSubtable));
	if (newsize > unique->maxSize) {
	    FREE(unique->stack);
	    unique->stack = ALLOC(DdNodePtr,newsize + 1);
	    if (unique->stack == NULL) {
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    unique->stack[0] = NULL; /* to suppress harmless UMR */
	    unique->memused +=
		(newsize - ddMax(unique->maxSize,unique->maxSizeZ))
		* sizeof(DdNode *);
	}
	for (i = 0; i < oldsize; i++) {
	    newsubtables[i].slots = unique->subtableZ[i].slots;
	    newsubtables[i].shift = unique->subtableZ[i].shift;
	    newsubtables[i].keys = unique->subtableZ[i].keys;
	    newsubtables[i].maxKeys = unique->subtableZ[i].maxKeys;
	    newsubtables[i].dead = unique->subtableZ[i].dead;
            newsubtables[i].next = i;
	    newsubtables[i].nodelist = unique->subtableZ[i].nodelist;
	    newperm[i] = unique->permZ[i];
	    newinvperm[i] = unique->invpermZ[i];
	}
	for (i = oldsize; i <= index; i++) {
	    newsubtables[i].slots = numSlots;
	    newsubtables[i].shift = sizeof(int) * 8 -
		cuddComputeFloorLog2(numSlots);
	    newsubtables[i].keys = 0;
	    newsubtables[i].maxKeys = numSlots * DD_MAX_SUBTABLE_DENSITY;
	    newsubtables[i].dead = 0;
            newsubtables[i].next = i;
	    newperm[i] = i;
	    newinvperm[i] = i;
	    newnodelist = newsubtables[i].nodelist = ALLOC(DdNodePtr, numSlots);
	    if (newnodelist == NULL) {
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    for (j = 0; (unsigned) j < numSlots; j++) {
		newnodelist[j] = NULL;
	    }
	}
	FREE(unique->subtableZ);
	unique->subtableZ = newsubtables;
	unique->maxSizeZ = newsize;
	FREE(unique->permZ);
	unique->permZ = newperm;
	FREE(unique->invpermZ);
	unique->invpermZ = newinvperm;
    }
    unique->slots += (index + 1 - unique->sizeZ) * numSlots;
    ddFixLimits(unique);
    unique->sizeZ = index + 1;

    /* Now that the table is in a coherent state, update the ZDD
    ** universe. We need to temporarily disable reordering,
    ** because we cannot reorder without universe in place.
    */

    reorderSave = unique->autoDynZ;
    unique->autoDynZ = 0;
    cuddZddFreeUniv(unique);
    if (!cuddZddInitUniv(unique)) {
	unique->autoDynZ = reorderSave;
	return(0);
    }
    unique->autoDynZ = reorderSave;

    return(1);

} /* end of cuddResizeTableZdd */


/**
  @brief Adjusts parameters of a table to slow down its growth.

  @sideeffect None

*/
void
cuddSlowTableGrowth(
  DdManager *unique)
{
    int i;

    unique->maxCacheHard = unique->cacheSlots - 1;
    unique->cacheSlack = - (int) (unique->cacheSlots + 1);
    for (i = 0; i < unique->size; i++) {
	unique->subtables[i].maxKeys <<= 2;
    }
    unique->gcFrac = DD_GC_FRAC_MIN;
    unique->minDead = (unsigned) (DD_GC_FRAC_MIN * (double) unique->slots);
    cuddShrinkDeathRow(unique);
#ifdef DD_VERBOSE
    (void) fprintf(unique->err,"CUDD: slowing down table growth: ");
    (void) fprintf(unique->err,"GC fraction = %.2f\t", unique->gcFrac);
    (void) fprintf(unique->err,"minDead = %u\n", unique->minDead);
#endif

} /* end of cuddSlowTableGrowth */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Rehashes a %ZDD unique subtable.

  @sideeffect None

  @see cuddRehash

*/
static void
ddRehashZdd(
  DdManager * unique,
  int  i)
{
    unsigned int slots, oldslots;
    int shift, oldshift;
    int j, pos;
    DdNodePtr *nodelist, *oldnodelist;
    DdNode *node, *next;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

    if (unique->slots > unique->looseUpTo) {
	unique->minDead = (unsigned) (DD_GC_FRAC_LO * (double) unique->slots);
#ifdef DD_VERBOSE
	if (unique->gcFrac == DD_GC_FRAC_HI) {
	    (void) fprintf(unique->err,"GC fraction = %.2f\t",
			   DD_GC_FRAC_LO);
	    (void) fprintf(unique->err,"minDead = %d\n", unique->minDead);
	}
#endif
	unique->gcFrac = DD_GC_FRAC_LO;
    }

    assert(i != CUDD_MAXINDEX);
    oldslots = unique->subtableZ[i].slots;
    oldshift = unique->subtableZ[i].shift;
    oldnodelist = unique->subtableZ[i].nodelist;

    /* Compute the new size of the subtable. Normally, we just
    ** double.  However, after reordering, a table may be severely
    ** overloaded. Therefore, we iterate. */
    slots = oldslots;
    shift = oldshift;
    do {
	slots <<= 1;
	shift--;
    } while (slots * DD_MAX_SUBTABLE_DENSITY < unique->subtableZ[i].keys);

    saveHandler = MMoutOfMemory;
    MMoutOfMemory = unique->outOfMemCallback;
    nodelist = ALLOC(DdNodePtr, slots);
    MMoutOfMemory = saveHandler;
    if (nodelist == NULL) {
	(void) fprintf(unique->err,
		       "Unable to resize ZDD subtable %d for lack of memory.\n",
		       i);
	(void) cuddGarbageCollect(unique,1);
	for (j = 0; j < unique->sizeZ; j++) {
	    unique->subtableZ[j].maxKeys <<= 1;
	}
	return;
    }
    unique->subtableZ[i].nodelist = nodelist;
    unique->subtableZ[i].slots = slots;
    unique->subtableZ[i].shift = shift;
    unique->subtableZ[i].maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;
    for (j = 0; (unsigned) j < slots; j++) {
	nodelist[j] = NULL;
    }
    for (j = 0; (unsigned) j < oldslots; j++) {
	node = oldnodelist[j];
	while (node != NULL) {
	    next = node->next;
	    pos = ddHash(cuddT(node), cuddE(node), shift);
	    node->next = nodelist[pos];
	    nodelist[pos] = node;
	    node = next;
	}
    }
    FREE(oldnodelist);

#ifdef DD_VERBOSE
    (void) fprintf(unique->err,
		   "rehashing layer %d: keys %d dead %d new size %d\n",
		   i, unique->subtableZ[i].keys,
		   unique->subtableZ[i].dead, slots);
#endif

    /* Update global data. */
    unique->memused += (slots - oldslots) * sizeof(DdNode *);
    unique->slots += (slots - oldslots);
    ddFixLimits(unique);

} /* end of ddRehashZdd */


/**
  @brief Increases the number of subtables in a unique table so
  that it meets or exceeds index.

  @details The parameter amount determines how much spare space is
  allocated to prevent too frequent resizing.  If index is negative,
  the table is resized, but no new variables are created.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_Reserve cuddResizeTableZdd

*/
static int
ddResizeTable(
  DdManager * unique,
  int index,
  int amount)
{
    DdSubtable *newsubtables;
    DdNodePtr *newnodelist;
    DdNodePtr *newvars;
    DdNode *sentinel = &(unique->sentinel);
    int oldsize,newsize;
    int i,j,reorderSave;
    int numSlots = unique->initSlots;
    int *newperm, *newinvperm, *newmap = NULL;
    DdNode *one, *zero;

    oldsize = unique->size;
    /* Easy case: there is still room in the current table. */
    if (index >= 0 && index < unique->maxSize) {
	for (i = oldsize; i <= index; i++) {
	    unique->subtables[i].slots = numSlots;
	    unique->subtables[i].shift = sizeof(int) * 8 -
		cuddComputeFloorLog2(numSlots);
	    unique->subtables[i].keys = 0;
	    unique->subtables[i].maxKeys = numSlots * DD_MAX_SUBTABLE_DENSITY;
	    unique->subtables[i].dead = 0;
            unique->subtables[i].next = i;
	    unique->subtables[i].bindVar = 0;
	    unique->subtables[i].varType = CUDD_VAR_PRIMARY_INPUT;
	    unique->subtables[i].pairIndex = 0;
	    unique->subtables[i].varHandled = 0;
	    unique->subtables[i].varToBeGrouped = CUDD_LAZY_NONE;

	    unique->perm[i] = i;
	    unique->invperm[i] = i;
	    newnodelist = unique->subtables[i].nodelist =
		ALLOC(DdNodePtr, numSlots);
	    if (newnodelist == NULL) {
		for (j = oldsize; j < i; j++) {
		    FREE(unique->subtables[j].nodelist);
		}
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    for (j = 0; j < numSlots; j++) {
		newnodelist[j] = sentinel;
	    }
	}
	if (unique->map != NULL) {
	    for (i = oldsize; i <= index; i++) {
		unique->map[i] = i;
	    }
	}
    } else {
	/* The current table is too small: we need to allocate a new,
	** larger one; move all old subtables, and initialize the new
	** subtables up to index included.
	*/
	newsize = (index < 0) ? amount + oldsize : index + amount;
#ifdef DD_VERBOSE
	(void) fprintf(unique->err,
		       "Increasing the table size from %d to %d\n",
		       unique->maxSize, newsize);
#endif
	newsubtables = ALLOC(DdSubtable,newsize);
	if (newsubtables == NULL) {
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	newvars = ALLOC(DdNodePtr,newsize);
	if (newvars == NULL) {
	    FREE(newsubtables);
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	newperm = ALLOC(int,newsize);
	if (newperm == NULL) {
	    FREE(newsubtables);
	    FREE(newvars);
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	newinvperm = ALLOC(int,newsize);
	if (newinvperm == NULL) {
	    FREE(newsubtables);
	    FREE(newvars);
	    FREE(newperm);
	    unique->errorCode = CUDD_MEMORY_OUT;
	    return(0);
	}
	if (unique->map != NULL) {
	    newmap = ALLOC(int,newsize);
	    if (newmap == NULL) {
		FREE(newsubtables);
		FREE(newvars);
		FREE(newperm);
		FREE(newinvperm);
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    unique->memused += (newsize - unique->maxSize) * sizeof(int);
	}
	unique->memused += (newsize - unique->maxSize) * ((numSlots+1) *
	    sizeof(DdNode *) + 2 * sizeof(int) + sizeof(DdSubtable));
	if (newsize > unique->maxSizeZ) {
	    FREE(unique->stack);
	    unique->stack = ALLOC(DdNodePtr,newsize + 1);
	    if (unique->stack == NULL) {
		FREE(newsubtables);
		FREE(newvars);
		FREE(newperm);
		FREE(newinvperm);
		if (unique->map != NULL) {
		    FREE(newmap);
		}
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    unique->stack[0] = NULL; /* to suppress harmless UMR */
	    unique->memused +=
		(newsize - ddMax(unique->maxSize,unique->maxSizeZ))
		* sizeof(DdNode *);
	}
	for (i = 0; i < oldsize; i++) {
	    newsubtables[i].slots = unique->subtables[i].slots;
	    newsubtables[i].shift = unique->subtables[i].shift;
	    newsubtables[i].keys = unique->subtables[i].keys;
	    newsubtables[i].maxKeys = unique->subtables[i].maxKeys;
	    newsubtables[i].dead = unique->subtables[i].dead;
            newsubtables[i].next = i;
	    newsubtables[i].nodelist = unique->subtables[i].nodelist;
	    newsubtables[i].bindVar = unique->subtables[i].bindVar;
	    newsubtables[i].varType = unique->subtables[i].varType;
	    newsubtables[i].pairIndex = unique->subtables[i].pairIndex;
	    newsubtables[i].varHandled = unique->subtables[i].varHandled;
	    newsubtables[i].varToBeGrouped = unique->subtables[i].varToBeGrouped;

	    newvars[i] = unique->vars[i];
	    newperm[i] = unique->perm[i];
	    newinvperm[i] = unique->invperm[i];
	}
	for (i = oldsize; i <= index; i++) {
	    newsubtables[i].slots = numSlots;
	    newsubtables[i].shift = sizeof(int) * 8 -
		cuddComputeFloorLog2(numSlots);
	    newsubtables[i].keys = 0;
	    newsubtables[i].maxKeys = numSlots * DD_MAX_SUBTABLE_DENSITY;
	    newsubtables[i].dead = 0;
            newsubtables[i].next = i;
	    newsubtables[i].bindVar = 0;
	    newsubtables[i].varType = CUDD_VAR_PRIMARY_INPUT;
	    newsubtables[i].pairIndex = 0;
	    newsubtables[i].varHandled = 0;
	    newsubtables[i].varToBeGrouped = CUDD_LAZY_NONE;

	    newperm[i] = i;
	    newinvperm[i] = i;
	    newnodelist = newsubtables[i].nodelist = ALLOC(DdNodePtr, numSlots);
	    if (newnodelist == NULL) {
		unique->errorCode = CUDD_MEMORY_OUT;
		return(0);
	    }
	    for (j = 0; j < numSlots; j++) {
		newnodelist[j] = sentinel;
	    }
	}
	if (unique->map != NULL) {
	    for (i = 0; i < oldsize; i++) {
		newmap[i] = unique->map[i];
	    }
	    for (i = oldsize; i <= index; i++) {
		newmap[i] = i;
	    }
	    FREE(unique->map);
	    unique->map = newmap;
	}
	FREE(unique->subtables);
	unique->subtables = newsubtables;
	unique->maxSize = newsize;
	FREE(unique->vars);
	unique->vars = newvars;
	FREE(unique->perm);
	unique->perm = newperm;
	FREE(unique->invperm);
	unique->invperm = newinvperm;
    }

    /* Now that the table is in a coherent state, create the new
    ** projection functions. We need to temporarily disable reordering,
    ** because we cannot reorder without projection functions in place.
    **/
    if (index >= 0) {
        one = unique->one;
        zero = Cudd_Not(one);

        unique->size = index + 1;
        if (unique->tree != NULL) {
	    unique->tree->size = ddMax(unique->tree->size, (MtrHalfWord) unique->size);
        }
        unique->slots += (index + 1 - oldsize) * numSlots;
        ddFixLimits(unique);

        reorderSave = unique->autoDyn;
        unique->autoDyn = 0;
        for (i = oldsize; i <= index; i++) {
            unique->vars[i] = cuddUniqueInter(unique,i,one,zero);
            if (unique->vars[i] == NULL) {
                unique->autoDyn = reorderSave;
                for (j = oldsize; j < i; j++) {
                    Cudd_IterDerefBdd(unique,unique->vars[j]);
                    cuddDeallocNode(unique,unique->vars[j]);
                    unique->vars[j] = NULL;
                }
                for (j = oldsize; j <= index; j++) {
                    FREE(unique->subtables[j].nodelist);
                    unique->subtables[j].nodelist = NULL;
                }
                unique->size = oldsize;
                unique->slots -= (index + 1 - oldsize) * numSlots;
                ddFixLimits(unique);
                return(0);
            }
            cuddRef(unique->vars[i]);
        }
        unique->autoDyn = reorderSave;
    }

    return(1);

} /* end of ddResizeTable */


/**
  @brief Searches the subtables above node for a parent.

  @details Returns 1 as soon as one parent is found. Returns 0 is the
  search is fruitless.

  @sideeffect None

*/
static int
cuddFindParent(
  DdManager * table,
  DdNode * node)
{
    int         i,j;
    int		slots;
    DdNodePtr	*nodelist;
    DdNode	*f;

    for (i = cuddI(table,node->index) - 1; i >= 0; i--) {
	nodelist = table->subtables[i].nodelist;
	slots = table->subtables[i].slots;

	for (j = 0; j < slots; j++) {
	    f = nodelist[j];
	    while (cuddT(f) > node) {
		f = f->next;
	    }
	    while (cuddT(f) == node && Cudd_Regular(cuddE(f)) > node) {
		f = f->next;
	    }
	    if (cuddT(f) == node && Cudd_Regular(cuddE(f)) == node) {
		return(1);
	    }
	}
    }

    return(0);

} /* end of cuddFindParent */


/**
  @brief Adjusts the values of table limits.

  @details Adjusts the values of table fields controlling the sizes of
  subtables and computed table. If the computed table is too small
  according to the new values, it is resized.

  @sideeffect Modifies manager fields. May resize computed table.

*/
static void
ddFixLimits(
  DdManager *unique)
{
    unique->minDead = (unsigned) (unique->gcFrac * (double) unique->slots);
    unique->cacheSlack = (int) ddMin(unique->maxCacheHard,
	DD_MAX_CACHE_TO_SLOTS_RATIO * unique->slots) -
	2 * (int) unique->cacheSlots;
    if (unique->cacheSlots < unique->slots/2 && unique->cacheSlack >= 0)
	cuddCacheResize(unique);
    return;

} /* end of ddFixLimits */


#ifndef DD_UNSORTED_FREE_LIST
#ifdef DD_RED_BLACK_FREE_LIST
/**
  @brief Inserts a DdNode in a red/black search tree.

  @details Nodes from the same "page" (defined by DD_PAGE_MASK) are
  linked in a LIFO list.

  @sideeffect None

  @see cuddOrderedThread

*/
static void
cuddOrderedInsert(
  DdNodePtr * root,
  DdNodePtr node)
{
    DdNode *scan;
    DdNodePtr *scanP;
    DdNodePtr *stack[DD_STACK_SIZE];
    int stackN = 0;

    scanP = root;
    while ((scan = *scanP) != NULL) {
	stack[stackN++] = scanP;
	if (DD_INSERT_COMPARE(node, scan) == 0) { /* add to page list */
	    DD_NEXT(node) = DD_NEXT(scan);
	    DD_NEXT(scan) = node;
	    return;
	}
	scanP = (node < scan) ? &DD_LEFT(scan) : &DD_RIGHT(scan);
    }
    DD_RIGHT(node) = DD_LEFT(node) = DD_NEXT(node) = NULL;
    DD_COLOR(node) = DD_RED;
    *scanP = node;
    stack[stackN] = &node;
    cuddDoRebalance(stack,stackN);

} /* end of cuddOrderedInsert */


/**
  @brief Threads all the nodes of a search tree into a linear list.

  @details For each node of the search tree, the "left" child, if
  non-null, has a lower address than its parent, and the "right"
  child, if non-null, has a higher address than its parent.  The list
  is sorted in order of increasing addresses. The search tree is
  destroyed as a result of this operation. The last element of the
  linear list is made to point to the address passed in list. Each
  node if the search tree is a linearly-linked list of nodes from the
  same memory page (as defined in DD_PAGE_MASK). When a node is added
  to the linear list, all the elements of the linked list are added.

  @sideeffect The search tree is destroyed as a result of this operation.

  @see cuddOrderedInsert

*/
static DdNode *
cuddOrderedThread(
  DdNode * root,
  DdNode * list)
{
    DdNode *current, *next, *prev, *end;

    current = root;
    /* The first word in the node is used to implement a stack that holds
    ** the nodes from the root of the tree to the current node. Here we
    ** put the root of the tree at the bottom of the stack.
    */
    *((DdNodePtr *) current) = NULL;

    while (current != NULL) {
	if (DD_RIGHT(current) != NULL) {
	    /* If possible, we follow the "right" link. Eventually we'll
	    ** find the node with the largest address in the current tree.
	    ** In this phase we use the first word of a node to implemen
	    ** a stack of the nodes on the path from the root to "current".
	    ** Also, we disconnect the "right" pointers to indicate that
	    ** we have already followed them.
	    */
	    next = DD_RIGHT(current);
	    DD_RIGHT(current) = NULL;
	    *((DdNodePtr *)next) = current;
	    current = next;
	} else {
	    /* We can't proceed along the "right" links any further.
	    ** Hence "current" is the largest element in the current tree.
	    ** We make this node the new head of "list". (Repeating this
	    ** operation until the tree is empty yields the desired linear
	    ** threading of all nodes.)
	    */
	    prev = *((DdNodePtr *) current); /* save prev node on stack in prev */
	    /* Traverse the linked list of current until the end. */
	    for (end = current; DD_NEXT(end) != NULL; end = DD_NEXT(end));
	    DD_NEXT(end) = list; /* attach "list" at end and make */
	    list = current;   /* "current" the new head of "list" */
	    /* Now, if current has a "left" child, we push it on the stack.
	    ** Otherwise, we just continue with the parent of "current".
	    */
	    if (DD_LEFT(current) != NULL) {
		next = DD_LEFT(current);
		*((DdNodePtr *) next) = prev;
		current = next;
	    } else {
		current = prev;
	    }
	}
    }

    return(list);

} /* end of cuddOrderedThread */


/**
  @brief Performs the left rotation for red/black trees.

  @sideeffect None

  @see cuddRotateRight

*/
static void
cuddRotateLeft(
  DdNodePtr * nodeP)
{
    DdNode *newRoot;
    DdNode *oldRoot = *nodeP;

    *nodeP = newRoot = DD_RIGHT(oldRoot);
    DD_RIGHT(oldRoot) = DD_LEFT(newRoot);
    DD_LEFT(newRoot) = oldRoot;

} /* end of cuddRotateLeft */


/**
  @brief Performs the right rotation for red/black trees.

  @sideeffect None

  @see cuddRotateLeft

*/
static void
cuddRotateRight(
  DdNodePtr * nodeP)
{
    DdNode *newRoot;
    DdNode *oldRoot = *nodeP;

    *nodeP = newRoot = DD_LEFT(oldRoot);
    DD_LEFT(oldRoot) = DD_RIGHT(newRoot);
    DD_RIGHT(newRoot) = oldRoot;

} /* end of cuddRotateRight */


/**
  @brief Rebalances a red/black tree.

  @sideeffect None

*/
static void
cuddDoRebalance(
  DdNodePtr ** stack,
  int  stackN)
{
    DdNodePtr *xP, *parentP, *grandpaP;
    DdNode *x, *y, *parent, *grandpa;

    xP = stack[stackN];
    x = *xP;
    /* Work our way back up, re-balancing the tree. */
    while (--stackN >= 0) {
	parentP = stack[stackN];
	parent = *parentP;
	if (DD_IS_BLACK(parent)) break;
	/* Since the root is black, here a non-null grandparent exists. */
	grandpaP = stack[stackN-1];
	grandpa = *grandpaP;
	if (parent == DD_LEFT(grandpa)) {
	    y = DD_RIGHT(grandpa);
	    if (y != NULL && DD_IS_RED(y)) {
		DD_COLOR(parent) = DD_BLACK;
		DD_COLOR(y) = DD_BLACK;
		DD_COLOR(grandpa) = DD_RED;
		x = grandpa;
		stackN--;
	    } else {
		if (x == DD_RIGHT(parent)) {
		    cuddRotateLeft(parentP);
		    DD_COLOR(x) = DD_BLACK;
		} else {
		    DD_COLOR(parent) = DD_BLACK;
		}
		DD_COLOR(grandpa) = DD_RED;
		cuddRotateRight(grandpaP);
		break;
	    }
	} else {
	    y = DD_LEFT(grandpa);
	    if (y != NULL && DD_IS_RED(y)) {
		DD_COLOR(parent) = DD_BLACK;
		DD_COLOR(y) = DD_BLACK;
		DD_COLOR(grandpa) = DD_RED;
		x = grandpa;
		stackN--;
	    } else {
		if (x == DD_LEFT(parent)) {
		    cuddRotateRight(parentP);
		    DD_COLOR(x) = DD_BLACK;
		} else {
		    DD_COLOR(parent) = DD_BLACK;
		}
		DD_COLOR(grandpa) = DD_RED;
		cuddRotateLeft(grandpaP);
	    }
	}
    }
    DD_COLOR(*(stack[0])) = DD_BLACK;

} /* end of cuddDoRebalance */
#endif
#endif


/**
  @brief Fixes a variable tree after the insertion of new subtables.

  @details After such an insertion, the low fields of the tree below
  the insertion point are inconsistent.

  @sideeffect None

*/
static void
ddPatchTree(
  DdManager *dd,
  MtrNode *treenode)
{
    MtrNode *auxnode = treenode;

    while (auxnode != NULL) {
	auxnode->low = dd->perm[auxnode->index];
	if (auxnode->child != NULL) {
	    ddPatchTree(dd, auxnode->child);
	}
	auxnode = auxnode->younger;
    }

    return;

} /* end of ddPatchTree */


#ifdef DD_DEBUG
/**
  @brief Checks whether a collision list is ordered.

  @sideeffect None

*/
static int
cuddCheckCollisionOrdering(
  DdManager *unique,
  int i,
  int j)
{
    DdNode *node, *next;
    DdNodePtr *nodelist;
    DdNode *sentinel = &(unique->sentinel);

    nodelist = unique->subtables[i].nodelist;
    node = nodelist[j];
    if (node == sentinel) return(1);
    next = node->next;
    while (next != sentinel) {
	if (cuddT(node) < cuddT(next) ||
	    (cuddT(node) == cuddT(next) && cuddE(node) < cuddE(next))) {
	    (void) fprintf(unique->err,
			   "Unordered list: index %u, position %d\n", i, j);
	    return(0);
	}
	node = next;
	next = node->next;
    }
    return(1);

} /* end of cuddCheckCollisionOrdering */
#endif




/**
  @brief Reports problem in garbage collection.

  @sideeffect None

  @see cuddGarbageCollect cuddGarbageCollectZdd

*/
static void
ddReportRefMess(
  DdManager *unique /**< manager */,
  int i /**< table in which the problem occurred */,
  const char *caller /**< procedure that detected the problem */)
{
    if (i == CUDD_CONST_INDEX) {
	(void) fprintf(unique->err,
			   "%s: problem in constants\n", caller);
    } else if (i != -1) {
	(void) fprintf(unique->err,
			   "%s: problem in table %d\n", caller, i);
    }
    (void) fprintf(unique->err, "  dead count != deleted\n");
    (void) fprintf(unique->err, "  This problem is often due to a missing \
call to Cudd_Ref\n  or to an extra call to Cudd_RecursiveDeref.\n  \
See the CUDD Programmer's Guide for additional details.");
    abort();

} /* end of ddReportRefMess */

cuddUtil.c
102122
/**
  @file

  @ingroup cudd

  @brief Utility functions.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include <stddef.h>
#include <float.h>
#include "util.h"
#include "epdInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* Random generator constants. */
#define MODULUS1 2147483563
#define LEQA1 40014
#define LEQQ1 53668
#define LEQR1 12211
#define MODULUS2 2147483399
#define LEQA2 40692
#define LEQQ2 52774
#define LEQR2 3791
#define STAB_DIV (1 + (MODULUS1 - 1) / STAB_SIZE)

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

#define bang(f)	((Cudd_IsComplement(f)) ? '!' : ' ')

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int dp2 (DdManager *dd, DdNode *f, st_table *t);
static void ddPrintMintermAux (DdManager *dd, DdNode *node, int *list);
static int ddDagInt (DdNode *n);
static int cuddNodeArrayRecur (DdNode *f, DdNodePtr *table, int index);
static int cuddEstimateCofactor (DdManager *dd, st_table *table, DdNode * node, int i, int phase, DdNode ** ptr);
static DdNode * cuddUniqueLookup (DdManager * unique, int  index, DdNode * T, DdNode * E);
static int cuddEstimateCofactorSimple (DdNode * node, int i);
static double ddCountMintermAux (DdManager *dd, DdNode *node, double max, DdHashTable *table);
static int ddEpdCountMintermAux (DdManager const *dd, DdNode *node, EpDouble *max, EpDouble *epd, st_table *table);
static long double ddLdblCountMintermAux(DdManager const *manager, DdNode *node, long double max, st_table *table);
static double ddCountPathAux (DdNode *node, st_table *table);
static double ddCountPathsToNonZero (DdNode * N, st_table * table);
static void ddSupportStep (DdNode *f, int *support);
static void ddClearFlag (DdNode *f);
static int ddLeavesInt (DdNode *n);
static int ddPickArbitraryMinterms (DdManager *dd, DdNode *node, int nvars, int nminterms, char **string);
static int ddPickRepresentativeCube (DdManager *dd, DdNode *node, double *weight, char *string);
static enum st_retval ddEpdFree (void * key, void * value, void * arg);
static void ddFindSupport(DdManager *dd, DdNode *f, int *SP);
static void ddClearVars(DdManager *dd, int SP);
static int indexCompare(const void *a, const void *b);
static enum st_retval ddLdblFree(void * key, void * value, void * arg);
#if HAVE_POWL != 1
static long double powl(long double base, long double exponent);
#endif
/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints a disjoint sum of products.

  @details Prints a disjoint sum of product cover for the function
  rooted at node. Each product corresponds to a path from node to a
  leaf node different from the logical zero, and different from the
  background value. Uses the package default output file.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_PrintDebug Cudd_bddPrintCover

*/
int
Cudd_PrintMinterm(
  DdManager * manager,
  DdNode * node)
{
    int		i, *list;

    list = ALLOC(int,manager->size);
    if (list == NULL) {
	manager->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (i = 0; i < manager->size; i++) list[i] = 2;
    ddPrintMintermAux(manager,node,list);
    FREE(list);
    return(1);

} /* end of Cudd_PrintMinterm */


/**
  @brief Prints a sum of prime implicants of a %BDD.

  @details Prints a sum of product cover for an incompletely
  specified function given by a lower bound and an upper bound.  Each
  product is a prime implicant obtained by expanding the product
  corresponding to a path from node to the constant one.  Uses the
  package default output file.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_PrintMinterm

*/
int
Cudd_bddPrintCover(
  DdManager *dd,
  DdNode *l,
  DdNode *u)
{
    int *array;
    int q, result;
    DdNode *lb;
#ifdef DD_DEBUG
    DdNode *cover;
#endif

    array = ALLOC(int, Cudd_ReadSize(dd));
    if (array == NULL) return(0);
    lb = l;
    cuddRef(lb);
#ifdef DD_DEBUG
    cover = Cudd_ReadLogicZero(dd);
    cuddRef(cover);
#endif
    while (lb != Cudd_ReadLogicZero(dd)) {
	DdNode *implicant, *prime, *tmp;
	int length;
	implicant = Cudd_LargestCube(dd,lb,&length);
	if (implicant == NULL) {
	    Cudd_RecursiveDeref(dd,lb);
	    FREE(array);
	    return(0);
	}
	cuddRef(implicant);
	prime = Cudd_bddMakePrime(dd,implicant,u);
	if (prime == NULL) {
	    Cudd_RecursiveDeref(dd,lb);
	    Cudd_RecursiveDeref(dd,implicant);
	    FREE(array);
	    return(0);
	}
	cuddRef(prime);
	Cudd_RecursiveDeref(dd,implicant);
	tmp = Cudd_bddAnd(dd,lb,Cudd_Not(prime));
	if (tmp == NULL) {
	    Cudd_RecursiveDeref(dd,lb);
	    Cudd_RecursiveDeref(dd,prime);
	    FREE(array);
	    return(0);
	}
	cuddRef(tmp);
	Cudd_RecursiveDeref(dd,lb);
	lb = tmp;
	result = Cudd_BddToCubeArray(dd,prime,array);
	if (result == 0) {
	    Cudd_RecursiveDeref(dd,lb);
	    Cudd_RecursiveDeref(dd,prime);
	    FREE(array);
	    return(0);
	}
	for (q = 0; q < dd->size; q++) {
	    switch (array[q]) {
	    case 0:
		(void) fprintf(dd->out, "0");
		break;
	    case 1:
		(void) fprintf(dd->out, "1");
		break;
	    case 2:
		(void) fprintf(dd->out, "-");
		break;
	    default:
		(void) fprintf(dd->out, "?");
	    }
	}
	(void) fprintf(dd->out, " 1\n");
#ifdef DD_DEBUG
	tmp = Cudd_bddOr(dd,prime,cover);
	if (tmp == NULL) {
	    Cudd_RecursiveDeref(dd,cover);
	    Cudd_RecursiveDeref(dd,lb);
	    Cudd_RecursiveDeref(dd,prime);
	    FREE(array);
	    return(0);
	}
	cuddRef(tmp);
	Cudd_RecursiveDeref(dd,cover);
	cover = tmp;
#endif
	Cudd_RecursiveDeref(dd,prime);
    }
    (void) fprintf(dd->out, "\n");
    Cudd_RecursiveDeref(dd,lb);
    FREE(array);
#ifdef DD_DEBUG
    if (!Cudd_bddLeq(dd,cover,u) || !Cudd_bddLeq(dd,l,cover)) {
	Cudd_RecursiveDeref(dd,cover);
	return(0);
    }
    Cudd_RecursiveDeref(dd,cover);
#endif
    return(1);

} /* end of Cudd_bddPrintCover */


/**
  @brief Prints to the manager standard output a %DD and its statistics.

  @details The statistics include the number of nodes, the number of leaves,
  and the number of minterms. (The number of minterms is the number of
  assignments to the variables that cause the function to be different
  from the logical zero (for BDDs) and from the background value (for
  ADDs.) The statistics are printed if pr &gt; 0. Specifically:
  <ul>
  <li> pr = 0 : prints nothing
  <li> pr = 1 : prints counts of nodes and minterms
  <li> pr = 2 : prints counts + disjoint sum of product
  <li> pr = 3 : prints counts + list of nodes
  <li> pr &gt; 3 : prints counts + disjoint sum of product + list of nodes
  </ul>
  For the purpose of counting the number of minterms, the function is
  supposed to depend on n variables.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_DagSize Cudd_CountLeaves Cudd_CountMinterm
  Cudd_PrintMinterm

*/
int
Cudd_PrintDebug(
  DdManager * dd,
  DdNode * f,
  int  n,
  int  pr)
{
    DdNode *azero, *bzero;
    int	   nodes;
    int	   leaves;
    double minterms;
    int    retval = 1;

    if (dd == NULL) {
	return(0);
    }
    if (f == NULL) {
	(void) fprintf(dd->out,": is the NULL DD\n");
	(void) fflush(dd->out);
        dd->errorCode = CUDD_INVALID_ARG;
	return(0);
    }
    azero = DD_ZERO(dd);
    bzero = Cudd_Not(DD_ONE(dd));
    if ((f == azero || f == bzero) && pr > 0){
       (void) fprintf(dd->out,": is the zero DD\n");
       (void) fflush(dd->out);
       return(1);
    }
    if (pr > 0) {
	nodes = Cudd_DagSize(f);
	if (nodes == CUDD_OUT_OF_MEM) retval = 0;
	leaves = Cudd_CountLeaves(f);
	if (leaves == CUDD_OUT_OF_MEM) retval = 0;
	minterms = Cudd_CountMinterm(dd, f, n);
	if (minterms == (double)CUDD_OUT_OF_MEM) {
            retval = 0;
            (void) fprintf(dd->out,": %d nodes %d leaves unknown minterms\n",
                           nodes, leaves);
        } else {
            (void) fprintf(dd->out,": %d nodes %d leaves %g minterms\n",
                           nodes, leaves, minterms);
        }
	if (pr > 2) {
	    if (!cuddP(dd, f)) retval = 0;
	}
	if (pr == 2 || pr > 3) {
	    if (!Cudd_PrintMinterm(dd,f)) retval = 0;
	    (void) fprintf(dd->out,"\n");
	}
	(void) fflush(dd->out);
    }
    return(retval);

} /* end of Cudd_PrintDebug */


/**
  @brief Prints a one-line summary of an %ADD or %BDD to the manager stdout.

  @details The summary includes the number of nodes, the number of leaves,
  and the number of minterms.  The number of minterms is computed with
  arbitrary precision unlike Cudd_PrintDebug().  For the purpose of counting
  minterms, the function `f` is supposed to depend on `n` variables.

  @return 1 if successful; 0 otherwise.

  @see Cudd_PrintDebug Cudd_ApaPrintMinterm Cudd_ApaPrintMintermExp
*/
int
Cudd_PrintSummary(
  DdManager * dd /**< manager */,
  DdNode * f /**< %DD to be summarized */,
  int n /**< number of variables for minterm computation */,
  int mode /**< integer (0) or exponential (1) format */)
{
    DdNode *azero, *bzero;
    int	nodes, leaves, digits;
    int retval = 1;
    DdApaNumber count;

    if (dd == NULL) {
        return(0);
    }
    if (f == NULL) {
	(void) fprintf(dd->out,": is the NULL DD\n");
	(void) fflush(dd->out);
        dd->errorCode = CUDD_INVALID_ARG;
	return(0);
    }
    azero = DD_ZERO(dd);
    bzero = Cudd_Not(DD_ONE(dd));
    if (f == azero || f == bzero){
        (void) fprintf(dd->out,": is the zero DD\n");
        (void) fflush(dd->out);
        return(1);
    }
    nodes = Cudd_DagSize(f);
    if (nodes == CUDD_OUT_OF_MEM) retval = 0;
    leaves = Cudd_CountLeaves(f);
    if (leaves == CUDD_OUT_OF_MEM) retval = 0;
    (void) fprintf(dd->out,": %d nodes %d leaves ", nodes, leaves);
    count = Cudd_ApaCountMinterm(dd, f, n, &digits);
    if (count == NULL) {
	retval = 0;
    } else if (mode) {
        if (!Cudd_ApaPrintExponential(dd->out, digits, count, 6))
            retval = 0;
    } else {
        if (!Cudd_ApaPrintDecimal(dd->out, digits, count))
            retval = 0;
    }
    FREE(count);
    (void) fprintf(dd->out, " minterms\n");
    (void) fflush(dd->out);
    return(retval);

} /* end of Cudd_PrintSummary */
  

/**
  @brief Counts the number of nodes in a %DD.

  @return the number of nodes in the graph rooted at node.

  @sideeffect None

  @see Cudd_SharingSize Cudd_PrintDebug

*/
int
Cudd_DagSize(
  DdNode * node)
{
    int	i;

    i = ddDagInt(Cudd_Regular(node));
    ddClearFlag(Cudd_Regular(node));

    return(i);

} /* end of Cudd_DagSize */


/**
  @brief Estimates the number of nodes in a cofactor of a %DD.

  @details This function uses a refinement of the algorithm of Cabodi
  et al.  (ICCAD96). The refinement allows the procedure to account
  for part of the recombination that may occur in the part of the
  cofactor above the cofactoring variable. This procedure does not
  create any new node.  It does keep a small table of results;
  therefore it may run out of memory.  If this is a concern, one
  should use Cudd_EstimateCofactorSimple, which is faster, does not
  allocate any memory, but is less accurate.

  @return an estimate of the number of nodes in a cofactor of the
  graph rooted at node with respect to the variable whose index is i.
  In case of failure, returns CUDD_OUT_OF_MEM.

  @sideeffect None

  @see Cudd_DagSize Cudd_EstimateCofactorSimple

*/
int
Cudd_EstimateCofactor(
  DdManager *dd /**< manager */,
  DdNode * f	/**< function */,
  int i		/**< index of variable */,
  int phase	/**< 1: positive; 0: negative */
  )
{
    int	val;
    DdNode *ptr;
    st_table *table;

    table = st_init_table(st_ptrcmp,st_ptrhash);
    if (table == NULL) {
        dd->errorCode = CUDD_MEMORY_OUT;
        return(CUDD_OUT_OF_MEM);
    }
    val = cuddEstimateCofactor(dd,table,Cudd_Regular(f),i,phase,&ptr);
    ddClearFlag(Cudd_Regular(f));
    st_free_table(table);
    if (val == CUDD_OUT_OF_MEM)
        dd->errorCode = CUDD_MEMORY_OUT;
    
    return(val);

} /* end of Cudd_EstimateCofactor */


/**
  @brief Estimates the number of nodes in a cofactor of a %DD.

  @details Returns an estimate of the number of nodes in the positive
  cofactor of the graph rooted at node with respect to the variable
  whose index is i.  This procedure implements with minor changes the
  algorithm of Cabodi et al.  (ICCAD96). It does not allocate any
  memory, it does not change the state of the manager, and it is
  fast. However, it has been observed to overestimate the size of the
  cofactor by as much as a factor of 2.

  @sideeffect None

  @see Cudd_DagSize

*/
int
Cudd_EstimateCofactorSimple(
  DdNode * node,
  int i)
{
    int	val;

    val = cuddEstimateCofactorSimple(Cudd_Regular(node),i);
    ddClearFlag(Cudd_Regular(node));

    return(val);

} /* end of Cudd_EstimateCofactorSimple */


/**
  @brief Counts the number of nodes in an array of DDs.

  @details Shared nodes are counted only once.

  @return the total number of nodes.

  @sideeffect None

  @see Cudd_DagSize

*/
int
Cudd_SharingSize(
  DdNode ** nodeArray,
  int  n)
{
    int	i,j;

    i = 0;
    for (j = 0; j < n; j++) {
	i += ddDagInt(Cudd_Regular(nodeArray[j]));
    }
    for (j = 0; j < n; j++) {
	ddClearFlag(Cudd_Regular(nodeArray[j]));
    }
    return(i);

} /* end of Cudd_SharingSize */


/**
  @brief Counts the minterms of an %ADD or %BDD.

  @details The function is assumed to depend on `nvars` variables. The
  minterm count is represented as a double; hence overflow is
  possible.  For functions with many variables (more than 1023 if
  floating point conforms to IEEE 754), one should consider
  Cudd_ApaCountMinterm() or Cudd_EpdCountMinterm().

  @return the number of minterms of the function rooted at node if
  successful; +infinity if the number of minterms is known to be larger
  than the maximum value representable as a double; `(double) CUDD_OUT_OF_MEM`
  otherwise.

  @sideeffect None

  @see Cudd_ApaCountMinterm Cudd_EpdCountMinterm Cudd_LdblCountMinterm
  Cudd_PrintDebug Cudd_CountPath

*/
double
Cudd_CountMinterm(
  DdManager * manager,
  DdNode * node,
  int  nvars)
{
    double	max;
    DdHashTable	*table;
    double	res;
    CUDD_VALUE_TYPE epsilon;

    /* Scale the maximum number of minterm.  This is done in an attempt
     * to deal with functions that depend on more than 1023, but less
     * than 2044 variables and don't have too many minterms.
     */
    max = pow(2.0,(double)(nvars + DBL_MIN_EXP));
    if (max >= DD_PLUS_INF_VAL) {
        return((double)CUDD_OUT_OF_MEM);
    }
    table = cuddHashTableInit(manager,1,2);
    if (table == NULL) {
	return((double)CUDD_OUT_OF_MEM);
    }
    /* Temporarily set epsilon to 0 to avoid rounding errors. */
    epsilon = Cudd_ReadEpsilon(manager);
    Cudd_SetEpsilon(manager,(CUDD_VALUE_TYPE)0.0);
    res = ddCountMintermAux(manager,node,max,table);
    cuddHashTableQuit(table);
    Cudd_SetEpsilon(manager,epsilon);
    if (res == (double)CUDD_OUT_OF_MEM) {
        return((double)CUDD_OUT_OF_MEM);
    } else if (res >= pow(2.0,(double)(DBL_MAX_EXP + DBL_MIN_EXP))) {
        /* Minterm count is too large to be scaled back. */
        return(DD_PLUS_INF_VAL);
    } else {
        /* Undo the scaling. */
        res *= pow(2.0,(double)-DBL_MIN_EXP);
        return(res);
    }

} /* end of Cudd_CountMinterm */


/**
  @brief Counts the paths of a %DD.

  @details Paths to all terminal nodes are counted. The path count is
  represented as a double; hence overflow is possible.

  @return the number of paths of the function rooted at node if
  successful; `(double) CUDD_OUT_OF_MEM` otherwise.

  @sideeffect None

  @see Cudd_CountMinterm

*/
double
Cudd_CountPath(
  DdNode * node)
{

    st_table	*table;
    double	i;

    table = st_init_table(st_ptrcmp,st_ptrhash);
    if (table == NULL) {
	return((double)CUDD_OUT_OF_MEM);
    }
    i = ddCountPathAux(Cudd_Regular(node),table);
    st_foreach(table, cuddStCountfree, NULL);
    st_free_table(table);
    return(i);

} /* end of Cudd_CountPath */


/**
  @brief Counts the minterms of an %ADD or %BDD with extended range.

  @details The function is assumed to depend on `nvars` variables. The
  minterm count is represented as an `EpDouble`, to allow for any
  number of variables.

  @return 0 if successful; `CUDD_OUT_OF_MEM` otherwise.

  @sideeffect None

  @see Cudd_CountMinterm Cudd_LdblCountMinterm Cudd_ApaCountMinterm
  Cudd_PrintDebug Cudd_CountPath

*/
int
Cudd_EpdCountMinterm(
  DdManager const * manager,
  DdNode * node,
  int  nvars,
  EpDouble * epd)
{
    EpDouble	max, tmp;
    st_table	*table;
    int		status;

    EpdPow2(nvars, &max);
    table = st_init_table(st_ptrcmp, st_ptrhash);
    if (table == NULL) {
	EpdMakeZero(epd, 0);
	return(CUDD_OUT_OF_MEM);
    }
    status = ddEpdCountMintermAux(manager,Cudd_Regular(node),&max,epd,table);
    st_foreach(table, ddEpdFree, NULL);
    st_free_table(table);
    if (status == CUDD_OUT_OF_MEM) {
	EpdMakeZero(epd, 0);
	return(CUDD_OUT_OF_MEM);
    }
    if (Cudd_IsComplement(node)) {
	EpdSubtract3(&max, epd, &tmp);
	EpdCopy(&tmp, epd);
    }
    return(0);

} /* end of Cudd_EpdCountMinterm */


/**
  @brief Returns the number of minterms of aa %ADD or %BDD as a long double.

  @details On systems where double and long double are the same type,
  Cudd_CountMinterm() is preferable.  On systems where long double values
  have 15-bit exponents, this function avoids overflow for up to 16383
  variables.  It applies scaling to try to avoid overflow when the number of
  variables is larger than 16383, but smaller than 32764.

  @return The nimterm count if successful; +infinity if the number is known to
  be too large for representation as a long double;
  `(long double)CUDD_OUT_OF_MEM` otherwise. 

  @see Cudd_CountMinterm Cudd_EpdCountMinterm Cudd_ApaCountMinterm
*/
long double
Cudd_LdblCountMinterm(
  DdManager const *manager,
  DdNode *node,
  int nvars)
{
    long double max, count;
    st_table *table;

    max = powl(2.0L, (long double) (nvars+LDBL_MIN_EXP));
    if (max == HUGE_VALL) {
        return((long double)CUDD_OUT_OF_MEM);
    }
    table = st_init_table(st_ptrcmp, st_ptrhash);
    if (table == NULL) {
        return((long double)CUDD_OUT_OF_MEM);
    }
    count = ddLdblCountMintermAux(manager, Cudd_Regular(node), max, table);
    st_foreach(table, ddLdblFree, NULL);
    st_free_table(table);
    if (count == (long double)CUDD_OUT_OF_MEM) {
        return((long double)CUDD_OUT_OF_MEM);
    }
    if (Cudd_IsComplement(node)) {
        count = max - count;
    }
    if (count >= powl(2.0L, (long double)(LDBL_MAX_EXP + LDBL_MIN_EXP))) {
        /* Minterm count is too large to be scaled back. */
        return(HUGE_VALL);
    } else {
        /* Undo the scaling. */
        count *= powl(2.0L,(long double)-LDBL_MIN_EXP);
        return(count);
    }

} /* end of Cudd_LdlbCountMinterm */


/**
  @brief Prints the number of minterms of an %ADD or %BDD with extended range.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_EpdCountMinterm Cudd_ApaPrintMintermExp

*/
int
Cudd_EpdPrintMinterm(
  DdManager const * dd,
  DdNode * node,
  int nvars)
{
    EpDouble epd;
    int ret;
    char pstring[128];

    ret = Cudd_EpdCountMinterm(dd, node, nvars, &epd);
    if (ret !=0) return(0);
    EpdGetString(&epd, pstring);
    fprintf(dd->out, "%s", pstring);
    return(1);

} /* end of Cudd_EpdPrintMinterm */


/**
  @brief Counts the paths to a non-zero terminal of a %DD.

  @details The path count is represented as a double; hence overflow is
  possible.

  @return the number of paths of the function rooted at node.

  @sideeffect None

  @see Cudd_CountMinterm Cudd_CountPath

*/
double
Cudd_CountPathsToNonZero(
  DdNode * node)
{

    st_table	*table;
    double	i;

    table = st_init_table(st_ptrcmp,st_ptrhash);
    if (table == NULL) {
	return((double)CUDD_OUT_OF_MEM);
    }
    i = ddCountPathsToNonZero(node,table);
    st_foreach(table, cuddStCountfree, NULL);
    st_free_table(table);
    return(i);

} /* end of Cudd_CountPathsToNonZero */


/**
  @brief Finds the variables on which a %DD depends.

  @return the number of variables if successful; CUDD_OUT_OF_MEM
  otherwise.

  @sideeffect The indices of the support variables are returned as
  side effects.  If the function is constant, no array is allocated.

  @see Cudd_Support Cudd_SupportIndex Cudd_VectorSupportIndices

*/
int
Cudd_SupportIndices(
  DdManager * dd /**< manager */,
  DdNode * f /**< %DD whose support is sought */,
  int **indices /**< array containing (on return) the indices */)
{
    int SP = 0;

    ddFindSupport(dd, Cudd_Regular(f), &SP);
    ddClearFlag(Cudd_Regular(f));
    ddClearVars(dd, SP);
    if (SP > 0) {
        int i;
        *indices = ALLOC(int, SP);
        if (*indices == NULL) {
            dd->errorCode = CUDD_MEMORY_OUT;
            return(CUDD_OUT_OF_MEM);
        }

        for (i = 0; i < SP; i++)
            (*indices)[i] = (int) (ptrint) dd->stack[i];

        util_qsort(*indices, SP, sizeof(int), indexCompare);
    } else {
        *indices = NULL;
    }

    return(SP);

} /* end of Cudd_SupportIndices */


/**
  @brief Finds the variables on which a %DD depends.

  @return a %BDD consisting of the product of the variables if
  successful; NULL otherwise.

  @sideeffect None

  @see Cudd_VectorSupport Cudd_ClassifySupport

*/
DdNode *
Cudd_Support(
  DdManager * dd /**< manager */,
  DdNode * f /**< %DD whose support is sought */)
{
    int	*support;
    DdNode *res;
    int j;

    int size = Cudd_SupportIndices(dd, f, &support);
    if (size == CUDD_OUT_OF_MEM)
        return(NULL);

    /* Transform support from array of indices to cube. */
    res = DD_ONE(dd);
    cuddRef(res);
    
    for (j = size - 1; j >= 0; j--) { /* for each index bottom-up (almost) */
        int index = support[j];
        DdNode *var = dd->vars[index];
        DdNode *tmp = Cudd_bddAnd(dd,res,var);
        if (tmp == NULL) {
            Cudd_RecursiveDeref(dd,res);
            FREE(support);
            return(NULL);
        }
        cuddRef(tmp);
        Cudd_RecursiveDeref(dd,res);
        res = tmp;
    }

    FREE(support);
    cuddDeref(res);
    return(res);

} /* end of Cudd_Support */


/**
  @brief Finds the variables on which a %DD depends.

  @return an index array of the variables if successful; NULL
  otherwise.  The size of the array equals the number of variables in
  the manager.  Each entry of the array is 1 if the corresponding
  variable is in the support of the %DD and 0 otherwise.

  @sideeffect None

  @see Cudd_Support Cudd_SupportIndices Cudd_ClassifySupport

*/
int *
Cudd_SupportIndex(
  DdManager * dd /**< manager */,
  DdNode * f /**< %DD whose support is sought */)
{
    int	*support;
    int	i;
    int size;

    /* Allocate and initialize support array for ddSupportStep. */
    size = ddMax(dd->size, dd->sizeZ);
    support = ALLOC(int,size);
    if (support == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < size; i++) {
	support[i] = 0;
    }

    /* Compute support and clean up markers. */
    ddSupportStep(Cudd_Regular(f),support);
    ddClearFlag(Cudd_Regular(f));

    return(support);

} /* end of Cudd_SupportIndex */


/**
  @brief Counts the variables on which a %DD depends.

  @return the variables on which a %DD depends.

  @sideeffect None

  @see Cudd_Support Cudd_SupportIndices

*/
int
Cudd_SupportSize(
  DdManager * dd /**< manager */,
  DdNode * f /**< %DD whose support size is sought */)
{
    int SP = 0;

    ddFindSupport(dd, Cudd_Regular(f), &SP);
    ddClearFlag(Cudd_Regular(f));
    ddClearVars(dd, SP);

    return(SP);

} /* end of Cudd_SupportSize */


/**
  @brief Finds the variables on which a set of DDs depends.

  @details The set must contain either BDDs and ADDs, or ZDDs.

  @return the number of variables if successful; CUDD_OUT_OF_MEM
  otherwise.

  @sideeffect The indices of the support variables are returned as
  side effects.  If the function is constant, no array is allocated.

  @see Cudd_Support Cudd_SupportIndex Cudd_VectorSupportIndices

*/
int
Cudd_VectorSupportIndices(
  DdManager * dd /**< manager */,
  DdNode ** F /**< %DD whose support is sought */,
  int  n /**< size of the array */,
  int **indices /**< array containing (on return) the indices */)
{
    int i;
    int SP = 0;

    /* Compute support and clean up markers. */
    for (i = 0; i < n; i++) {
	ddFindSupport(dd, Cudd_Regular(F[i]), &SP);
    }
    for (i = 0; i < n; i++) {
	ddClearFlag(Cudd_Regular(F[i]));
    }
    ddClearVars(dd, SP);

    if (SP > 0) {
        *indices = ALLOC(int, SP);
        if (*indices == NULL) {
            dd->errorCode = CUDD_MEMORY_OUT;
            return(CUDD_OUT_OF_MEM);
        }

        for (i = 0; i < SP; i++)
            (*indices)[i] = (int) (ptrint) dd->stack[i];

        util_qsort(*indices, SP, sizeof(int), indexCompare);
    } else {
        *indices = NULL;
    }

    return(SP);

} /* end of Cudd_VectorSupportIndices */


/**
  @brief Finds the variables on which a set of DDs depends.

  @details The set must contain either BDDs and ADDs, or ZDDs.

  @return a %BDD consisting of the product of the variables if
  successful; NULL otherwise.

  @sideeffect None

  @see Cudd_Support Cudd_ClassifySupport

*/
DdNode *
Cudd_VectorSupport(
  DdManager * dd /**< manager */,
  DdNode ** F /**< array of DDs whose support is sought */,
  int  n /**< size of the array */)
{
    int	*support;
    DdNode *res;
    int	j;
    int size = Cudd_VectorSupportIndices(dd, F, n, &support);
    if (size == CUDD_OUT_OF_MEM)
        return(NULL);

    /* Transform support from array of indices to cube. */
    res = DD_ONE(dd);
    cuddRef(res);
    
    for (j = size - 1; j >= 0; j--) { /* for each index bottom-up (almost) */
        int index = support[j];
        DdNode *var = dd->vars[index];
        DdNode *tmp = Cudd_bddAnd(dd,res,var);
        if (tmp == NULL) {
            Cudd_RecursiveDeref(dd,res);
            FREE(support);
            return(NULL);
        }
        cuddRef(tmp);
        Cudd_RecursiveDeref(dd,res);
        res = tmp;
    }

    FREE(support);
    cuddDeref(res);
    return(res);

} /* end of Cudd_VectorSupport */


/**
  @brief Finds the variables on which a set of DDs depends.

  @details The set must contain either BDDs and ADDs, or ZDDs.

  @return an index array of the variables if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_SupportIndex Cudd_VectorSupport Cudd_VectorSupportIndices

*/
int *
Cudd_VectorSupportIndex(
  DdManager * dd /**< manager */,
  DdNode ** F /**< array of DDs whose support is sought */,
  int  n /**< size of the array */)
{
    int	*support;
    int	i;
    int size;

    /* Allocate and initialize support array for ddSupportStep. */
    size = ddMax(dd->size, dd->sizeZ);
    support = ALLOC(int,size);
    if (support == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < size; i++) {
	support[i] = 0;
    }

    /* Compute support and clean up markers. */
    for (i = 0; i < n; i++) {
	ddSupportStep(Cudd_Regular(F[i]),support);
    }
    for (i = 0; i < n; i++) {
	ddClearFlag(Cudd_Regular(F[i]));
    }

    return(support);

} /* end of Cudd_VectorSupportIndex */


/**
  @brief Counts the variables on which a set of DDs depends.

  @details The set must contain either BDDs and ADDs, or ZDDs.

  @return the number of variables on which a set of DDs depends.

  @sideeffect None

  @see Cudd_VectorSupport Cudd_SupportSize

*/
int
Cudd_VectorSupportSize(
  DdManager * dd /**< manager */,
  DdNode ** F /**< array of DDs whose support is sought */,
  int  n /**< size of the array */)
{
    int i;
    int SP = 0;

    /* Compute support and clean up markers. */
    for (i = 0; i < n; i++) {
	ddFindSupport(dd, Cudd_Regular(F[i]), &SP);
    }
    for (i = 0; i < n; i++) {
	ddClearFlag(Cudd_Regular(F[i]));
    }
    ddClearVars(dd, SP);

    return(SP);

} /* end of Cudd_VectorSupportSize */


/**
  @brief Classifies the variables in the support of two DDs.

  @details Classifies the variables in the support of two DDs
  <code>f</code> and <code>g</code>, depending on whether they appear
  in both DDs, only in <code>f</code>, or only in <code>g</code>.

  @return 1 if successful; 0 otherwise.

  @sideeffect The cubes of the three classes of variables are
  returned as side effects.

  @see Cudd_Support Cudd_VectorSupport

*/
int
Cudd_ClassifySupport(
  DdManager * dd /**< manager */,
  DdNode * f /**< first %DD */,
  DdNode * g /**< second %DD */,
  DdNode ** common /**< cube of shared variables */,
  DdNode ** onlyF /**< cube of variables only in f */,
  DdNode ** onlyG /**< cube of variables only in g */)
{
    int	*supportF, *supportG;
    int	fi, gi;
    int sizeF, sizeG;

    sizeF = Cudd_SupportIndices(dd, f, &supportF);
    if (sizeF == CUDD_OUT_OF_MEM)
        return(0);

    sizeG = Cudd_SupportIndices(dd, g, &supportG);
    if (sizeG == CUDD_OUT_OF_MEM) {
        FREE(supportF);
        return(0);
    }

    /* Classify variables and create cubes. This part of the procedure
    ** relies on the sorting of the indices in the two support arrays.
    */
    *common = *onlyF = *onlyG = DD_ONE(dd);
    cuddRef(*common); cuddRef(*onlyF); cuddRef(*onlyG);
    fi = sizeF - 1;
    gi = sizeG - 1;
    while (fi >= 0 || gi >= 0) {
        int indexF = fi >= 0 ? supportF[fi] : -1;
        int indexG = gi >= 0 ? supportG[gi] : -1;
        int index = ddMax(indexF, indexG);
        DdNode *var = dd->vars[index];
#ifdef DD_DEBUG
        assert(index >= 0);
#endif
        if (indexF == indexG) {
            DdNode *tmp = Cudd_bddAnd(dd,*common,var);
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(dd,*common);
		Cudd_RecursiveDeref(dd,*onlyF);
		Cudd_RecursiveDeref(dd,*onlyG);
		FREE(supportF); FREE(supportG);
		return(0);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(dd,*common);
	    *common = tmp;
            fi--;
            gi--;
        } else if (index == indexF) {
	    DdNode *tmp = Cudd_bddAnd(dd,*onlyF,var);
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(dd,*common);
		Cudd_RecursiveDeref(dd,*onlyF);
		Cudd_RecursiveDeref(dd,*onlyG);
		FREE(supportF); FREE(supportG);
		return(0);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(dd,*onlyF);
	    *onlyF = tmp;
            fi--;
        } else { /* index == indexG */
	    DdNode *tmp = Cudd_bddAnd(dd,*onlyG,var);
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(dd,*common);
		Cudd_RecursiveDeref(dd,*onlyF);
		Cudd_RecursiveDeref(dd,*onlyG);
		FREE(supportF); FREE(supportG);
		return(0);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(dd,*onlyG);
	    *onlyG = tmp;
            gi--;
        }
    }

    FREE(supportF); FREE(supportG);
    cuddDeref(*common); cuddDeref(*onlyF); cuddDeref(*onlyG);
    return(1);

} /* end of Cudd_ClassifySupport */


/**
  @brief Counts the number of leaves in a %DD.

  @return the number of leaves in the %DD rooted at node if successful;
  CUDD_OUT_OF_MEM otherwise.

  @sideeffect None

  @see Cudd_PrintDebug

*/
int
Cudd_CountLeaves(
  DdNode * node)
{
    int	i;

    i = ddLeavesInt(Cudd_Regular(node));
    ddClearFlag(Cudd_Regular(node));
    return(i);

} /* end of Cudd_CountLeaves */


/**
  @brief Picks one on-set cube randomly from the given %DD.

  @details The cube is written into an array of characters.  The array
  must have at least as many entries as there are variables.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_bddPickOneMinterm

*/
int
Cudd_bddPickOneCube(
  DdManager * ddm,
  DdNode * node,
  char * string)
{
    DdNode *N, *T, *E;
    DdNode *one, *bzero;
    char   dir;
    int    i;

    if (string == NULL || node == NULL) return(0);

    /* The constant 0 function has no on-set cubes. */
    one = DD_ONE(ddm);
    bzero = Cudd_Not(one);
    if (node == bzero) {
        ddm->errorCode = CUDD_INVALID_ARG;
        return(0);
    }

    for (i = 0; i < ddm->size; i++) string[i] = 2;

    for (;;) {

	if (node == one) break;

	N = Cudd_Regular(node);

	T = cuddT(N); E = cuddE(N);
	if (Cudd_IsComplement(node)) {
	    T = Cudd_Not(T); E = Cudd_Not(E);
	}
	if (T == bzero) {
	    string[N->index] = 0;
	    node = E;
	} else if (E == bzero) {
	    string[N->index] = 1;
	    node = T;
	} else {
	    dir = (char) ((Cudd_Random(ddm) & 0x2000) >> 13);
	    string[N->index] = dir;
	    node = dir ? T : E;
	}
    }
    return(1);

} /* end of Cudd_bddPickOneCube */


/**
  @brief Picks one on-set minterm randomly from the given %DD.

  @details The minterm is in terms of <code>vars</code>. The array
  <code>vars</code> should contain at least all variables in the
  support of <code>f</code>; if this condition is not met the minterm
  built by this procedure may not be contained in <code>f</code>.

  @return a pointer to the %BDD for the minterm if successful; NULL otherwise.
  There are three reasons why the procedure may fail:
  <ul>
  <li> It may run out of memory;
  <li> the function <code>f</code> may be the constant 0;
  <li> the minterm may not be contained in <code>f</code>.
  </ul>

  @sideeffect None

  @see Cudd_bddPickOneCube

*/
DdNode *
Cudd_bddPickOneMinterm(
  DdManager * dd /**< manager */,
  DdNode * f /**< function from which to pick one minterm */,
  DdNode ** vars /**< array of variables */,
  int  n /**< size of <code>vars</code> */)
{
    char *string;
    int i, size;
    int *indices;
    int result;
    DdNode *old, *neW;

    size = dd->size;
    string = ALLOC(char, size);
    if (string == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    indices = ALLOC(int,n);
    if (indices == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(string);
	return(NULL);
    }

    for (i = 0; i < n; i++) {
	indices[i] = vars[i]->index;
    }

    result = Cudd_bddPickOneCube(dd,f,string);
    if (result == 0) {
	FREE(string);
	FREE(indices);
	return(NULL);
    }

    /* Randomize choice for don't cares. */
    for (i = 0; i < n; i++) {
	if (string[indices[i]] == 2)
	    string[indices[i]] = (char) ((Cudd_Random(dd) & 0x20) >> 5);
    }

    /* Build result BDD. */
    old = Cudd_ReadOne(dd);
    cuddRef(old);

    for (i = n-1; i >= 0; i--) {
	neW = Cudd_bddAnd(dd,old,Cudd_NotCond(vars[i],string[indices[i]]==0));
	if (neW == NULL) {
	    FREE(string);
	    FREE(indices);
	    Cudd_RecursiveDeref(dd,old);
	    return(NULL);
	}
	cuddRef(neW);
	Cudd_RecursiveDeref(dd,old);
	old = neW;
    }

#ifdef DD_DEBUG
    /* Test. */
    if (Cudd_bddLeq(dd,old,f)) {
	cuddDeref(old);
    } else {
	Cudd_RecursiveDeref(dd,old);
	old = NULL;
    }
#else
    cuddDeref(old);
#endif

    FREE(string);
    FREE(indices);
    return(old);

}  /* end of Cudd_bddPickOneMinterm */


/**
  @brief Picks k on-set minterms evenly distributed from given %DD.

  @details The minterms are in terms of <code>vars</code>. The array
  <code>vars</code> should contain at least all variables in the
  support of <code>f</code>; if this condition is not met the minterms
  built by this procedure may not be contained in <code>f</code>.

  @return an array of BDDs for the minterms if successful; NULL otherwise.
  There are three reasons why the procedure may fail:
  <ul>
  <li> It may run out of memory;
  <li> the function <code>f</code> may be the constant 0;
  <li> the minterms may not be contained in <code>f</code>.
  </ul>

  @sideeffect None

  @see Cudd_bddPickOneMinterm Cudd_bddPickOneCube

*/
DdNode **
Cudd_bddPickArbitraryMinterms(
  DdManager * dd /**< manager */,
  DdNode * f /**< function from which to pick k minterms */,
  DdNode ** vars /**< array of variables */,
  int  n /**< size of <code>vars</code> */,
  int  k /**< number of minterms to find */)
{
    char **string;
    int i, j, l, size;
    int *indices;
    int result;
    DdNode **old, *neW;
    double minterms;
    char *saveString;
    int saveFlag, savePoint = 0, isSame;

    minterms = Cudd_CountMinterm(dd,f,n);
    if ((double)k > minterms) {
	return(NULL);
    }

    size = dd->size;
    string = ALLOC(char *, k);
    if (string == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < k; i++) {
	string[i] = ALLOC(char, size + 1);
	if (string[i] == NULL) {
	    for (j = 0; j < i; j++)
		FREE(string[i]);
	    FREE(string);
	    dd->errorCode = CUDD_MEMORY_OUT;
	    return(NULL);
	}
	for (j = 0; j < size; j++) string[i][j] = '2';
	string[i][size] = '\0';
    }
    indices = ALLOC(int,n);
    if (indices == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	for (i = 0; i < k; i++)
	    FREE(string[i]);
	FREE(string);
	return(NULL);
    }

    for (i = 0; i < n; i++) {
	indices[i] = vars[i]->index;
    }

    result = ddPickArbitraryMinterms(dd,f,n,k,string);
    if (result == 0) {
	for (i = 0; i < k; i++)
	    FREE(string[i]);
	FREE(string);
	FREE(indices);
	return(NULL);
    }

    old = ALLOC(DdNode *, k);
    if (old == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	for (i = 0; i < k; i++)
	    FREE(string[i]);
	FREE(string);
	FREE(indices);
	return(NULL);
    }
    saveString = ALLOC(char, size + 1);
    if (saveString == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	for (i = 0; i < k; i++)
	    FREE(string[i]);
	FREE(string);
	FREE(indices);
	FREE(old);
	return(NULL);
    }
    saveFlag = 0;

    /* Build result BDD array. */
    for (i = 0; i < k; i++) {
	isSame = 0;
	if (!saveFlag) {
	    for (j = i + 1; j < k; j++) {
		if (strcmp(string[i], string[j]) == 0) {
		    savePoint = i;
		    strcpy(saveString, string[i]);
		    saveFlag = 1;
		    break;
		}
	    }
	} else {
	    if (strcmp(string[i], saveString) == 0) {
		isSame = 1;
	    } else {
		saveFlag = 0;
		for (j = i + 1; j < k; j++) {
		    if (strcmp(string[i], string[j]) == 0) {
			savePoint = i;
			strcpy(saveString, string[i]);
			saveFlag = 1;
			break;
		    }
		}
	    }
	}
	/* Randomize choice for don't cares. */
	for (j = 0; j < n; j++) {
	    if (string[i][indices[j]] == '2')
		string[i][indices[j]] =
		  (char) ((Cudd_Random(dd) & 0x20) ? '1' : '0');
	}

	while (isSame) {
	    isSame = 0;
	    for (j = savePoint; j < i; j++) {
		if (strcmp(string[i], string[j]) == 0) {
		    isSame = 1;
		    break;
		}
	    }
	    if (isSame) {
		strcpy(string[i], saveString);
		/* Randomize choice for don't cares. */
		for (j = 0; j < n; j++) {
		    if (string[i][indices[j]] == '2')
			string[i][indices[j]] =
			  (char) ((Cudd_Random(dd) & 0x20) ? '1' : '0');
		}
	    }
	}

	old[i] = Cudd_ReadOne(dd);
	cuddRef(old[i]);

	for (j = 0; j < n; j++) {
	    if (string[i][indices[j]] == '0') {
		neW = Cudd_bddAnd(dd,old[i],Cudd_Not(vars[j]));
	    } else {
		neW = Cudd_bddAnd(dd,old[i],vars[j]);
	    }
	    if (neW == NULL) {
		FREE(saveString);
		for (l = 0; l < k; l++)
		    FREE(string[l]);
		FREE(string);
		FREE(indices);
		for (l = 0; l <= i; l++)
		    Cudd_RecursiveDeref(dd,old[l]);
		FREE(old);
		return(NULL);
	    }
	    cuddRef(neW);
	    Cudd_RecursiveDeref(dd,old[i]);
	    old[i] = neW;
	}

	/* Test. */
	if (!Cudd_bddLeq(dd,old[i],f)) {
	    FREE(saveString);
	    for (l = 0; l < k; l++)
		FREE(string[l]);
	    FREE(string);
	    FREE(indices);
	    for (l = 0; l <= i; l++)
		Cudd_RecursiveDeref(dd,old[l]);
	    FREE(old);
	    return(NULL);
	}
    }

    FREE(saveString);
    for (i = 0; i < k; i++) {
	cuddDeref(old[i]);
	FREE(string[i]);
    }
    FREE(string);
    FREE(indices);
    return(old);

}  /* end of Cudd_bddPickArbitraryMinterms */


/**
  @brief Extracts a subset from a %BDD.

  @details Extracts a subset from a %BDD in the following procedure.
  1. Compute the weight for each mask variable by counting the number of
     minterms for both positive and negative cofactors of the %BDD with
     respect to each mask variable. (weight = # positive - # negative)
  2. Find a representative cube of the %BDD by using the weight. From the
     top variable of the %BDD, for each variable, if the weight is greater
     than 0.0, choose THEN branch, othereise ELSE branch, until meeting
     the constant 1.
  3. Quantify out the variables not in maskVars from the representative
     cube and if a variable in maskVars is don't care, replace the
     variable with a constant(1 or 0) depending on the weight.
  4. Make a subset of the %BDD by multiplying with the modified cube.

  @sideeffect None

*/
DdNode *
Cudd_SubsetWithMaskVars(
  DdManager * dd /**< manager */,
  DdNode * f /**< function from which to pick a cube */,
  DdNode ** vars /**< array of variables */,
  int  nvars /**< size of <code>vars</code> */,
  DdNode ** maskVars /**< array of variables */,
  int  mvars /**< size of <code>maskVars</code> */)
{
    double	*weight;
    char	*string;
    int		i, size;
    int		*indices, *mask;
    int		result;
    DdNode	*cube, *newCube, *subset;
    DdNode	*cof;
    DdNode	*support;
    DdNode	*zero;

    support = Cudd_Support(dd,f);
    cuddRef(support);
    Cudd_RecursiveDeref(dd,support);

    size = dd->size;

    weight = ALLOC(double,size);
    if (weight == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    for (i = 0; i < size; i++) {
	weight[i] = 0.0;
    }
    for (i = 0; i < mvars; i++) {
	cof = Cudd_Cofactor(dd, f, maskVars[i]);
	cuddRef(cof);
	weight[i] = Cudd_CountMinterm(dd, cof, nvars);
	Cudd_RecursiveDeref(dd,cof);

	cof = Cudd_Cofactor(dd, f, Cudd_Not(maskVars[i]));
	cuddRef(cof);
	weight[i] -= Cudd_CountMinterm(dd, cof, nvars);
	Cudd_RecursiveDeref(dd,cof);
    }

    string = ALLOC(char, size + 1);
    if (string == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(weight);
	return(NULL);
    }
    mask = ALLOC(int, size);
    if (mask == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(weight);
	FREE(string);
	return(NULL);
    }
    for (i = 0; i < size; i++) {
	string[i] = '2';
	mask[i] = 0;
    }
    string[size] = '\0';
    indices = ALLOC(int,nvars);
    if (indices == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(weight);
	FREE(string);
	FREE(mask);
	return(NULL);
    }
    for (i = 0; i < nvars; i++) {
	indices[i] = vars[i]->index;
    }

    result = ddPickRepresentativeCube(dd,f,weight,string);
    if (result == 0) {
	FREE(weight);
	FREE(string);
	FREE(mask);
	FREE(indices);
	return(NULL);
    }

    cube = Cudd_ReadOne(dd);
    cuddRef(cube);
    zero = Cudd_Not(Cudd_ReadOne(dd));
    for (i = 0; i < nvars; i++) {
	if (string[indices[i]] == '0') {
	    newCube = Cudd_bddIte(dd,cube,Cudd_Not(vars[i]),zero);
	} else if (string[indices[i]] == '1') {
	    newCube = Cudd_bddIte(dd,cube,vars[i],zero);
	} else
	    continue;
	if (newCube == NULL) {
	    FREE(weight);
	    FREE(string);
	    FREE(mask);
	    FREE(indices);
	    Cudd_RecursiveDeref(dd,cube);
	    return(NULL);
	}
	cuddRef(newCube);
	Cudd_RecursiveDeref(dd,cube);
	cube = newCube;
    }
    Cudd_RecursiveDeref(dd,cube);

    for (i = 0; i < mvars; i++) {
	mask[maskVars[i]->index] = 1;
    }
    for (i = 0; i < nvars; i++) {
	if (mask[indices[i]]) {
	    if (string[indices[i]] == '2') {
		if (weight[indices[i]] >= 0.0)
		    string[indices[i]] = '1';
		else
		    string[indices[i]] = '0';
	    }
	} else {
	    string[indices[i]] = '2';
	}
    }

    cube = Cudd_ReadOne(dd);
    cuddRef(cube);
    zero = Cudd_Not(Cudd_ReadOne(dd));

    /* Build result BDD. */
    for (i = 0; i < nvars; i++) {
	if (string[indices[i]] == '0') {
	    newCube = Cudd_bddIte(dd,cube,Cudd_Not(vars[i]),zero);
	} else if (string[indices[i]] == '1') {
	    newCube = Cudd_bddIte(dd,cube,vars[i],zero);
	} else
	    continue;
	if (newCube == NULL) {
	    FREE(weight);
	    FREE(string);
	    FREE(mask);
	    FREE(indices);
	    Cudd_RecursiveDeref(dd,cube);
	    return(NULL);
	}
	cuddRef(newCube);
	Cudd_RecursiveDeref(dd,cube);
	cube = newCube;
    }

    subset = Cudd_bddAnd(dd,f,cube);
    cuddRef(subset);
    Cudd_RecursiveDeref(dd,cube);

    /* Test. */
    if (Cudd_bddLeq(dd,subset,f)) {
	cuddDeref(subset);
    } else {
	Cudd_RecursiveDeref(dd,subset);
	subset = NULL;
    }

    FREE(weight);
    FREE(string);
    FREE(mask);
    FREE(indices);
    return(subset);

} /* end of Cudd_SubsetWithMaskVars */


/**
  @brief Finds the first cube of a decision diagram.

  @details Defines an iterator on the onset of a decision diagram
  and finds its first cube.<p>
  A cube is represented as an array of literals, which are integers in
  {0, 1, 2}; 0 represents a complemented literal, 1 represents an
  uncomplemented literal, and 2 stands for don't care. The enumeration
  produces a disjoint cover of the function associated with the diagram.
  The size of the array equals the number of variables in the manager at
  the time Cudd_FirstCube is called.<p>
  For each cube, a value is also returned. This value is always 1 for a
  %BDD, while it may be different from 1 for an %ADD.
  For BDDs, the offset is the set of cubes whose value is the logical zero.
  For ADDs, the offset is the set of cubes whose value is the
  background value. The cubes of the offset are not enumerated.

  @return a generator that contains the information necessary to
  continue the enumeration if successful; NULL otherwise.

  @sideeffect The first cube and its value are returned as side effects.

  @see Cudd_ForeachCube Cudd_NextCube Cudd_GenFree Cudd_IsGenEmpty
  Cudd_FirstNode

*/
DdGen *
Cudd_FirstCube(
  DdManager * dd,
  DdNode * f,
  int ** cube,
  CUDD_VALUE_TYPE * value)
{
    DdGen *gen;
    DdNode *top, *treg, *next, *nreg, *prev, *preg;
    int i;
    int nvars;

    /* Sanity Check. */
    if (dd == NULL || f == NULL) return(NULL);

    /* Allocate generator an initialize it. */
    gen = ALLOC(DdGen,1);
    if (gen == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    gen->manager = dd;
    gen->type = CUDD_GEN_CUBES;
    gen->status = CUDD_GEN_EMPTY;
    gen->gen.cubes.cube = NULL;
    gen->gen.cubes.value = DD_ZERO_VAL;
    gen->stack.sp = 0;
    gen->stack.stack = NULL;
    gen->node = NULL;

    nvars = dd->size;
    gen->gen.cubes.cube = ALLOC(int,nvars);
    if (gen->gen.cubes.cube == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(gen);
	return(NULL);
    }
    for (i = 0; i < nvars; i++) gen->gen.cubes.cube[i] = 2;

    /* The maximum stack depth is one plus the number of variables.
    ** because a path may have nodes at all levels, including the
    ** constant level.
    */
    gen->stack.stack = ALLOC(DdNodePtr, nvars+1);
    if (gen->stack.stack == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(gen->gen.cubes.cube);
	FREE(gen);
	return(NULL);
    }
    for (i = 0; i <= nvars; i++) gen->stack.stack[i] = NULL;

    /* Find the first cube of the onset. */
    gen->stack.stack[gen->stack.sp] = f; gen->stack.sp++;

    while (1) {
	top = gen->stack.stack[gen->stack.sp-1];
	treg = Cudd_Regular(top);
	if (!cuddIsConstant(treg)) {
	    /* Take the else branch first. */
	    gen->gen.cubes.cube[treg->index] = 0;
	    next = cuddE(treg);
	    if (top != treg) next = Cudd_Not(next);
	    gen->stack.stack[gen->stack.sp] = next; gen->stack.sp++;
	} else if (top == Cudd_Not(DD_ONE(dd)) || top == dd->background) {
	    /* Backtrack */
	    while (1) {
		if (gen->stack.sp == 1) {
		    /* The current node has no predecessor. */
		    gen->status = CUDD_GEN_EMPTY;
		    gen->stack.sp--;
		    goto done;
		}
		prev = gen->stack.stack[gen->stack.sp-2];
		preg = Cudd_Regular(prev);
		nreg = cuddT(preg);
		if (prev != preg) {next = Cudd_Not(nreg);} else {next = nreg;}
		if (next != top) { /* follow the then branch next */
		    gen->gen.cubes.cube[preg->index] = 1;
		    gen->stack.stack[gen->stack.sp-1] = next;
		    break;
		}
		/* Pop the stack and try again. */
		gen->gen.cubes.cube[preg->index] = 2;
		gen->stack.sp--;
		top = gen->stack.stack[gen->stack.sp-1];
	    }
	} else {
	    gen->status = CUDD_GEN_NONEMPTY;
	    gen->gen.cubes.value = cuddV(top);
	    goto done;
	}
    }

done:
    *cube = gen->gen.cubes.cube;
    *value = gen->gen.cubes.value;
    return(gen);

} /* end of Cudd_FirstCube */


/**
  @brief Generates the next cube of a decision diagram onset.

  @return 0 if the enumeration is completed; 1 otherwise.

  @sideeffect The cube and its value are returned as side effects. The
  generator is modified.

  @see Cudd_ForeachCube Cudd_FirstCube Cudd_GenFree Cudd_IsGenEmpty
  Cudd_NextNode

*/
int
Cudd_NextCube(
  DdGen * gen,
  int ** cube,
  CUDD_VALUE_TYPE * value)
{
    DdNode *top, *treg, *next, *nreg, *prev, *preg;
    DdManager *dd = gen->manager;

    /* Backtrack from previously reached terminal node. */
    while (1) {
	if (gen->stack.sp == 1) {
	    /* The current node has no predecessor. */
	    gen->status = CUDD_GEN_EMPTY;
	    gen->stack.sp--;
	    goto done;
	}
	top = gen->stack.stack[gen->stack.sp-1];
	prev = gen->stack.stack[gen->stack.sp-2];
	preg = Cudd_Regular(prev);
	nreg = cuddT(preg);
	if (prev != preg) {next = Cudd_Not(nreg);} else {next = nreg;}
	if (next != top) { /* follow the then branch next */
	    gen->gen.cubes.cube[preg->index] = 1;
	    gen->stack.stack[gen->stack.sp-1] = next;
	    break;
	}
	/* Pop the stack and try again. */
	gen->gen.cubes.cube[preg->index] = 2;
	gen->stack.sp--;
    }

    while (1) {
	top = gen->stack.stack[gen->stack.sp-1];
	treg = Cudd_Regular(top);
	if (!cuddIsConstant(treg)) {
	    /* Take the else branch first. */
	    gen->gen.cubes.cube[treg->index] = 0;
	    next = cuddE(treg);
	    if (top != treg) next = Cudd_Not(next);
	    gen->stack.stack[gen->stack.sp] = next; gen->stack.sp++;
	} else if (top == Cudd_Not(DD_ONE(dd)) || top == dd->background) {
	    /* Backtrack */
	    while (1) {
		if (gen->stack.sp == 1) {
		    /* The current node has no predecessor. */
		    gen->status = CUDD_GEN_EMPTY;
		    gen->stack.sp--;
		    goto done;
		}
		prev = gen->stack.stack[gen->stack.sp-2];
		preg = Cudd_Regular(prev);
		nreg = cuddT(preg);
		if (prev != preg) {next = Cudd_Not(nreg);} else {next = nreg;}
		if (next != top) { /* follow the then branch next */
		    gen->gen.cubes.cube[preg->index] = 1;
		    gen->stack.stack[gen->stack.sp-1] = next;
		    break;
		}
		/* Pop the stack and try again. */
		gen->gen.cubes.cube[preg->index] = 2;
		gen->stack.sp--;
		top = gen->stack.stack[gen->stack.sp-1];
	    }
	} else {
	    gen->status = CUDD_GEN_NONEMPTY;
	    gen->gen.cubes.value = cuddV(top);
	    goto done;
	}
    }

done:
    if (gen->status == CUDD_GEN_EMPTY) return(0);
    *cube = gen->gen.cubes.cube;
    *value = gen->gen.cubes.value;
    return(1);

} /* end of Cudd_NextCube */


/**
  @brief Finds the first prime of a Boolean function.

  @details@parblock
  Defines an iterator on a pair of BDDs describing a
  (possibly incompletely specified) Boolean functions and finds the
  first cube of a cover of the function.

  The two argument BDDs are the lower and upper bounds of an interval.
  It is a mistake to call this function with a lower bound that is not
  less than or equal to the upper bound.

  A cube is represented as an array of literals, which are integers in
  {0, 1, 2}; 0 represents a complemented literal, 1 represents an
  uncomplemented literal, and 2 stands for don't care. The enumeration
  produces a prime and irredundant cover of the function associated
  with the two BDDs.  The size of the array equals the number of
  variables in the manager at the time Cudd_FirstCube is called.

  This iterator can only be used on BDDs.
  @endparblock

  @return a generator that contains the information necessary to
  continue the enumeration if successful; NULL otherwise.

  @sideeffect The first cube is returned as side effect.

  @see Cudd_ForeachPrime Cudd_NextPrime Cudd_GenFree Cudd_IsGenEmpty
  Cudd_FirstCube Cudd_FirstNode

*/
DdGen *
Cudd_FirstPrime(
  DdManager *dd,
  DdNode *l,
  DdNode *u,
  int **cube)
{
    DdGen *gen;
    DdNode *implicant, *prime, *tmp;
    int length, result;

    /* Sanity Check. */
    if (dd == NULL || l == NULL || u == NULL) return(NULL);

    /* Allocate generator an initialize it. */
    gen = ALLOC(DdGen,1);
    if (gen == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    gen->manager = dd;
    gen->type = CUDD_GEN_PRIMES;
    gen->status = CUDD_GEN_EMPTY;
    gen->gen.primes.cube = NULL;
    gen->gen.primes.ub = u;
    gen->stack.sp = 0;
    gen->stack.stack = NULL;
    gen->node = l;
    cuddRef(l);

    gen->gen.primes.cube = ALLOC(int,dd->size);
    if (gen->gen.primes.cube == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	FREE(gen);
	return(NULL);
    }

    if (gen->node == Cudd_ReadLogicZero(dd)) {
	gen->status = CUDD_GEN_EMPTY;
    } else {
	implicant = Cudd_LargestCube(dd,gen->node,&length);
	if (implicant == NULL) {
	    Cudd_RecursiveDeref(dd,gen->node);
	    FREE(gen->gen.primes.cube);
	    FREE(gen);
	    return(NULL);
	}
	cuddRef(implicant);
	prime = Cudd_bddMakePrime(dd,implicant,gen->gen.primes.ub);
	if (prime == NULL) {
	    Cudd_RecursiveDeref(dd,gen->node);
	    Cudd_RecursiveDeref(dd,implicant);
	    FREE(gen->gen.primes.cube);
	    FREE(gen);
	    return(NULL);
	}
	cuddRef(prime);
	Cudd_RecursiveDeref(dd,implicant);
	tmp = Cudd_bddAnd(dd,gen->node,Cudd_Not(prime));
	if (tmp == NULL) {
	    Cudd_RecursiveDeref(dd,gen->node);
	    Cudd_RecursiveDeref(dd,prime);
	    FREE(gen->gen.primes.cube);
	    FREE(gen);
	    return(NULL);
	}
	cuddRef(tmp);
	Cudd_RecursiveDeref(dd,gen->node);
	gen->node = tmp;
	result = Cudd_BddToCubeArray(dd,prime,gen->gen.primes.cube);
	if (result == 0) {
	    Cudd_RecursiveDeref(dd,gen->node);
	    Cudd_RecursiveDeref(dd,prime);
	    FREE(gen->gen.primes.cube);
	    FREE(gen);
	    return(NULL);
	}
	Cudd_RecursiveDeref(dd,prime);
	gen->status = CUDD_GEN_NONEMPTY;
    }
    *cube = gen->gen.primes.cube;
    return(gen);

} /* end of Cudd_FirstPrime */


/**
  @brief Generates the next prime of a Boolean function.

  @return 0 if the enumeration is completed; 1 otherwise.

  @sideeffect The cube and is returned as side effects. The
  generator is modified.

  @see Cudd_ForeachPrime Cudd_FirstPrime Cudd_GenFree Cudd_IsGenEmpty
  Cudd_NextCube Cudd_NextNode

*/
int
Cudd_NextPrime(
  DdGen *gen,
  int **cube)
{
    DdNode *implicant, *prime, *tmp;
    DdManager *dd = gen->manager;
    int length, result;

    if (gen->node == Cudd_ReadLogicZero(dd)) {
	gen->status = CUDD_GEN_EMPTY;
    } else {
	implicant = Cudd_LargestCube(dd,gen->node,&length);
	if (implicant == NULL) {
	    gen->status = CUDD_GEN_EMPTY;
	    return(0);
	}
	cuddRef(implicant);
	prime = Cudd_bddMakePrime(dd,implicant,gen->gen.primes.ub);
	if (prime == NULL) {
	    Cudd_RecursiveDeref(dd,implicant);
	    gen->status = CUDD_GEN_EMPTY;
	    return(0);
	}
	cuddRef(prime);
	Cudd_RecursiveDeref(dd,implicant);
	tmp = Cudd_bddAnd(dd,gen->node,Cudd_Not(prime));
	if (tmp == NULL) {
	    Cudd_RecursiveDeref(dd,prime);
	    gen->status = CUDD_GEN_EMPTY;
	    return(0);
	}
	cuddRef(tmp);
	Cudd_RecursiveDeref(dd,gen->node);
	gen->node = tmp;
	result = Cudd_BddToCubeArray(dd,prime,gen->gen.primes.cube);
	if (result == 0) {
	    Cudd_RecursiveDeref(dd,prime);
	    gen->status = CUDD_GEN_EMPTY;
	    return(0);
	}
	Cudd_RecursiveDeref(dd,prime);
	gen->status = CUDD_GEN_NONEMPTY;
    }
    if (gen->status == CUDD_GEN_EMPTY) return(0);
    *cube = gen->gen.primes.cube;
    return(1);

} /* end of Cudd_NextPrime */


/**
  @brief Computes the cube of an array of %BDD variables.

  @details If non-null, the phase argument indicates which literal of
  each variable should appear in the cube. If phase\[i\] is nonzero,
  then the positive literal is used. If phase is NULL, the cube is
  positive unate.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_addComputeCube Cudd_IndicesToCube Cudd_CubeArrayToBdd

*/
DdNode *
Cudd_bddComputeCube(
  DdManager * dd,
  DdNode ** vars,
  int * phase,
  int  n)
{
    DdNode	*cube;
    DdNode	*fn;
    int         i;

    cube = DD_ONE(dd);
    cuddRef(cube);

    for (i = n - 1; i >= 0; i--) {
	if (phase == NULL || phase[i] != 0) {
	    fn = Cudd_bddAnd(dd,vars[i],cube);
	} else {
	    fn = Cudd_bddAnd(dd,Cudd_Not(vars[i]),cube);
	}
	if (fn == NULL) {
	    Cudd_RecursiveDeref(dd,cube);
	    return(NULL);
	}
	cuddRef(fn);
	Cudd_RecursiveDeref(dd,cube);
	cube = fn;
    }
    cuddDeref(cube);

    return(cube);

}  /* end of Cudd_bddComputeCube */


/**
  @brief Computes the cube of an array of %ADD variables.

  @details If non-null, the phase argument indicates which literal of
  each variable should appear in the cube. If phase\[i\] is nonzero,
  then the positive literal is used. If phase is NULL, the cube is
  positive unate.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect none

  @see Cudd_bddComputeCube

*/
DdNode *
Cudd_addComputeCube(
  DdManager * dd,
  DdNode ** vars,
  int * phase,
  int  n)
{
    DdNode	*cube, *azero;
    DdNode	*fn;
    int         i;

    cube = DD_ONE(dd);
    cuddRef(cube);
    azero = DD_ZERO(dd);

    for (i = n - 1; i >= 0; i--) {
	if (phase == NULL || phase[i] != 0) {
	    fn = Cudd_addIte(dd,vars[i],cube,azero);
	} else {
	    fn = Cudd_addIte(dd,vars[i],azero,cube);
	}
	if (fn == NULL) {
	    Cudd_RecursiveDeref(dd,cube);
	    return(NULL);
	}
	cuddRef(fn);
	Cudd_RecursiveDeref(dd,cube);
	cube = fn;
    }
    cuddDeref(cube);

    return(cube);

} /* end of Cudd_addComputeCube */


/**
  @brief Builds the %BDD of a cube from a positional array.

  @details The array must have one integer entry for each %BDD
  variable.  If the i-th entry is 1, the variable of index i appears
  in true form in the cube; If the i-th entry is 0, the variable of
  index i appears complemented in the cube; otherwise the variable
  does not appear in the cube.

  @return a pointer to the %BDD for the cube if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_bddComputeCube Cudd_IndicesToCube Cudd_BddToCubeArray

*/
DdNode *
Cudd_CubeArrayToBdd(
  DdManager *dd,
  int *array)
{
    DdNode *cube, *var, *tmp;
    int i;
    int size = Cudd_ReadSize(dd);

    cube = DD_ONE(dd);
    cuddRef(cube);
    for (i = size - 1; i >= 0; i--) {
	if ((array[i] & ~1) == 0) {
	    var = Cudd_bddIthVar(dd,i);
	    tmp = Cudd_bddAnd(dd,cube,Cudd_NotCond(var,array[i]==0));
	    if (tmp == NULL) {
		Cudd_RecursiveDeref(dd,cube);
		return(NULL);
	    }
	    cuddRef(tmp);
	    Cudd_RecursiveDeref(dd,cube);
	    cube = tmp;
	}
    }
    cuddDeref(cube);
    return(cube);

} /* end of Cudd_CubeArrayToBdd */


/**
  @brief Builds a positional array from the %BDD of a cube.

  @details Array must have one entry for each %BDD variable.  The
  positional array has 1 in i-th position if the variable of index i
  appears in true form in the cube; it has 0 in i-th position if the
  variable of index i appears in complemented form in the cube;
  finally, it has 2 in i-th position if the variable of index i does
  not appear in the cube.

  @return 1 if successful (the %BDD is indeed a cube); 0 otherwise.

  @sideeffect The result is in the array passed by reference.

  @see Cudd_CubeArrayToBdd

*/
int
Cudd_BddToCubeArray(
  DdManager *dd,
  DdNode *cube,
  int *array)
{
    DdNode *scan, *t, *e;
    int i;
    int size = Cudd_ReadSize(dd);
    DdNode *lzero = Cudd_Not(DD_ONE(dd));

    for (i = size-1; i >= 0; i--) {
	array[i] = 2;
    }
    scan = cube;
    while (!Cudd_IsConstantInt(scan)) {
	unsigned int index = Cudd_Regular(scan)->index;
	cuddGetBranches(scan,&t,&e);
	if (t == lzero) {
	    array[index] = 0;
	    scan = e;
	} else if (e == lzero) {
	    array[index] = 1;
	    scan = t;
	} else {
	    return(0);	/* cube is not a cube */
	}
    }
    if (scan == lzero) {
	return(0);
    } else {
	return(1);
    }

} /* end of Cudd_BddToCubeArray */


/**
  @brief Finds the first node of a decision diagram.

  @details Defines an iterator on the nodes of a decision diagram and
  finds its first node.  The nodes are enumerated in a reverse
  topological order, so that a node is always preceded in the
  enumeration by its descendants.

  @return a generator that contains the information necessary to
  continue the enumeration if successful; NULL otherwise.

  @sideeffect The first node is returned as a side effect.

  @see Cudd_ForeachNode Cudd_NextNode Cudd_GenFree Cudd_IsGenEmpty
  Cudd_FirstCube

*/
DdGen *
Cudd_FirstNode(
  DdManager * dd,
  DdNode * f,
  DdNode ** node)
{
    DdGen *gen;
    int size;

    /* Sanity Check. */
    if (dd == NULL || f == NULL) return(NULL);

    /* Allocate generator an initialize it. */
    gen = ALLOC(DdGen,1);
    if (gen == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    gen->manager = dd;
    gen->type = CUDD_GEN_NODES;
    gen->status = CUDD_GEN_EMPTY;
    gen->stack.sp = 0;
    gen->node = NULL;

    /* Collect all the nodes on the generator stack for later perusal. */
    gen->stack.stack = cuddNodeArray(Cudd_Regular(f), &size);
    if (gen->stack.stack == NULL) {
	FREE(gen);
	dd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }
    gen->gen.nodes.size = size;

    /* Find the first node. */
    if (gen->stack.sp < gen->gen.nodes.size) {
	gen->status = CUDD_GEN_NONEMPTY;
	gen->node = gen->stack.stack[gen->stack.sp];
	*node = gen->node;
    }

    return(gen);

} /* end of Cudd_FirstNode */


/**
  @brief Finds the next node of a decision diagram.

  @return 0 if the enumeration is completed; 1 otherwise.

  @sideeffect The next node is returned as a side effect.

  @see Cudd_ForeachNode Cudd_FirstNode Cudd_GenFree Cudd_IsGenEmpty
  Cudd_NextCube

*/
int
Cudd_NextNode(
  DdGen * gen,
  DdNode ** node)
{
    /* Find the next node. */
    gen->stack.sp++;
    if (gen->stack.sp < gen->gen.nodes.size) {
	gen->node = gen->stack.stack[gen->stack.sp];
	*node = gen->node;
	return(1);
    } else {
	gen->status = CUDD_GEN_EMPTY;
	return(0);
    }

} /* end of Cudd_NextNode */


/**
  @brief Frees a CUDD generator.

  @return always 0.

  @sideeffect None

  @see Cudd_ForeachCube Cudd_ForeachNode Cudd_FirstCube Cudd_NextCube
  Cudd_FirstNode Cudd_NextNode Cudd_IsGenEmpty

*/
int
Cudd_GenFree(
  DdGen * gen)
{
    if (gen == NULL) return(0);
    switch (gen->type) {
    case CUDD_GEN_CUBES:
    case CUDD_GEN_ZDD_PATHS:
	FREE(gen->gen.cubes.cube);
	FREE(gen->stack.stack);
	break;
    case CUDD_GEN_PRIMES:
	FREE(gen->gen.primes.cube);
	Cudd_RecursiveDeref(gen->manager,gen->node);
	break;
    case CUDD_GEN_NODES:
	FREE(gen->stack.stack);
	break;
    default:
	return(0);
    }
    FREE(gen);
    return(0);

} /* end of Cudd_GenFree */


/**
  @brief Queries the status of a generator.

  @return 1 if the generator is empty or NULL; 0 otherswise.

  @sideeffect None

  @see Cudd_ForeachCube Cudd_ForeachNode Cudd_FirstCube Cudd_NextCube
  Cudd_FirstNode Cudd_NextNode Cudd_GenFree

*/
int
Cudd_IsGenEmpty(
  DdGen * gen)
{
    if (gen == NULL) return(1);
    return(gen->status == CUDD_GEN_EMPTY);

} /* end of Cudd_IsGenEmpty */


/**
  @brief Builds a cube of %BDD variables from an array of indices.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_bddComputeCube Cudd_CubeArrayToBdd

*/
DdNode *
Cudd_IndicesToCube(
  DdManager * dd,
  int * array,
  int  n)
{
    DdNode *cube, *tmp;
    int i;

    cube = DD_ONE(dd);
    cuddRef(cube);
    for (i = n - 1; i >= 0; i--) {
	tmp = Cudd_bddAnd(dd,Cudd_bddIthVar(dd,array[i]),cube);
	if (tmp == NULL) {
	    Cudd_RecursiveDeref(dd,cube);
	    return(NULL);
	}
	cuddRef(tmp);
	Cudd_RecursiveDeref(dd,cube);
	cube = tmp;
    }

    cuddDeref(cube);
    return(cube);

} /* end of Cudd_IndicesToCube */


/**
  @brief Prints the package version number.

  @sideeffect None

*/
void
Cudd_PrintVersion(
  FILE * fp)
{
    (void) fprintf(fp, "%s\n", CUDD_VERSION);

} /* end of Cudd_PrintVersion */


/**
  @brief Computes the average distance between adjacent nodes in the manager.

  @details Adjacent nodes are node pairs such that the second node
  is the then child, else child, or next node in the collision list.

  @sideeffect None

*/
double
Cudd_AverageDistance(
  DdManager * dd)
{
    double tetotal, nexttotal;
    double tesubtotal, nextsubtotal;
    double temeasured, nextmeasured;
    int i, j;
    int slots, nvars;
    ptrdiff_t diff;
    DdNode *scan;
    DdNodePtr *nodelist;
    DdNode *sentinel = &(dd->sentinel);

    nvars = dd->size;
    if (nvars == 0) return(0.0);

    /* Initialize totals. */
    tetotal = 0.0;
    nexttotal = 0.0;
    temeasured = 0.0;
    nextmeasured = 0.0;

    /* Scan the variable subtables. */
    for (i = 0; i < nvars; i++) {
	nodelist = dd->subtables[i].nodelist;
	tesubtotal = 0.0;
	nextsubtotal = 0.0;
	slots = dd->subtables[i].slots;
	for (j = 0; j < slots; j++) {
	    scan = nodelist[j];
	    while (scan != sentinel) {
		diff = (ptrint) scan - (ptrint) cuddT(scan);
		tesubtotal += (double) ddAbs(diff);
		diff = (ptrint) scan - (ptrint) Cudd_Regular(cuddE(scan));
		tesubtotal += (double) ddAbs(diff);
		temeasured += 2.0;
		if (scan->next != sentinel) {
		    diff = (ptrint) scan - (ptrint) scan->next;
		    nextsubtotal += (double) ddAbs(diff);
		    nextmeasured += 1.0;
		}
		scan = scan->next;
	    }
	}
	tetotal += tesubtotal;
	nexttotal += nextsubtotal;
    }

    /* Scan the constant table. */
    nodelist = dd->constants.nodelist;
    nextsubtotal = 0.0;
    slots = dd->constants.slots;
    for (j = 0; j < slots; j++) {
	scan = nodelist[j];
	while (scan != NULL) {
	    if (scan->next != NULL) {
		diff = (ptrint) scan - (ptrint) scan->next;
		nextsubtotal += (double) ddAbs(diff);
		nextmeasured += 1.0;
	    }
	    scan = scan->next;
	}
    }
    nexttotal += nextsubtotal;

    return((tetotal + nexttotal) / (temeasured + nextmeasured));

} /* end of Cudd_AverageDistance */


/**
  @brief Portable random number generator.

  @details Based on ran2 from "Numerical Recipes in C." It is a long
  period (> 2 * 10^18) random number generator of L'Ecuyer with
  Bays-Durham shuffle.  The random generator can be explicitly
  initialized by calling Cudd_Srandom. If no explicit initialization
  is performed, then the seed 1 is assumed.

  @return a long integer uniformly distributed between 0 and
  2147483561 (inclusive of the endpoint values).

  @sideeffect None

  @see Cudd_Srandom

*/
int32_t
Cudd_Random(DdManager *dd)
{
    int i;	/* index in the shuffle table */
    int32_t w;	/* work variable */

    /* dd->cuddRand == 0 if the geneartor has not been initialized yet. */
    if (dd->cuddRand == 0) Cudd_Srandom(dd,1);

    /* Compute cuddRand = (cuddRand * LEQA1) % MODULUS1 avoiding
    ** overflows by Schrage's method.
    */
    w          = dd->cuddRand / LEQQ1;
    dd->cuddRand   = LEQA1 * (dd->cuddRand - w * LEQQ1) - w * LEQR1;
    dd->cuddRand  += (dd->cuddRand < 0) * MODULUS1;

    /* Compute dd->cuddRand2 = (dd->cuddRand2 * LEQA2) % MODULUS2 avoiding
    ** overflows by Schrage's method.
    */
    w          = dd->cuddRand2 / LEQQ2;
    dd->cuddRand2  = LEQA2 * (dd->cuddRand2 - w * LEQQ2) - w * LEQR2;
    dd->cuddRand2 += (dd->cuddRand2 < 0) * MODULUS2;

    /* dd->cuddRand is shuffled with the Bays-Durham algorithm.
    ** dd->shuffleSelect and cuddRand2 are combined to generate the output.
    */

    /* Pick one element from the shuffle table; "i" will be in the range
    ** from 0 to STAB_SIZE-1.
    */
    i = (int) (dd->shuffleSelect / STAB_DIV);
    /* Mix the element of the shuffle table with the current iterate of
    ** the second sub-generator, and replace the chosen element of the
    ** shuffle table with the current iterate of the first sub-generator.
    */
    dd->shuffleSelect   = dd->shuffleTable[i] - dd->cuddRand2;
    dd->shuffleTable[i] = dd->cuddRand;
    dd->shuffleSelect  += (dd->shuffleSelect < 1) * (MODULUS1 - 1);
    /* Since dd->shuffleSelect != 0, and we want to be able to return 0,
    ** here we subtract 1 before returning.
    */
    return(dd->shuffleSelect - 1);

} /* end of Cudd_Random */


/**
  @brief Initializer for the portable random number generator.

  @details Based on ran2 in "Numerical Recipes in C." The input is the
  seed for the generator. If it is negative, its absolute value is
  taken as seed.  If it is 0, then 1 is taken as seed. The initialized
  sets up the two recurrences used to generate a long-period stream,
  and sets up the shuffle table.

  @sideeffect None

  @see Cudd_Random

*/
void
Cudd_Srandom(
  DdManager *dd,
  int32_t  seed)
{
    int32_t i;

    if (seed < 0)       dd->cuddRand = -seed;
    else if (seed == 0) dd->cuddRand = 1;
    else                dd->cuddRand = seed;
    dd->cuddRand2 = dd->cuddRand;
    /* Load the shuffle table (after 11 warm-ups). */
    for (i = 0; i < STAB_SIZE + 11; i++) {
	int32_t w;
	w = dd->cuddRand / LEQQ1;
	dd->cuddRand = LEQA1 * (dd->cuddRand - w * LEQQ1) - w * LEQR1;
	dd->cuddRand += (dd->cuddRand < 0) * MODULUS1;
	dd->shuffleTable[i % STAB_SIZE] = dd->cuddRand;
    }
    dd->shuffleSelect = dd->shuffleTable[1 % STAB_SIZE];

} /* end of Cudd_Srandom */


/**
  @brief Computes the density of a %BDD or %ADD.

  @details The density is the ratio of the number of minterms to the
  number of nodes. If 0 is passed as number of variables, the number
  of variables existing in the manager is used.

  @return the density if successful; (double) CUDD_OUT_OF_MEM
  otherwise.

  @sideeffect None

  @see Cudd_CountMinterm Cudd_DagSize

*/
double
Cudd_Density(
  DdManager * dd /**< manager */,
  DdNode * f /**< function whose density is sought */,
  int  nvars /**< size of the support of f */)
{
    double minterms;
    int nodes;
    double density;

    if (nvars == 0) nvars = dd->size;
    minterms = Cudd_CountMinterm(dd,f,nvars);
    if (minterms == (double) CUDD_OUT_OF_MEM) return(minterms);
    nodes = Cudd_DagSize(f);
    density = minterms / (double) nodes;
    return(density);

} /* end of Cudd_Density */


/**
  @brief Warns that a memory allocation failed.

  @details This function can be used as replacement of MMout_of_memory
  to prevent the safe_mem functions of the util package from exiting
  when malloc returns NULL.  One possible use is in case of
  discretionary allocations; for instance, an allocation of memory to
  enlarge the computed table.

  @sideeffect None

  @see Cudd_OutOfMemSilent Cudd_RegisterOutOfMemoryCallback

*/
void
Cudd_OutOfMem(
  size_t size /**< size of the allocation that failed */)
{
    (void) fflush(stdout);
    (void) fprintf(stderr, "\nCUDD: unable to allocate %" PRIszt " bytes\n",
                   size);

} /* end of Cudd_OutOfMem */


/**
  @brief Doesn not warn that a memory allocation failed.

  @details This function can be used as replacement of MMout_of_memory
  to prevent the safe_mem functions of the util package from exiting
  when malloc returns NULL.  One possible use is in case of
  discretionary allocations; for instance, an allocation of memory to
  enlarge the computed table.

  @sideeffect None

  @see Cudd_OutOfMem Cudd_RegisterOutOfMemoryCallback

*/
void
Cudd_OutOfMemSilent(
  size_t size /**< size of the allocation that failed */)
{
    (void) size; /* suppress warning */

} /* end of Cudd_OutOfMem */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints a %DD to the standard output. One line per node is
  printed.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_PrintDebug

*/
int
cuddP(
  DdManager * dd,
  DdNode * f)
{
    int retval;
    st_table *table = st_init_table(st_ptrcmp,st_ptrhash);

    if (table == NULL) return(0);

    retval = dp2(dd,f,table);
    st_free_table(table);
    (void) fputc('\n',dd->out);
    return(retval);

} /* end of cuddP */


/**
  @brief Frees the memory used to store the minterm counts recorded
  in the visited table.

  @return ST_CONTINUE.

  @sideeffect None

*/
enum st_retval
cuddStCountfree(
  void * key,
  void * value,
  void * arg)
{
    double *d = (double *)value;

    (void) key; /* avoid warning */
    (void) arg; /* avoid warning */
    FREE(d);
    return(ST_CONTINUE);

} /* end of cuddStCountfree */


/**
  @brief Recursively collects all the nodes of a %DD in a symbol
  table.

  @details Traverses the %DD f and collects all its nodes in a
  symbol table.  f is assumed to be a regular pointer and
  cuddCollectNodes guarantees this assumption in the recursive calls.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
cuddCollectNodes(
  DdNode * f,
  st_table * visited)
{
    DdNode	*T, *E;
    int		retval;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(f));
#endif

    /* If already visited, nothing to do. */
    if (st_is_member(visited, f) == 1)
	return(1);

    /* Check for abnormal condition that should never happen. */
    if (f == NULL)
	return(0);

    /* Mark node as visited. */
    if (st_add_direct(visited, f, NULL) == ST_OUT_OF_MEM)
	return(0);

    /* Check terminal case. */
    if (cuddIsConstant(f))
	return(1);

    /* Recursive calls. */
    T = cuddT(f);
    retval = cuddCollectNodes(T,visited);
    if (retval != 1) return(retval);
    E = Cudd_Regular(cuddE(f));
    retval = cuddCollectNodes(E,visited);
    return(retval);

} /* end of cuddCollectNodes */


/**
  @brief Recursively collects all the nodes of a %DD in an array.

  @details Traverses the %DD f and collects all its nodes in an array.
  The caller should free the array returned by cuddNodeArray.  The
  nodes are collected in reverse topological order, so that a node is
  always preceded in the array by all its descendants.

  @return a pointer to the array of nodes in case of success; NULL
  otherwise.

  @sideeffect The number of nodes is returned as a side effect.

  @see Cudd_FirstNode

*/
DdNodePtr *
cuddNodeArray(
  DdNode *f,
  int *n)
{
    DdNodePtr *table;
    int size, retval;

    size = ddDagInt(Cudd_Regular(f));
    table = ALLOC(DdNodePtr, size);
    if (table == NULL) {
	ddClearFlag(Cudd_Regular(f));
	return(NULL);
    }

    retval = cuddNodeArrayRecur(f, table, 0);
    assert(retval == size);

    *n = size;
    return(table);

} /* cuddNodeArray */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of cuddP.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
dp2(
  DdManager *dd,
  DdNode * f,
  st_table * t)
{
    DdNode *g, *n, *N;
    int T,E;

    if (f == NULL) {
	return(0);
    }
    g = Cudd_Regular(f);
    if (cuddIsConstant(g)) {
	(void) fprintf(dd->out,"ID = %c0x%" PRIxPTR "\tvalue = %-9g\n", bang(f),
		(ptruint) g / (ptruint) sizeof(DdNode),cuddV(g));
	return(1);
    }
    if (st_is_member(t,g) == 1) {
	return(1);
    }
    if (st_add_direct(t,g,NULL) == ST_OUT_OF_MEM)
	return(0);
#ifdef DD_STATS
    (void) fprintf(dd->out,"ID = %c0x%"PRIxPTR"\tindex = %d\tr = %d\t", bang(f),
		(ptruint) g / (ptruint) sizeof(DdNode), g->index, g->ref);
#else
    (void) fprintf(dd->out,"ID = %c0x%" PRIxPTR "\tindex = %u\t", bang(f),
		(ptruint) g / (ptruint) sizeof(DdNode),g->index);
#endif
    n = cuddT(g);
    if (cuddIsConstant(n)) {
	(void) fprintf(dd->out,"T = %-9g\t",cuddV(n));
	T = 1;
    } else {
	(void) fprintf(dd->out,"T = 0x%" PRIxPTR "\t",
                       (ptruint) n / (ptruint) sizeof(DdNode));
	T = 0;
    }

    n = cuddE(g);
    N = Cudd_Regular(n);
    if (cuddIsConstant(N)) {
	(void) fprintf(dd->out,"E = %c%-9g\n",bang(n),cuddV(N));
	E = 1;
    } else {
	(void) fprintf(dd->out,"E = %c0x%" PRIxPTR "\n",
                       bang(n), (ptruint) N/(ptruint) sizeof(DdNode));
	E = 0;
    }
    if (E == 0) {
	if (dp2(dd,N,t) == 0)
	    return(0);
    }
    if (T == 0) {
	if (dp2(dd,cuddT(g),t) == 0)
	    return(0);
    }
    return(1);

} /* end of dp2 */


/**
  @brief Performs the recursive step of Cudd_PrintMinterm.

  @sideeffect None

*/
static void
ddPrintMintermAux(
  DdManager * dd /**< manager */,
  DdNode * node /**< current node */,
  int * list /**< current recursion path */)
{
    DdNode	 *N,*Nv,*Nnv;
    int		 i,v;
    unsigned int index;

    N = Cudd_Regular(node);

    if (cuddIsConstant(N)) {
	/* Terminal case: Print one cube based on the current recursion
	** path, unless we have reached the background value (ADDs) or
	** the logical zero (BDDs).
	*/
	if (node != dd->background && node != Cudd_Not(dd->one)) {
	    for (i = 0; i < dd->size; i++) {
		v = list[i];
		if (v == 0) (void) fprintf(dd->out,"0");
		else if (v == 1) (void) fprintf(dd->out,"1");
		else (void) fprintf(dd->out,"-");
	    }
	    (void) fprintf(dd->out," % g\n", cuddV(node));
	}
    } else {
	Nv  = cuddT(N);
	Nnv = cuddE(N);
	if (Cudd_IsComplement(node)) {
	    Nv  = Cudd_Not(Nv);
	    Nnv = Cudd_Not(Nnv);
	}
	index = N->index;
	list[index] = 0;
	ddPrintMintermAux(dd,Nnv,list);
	list[index] = 1;
	ddPrintMintermAux(dd,Nv,list);
	list[index] = 2;
    }
    return;

} /* end of ddPrintMintermAux */


/**
  @brief Performs the recursive step of Cudd_DagSize.

  @return the number of nodes in the graph rooted at n.

  @sideeffect None

*/
static int
ddDagInt(
  DdNode * n)
{
    int tval, eval;

    if (Cudd_IsComplement(n->next)) {
	return(0);
    }
    n->next = Cudd_Not(n->next);
    if (cuddIsConstant(n)) {
	return(1);
    }
    tval = ddDagInt(cuddT(n));
    eval = ddDagInt(Cudd_Regular(cuddE(n)));
    return(1 + tval + eval);

} /* end of ddDagInt */


/**
  @brief Performs the recursive step of cuddNodeArray.

  @details node is supposed to be regular; the invariant is maintained
  by this procedure.

  @return an the number of nodes in the %DD.

  @sideeffect Clears the least significant bit of the next field that
  was used as visited flag by cuddNodeArrayRecur when counting the
  nodes.

*/
static int
cuddNodeArrayRecur(
  DdNode *f,
  DdNodePtr *table,
  int index)
{
    int tindex, eindex;

    if (!Cudd_IsComplement(f->next)) {
	return(index);
    }
    /* Clear visited flag. */
    f->next = Cudd_Regular(f->next);
    if (cuddIsConstant(f)) {
	table[index] = f;
	return(index + 1);
    }
    tindex = cuddNodeArrayRecur(cuddT(f), table, index);
    eindex = cuddNodeArrayRecur(Cudd_Regular(cuddE(f)), table, tindex);
    table[eindex] = f;
    return(eindex + 1);

} /* end of cuddNodeArrayRecur */


/**
  @brief Performs the recursive step of Cudd_CofactorEstimate.

  @details Uses the least significant bit of the next field as visited
  flag. node is supposed to be regular; the invariant is maintained by
  this procedure.

  @return an estimate of the number of nodes in the %DD of a cofactor
  of node.

  @sideeffect None

*/
static int
cuddEstimateCofactor(
  DdManager *dd,
  st_table *table,
  DdNode * node,
  int i,
  int phase,
  DdNode ** ptr)
{
    int tval, eval, val;
    DdNode *ptrT, *ptrE;

#ifdef DD_DEBUG
    assert(!Cudd_IsComplement(node));
#endif
    if (Cudd_IsComplement(node->next)) {
	if (!st_lookup(table, node, (void **)ptr)) {
	    if (st_add_direct(table, node, node) == ST_OUT_OF_MEM)
		return(CUDD_OUT_OF_MEM);
	    *ptr = node;
	}
	return(0);
    }
    node->next = Cudd_Not(node->next);
    if (cuddIsConstant(node)) {
	*ptr = node;
	if (st_add_direct(table, node, node) == ST_OUT_OF_MEM)
	    return(CUDD_OUT_OF_MEM);
	return(1);
    }
    if ((int) node->index == i) {
	if (phase == 1) {
	    *ptr = cuddT(node);
	    val = ddDagInt(cuddT(node));
	} else {
	    *ptr = cuddE(node);
	    val = ddDagInt(Cudd_Regular(cuddE(node)));
	}
	if (node->ref > 1) {
	    if (st_add_direct(table,node,*ptr) == ST_OUT_OF_MEM)
		return(CUDD_OUT_OF_MEM);
	}
	return(val);
    }
    if (dd->perm[node->index] > dd->perm[i]) {
	*ptr = node;
	if (node->ref > 1) {
	    if (st_add_direct(table,node,node) == ST_OUT_OF_MEM)
		return(CUDD_OUT_OF_MEM);
	}
	val = 1 + ddDagInt(cuddT(node)) + ddDagInt(Cudd_Regular(cuddE(node)));
	return(val);
    }
    tval = cuddEstimateCofactor(dd,table,cuddT(node),i,phase,&ptrT);
    if (tval == CUDD_OUT_OF_MEM) return(CUDD_OUT_OF_MEM);
    eval = cuddEstimateCofactor(dd,table,Cudd_Regular(cuddE(node)),i,
				phase,&ptrE);
    if (eval == CUDD_OUT_OF_MEM) return(CUDD_OUT_OF_MEM);
    ptrE = Cudd_NotCond(ptrE,Cudd_IsComplement(cuddE(node)));
    if (ptrT == ptrE) {		/* recombination */
	*ptr = ptrT;
	val = tval;
	if (node->ref > 1) {
	    if (st_add_direct(table,node,*ptr) == ST_OUT_OF_MEM)
		return(CUDD_OUT_OF_MEM);
	}
    } else {
        int complement = Cudd_IsComplement(ptrT);
        if (complement) {
            ptrT = Cudd_Regular(ptrT);
            ptrE = Cudd_Complement(ptrE);
        }
        if ((ptrT != cuddT(node) || ptrE != cuddE(node)) &&
            (*ptr = cuddUniqueLookup(dd,node->index,ptrT,ptrE)) != NULL) {
            if (Cudd_IsComplement((*ptr)->next)) {
                val = 0;
            } else {
                val = 1 + tval + eval;
            }
            if (node->ref > 1) {
                if (st_add_direct(table,node,*ptr) == ST_OUT_OF_MEM)
                    return(CUDD_OUT_OF_MEM);
            }
            if (complement) {
                *ptr = Cudd_Complement(*ptr);
            }
        } else {
            *ptr = node;
            val = 1 + tval + eval;
        }
    }
    return(val);

} /* end of cuddEstimateCofactor */


/**
  @brief Checks the unique table for the existence of an internal node.

  @return a pointer to the node if it is in the table; NULL otherwise.

  @sideeffect None

  @see cuddUniqueInter

*/
static DdNode *
cuddUniqueLookup(
  DdManager * unique,
  int  index,
  DdNode * T,
  DdNode * E)
{
    unsigned int posn;
    int level;
    DdNodePtr *nodelist;
    DdNode *looking;
    DdSubtable *subtable;

    if (index >= unique->size) {
	return(NULL);
    }

    level = unique->perm[index];
    subtable = &(unique->subtables[level]);

#ifdef DD_DEBUG
    assert(level < cuddI(unique,T->index));
    assert(level < cuddI(unique,Cudd_Regular(E)->index));
#endif

    posn = ddHash(T, E, subtable->shift);
    nodelist = subtable->nodelist;
    looking = nodelist[posn];

    while (T < cuddT(looking)) {
	looking = Cudd_Regular(looking->next);
    }
    while (T == cuddT(looking) && E < cuddE(looking)) {
	looking = Cudd_Regular(looking->next);
    }
    if (cuddT(looking) == T && cuddE(looking) == E) {
	return(looking);
    }

    return(NULL);

} /* end of cuddUniqueLookup */


/**
  @brief Performs the recursive step of Cudd_CofactorEstimateSimple.

  @details Uses the least significant bit of the next field as visited
  flag. node is supposed to be regular; the invariant is maintained by
  this procedure.

  @return an estimate of the number of nodes in the %DD of the positive
  cofactor of node.

  @sideeffect None

*/
static int
cuddEstimateCofactorSimple(
  DdNode * node,
  int i)
{
    int tval, eval;

    if (Cudd_IsComplement(node->next)) {
	return(0);
    }
    node->next = Cudd_Not(node->next);
    if (cuddIsConstant(node)) {
	return(1);
    }
    tval = cuddEstimateCofactorSimple(cuddT(node),i);
    if ((int) node->index == i) return(tval);
    eval = cuddEstimateCofactorSimple(Cudd_Regular(cuddE(node)),i);
    return(1 + tval + eval);

} /* end of cuddEstimateCofactorSimple */


/**
  @brief Performs the recursive step of Cudd_CountMinterm.

  @details It is based on the following identity. Let |f| be the
  number of minterms of f. Then:

      |f| = (|f0|+|f1|)/2

  where f0 and f1 are the two cofactors of f.  Does not use the
  identity |f'| = max - |f|, to minimize loss of accuracy due to
  roundoff.

  @return the number of minterms of the function rooted at node.

  @sideeffect None

*/
static double
ddCountMintermAux(
  DdManager * dd,
  DdNode * node,
  double  max,
  DdHashTable * table)
{
    DdNode	*N, *Nt, *Ne;
    double	min, minT, minE;
    DdNode	*res;

    N = Cudd_Regular(node);

    if (cuddIsConstant(N)) {
	if (node == dd->background || node == Cudd_Not(dd->one)) {
	    return(0.0);
	} else {
	    return(max);
	}
    }
    if (N->ref != 1 && (res = cuddHashTableLookup1(table,node)) != NULL) {
	min = cuddV(res);
	if (res->ref == 0) {
	    table->manager->dead++;
	    table->manager->constants.dead++;
	}
	return(min);
    }

    Nt = cuddT(N); Ne = cuddE(N);
    if (Cudd_IsComplement(node)) {
	Nt = Cudd_Not(Nt); Ne = Cudd_Not(Ne);
    }

    minT = ddCountMintermAux(dd,Nt,max,table);
    if (minT == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
    minT *= 0.5;
    minE = ddCountMintermAux(dd,Ne,max,table);
    if (minE == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
    minE *= 0.5;
    min = minT + minE;

    if (N->ref != 1) {
	ptrint fanout = (ptrint) N->ref;
	cuddSatDec(fanout);
	res = cuddUniqueConst(table->manager,min);
	if (!res) {
	    return((double)CUDD_OUT_OF_MEM);
	}
	if (!cuddHashTableInsert1(table,node,res,fanout)) {
	    cuddRef(res); Cudd_RecursiveDeref(table->manager, res);
	    return((double)CUDD_OUT_OF_MEM);
	}
    }

    return(min);

} /* end of ddCountMintermAux */


/**
  @brief Performs the recursive step of Cudd_CountPath.

  @details It is based on the following identity. Let |f| be the
  number of paths of f. Then:

      |f| = |f0|+|f1|

  where f0 and f1 are the two cofactors of f.  Uses the
  identity |f'| = |f|, to improve the utilization of the (local) cache.

  @return the number of paths of the function rooted at node.

  @sideeffect None

*/
static double
ddCountPathAux(
  DdNode * node,
  st_table * table)
{

    DdNode	*Nv, *Nnv;
    double	paths, *ppaths, paths1, paths2;
    void	*dummy;


    if (cuddIsConstant(node)) {
	return(1.0);
    }
    if (st_lookup(table, node, &dummy)) {
	paths = *(double *) dummy;
	return(paths);
    }

    Nv = cuddT(node); Nnv = cuddE(node);

    paths1 = ddCountPathAux(Nv,table);
    if (paths1 == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
    paths2 = ddCountPathAux(Cudd_Regular(Nnv),table);
    if (paths2 == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
    paths = paths1 + paths2;

    ppaths = ALLOC(double,1);
    if (ppaths == NULL) {
	return((double)CUDD_OUT_OF_MEM);
    }

    *ppaths = paths;

    if (st_add_direct(table, node, ppaths) == ST_OUT_OF_MEM) {
	FREE(ppaths);
	return((double)CUDD_OUT_OF_MEM);
    }
    return(paths);

} /* end of ddCountPathAux */


/**
  @brief Performs the recursive step of Cudd_EpdCountMinterm.

  @details It is based on the following identity. Let |f| be the
  number of minterms of f. Then:

      |f| = (|f0|+|f1|)/2

  where f0 and f1 are the two cofactors of f.  Does not use the
  identity |f'| = max - |f|, to minimize loss of accuracy due to
  roundoff.

  @return the number of minterms of the function rooted at node.

  @sideeffect None

*/
static int
ddEpdCountMintermAux(
  DdManager const * dd,
  DdNode * node,
  EpDouble * max,
  EpDouble * epd,
  st_table * table)
{
    DdNode	*Nt, *Ne;
    EpDouble	*min, minT, minE;
    EpDouble	*res;
    int		status;

    /* node is assumed to be regular */
    if (cuddIsConstant(node)) {
	if (node == dd->background) {
	    EpdMakeZero(epd, 0);
	} else {
	    EpdCopy(max, epd);
	}
	return(0);
    }
    if (node->ref != 1 && st_lookup(table, node, (void **) &res)) {
	EpdCopy(res, epd);
	return(0);
    }

    Nt = cuddT(node); Ne = cuddE(node);

    status = ddEpdCountMintermAux(dd,Nt,max,&minT,table);
    if (status == CUDD_OUT_OF_MEM) return(CUDD_OUT_OF_MEM);
    EpdMultiply(&minT, (double)0.5);
    status = ddEpdCountMintermAux(dd,Cudd_Regular(Ne),max,&minE,table);
    if (status == CUDD_OUT_OF_MEM) return(CUDD_OUT_OF_MEM);
    if (Cudd_IsComplement(Ne)) {
	EpdSubtract3(max, &minE, epd);
	EpdCopy(epd, &minE);
    }
    EpdMultiply(&minE, (double)0.5);
    EpdAdd3(&minT, &minE, epd);

    if (node->ref > 1) {
	min = EpdAlloc();
	if (!min)
	    return(CUDD_OUT_OF_MEM);
	EpdCopy(epd, min);
	if (st_insert(table, node, min) == ST_OUT_OF_MEM) {
	    EpdFree(min);
	    return(CUDD_OUT_OF_MEM);
	}
    }

    return(0);

} /* end of ddEpdCountMintermAux */


/**
  @brief Performs the recursive step of Cudd_LdblCountMinterm.

  @details It is based on the following identity. Let |f| be the
  number of minterms of f. Then:

      |f| = (|f0|+|f1|)/2

  where f0 and f1 are the two cofactors of f.  Does not use the
  identity |f'| = max - |f|, to minimize loss of accuracy due to
  roundoff.

  @return the number of minterms of the function rooted at node.

  @sideeffect None

*/
static long double
ddLdblCountMintermAux(
  DdManager const *manager,
  DdNode *node,
  long double max,
  st_table *table)
{
    DdNode *t, *e;
    long double min, minT, minE;
    long double *res;
    if (cuddIsConstant(node)) {
        if (node == manager->background) {
            return 0.0L;
        } else {
            return max;
        }
    }
    if (node->ref != 1 && st_lookup(table, node, (void **) &res)) {
        return *res;
    }

    t = cuddT(node); e = cuddE(node);

    minT = ddLdblCountMintermAux(manager, t, max, table);
    if (minT == (long double) CUDD_OUT_OF_MEM)
        return((long double) CUDD_OUT_OF_MEM);
    minT *= 0.5L;
    minE = ddLdblCountMintermAux(manager, Cudd_Regular(e), max, table);
    if (minE == (long double) CUDD_OUT_OF_MEM)
        return((long double) CUDD_OUT_OF_MEM);
    if (Cudd_IsComplement(e)) {
        minE = max - minE;
    }
    minE *= 0.5L;
    min = minT + minE;
    if (node->ref != 1) {
        res = ALLOC(long double, 1);
        if (res == NULL)
            return((long double) CUDD_OUT_OF_MEM);
        *res = min;
        if (st_insert(table, node, res) == ST_OUT_OF_MEM) {
            FREE(res);
            return((long double) CUDD_OUT_OF_MEM);
        }
    }
    return(min);

} /* end of ddLdblCountMintermAux */


/**
  @brief Performs the recursive step of Cudd_CountPathsToNonZero.

  @details It is based on the following identity. Let |f| be the
  number of paths of f. Then:

      |f| = |f0|+|f1|

  where f0 and f1 are the two cofactors of f.

  @return the number of paths of the function rooted at node.

  @sideeffect None

*/
static double
ddCountPathsToNonZero(
  DdNode * N,
  st_table * table)
{

    DdNode	*node, *Nt, *Ne;
    double	paths, *ppaths, paths1, paths2;
    void	*dummy;

    node = Cudd_Regular(N);
    if (cuddIsConstant(node)) {
	return((double) !(Cudd_IsComplement(N) || cuddV(node)==DD_ZERO_VAL));
    }
    if (st_lookup(table, N, &dummy)) {
	paths = *(double *) dummy;
	return(paths);
    }

    Nt = cuddT(node); Ne = cuddE(node);
    if (node != N) {
	Nt = Cudd_Not(Nt); Ne = Cudd_Not(Ne);
    }

    paths1 = ddCountPathsToNonZero(Nt,table);
    if (paths1 == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
    paths2 = ddCountPathsToNonZero(Ne,table);
    if (paths2 == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
    paths = paths1 + paths2;

    ppaths = ALLOC(double,1);
    if (ppaths == NULL) {
	return((double)CUDD_OUT_OF_MEM);
    }

    *ppaths = paths;

    if (st_add_direct(table, N, ppaths) == ST_OUT_OF_MEM) {
	FREE(ppaths);
	return((double)CUDD_OUT_OF_MEM);
    }
    return(paths);

} /* end of ddCountPathsToNonZero */


/**
  @brief Performs the recursive step of Cudd_Support.

  @details Performs a DFS from f. The support is accumulated in supp
  as a side effect. Uses the LSB of the then pointer as visited flag.

  @sideeffect None

  @see ddClearFlag

*/
static void
ddSupportStep(
  DdNode * f,
  int * support)
{
    if (cuddIsConstant(f) || Cudd_IsComplement(f->next))
	return;

    support[f->index] = 1;
    ddSupportStep(cuddT(f),support);
    ddSupportStep(Cudd_Regular(cuddE(f)),support);
    /* Mark as visited. */
    f->next = Cudd_Complement(f->next);

} /* end of ddSupportStep */


/**
  @brief Performs a DFS from f, clearing the LSB of the next pointers.

  @sideeffect None

  @see ddSupportStep ddFindSupport ddLeavesInt ddDagInt

*/
static void
ddClearFlag(
  DdNode * f)
{
    if (!Cudd_IsComplement(f->next)) {
	return;
    }
    /* Clear visited flag. */
    f->next = Cudd_Regular(f->next);
    if (cuddIsConstant(f)) {
	return;
    }
    ddClearFlag(cuddT(f));
    ddClearFlag(Cudd_Regular(cuddE(f)));
    return;

} /* end of ddClearFlag */


/**
  @brief Performs the recursive step of Cudd_CountLeaves.

  @return the number of leaves in the %DD rooted at n.

  @sideeffect None

  @see Cudd_CountLeaves

*/
static int
ddLeavesInt(
  DdNode * n)
{
    int tval, eval;

    if (Cudd_IsComplement(n->next)) {
	return(0);
    }
    n->next = Cudd_Not(n->next);
    if (cuddIsConstant(n)) {
	return(1);
    }
    tval = ddLeavesInt(cuddT(n));
    eval = ddLeavesInt(Cudd_Regular(cuddE(n)));
    return(tval + eval);

} /* end of ddLeavesInt */


/**
  @brief Performs the recursive step of Cudd_bddPickArbitraryMinterms.

  @return 1 if successful; 0 otherwise.

  @sideeffect none

  @see Cudd_bddPickArbitraryMinterms

*/
static int
ddPickArbitraryMinterms(
  DdManager *dd,
  DdNode *node,
  int nvars,
  int nminterms,
  char **string)
{
    DdNode *N, *T, *E;
    DdNode *one, *bzero;
    int    i, t, result;
    double min1, min2;

    if (string == NULL || node == NULL) return(0);

    /* The constant 0 function has no on-set cubes. */
    one = DD_ONE(dd);
    bzero = Cudd_Not(one);
    if (nminterms == 0 || node == bzero) return(1);
    if (node == one) {
	return(1);
    }

    N = Cudd_Regular(node);
    T = cuddT(N); E = cuddE(N);
    if (Cudd_IsComplement(node)) {
	T = Cudd_Not(T); E = Cudd_Not(E);
    }

    min1 = Cudd_CountMinterm(dd, T, nvars) / 2.0;
    if (min1 == (double)CUDD_OUT_OF_MEM) return(0);
    min2 = Cudd_CountMinterm(dd, E, nvars) / 2.0;
    if (min2 == (double)CUDD_OUT_OF_MEM) return(0);

    t = (int)((double)nminterms * min1 / (min1 + min2) + 0.5);
    for (i = 0; i < t; i++)
	string[i][N->index] = '1';
    for (i = t; i < nminterms; i++)
	string[i][N->index] = '0';

    result = ddPickArbitraryMinterms(dd,T,nvars,t,&string[0]);
    if (result == 0)
	return(0);
    result = ddPickArbitraryMinterms(dd,E,nvars,nminterms-t,&string[t]);
    return(result);

} /* end of ddPickArbitraryMinterms */


/**
  @brief Finds a representative cube of a %BDD.

  @details Finds a representative cube of a %BDD with the weight of
  each variable. From the top variable, if the weight is greater than or
  equal to 0.0, choose THEN branch unless the child is the constant 0.
  Otherwise, choose ELSE branch unless the child is the constant 0.

  @sideeffect Cudd_SubsetWithMaskVars Cudd_bddPickOneCube

*/
static int
ddPickRepresentativeCube(
  DdManager *dd,
  DdNode *node,
  double *weight,
  char *string)
{
    DdNode *N, *T, *E;
    DdNode *one, *bzero;

    if (string == NULL || node == NULL) return(0);

    /* The constant 0 function has no on-set cubes. */
    one = DD_ONE(dd);
    bzero = Cudd_Not(one);
    if (node == bzero) return(0);

    if (node == DD_ONE(dd)) return(1);

    for (;;) {
	N = Cudd_Regular(node);
	if (N == one)
	    break;
	T = cuddT(N);
	E = cuddE(N);
	if (Cudd_IsComplement(node)) {
	    T = Cudd_Not(T);
	    E = Cudd_Not(E);
	}
	if (weight[N->index] >= 0.0) {
	    if (T == bzero) {
		node = E;
		string[N->index] = '0';
	    } else {
		node = T;
		string[N->index] = '1';
	    }
	} else {
	    if (E == bzero) {
		node = T;
		string[N->index] = '1';
	    } else {
		node = E;
		string[N->index] = '0';
	    }
	}
    }
    return(1);

} /* end of ddPickRepresentativeCube */


/**
  @brief Frees the memory used to store the minterm counts recorded
  in the visited table.

  @return ST_CONTINUE.

  @sideeffect None

*/
static enum st_retval
ddEpdFree(
  void * key,
  void * value,
  void * arg)
{
    EpDouble *epd = (EpDouble *) value;

    (void) key; /* avoid warning */
    (void) arg; /* avoid warning */
    EpdFree(epd);
    return(ST_CONTINUE);

} /* end of ddEpdFree */


/**
  @brief Recursively find the support of f.

  @details This function uses the LSB of the next field of the nodes
  of f as visited flag.  It also uses the LSB of the next field of the
  variables as flag to remember whether a certain index has already
  been seen.  Finally, it uses the manager stack to record all seen
  indices.

  @sideeffect The stack pointer SP is modified by side-effect.  The next
  fields are changed and need to be reset.

*/
static void
ddFindSupport(
  DdManager *dd,
  DdNode *f,
  int *SP)
{
    unsigned int index;
    DdNode *var;

    if (cuddIsConstant(f) || Cudd_IsComplement(f->next)) {
	return;
    }

    index = f->index;
    var = dd->vars[index];
    /* It is possible that var is embedded in f.  That causes no problem,
    ** though, because if we see it after encountering another node with
    ** the same index, nothing is supposed to happen.
    */
    if (!Cudd_IsComplement(var->next)) {
        var->next = Cudd_Complement(var->next);
        dd->stack[*SP] = (DdNode *)(ptruint) index;
        (*SP)++;
    }
    ddFindSupport(dd, cuddT(f), SP);
    ddFindSupport(dd, Cudd_Regular(cuddE(f)), SP);
    /* Mark as visited. */
    f->next = Cudd_Complement(f->next);

} /* end of ddFindSupport */


/**
  @brief Clears visited flags for variables.

  @sideeffect None

*/
static void
ddClearVars(
  DdManager *dd,
  int SP)
{
    int i;

    for (i = 0; i < SP; i++) {
        int index = (int) (ptrint) dd->stack[i];
        DdNode *var = dd->vars[index];
        var->next = Cudd_Regular(var->next);
    }
    
} /* end of ddClearVars */


/**
  @brief Compares indices for qsort.

  @details Subtracting these integers cannot produce overflow, because
  they are non-negative.

  @sideeffect None

*/
static int
indexCompare(
  const void *a,
  const void *b)
{
    int ia = *(int const *) a;
    int ib = *(int const *) b;
    return(ia - ib);

} /* end of indexCompare */


/**
  @brief Frees the memory used to store the minterm counts recorded in the
  visited table by Cudd_LdblCountMinterm.

  @returns ST_CONTINUE.

  @sideeffect None
*/
static enum st_retval
ddLdblFree(
  void * key,
  void * value,
  void * arg)
{
    long double * ld = (long double *) value;

    (void) key; /* avoid warning */
    (void) arg; /* avoid warning */
    FREE(ld);
    return(ST_CONTINUE);

} /* end of ddLdblFree */


#if HAVE_POWL != 1
/**
  @brief Replacement for standard library powl.

  @details Some systems' C libraries, notably Cygwin as of 2015,
  lack an implementation of powl.  This simple-minded replacement
  works for integral powers.  It is based on iterative squaring.

  @return base raised to the exponent.
*/
static long double
powl(
  long double base,
  long double exponent)
{
    long exp;
    long double power = 1.0L, square = base;
    if (exponent < 0.0L) {
        exp = (long) -exponent;
    } else {
        exp = (long) exponent;
    }
    /* Compute base^exponent by iterative squaring.
     * The loop invariant is power * square^exp = base^exponent.
     */
    while (exp > 0) {
        if (exp & 1L)
            power *= square;
        square *= square;
        exp >>= 1L;
    }
    if (exponent < 0.0L) {
        power = 1.0L / power;
    }
    return(power);

} /* end of powl */
#endif

cuddWindow.c
24532
/**
  @file

  @ingroup cudd

  @brief Functions for variable reordering by window permutation.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int ddWindow2 (DdManager *table, int low, int high);
static int ddWindowConv2 (DdManager *table, int low, int high);
static int ddPermuteWindow3 (DdManager *table, int x);
static int ddWindow3 (DdManager *table, int low, int high);
static int ddWindowConv3 (DdManager *table, int low, int high);
static int ddPermuteWindow4 (DdManager *table, int w);
static int ddWindow4 (DdManager *table, int low, int high);
static int ddWindowConv4 (DdManager *table, int low, int high);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Reorders by applying the method of the sliding window.

  @details Tries all possible permutations to the variables in a
  window that slides from low to high. The size of the window is
  determined by submethod.  Assumes that no dead nodes are present.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
cuddWindowReorder(
  DdManager * table /**< %DD table */,
  int low /**< lowest index to reorder */,
  int high /**< highest index to reorder */,
  Cudd_ReorderingType submethod /**< window reordering option */)
{

    int res;
#ifdef DD_DEBUG
    int supposedOpt;
#endif

    switch (submethod) {
    case CUDD_REORDER_WINDOW2:
	res = ddWindow2(table,low,high);
	break;
    case CUDD_REORDER_WINDOW3:
	res = ddWindow3(table,low,high);
	break;
    case CUDD_REORDER_WINDOW4:
	res = ddWindow4(table,low,high);
	break;
    case CUDD_REORDER_WINDOW2_CONV:
	res = ddWindowConv2(table,low,high);
	break;
    case CUDD_REORDER_WINDOW3_CONV:
	res = ddWindowConv3(table,low,high);
#ifdef DD_DEBUG
	supposedOpt = (int) (table->keys - table->isolated);
	res = ddWindow3(table,low,high);
	if (table->keys - table->isolated != (unsigned) supposedOpt) {
	    (void) fprintf(table->err, "Convergence failed! (%d != %d)\n",
			   table->keys - table->isolated, supposedOpt);
	}
#endif
	break;
    case CUDD_REORDER_WINDOW4_CONV:
	res = ddWindowConv4(table,low,high);
#ifdef DD_DEBUG
	supposedOpt = (int) (table->keys - table->isolated);
	res = ddWindow4(table,low,high);
	if (table->keys - table->isolated != (unsigned) supposedOpt) {
	    (void) fprintf(table->err,"Convergence failed! (%d != %d)\n",
			   table->keys - table->isolated, supposedOpt);
	}
#endif
	break;
    default: return(0);
    }

    return(res);

} /* end of cuddWindowReorder */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
  @brief Reorders by applying a sliding window of width 2.

  @details Tries both permutations of the variables in a window that
  slides from low to high.  Assumes that no dead nodes are present.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddWindow2(
  DdManager * table,
  int  low,
  int  high)
{

    int x;
    int res;
    int size;

#ifdef DD_DEBUG
    assert(low >= 0 && high < table->size);
#endif

    if (high-low < 1) return(0);

    res = (int) (table->keys - table->isolated);
    for (x = low; x < high; x++) {
	size = res;
	res = cuddSwapInPlace(table,x,x+1);
	if (res == 0) return(0);
	if (res >= size) { /* no improvement: undo permutation */
	    res = cuddSwapInPlace(table,x,x+1);
	    if (res == 0) return(0);
	}
#ifdef DD_STATS
	if (res < size) {
	    (void) fprintf(table->out,"-");
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
    }

    return(1);

} /* end of ddWindow2 */


/**
  @brief Reorders by repeatedly applying a sliding window of width 2.

  @details Tries both permutations of the variables in a window that
  slides from low to high.  Assumes that no dead nodes are present.
  Uses an event-driven approach to determine convergence.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddWindowConv2(
  DdManager * table,
  int  low,
  int  high)
{
    int x;
    int res;
    int nwin;
    int newevent;
    int *events;
    int size;

#ifdef DD_DEBUG
    assert(low >= 0 && high < table->size);
#endif

    if (high-low < 1) return(ddWindowConv2(table,low,high));

    nwin = high-low;
    events = ALLOC(int,nwin);
    if (events == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (x=0; x<nwin; x++) {
	events[x] = 1;
    }

    res = (int) (table->keys - table->isolated);
    do {
	newevent = 0;
	for (x=0; x<nwin; x++) {
	    if (events[x]) {
		size = res;
		res = cuddSwapInPlace(table,x+low,x+low+1);
		if (res == 0) {
		    FREE(events);
		    return(0);
		}
		if (res >= size) { /* no improvement: undo permutation */
		    res = cuddSwapInPlace(table,x+low,x+low+1);
		    if (res == 0) {
			FREE(events);
			return(0);
		    }
		}
		if (res < size) {
		    if (x < nwin-1)	events[x+1] = 1;
		    if (x > 0)		events[x-1] = 1;
		    newevent = 1;
		}
		events[x] = 0;
#ifdef DD_STATS
		if (res < size) {
		    (void) fprintf(table->out,"-");
		} else {
		    (void) fprintf(table->out,"=");
		}
		fflush(table->out);
#endif
	    }
	}
#ifdef DD_STATS
	if (newevent) {
	    (void) fprintf(table->out,"|");
	    fflush(table->out);
	}
#endif
    } while (newevent);

    FREE(events);

    return(1);

} /* end of ddWindowConv3 */


/**
  @brief Tries all the permutations of the three variables between
  x and x+2 and retains the best.

  @details Assumes that no dead nodes are present.

  @return the index of the best permutation (1-6) in case of success;
  0 otherwise.

  @sideeffect None

*/
static int
ddPermuteWindow3(
  DdManager * table,
  int  x)
{
    int y,z;
    int	size,sizeNew;
    int	best;

#ifdef DD_DEBUG
    assert(table->dead == 0);
    assert(x+2 < table->size);
#endif

    size = (int) (table->keys - table->isolated);
    y = x+1; z = y+1;

    /* The permutation pattern is:
    ** (x,y)(y,z)
    ** repeated three times to get all 3! = 6 permutations.
    */
#define ABC 1
    best = ABC;

#define	BAC 2
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = BAC;
	size = sizeNew;
    }
#define BCA 3
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = BCA;
	size = sizeNew;
    }
#define CBA 4
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = CBA;
	size = sizeNew;
    }
#define CAB 5
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = CAB;
	size = sizeNew;
    }
#define ACB 6
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = ACB;
	size = sizeNew;
    }

    /* Now take the shortest route to the best permuytation.
    ** The initial permutation is ACB.
    */
    switch(best) {
    case BCA: if (!cuddSwapInPlace(table,y,z)) return(0);
    case CBA: if (!cuddSwapInPlace(table,x,y)) return(0);
    case ABC: if (!cuddSwapInPlace(table,y,z)) return(0);
    case ACB: break;
    case BAC: if (!cuddSwapInPlace(table,y,z)) return(0);
    case CAB: if (!cuddSwapInPlace(table,x,y)) return(0);
	       break;
    default: return(0);
    }

#ifdef DD_DEBUG
    assert(table->keys - table->isolated == (unsigned) size);
#endif

    return(best);

} /* end of ddPermuteWindow3 */


/**
  @brief Reorders by applying a sliding window of width 3.

  @details Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddWindow3(
  DdManager * table,
  int  low,
  int  high)
{

    int x;
    int res;

#ifdef DD_DEBUG
    assert(low >= 0 && high < table->size);
#endif

    if (high-low < 2) return(ddWindow2(table,low,high));

    for (x = low; x+1 < high; x++) {
	res = ddPermuteWindow3(table,x);
	if (res == 0) return(0);
#ifdef DD_STATS
	if (res == ABC) {
	    (void) fprintf(table->out,"=");
	} else {
	    (void) fprintf(table->out,"-");
	}
	fflush(table->out);
#endif
    }

    return(1);

} /* end of ddWindow3 */


/**
  @brief Reorders by repeatedly applying a sliding window of width 3.

  @details Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddWindowConv3(
  DdManager * table,
  int  low,
  int  high)
{
    int x;
    int res;
    int nwin;
    int newevent;
    int *events;

#ifdef DD_DEBUG
    assert(low >= 0 && high < table->size);
#endif

    if (high-low < 2) return(ddWindowConv2(table,low,high));

    nwin = high-low-1;
    events = ALLOC(int,nwin);
    if (events == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (x=0; x<nwin; x++) {
	events[x] = 1;
    }

    do {
	newevent = 0;
	for (x=0; x<nwin; x++) {
	    if (events[x]) {
		res = ddPermuteWindow3(table,x+low);
		switch (res) {
		case ABC:
		    break;
		case BAC:
		    if (x < nwin-1)	events[x+1] = 1;
		    if (x > 1)		events[x-2] = 1;
		    newevent = 1;
		    break;
		case BCA:
		case CBA:
		case CAB:
		    if (x < nwin-2)	events[x+2] = 1;
		    if (x < nwin-1)	events[x+1] = 1;
		    if (x > 0)		events[x-1] = 1;
		    if (x > 1)		events[x-2] = 1;
		    newevent = 1;
		    break;
		case ACB:
		    if (x < nwin-2)	events[x+2] = 1;
		    if (x > 0)		events[x-1] = 1;
		    newevent = 1;
		    break;
		default:
		    FREE(events);
		    return(0);
		}
		events[x] = 0;
#ifdef DD_STATS
		if (res == ABC) {
		    (void) fprintf(table->out,"=");
		} else {
		    (void) fprintf(table->out,"-");
		}
		fflush(table->out);
#endif
	    }
	}
#ifdef DD_STATS
	if (newevent) {
	    (void) fprintf(table->out,"|");
	    fflush(table->out);
	}
#endif
    } while (newevent);

    FREE(events);

    return(1);

} /* end of ddWindowConv3 */


/**
  @brief Tries all the permutations of the four variables between w
  and w+3 and retains the best.

  @details Assumes that no dead nodes are present.

  @return the index of the best permutation (1-24) in case of success;
  0 otherwise.

  @sideeffect None

*/
static int
ddPermuteWindow4(
  DdManager * table,
  int  w)
{
    int x,y,z;
    int	size,sizeNew;
    int	best;

#ifdef DD_DEBUG
    assert(table->dead == 0);
    assert(w+3 < table->size);
#endif

    size = (int) (table->keys - table->isolated);
    x = w+1; y = x+1; z = y+1;

    /* The permutation pattern is:
     * (w,x)(y,z)(w,x)(x,y)
     * (y,z)(w,x)(y,z)(x,y)
     * repeated three times to get all 4! = 24 permutations.
     * This gives a hamiltonian circuit of Cayley's graph.
     * The codes to the permutation are assigned in topological order.
     * The permutations at lower distance from the final permutation are
     * assigned lower codes. This way we can choose, between
     * permutations that give the same size, one that requires the minimum
     * number of swaps from the final permutation of the hamiltonian circuit.
     * There is an exception to this rule: ABCD is given Code 1, to
     * avoid oscillation when convergence is sought.
     */
#define ABCD 1
    best = ABCD;

#define	BACD 7
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = BACD;
	size = sizeNew;
    }
#define BADC 13
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = BADC;
	size = sizeNew;
    }
#define ABDC 8
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size || (sizeNew == size && ABDC < best)) {
	if (sizeNew == 0) return(0);
	best = ABDC;
	size = sizeNew;
    }
#define ADBC 14
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = ADBC;
	size = sizeNew;
    }
#define ADCB 9
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size || (sizeNew == size && ADCB < best)) {
	if (sizeNew == 0) return(0);
	best = ADCB;
	size = sizeNew;
    }
#define DACB 15
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = DACB;
	size = sizeNew;
    }
#define DABC 20
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = DABC;
	size = sizeNew;
    }
#define DBAC 23
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = DBAC;
	size = sizeNew;
    }
#define BDAC 19
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size || (sizeNew == size && BDAC < best)) {
	if (sizeNew == 0) return(0);
	best = BDAC;
	size = sizeNew;
    }
#define BDCA 21
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size || (sizeNew == size && BDCA < best)) {
	if (sizeNew == 0) return(0);
	best = BDCA;
	size = sizeNew;
    }
#define DBCA 24
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size) {
	if (sizeNew == 0) return(0);
	best = DBCA;
	size = sizeNew;
    }
#define DCBA 22
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size || (sizeNew == size && DCBA < best)) {
	if (sizeNew == 0) return(0);
	best = DCBA;
	size = sizeNew;
    }
#define DCAB 18
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size || (sizeNew == size && DCAB < best)) {
	if (sizeNew == 0) return(0);
	best = DCAB;
	size = sizeNew;
    }
#define CDAB 12
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size || (sizeNew == size && CDAB < best)) {
	if (sizeNew == 0) return(0);
	best = CDAB;
	size = sizeNew;
    }
#define CDBA 17
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size || (sizeNew == size && CDBA < best)) {
	if (sizeNew == 0) return(0);
	best = CDBA;
	size = sizeNew;
    }
#define CBDA 11
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size || (sizeNew == size && CBDA < best)) {
	if (sizeNew == 0) return(0);
	best = CBDA;
	size = sizeNew;
    }
#define BCDA 16
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size || (sizeNew == size && BCDA < best)) {
	if (sizeNew == 0) return(0);
	best = BCDA;
	size = sizeNew;
    }
#define BCAD 10
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size || (sizeNew == size && BCAD < best)) {
	if (sizeNew == 0) return(0);
	best = BCAD;
	size = sizeNew;
    }
#define CBAD 5
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size || (sizeNew == size && CBAD < best)) {
	if (sizeNew == 0) return(0);
	best = CBAD;
	size = sizeNew;
    }
#define CABD 3
    sizeNew = cuddSwapInPlace(table,x,y);
    if (sizeNew < size || (sizeNew == size && CABD < best)) {
	if (sizeNew == 0) return(0);
	best = CABD;
	size = sizeNew;
    }
#define CADB 6
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size || (sizeNew == size && CADB < best)) {
	if (sizeNew == 0) return(0);
	best = CADB;
	size = sizeNew;
    }
#define ACDB 4
    sizeNew = cuddSwapInPlace(table,w,x);
    if (sizeNew < size || (sizeNew == size && ACDB < best)) {
	if (sizeNew == 0) return(0);
	best = ACDB;
	size = sizeNew;
    }
#define ACBD 2
    sizeNew = cuddSwapInPlace(table,y,z);
    if (sizeNew < size || (sizeNew == size && ACBD < best)) {
	if (sizeNew == 0) return(0);
	best = ACBD;
	size = sizeNew;
    }

    /* Now take the shortest route to the best permutation.
    ** The initial permutation is ACBD.
    */
    switch(best) {
    case DBCA: if (!cuddSwapInPlace(table,y,z)) return(0);
    case BDCA: if (!cuddSwapInPlace(table,x,y)) return(0);
    case CDBA: if (!cuddSwapInPlace(table,w,x)) return(0);
    case ADBC: if (!cuddSwapInPlace(table,y,z)) return(0);
    case ABDC: if (!cuddSwapInPlace(table,x,y)) return(0);
    case ACDB: if (!cuddSwapInPlace(table,y,z)) return(0);
    case ACBD: break;
    case DCBA: if (!cuddSwapInPlace(table,y,z)) return(0);
    case BCDA: if (!cuddSwapInPlace(table,x,y)) return(0);
    case CBDA: if (!cuddSwapInPlace(table,w,x)) return(0);
	       if (!cuddSwapInPlace(table,x,y)) return(0);
	       if (!cuddSwapInPlace(table,y,z)) return(0);
	       break;
    case DBAC: if (!cuddSwapInPlace(table,x,y)) return(0);
    case DCAB: if (!cuddSwapInPlace(table,w,x)) return(0);
    case DACB: if (!cuddSwapInPlace(table,y,z)) return(0);
    case BACD: if (!cuddSwapInPlace(table,x,y)) return(0);
    case CABD: if (!cuddSwapInPlace(table,w,x)) return(0);
	       break;
    case DABC: if (!cuddSwapInPlace(table,y,z)) return(0);
    case BADC: if (!cuddSwapInPlace(table,x,y)) return(0);
    case CADB: if (!cuddSwapInPlace(table,w,x)) return(0);
	       if (!cuddSwapInPlace(table,y,z)) return(0);
	       break;
    case BDAC: if (!cuddSwapInPlace(table,x,y)) return(0);
    case CDAB: if (!cuddSwapInPlace(table,w,x)) return(0);
    case ADCB: if (!cuddSwapInPlace(table,y,z)) return(0);
    case ABCD: if (!cuddSwapInPlace(table,x,y)) return(0);
	       break;
    case BCAD: if (!cuddSwapInPlace(table,x,y)) return(0);
    case CBAD: if (!cuddSwapInPlace(table,w,x)) return(0);
	       if (!cuddSwapInPlace(table,x,y)) return(0);
	       break;
    default: return(0);
    }

#ifdef DD_DEBUG
    assert(table->keys - table->isolated == (unsigned) size);
#endif

    return(best);

} /* end of ddPermuteWindow4 */


/**
  @brief Reorders by applying a sliding window of width 4.

  @details Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddWindow4(
  DdManager * table,
  int  low,
  int  high)
{

    int w;
    int res;

#ifdef DD_DEBUG
    assert(low >= 0 && high < table->size);
#endif

    if (high-low < 3) return(ddWindow3(table,low,high));

    for (w = low; w+2 < high; w++) {
	res = ddPermuteWindow4(table,w);
	if (res == 0) return(0);
#ifdef DD_STATS
	if (res == ABCD) {
	    (void) fprintf(table->out,"=");
	} else {
	    (void) fprintf(table->out,"-");
	}
	fflush(table->out);
#endif
    }

    return(1);

} /* end of ddWindow4 */


/**
  @brief Reorders by repeatedly applying a sliding window of width 4.

  @details Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
ddWindowConv4(
  DdManager * table,
  int  low,
  int  high)
{
    int x;
    int res;
    int nwin;
    int newevent;
    int *events;

#ifdef DD_DEBUG
    assert(low >= 0 && high < table->size);
#endif

    if (high-low < 3) return(ddWindowConv3(table,low,high));

    nwin = high-low-2;
    events = ALLOC(int,nwin);
    if (events == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (x=0; x<nwin; x++) {
	events[x] = 1;
    }

    do {
	newevent = 0;
	for (x=0; x<nwin; x++) {
	    if (events[x]) {
		res = ddPermuteWindow4(table,x+low);
		switch (res) {
		case ABCD:
		    break;
		case BACD:
		    if (x < nwin-1)	events[x+1] = 1;
		    if (x > 2)		events[x-3] = 1;
		    newevent = 1;
		    break;
		case BADC:
		    if (x < nwin-3)	events[x+3] = 1;
		    if (x < nwin-1)	events[x+1] = 1;
		    if (x > 0)		events[x-1] = 1;
		    if (x > 2)		events[x-3] = 1;
		    newevent = 1;
		    break;
		case ABDC:
		    if (x < nwin-3)	events[x+3] = 1;
		    if (x > 0)		events[x-1] = 1;
		    newevent = 1;
		    break;
		case ADBC:
		case ADCB:
		case ACDB:
		    if (x < nwin-3)	events[x+3] = 1;
		    if (x < nwin-2)	events[x+2] = 1;
		    if (x > 0)		events[x-1] = 1;
		    if (x > 1)		events[x-2] = 1;
		    newevent = 1;
		    break;
		case DACB:
		case DABC:
		case DBAC:
		case BDAC:
		case BDCA:
		case DBCA:
		case DCBA:
		case DCAB:
		case CDAB:
		case CDBA:
		case CBDA:
		case BCDA:
		case CADB:
		    if (x < nwin-3)	events[x+3] = 1;
		    if (x < nwin-2)	events[x+2] = 1;
		    if (x < nwin-1)	events[x+1] = 1;
		    if (x > 0)		events[x-1] = 1;
		    if (x > 1)		events[x-2] = 1;
		    if (x > 2)		events[x-3] = 1;
		    newevent = 1;
		    break;
		case BCAD:
		case CBAD:
		case CABD:
		    if (x < nwin-2)	events[x+2] = 1;
		    if (x < nwin-1)	events[x+1] = 1;
		    if (x > 1)		events[x-2] = 1;
		    if (x > 2)		events[x-3] = 1;
		    newevent = 1;
		    break;
		case ACBD:
		    if (x < nwin-2)	events[x+2] = 1;
		    if (x > 1)		events[x-2] = 1;
		    newevent = 1;
		    break;
		default:
		    FREE(events);
		    return(0);
		}
		events[x] = 0;
#ifdef DD_STATS
		if (res == ABCD) {
		    (void) fprintf(table->out,"=");
		} else {
		    (void) fprintf(table->out,"-");
		}
		fflush(table->out);
#endif
	    }
	}
#ifdef DD_STATS
	if (newevent) {
	    (void) fprintf(table->out,"|");
	    fflush(table->out);
	}
#endif
    } while (newevent);

    FREE(events);

    return(1);

} /* end of ddWindowConv4 */

cuddZddCount.c
8209
/**
  @file

  @ingroup cudd

  @brief Procedures to count the number of minterms of a %ZDD.

  @author Hyong-Kyoon Shin, In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int cuddZddCountStep (DdNode *P, st_table *table, DdNode *base, DdNode *empty);
static double cuddZddCountDoubleStep (DdNode *P, st_table *table, DdNode *base, DdNode *empty);
static enum st_retval st_zdd_countfree (void *key, void *value, void *arg);
static enum st_retval st_zdd_count_dbl_free (void *key, void *value, void *arg);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Counts the number of minterms in a %ZDD.

  @details Returns an integer representing the number of minterms
  in a %ZDD.

  @sideeffect None

  @see Cudd_zddCountDouble

*/
int
Cudd_zddCount(
  DdManager * zdd,
  DdNode * P)
{
    st_table	*table;
    int		res;
    DdNode	*base, *empty;

    base  = DD_ONE(zdd);
    empty = DD_ZERO(zdd);
    table = st_init_table(st_ptrcmp, st_ptrhash);
    if (table == NULL) return(CUDD_OUT_OF_MEM);
    res = cuddZddCountStep(P, table, base, empty);
    if (res == CUDD_OUT_OF_MEM) {
	zdd->errorCode = CUDD_MEMORY_OUT;
    }
    st_foreach(table, st_zdd_countfree, NIL(void));
    st_free_table(table);

    return(res);

} /* end of Cudd_zddCount */


/**
  @brief Counts the number of minterms of a %ZDD.

  @details This procedure is used in Cudd_zddCountMinterm.

  @result the count.  If the procedure runs out of memory, it returns
  (double) CUDD_OUT_OF_MEM.

  @sideeffect None

  @see Cudd_zddCountMinterm Cudd_zddCount

*/
double
Cudd_zddCountDouble(
  DdManager * zdd,
  DdNode * P)
{
    st_table	*table;
    double	res;
    DdNode	*base, *empty;

    base  = DD_ONE(zdd);
    empty = DD_ZERO(zdd);
    table = st_init_table(st_ptrcmp, st_ptrhash);
    if (table == NULL) return((double)CUDD_OUT_OF_MEM);
    res = cuddZddCountDoubleStep(P, table, base, empty);
    if (res == (double)CUDD_OUT_OF_MEM) {
	zdd->errorCode = CUDD_MEMORY_OUT;
    }
    st_foreach(table, st_zdd_count_dbl_free, NIL(void));
    st_free_table(table);

    return(res);

} /* end of Cudd_zddCountDouble */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_zddCount.

  @sideeffect None

*/
static int
cuddZddCountStep(
  DdNode * P,
  st_table * table,
  DdNode * base,
  DdNode * empty)
{
    int		res;
    int		*dummy;

    if (P == empty)
	return(0);
    if (P == base)
	return(1);

    /* Check cache. */
    if (st_lookup(table, P, (void **) &dummy)) {
	res = *dummy;
	return(res);
    }

    res = cuddZddCountStep(cuddE(P), table, base, empty) +
	cuddZddCountStep(cuddT(P), table, base, empty);

    dummy = ALLOC(int, 1);
    if (dummy == NULL) {
	return(CUDD_OUT_OF_MEM);
    }
    *dummy = res;
    if (st_insert(table, P, dummy) == ST_OUT_OF_MEM) {
	FREE(dummy);
	return(CUDD_OUT_OF_MEM);
    }

    return(res);

} /* end of cuddZddCountStep */


/**
  @brief Performs the recursive step of Cudd_zddCountDouble.

  @sideeffect None

*/
static double
cuddZddCountDoubleStep(
  DdNode * P,
  st_table * table,
  DdNode * base,
  DdNode * empty)
{
    double	res;
    double	*dummy;

    if (P == empty)
	return((double)0.0);
    if (P == base)
	return((double)1.0);

    /* Check cache */
    if (st_lookup(table, P, (void **) &dummy)) {
	res = *dummy;
	return(res);
    }

    res = cuddZddCountDoubleStep(cuddE(P), table, base, empty) +
	cuddZddCountDoubleStep(cuddT(P), table, base, empty);

    dummy = ALLOC(double, 1);
    if (dummy == NULL) {
	return((double)CUDD_OUT_OF_MEM);
    }
    *dummy = res;
    if (st_insert(table, P, dummy) == ST_OUT_OF_MEM) {
	FREE(dummy);
	return((double)CUDD_OUT_OF_MEM);
    }

    return(res);

} /* end of cuddZddCountDoubleStep */


/**
  @brief Frees the memory associated with the computed table of
  Cudd_zddCount.

  @sideeffect None

*/
static enum st_retval
st_zdd_countfree(
  void * key,
  void * value,
  void * arg)
{
    int	*d = (int *) value;

    (void) key; /* avoid warning */
    (void) arg; /* avoid warning */
    FREE(d);
    return(ST_CONTINUE);

} /* end of st_zdd_countfree */


/**
  @brief Frees the memory associated with the computed table of
  Cudd_zddCountDouble.

  @sideeffect None

*/
static enum st_retval
st_zdd_count_dbl_free(
  void * key,
  void * value,
  void * arg)
{
    double *d = (double *) value;

    (void) key; /* avoid warning */
    (void) arg; /* avoid warning */
    FREE(d);
    return(ST_CONTINUE);

} /* end of st_zdd_count_dbl_free */

cuddZddFuncs.c
36242
/**
  @file

  @ingroup cudd

  @brief Functions to manipulate covers represented as ZDDs.

  @author In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes the product of two covers represented by ZDDs.

  @details The result is also a %ZDD.  The covers on which
  Cudd_zddProduct operates use two %ZDD variables for each function
  variable (one %ZDD variable for each literal of the variable). Those
  two %ZDD variables should be adjacent in the order.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddUnateProduct

*/
DdNode	*
Cudd_zddProduct(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddZddProduct(dd, f, g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddProduct */


/**
  @brief Computes the product of two unate covers represented as ZDDs.

  @details Unate covers use one %ZDD variable for each %BDD
  variable.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddProduct

*/
DdNode	*
Cudd_zddUnateProduct(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddZddUnateProduct(dd, f, g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddUnateProduct */


/**
  @brief Applies weak division to two covers.

  @details Applies weak division to two ZDDs representing two covers.
  The result of weak division depends on the variable order. The
  covers on which Cudd_zddWeakDiv operates use two %ZDD variables for
  each function variable (one %ZDD variable for each literal of the
  variable). Those two %ZDD variables should be adjacent in the order.

  @return a pointer to the %ZDD representing the result if successful;
  NULL otherwise.

  @sideeffect None

  @see Cudd_zddDivide

*/
DdNode	*
Cudd_zddWeakDiv(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddZddWeakDiv(dd, f, g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddWeakDiv */


/**
  @brief Computes the quotient of two unate covers.

  @details Computes the quotient of two unate covers represented by
  ZDDs.  Unate covers use one %ZDD variable for each %BDD variable.

  @return a pointer to the resulting %ZDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_zddWeakDiv

*/
DdNode	*
Cudd_zddDivide(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddZddDivide(dd, f, g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddDivide */


/**
  @brief Modified version of Cudd_zddWeakDiv.

  @details This function may disappear in future releases.

  @sideeffect None

  @see Cudd_zddWeakDiv

*/
DdNode	*
Cudd_zddWeakDivF(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddZddWeakDivF(dd, f, g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddWeakDivF */


/**
  @brief Modified version of Cudd_zddDivide.

  @details This function may disappear in future releases.

  @sideeffect None

*/
DdNode	*
Cudd_zddDivideF(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddZddDivideF(dd, f, g);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddDivideF */


/**
  @brief Computes a complement cover for a %ZDD node.

  @details For lack of a better method, we first extract the function
  %BDD from the %ZDD cover, then make the complement of the %ZDD cover
  from the complement of the %BDD node by using ISOP.  The result
  depends on current variable order.

  @return a pointer to the resulting cover if successful; NULL
  otherwise.

  @sideeffect The result depends on current variable order.

*/
DdNode	*
Cudd_zddComplement(
  DdManager *dd,
  DdNode *node)
{
    DdNode	*b, *isop, *zdd_I;

    /* Check cache */
    zdd_I = cuddCacheLookup1Zdd(dd, cuddZddComplement, node);
    if (zdd_I)
	return(zdd_I);

    b = Cudd_MakeBddFromZddCover(dd, node);
    if (!b)
	return(NULL);
    Cudd_Ref(b);
    isop = Cudd_zddIsop(dd, Cudd_Not(b), Cudd_Not(b), &zdd_I);
    if (!isop) {
	Cudd_RecursiveDeref(dd, b);
	return(NULL);
    }
    Cudd_Ref(isop);
    Cudd_Ref(zdd_I);
    Cudd_RecursiveDeref(dd, b);
    Cudd_RecursiveDeref(dd, isop);

    cuddCacheInsert1(dd, cuddZddComplement, node, zdd_I);
    Cudd_Deref(zdd_I);
    return(zdd_I);
} /* end of Cudd_zddComplement */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_zddProduct.

  @sideeffect None

  @see Cudd_zddProduct

*/
DdNode	*
cuddZddProduct(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    int		v;
    int		top_f, top_g;
    DdNode	*tmp, *term1, *term2, *term3;
    DdNode	*f0, *f1, *fd, *g0, *g1, *gd;
    DdNode	*R0, *R1, *Rd, *N0, *N1;
    DdNode	*r;
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = DD_ZERO(dd);
    int		flag;
    int		pv, nv;

    statLine(dd);
    if (f == zero || g == zero)
        return(zero);
    if (f == one)
        return(g);
    if (g == one)
        return(f);

    top_f = dd->permZ[f->index];
    top_g = dd->permZ[g->index];

    if (top_f > top_g)
	return(cuddZddProduct(dd, g, f));

    /* Check cache */
    r = cuddCacheLookup2Zdd(dd, cuddZddProduct, f, g);
    if (r)
	return(r);

    v = (int) f->index;	/* either yi or zi */
    flag = cuddZddGetCofactors3(dd, f, v, &f1, &f0, &fd);
    if (flag == 1)
	return(NULL);
    Cudd_Ref(f1);
    Cudd_Ref(f0);
    Cudd_Ref(fd);
    flag = cuddZddGetCofactors3(dd, g, v, &g1, &g0, &gd);
    if (flag == 1) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	return(NULL);
    }
    Cudd_Ref(g1);
    Cudd_Ref(g0);
    Cudd_Ref(gd);
    pv = cuddZddGetPosVarIndex(dd, v);
    nv = cuddZddGetNegVarIndex(dd, v);

    Rd = cuddZddProduct(dd, fd, gd);
    if (Rd == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	Cudd_RecursiveDerefZdd(dd, gd);
	return(NULL);
    }
    Cudd_Ref(Rd);

    term1 = cuddZddProduct(dd, f0, g0);
    if (term1 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, Rd);
	return(NULL);
    }
    Cudd_Ref(term1);
    term2 = cuddZddProduct(dd, f0, gd);
    if (term2 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, Rd);
	Cudd_RecursiveDerefZdd(dd, term1);
	return(NULL);
    }
    Cudd_Ref(term2);
    term3 = cuddZddProduct(dd, fd, g0);
    if (term3 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, Rd);
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, term2);
	return(NULL);
    }
    Cudd_Ref(term3);
    Cudd_RecursiveDerefZdd(dd, f0);
    Cudd_RecursiveDerefZdd(dd, g0);
    tmp = cuddZddUnion(dd, term1, term2);
    if (tmp == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, Rd);
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, term2);
	Cudd_RecursiveDerefZdd(dd, term3);
	return(NULL);
    }
    Cudd_Ref(tmp);
    Cudd_RecursiveDerefZdd(dd, term1);
    Cudd_RecursiveDerefZdd(dd, term2);
    R0 = cuddZddUnion(dd, tmp, term3);
    if (R0 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, Rd);
	Cudd_RecursiveDerefZdd(dd, term3);
	Cudd_RecursiveDerefZdd(dd, tmp);
	return(NULL);
    }
    Cudd_Ref(R0);
    Cudd_RecursiveDerefZdd(dd, tmp);
    Cudd_RecursiveDerefZdd(dd, term3);
    N0 = cuddZddGetNode(dd, nv, R0, Rd); /* nv = zi */
    if (N0 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, Rd);
	Cudd_RecursiveDerefZdd(dd, R0);
	return(NULL);
    }
    Cudd_Ref(N0);
    Cudd_RecursiveDerefZdd(dd, R0);
    Cudd_RecursiveDerefZdd(dd, Rd);

    term1 = cuddZddProduct(dd, f1, g1);
    if (term1 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, N0);
	return(NULL);
    }
    Cudd_Ref(term1);
    term2 = cuddZddProduct(dd, f1, gd);
    if (term2 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, N0);
	Cudd_RecursiveDerefZdd(dd, term1);
	return(NULL);
    }
    Cudd_Ref(term2);
    term3 = cuddZddProduct(dd, fd, g1);
    if (term3 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, gd);
	Cudd_RecursiveDerefZdd(dd, N0);
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, term2);
	return(NULL);
    }
    Cudd_Ref(term3);
    Cudd_RecursiveDerefZdd(dd, f1);
    Cudd_RecursiveDerefZdd(dd, g1);
    Cudd_RecursiveDerefZdd(dd, fd);
    Cudd_RecursiveDerefZdd(dd, gd);
    tmp = cuddZddUnion(dd, term1, term2);
    if (tmp == NULL) {
	Cudd_RecursiveDerefZdd(dd, N0);
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, term2);
	Cudd_RecursiveDerefZdd(dd, term3);
	return(NULL);
    }
    Cudd_Ref(tmp);
    Cudd_RecursiveDerefZdd(dd, term1);
    Cudd_RecursiveDerefZdd(dd, term2);
    R1 = cuddZddUnion(dd, tmp, term3);
    if (R1 == NULL) {
	Cudd_RecursiveDerefZdd(dd, N0);
	Cudd_RecursiveDerefZdd(dd, term3);
	Cudd_RecursiveDerefZdd(dd, tmp);
	return(NULL);
    }
    Cudd_Ref(R1);
    Cudd_RecursiveDerefZdd(dd, tmp);
    Cudd_RecursiveDerefZdd(dd, term3);
    N1 = cuddZddGetNode(dd, pv, R1, N0); /* pv = yi */
    if (N1 == NULL) {
	Cudd_RecursiveDerefZdd(dd, N0);
	Cudd_RecursiveDerefZdd(dd, R1);
	return(NULL);
    }
    Cudd_Ref(N1);
    Cudd_RecursiveDerefZdd(dd, R1);
    Cudd_RecursiveDerefZdd(dd, N0);

    cuddCacheInsert2(dd, cuddZddProduct, f, g, N1);
    Cudd_Deref(N1);
    return(N1);

} /* end of cuddZddProduct */


/**
  @brief Performs the recursive step of Cudd_zddUnateProduct.

  @sideeffect None

  @see Cudd_zddUnateProduct

*/
DdNode	*
cuddZddUnateProduct(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    int		v;
    int		top_f, top_g;
    DdNode	*term1, *term2, *term3, *term4;
    DdNode	*sum1, *sum2;
    DdNode	*f0, *f1, *g0, *g1;
    DdNode	*r;
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = DD_ZERO(dd);
    int		flag;

    statLine(dd);
    if (f == zero || g == zero)
        return(zero);
    if (f == one)
        return(g);
    if (g == one)
        return(f);

    top_f = dd->permZ[f->index];
    top_g = dd->permZ[g->index];

    if (top_f > top_g)
	return(cuddZddUnateProduct(dd, g, f));

    /* Check cache */
    r = cuddCacheLookup2Zdd(dd, cuddZddUnateProduct, f, g);
    if (r)
	return(r);

    v = (int) f->index;	/* either yi or zi */
    flag = cuddZddGetCofactors2(dd, f, v, &f1, &f0);
    if (flag == 1)
	return(NULL);
    Cudd_Ref(f1);
    Cudd_Ref(f0);
    flag = cuddZddGetCofactors2(dd, g, v, &g1, &g0);
    if (flag == 1) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	return(NULL);
    }
    Cudd_Ref(g1);
    Cudd_Ref(g0);

    term1 = cuddZddUnateProduct(dd, f1, g1);
    if (term1 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	return(NULL);
    }
    Cudd_Ref(term1);
    term2 = cuddZddUnateProduct(dd, f1, g0);
    if (term2 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	Cudd_RecursiveDerefZdd(dd, term1);
	return(NULL);
    }
    Cudd_Ref(term2);
    term3 = cuddZddUnateProduct(dd, f0, g1);
    if (term3 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, term2);
	return(NULL);
    }
    Cudd_Ref(term3);
    term4 = cuddZddUnateProduct(dd, f0, g0);
    if (term4 == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, term2);
	Cudd_RecursiveDerefZdd(dd, term3);
	return(NULL);
    }
    Cudd_Ref(term4);
    Cudd_RecursiveDerefZdd(dd, f1);
    Cudd_RecursiveDerefZdd(dd, f0);
    Cudd_RecursiveDerefZdd(dd, g1);
    Cudd_RecursiveDerefZdd(dd, g0);
    sum1 = cuddZddUnion(dd, term1, term2);
    if (sum1 == NULL) {
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, term2);
	Cudd_RecursiveDerefZdd(dd, term3);
	Cudd_RecursiveDerefZdd(dd, term4);
	return(NULL);
    }
    Cudd_Ref(sum1);
    Cudd_RecursiveDerefZdd(dd, term1);
    Cudd_RecursiveDerefZdd(dd, term2);
    sum2 = cuddZddUnion(dd, sum1, term3);
    if (sum2 == NULL) {
	Cudd_RecursiveDerefZdd(dd, term3);
	Cudd_RecursiveDerefZdd(dd, term4);
	Cudd_RecursiveDerefZdd(dd, sum1);
	return(NULL);
    }
    Cudd_Ref(sum2);
    Cudd_RecursiveDerefZdd(dd, sum1);
    Cudd_RecursiveDerefZdd(dd, term3);
    r = cuddZddGetNode(dd, v, sum2, term4);
    if (r == NULL) {
	Cudd_RecursiveDerefZdd(dd, term4);
	Cudd_RecursiveDerefZdd(dd, sum2);
	return(NULL);
    }
    Cudd_Ref(r);
    Cudd_RecursiveDerefZdd(dd, sum2);
    Cudd_RecursiveDerefZdd(dd, term4);

    cuddCacheInsert2(dd, cuddZddUnateProduct, f, g, r);
    Cudd_Deref(r);
    return(r);

} /* end of cuddZddUnateProduct */


/**
  @brief Performs the recursive step of Cudd_zddWeakDiv.

  @sideeffect None

  @see Cudd_zddWeakDiv

*/
DdNode	*
cuddZddWeakDiv(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    int		v;
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = DD_ZERO(dd);
    DdNode	*f0, *f1, *fd, *g0, *g1, *gd;
    DdNode	*q, *tmp;
    DdNode	*r;
    int		flag;

    statLine(dd);
    if (g == one)
	return(f);
    if (f == zero || f == one)
	return(zero);
    if (f == g)
	return(one);

    /* Check cache. */
    r = cuddCacheLookup2Zdd(dd, cuddZddWeakDiv, f, g);
    if (r)
	return(r);

    v = (int) g->index;

    flag = cuddZddGetCofactors3(dd, f, v, &f1, &f0, &fd);
    if (flag == 1)
	return(NULL);
    Cudd_Ref(f1);
    Cudd_Ref(f0);
    Cudd_Ref(fd);
    flag = cuddZddGetCofactors3(dd, g, v, &g1, &g0, &gd);
    if (flag == 1) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	return(NULL);
    }
    Cudd_Ref(g1);
    Cudd_Ref(g0);
    Cudd_Ref(gd);

    q = g;

    if (g0 != zero) {
	q = cuddZddWeakDiv(dd, f0, g0);
	if (q == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, g0);
	    Cudd_RecursiveDerefZdd(dd, gd);
	    return(NULL);
	}
	Cudd_Ref(q);
    }
    else
	Cudd_Ref(q);
    Cudd_RecursiveDerefZdd(dd, f0);
    Cudd_RecursiveDerefZdd(dd, g0);

    if (q == zero) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
	cuddCacheInsert2(dd, cuddZddWeakDiv, f, g, zero);
	Cudd_Deref(q);
	return(zero);
    }

    if (g1 != zero) {
	Cudd_RecursiveDerefZdd(dd, q);
	tmp = cuddZddWeakDiv(dd, f1, g1);
	if (tmp == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, gd);
	    return(NULL);
	}
	Cudd_Ref(tmp);
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, g1);
	if (q == g)
	    q = tmp;
	else {
	    q = cuddZddIntersect(dd, q, tmp);
	    if (q == NULL) {
		Cudd_RecursiveDerefZdd(dd, fd);
		Cudd_RecursiveDerefZdd(dd, gd);
		return(NULL);
	    }
	    Cudd_Ref(q);
	    Cudd_RecursiveDerefZdd(dd, tmp);
	}
    }
    else {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, g1);
    }

    if (q == zero) {
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
	cuddCacheInsert2(dd, cuddZddWeakDiv, f, g, zero);
	Cudd_Deref(q);
	return(zero);
    }

    if (gd != zero) {
	Cudd_RecursiveDerefZdd(dd, q);
	tmp = cuddZddWeakDiv(dd, fd, gd);
	if (tmp == NULL) {
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, gd);
	    return(NULL);
	}
	Cudd_Ref(tmp);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
	if (q == g)
	    q = tmp;
	else {
	    q = cuddZddIntersect(dd, q, tmp);
	    if (q == NULL) {
		Cudd_RecursiveDerefZdd(dd, tmp);
		return(NULL);
	    }
	    Cudd_Ref(q);
	    Cudd_RecursiveDerefZdd(dd, tmp);
	}
    }
    else {
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
    }

    cuddCacheInsert2(dd, cuddZddWeakDiv, f, g, q);
    Cudd_Deref(q);
    return(q);

} /* end of cuddZddWeakDiv */


/**
  @brief Performs the recursive step of Cudd_zddWeakDivF.

  @sideeffect None

  @see Cudd_zddWeakDivF

*/
DdNode	*
cuddZddWeakDivF(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    int		v;
    int		top_f, top_g, vf, vg;
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = DD_ZERO(dd);
    DdNode	*f0, *f1, *fd, *g0, *g1, *gd;
    DdNode	*q, *tmp;
    DdNode	*r;
    DdNode	*term1, *term0, *termd;
    int		flag;
    int		pv, nv;

    statLine(dd);
    if (g == one)
	return(f);
    if (f == zero || f == one)
	return(zero);
    if (f == g)
	return(one);

    /* Check cache. */
    r = cuddCacheLookup2Zdd(dd, cuddZddWeakDivF, f, g);
    if (r)
	return(r);

    top_f = dd->permZ[f->index];
    top_g = dd->permZ[g->index];
    vf = top_f >> 1;
    vg = top_g >> 1;
    v = ddMin(top_f, top_g);

    if (v == top_f && vf < vg) {
	v = (int) f->index;
	flag = cuddZddGetCofactors3(dd, f, v, &f1, &f0, &fd);
	if (flag == 1)
	    return(NULL);
	Cudd_Ref(f1);
	Cudd_Ref(f0);
	Cudd_Ref(fd);

	pv = cuddZddGetPosVarIndex(dd, v);
	nv = cuddZddGetNegVarIndex(dd, v);

	term1 = cuddZddWeakDivF(dd, f1, g);
	if (term1 == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, fd);
	    return(NULL);
	}
	Cudd_Ref(term1);
	Cudd_RecursiveDerefZdd(dd, f1);
	term0 = cuddZddWeakDivF(dd, f0, g);
	if (term0 == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, term1);
	    return(NULL);
	}
	Cudd_Ref(term0);
	Cudd_RecursiveDerefZdd(dd, f0);
	termd = cuddZddWeakDivF(dd, fd, g);
	if (termd == NULL) {
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, term1);
	    Cudd_RecursiveDerefZdd(dd, term0);
	    return(NULL);
	}
	Cudd_Ref(termd);
	Cudd_RecursiveDerefZdd(dd, fd);

	tmp = cuddZddGetNode(dd, nv, term0, termd); /* nv = zi */
	if (tmp == NULL) {
	    Cudd_RecursiveDerefZdd(dd, term1);
	    Cudd_RecursiveDerefZdd(dd, term0);
	    Cudd_RecursiveDerefZdd(dd, termd);
	    return(NULL);
	}
	Cudd_Ref(tmp);
	Cudd_RecursiveDerefZdd(dd, term0);
	Cudd_RecursiveDerefZdd(dd, termd);
	q = cuddZddGetNode(dd, pv, term1, tmp); /* pv = yi */
	if (q == NULL) {
	    Cudd_RecursiveDerefZdd(dd, term1);
	    Cudd_RecursiveDerefZdd(dd, tmp);
	    return(NULL);
	}
	Cudd_Ref(q);
	Cudd_RecursiveDerefZdd(dd, term1);
	Cudd_RecursiveDerefZdd(dd, tmp);

	cuddCacheInsert2(dd, cuddZddWeakDivF, f, g, q);
	Cudd_Deref(q);
	return(q);
    }

    if (v == top_f)
	v = (int) f->index;
    else
	v = (int) g->index;

    flag = cuddZddGetCofactors3(dd, f, v, &f1, &f0, &fd);
    if (flag == 1)
	return(NULL);
    Cudd_Ref(f1);
    Cudd_Ref(f0);
    Cudd_Ref(fd);
    flag = cuddZddGetCofactors3(dd, g, v, &g1, &g0, &gd);
    if (flag == 1) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	return(NULL);
    }
    Cudd_Ref(g1);
    Cudd_Ref(g0);
    Cudd_Ref(gd);

    q = g;

    if (g0 != zero) {
	q = cuddZddWeakDivF(dd, f0, g0);
	if (q == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, g0);
	    Cudd_RecursiveDerefZdd(dd, gd);
	    return(NULL);
	}
	Cudd_Ref(q);
    }
    else
	Cudd_Ref(q);
    Cudd_RecursiveDerefZdd(dd, f0);
    Cudd_RecursiveDerefZdd(dd, g0);

    if (q == zero) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
	cuddCacheInsert2(dd, cuddZddWeakDivF, f, g, zero);
	Cudd_Deref(q);
	return(zero);
    }

    if (g1 != zero) {
	Cudd_RecursiveDerefZdd(dd, q);
	tmp = cuddZddWeakDivF(dd, f1, g1);
	if (tmp == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, gd);
	    return(NULL);
	}
	Cudd_Ref(tmp);
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, g1);
	if (q == g)
	    q = tmp;
	else {
	    q = cuddZddIntersect(dd, q, tmp);
	    if (q == NULL) {
		Cudd_RecursiveDerefZdd(dd, fd);
		Cudd_RecursiveDerefZdd(dd, gd);
		return(NULL);
	    }
	    Cudd_Ref(q);
	    Cudd_RecursiveDerefZdd(dd, tmp);
	}
    }
    else {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, g1);
    }

    if (q == zero) {
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
	cuddCacheInsert2(dd, cuddZddWeakDivF, f, g, zero);
	Cudd_Deref(q);
	return(zero);
    }

    if (gd != zero) {
	Cudd_RecursiveDerefZdd(dd, q);
	tmp = cuddZddWeakDivF(dd, fd, gd);
	if (tmp == NULL) {
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDerefZdd(dd, gd);
	    return(NULL);
	}
	Cudd_Ref(tmp);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
	if (q == g)
	    q = tmp;
	else {
	    q = cuddZddIntersect(dd, q, tmp);
	    if (q == NULL) {
		Cudd_RecursiveDerefZdd(dd, tmp);
		return(NULL);
	    }
	    Cudd_Ref(q);
	    Cudd_RecursiveDerefZdd(dd, tmp);
	}
    }
    else {
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDerefZdd(dd, gd);
    }

    cuddCacheInsert2(dd, cuddZddWeakDivF, f, g, q);
    Cudd_Deref(q);
    return(q);

} /* end of cuddZddWeakDivF */


/**
  @brief Performs the recursive step of Cudd_zddDivide.

  @sideeffect None

  @see Cudd_zddDivide

*/
DdNode	*
cuddZddDivide(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    int		v;
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = DD_ZERO(dd);
    DdNode	*f0, *f1, *g0, *g1;
    DdNode	*q, *r, *tmp;
    int		flag;

    statLine(dd);
    if (g == one)
	return(f);
    if (f == zero || f == one)
	return(zero);
    if (f == g)
	return(one);

    /* Check cache. */
    r = cuddCacheLookup2Zdd(dd, cuddZddDivide, f, g);
    if (r)
	return(r);

    v = (int) g->index;

    flag = cuddZddGetCofactors2(dd, f, v, &f1, &f0);
    if (flag == 1)
	return(NULL);
    Cudd_Ref(f1);
    Cudd_Ref(f0);
    flag = cuddZddGetCofactors2(dd, g, v, &g1, &g0);	/* g1 != zero */
    if (flag == 1) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	return(NULL);
    }
    Cudd_Ref(g1);
    Cudd_Ref(g0);

    r = cuddZddDivide(dd, f1, g1);
    if (r == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	return(NULL);
    }
    Cudd_Ref(r);

    if (r != zero && g0 != zero) {
	tmp = r;
	q = cuddZddDivide(dd, f0, g0);
	if (q == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, g0);
	    return(NULL);
	}
	Cudd_Ref(q);
	r = cuddZddIntersect(dd, r, q);
	if (r == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, g0);
	    Cudd_RecursiveDerefZdd(dd, q);
	    return(NULL);
	}
	Cudd_Ref(r);
	Cudd_RecursiveDerefZdd(dd, q);
	Cudd_RecursiveDerefZdd(dd, tmp);
    }

    Cudd_RecursiveDerefZdd(dd, f1);
    Cudd_RecursiveDerefZdd(dd, f0);
    Cudd_RecursiveDerefZdd(dd, g1);
    Cudd_RecursiveDerefZdd(dd, g0);
    
    cuddCacheInsert2(dd, cuddZddDivide, f, g, r);
    Cudd_Deref(r);
    return(r);

} /* end of cuddZddDivide */


/**
  @brief Performs the recursive step of Cudd_zddDivideF.

  @sideeffect None

  @see Cudd_zddDivideF

*/
DdNode	*
cuddZddDivideF(
  DdManager * dd,
  DdNode * f,
  DdNode * g)
{
    int		v;
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = DD_ZERO(dd);
    DdNode	*f0, *f1, *g0, *g1;
    DdNode	*q, *r, *tmp;
    int		flag;

    statLine(dd);
    if (g == one)
	return(f);
    if (f == zero || f == one)
	return(zero);
    if (f == g)
	return(one);

    /* Check cache. */
    r = cuddCacheLookup2Zdd(dd, cuddZddDivideF, f, g);
    if (r)
	return(r);

    v = (int) g->index;

    flag = cuddZddGetCofactors2(dd, f, v, &f1, &f0);
    if (flag == 1)
	return(NULL);
    Cudd_Ref(f1);
    Cudd_Ref(f0);
    flag = cuddZddGetCofactors2(dd, g, v, &g1, &g0);	/* g1 != zero */
    if (flag == 1) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	return(NULL);
    }
    Cudd_Ref(g1);
    Cudd_Ref(g0);

    r = cuddZddDivideF(dd, f1, g1);
    if (r == NULL) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, g1);
	Cudd_RecursiveDerefZdd(dd, g0);
	return(NULL);
    }
    Cudd_Ref(r);

    if (r != zero && g0 != zero) {
	tmp = r;
	q = cuddZddDivideF(dd, f0, g0);
	if (q == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, g0);
	    return(NULL);
	}
	Cudd_Ref(q);
	r = cuddZddIntersect(dd, r, q);
	if (r == NULL) {
	    Cudd_RecursiveDerefZdd(dd, f1);
	    Cudd_RecursiveDerefZdd(dd, f0);
	    Cudd_RecursiveDerefZdd(dd, g1);
	    Cudd_RecursiveDerefZdd(dd, g0);
	    Cudd_RecursiveDerefZdd(dd, q);
	    return(NULL);
	}
	Cudd_Ref(r);
	Cudd_RecursiveDerefZdd(dd, q);
	Cudd_RecursiveDerefZdd(dd, tmp);
    }

    Cudd_RecursiveDerefZdd(dd, f1);
    Cudd_RecursiveDerefZdd(dd, f0);
    Cudd_RecursiveDerefZdd(dd, g1);
    Cudd_RecursiveDerefZdd(dd, g0);
    
    cuddCacheInsert2(dd, cuddZddDivideF, f, g, r);
    Cudd_Deref(r);
    return(r);

} /* end of cuddZddDivideF */


/**
  @brief Computes the three-way decomposition of f w.r.t. v.

  @details Computes the three-way decomposition of function f
  (represented by a %ZDD) with respect to variable v.

  @return 0 if successful; 1 otherwise.

  @sideeffect The results are returned in f1, f0, and fd.

  @see cuddZddGetCofactors2

*/
int
cuddZddGetCofactors3(
  DdManager * dd,
  DdNode * f,
  int  v,
  DdNode ** f1,
  DdNode ** f0,
  DdNode ** fd)
{
    DdNode	*pc, *nc;
    DdNode	*zero = DD_ZERO(dd);
    int		top, hv, ht, pv, nv;
    int		level;

    top = dd->permZ[f->index];
    level = dd->permZ[v];
    hv = level >> 1;
    ht = top >> 1;

    if (hv < ht) {
	*f1 = zero;
	*f0 = zero;
	*fd = f;
    }
    else {
	pv = cuddZddGetPosVarIndex(dd, v);
	nv = cuddZddGetNegVarIndex(dd, v);

	/* not to create intermediate ZDD node */
	if (cuddZddGetPosVarLevel(dd, v) < cuddZddGetNegVarLevel(dd, v)) {
	    pc = cuddZddSubset1(dd, f, pv);
	    if (pc == NULL)
		return(1);
	    Cudd_Ref(pc);
	    nc = cuddZddSubset0(dd, f, pv);
	    if (nc == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		return(1);
	    }
	    Cudd_Ref(nc);

	    *f1 = cuddZddSubset0(dd, pc, nv);
	    if (*f1 == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		Cudd_RecursiveDerefZdd(dd, nc);
		return(1);
	    }
	    Cudd_Ref(*f1);
	    *f0 = cuddZddSubset1(dd, nc, nv);
	    if (*f0 == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		Cudd_RecursiveDerefZdd(dd, nc);
		Cudd_RecursiveDerefZdd(dd, *f1);
		return(1);
	    }
	    Cudd_Ref(*f0);

	    *fd = cuddZddSubset0(dd, nc, nv);
	    if (*fd == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		Cudd_RecursiveDerefZdd(dd, nc);
		Cudd_RecursiveDerefZdd(dd, *f1);
		Cudd_RecursiveDerefZdd(dd, *f0);
		return(1);
	    }
	    Cudd_Ref(*fd);
	} else {
	    pc = cuddZddSubset1(dd, f, nv);
	    if (pc == NULL)
		return(1);
	    Cudd_Ref(pc);
	    nc = cuddZddSubset0(dd, f, nv);
	    if (nc == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		return(1);
	    }
	    Cudd_Ref(nc);

	    *f0 = cuddZddSubset0(dd, pc, pv);
	    if (*f0 == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		Cudd_RecursiveDerefZdd(dd, nc);
		return(1);
	    }
	    Cudd_Ref(*f0);
	    *f1 = cuddZddSubset1(dd, nc, pv);
	    if (*f1 == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		Cudd_RecursiveDerefZdd(dd, nc);
		Cudd_RecursiveDerefZdd(dd, *f0);
		return(1);
	    }
	    Cudd_Ref(*f1);

	    *fd = cuddZddSubset0(dd, nc, pv);
	    if (*fd == NULL) {
		Cudd_RecursiveDerefZdd(dd, pc);
		Cudd_RecursiveDerefZdd(dd, nc);
		Cudd_RecursiveDerefZdd(dd, *f1);
		Cudd_RecursiveDerefZdd(dd, *f0);
		return(1);
	    }
	    Cudd_Ref(*fd);
	}

	Cudd_RecursiveDerefZdd(dd, pc);
	Cudd_RecursiveDerefZdd(dd, nc);
	Cudd_Deref(*f1);
	Cudd_Deref(*f0);
	Cudd_Deref(*fd);
    }
    return(0);

} /* end of cuddZddGetCofactors3 */


/**
  @brief Computes the two-way decomposition of f w.r.t. v.

  @sideeffect The results are returned in f1 and f0.

  @see cuddZddGetCofactors3

*/
int
cuddZddGetCofactors2(
  DdManager * dd,
  DdNode * f,
  int  v,
  DdNode ** f1,
  DdNode ** f0)
{
    *f1 = cuddZddSubset1(dd, f, v);
    if (*f1 == NULL)
	return(1);
    *f0 = cuddZddSubset0(dd, f, v);
    if (*f0 == NULL) {
	Cudd_RecursiveDerefZdd(dd, *f1);
	return(1);
    }
    return(0);

} /* end of cuddZddGetCofactors2 */


/**
  @brief Computes a complement of a %ZDD node.

  @details So far, since we couldn't find a direct way to get the
  complement of a %ZDD cover, we first convert a %ZDD cover to a %BDD,
  then make the complement of the %ZDD cover from the complement of the
  %BDD node by using ISOP.  The result depends on current variable order.

*/
DdNode	*
cuddZddComplement(
  DdManager * dd,
  DdNode *node)
{
    DdNode	*b, *isop, *zdd_I;

    /* Check cache */
    zdd_I = cuddCacheLookup1Zdd(dd, cuddZddComplement, node);
    if (zdd_I)
	return(zdd_I);

    b = cuddMakeBddFromZddCover(dd, node);
    if (!b)
	return(NULL);
    cuddRef(b);
    isop = cuddZddIsop(dd, Cudd_Not(b), Cudd_Not(b), &zdd_I);
    if (!isop) {
	Cudd_RecursiveDeref(dd, b);
	return(NULL);
    }
    cuddRef(isop);
    cuddRef(zdd_I);
    Cudd_RecursiveDeref(dd, b);
    Cudd_RecursiveDeref(dd, isop);

    cuddCacheInsert1(dd, cuddZddComplement, node, zdd_I);
    cuddDeref(zdd_I);
    return(zdd_I);
} /* end of cuddZddComplement */


/**
  @brief Returns the index of positive %ZDD variable.
*/
int
cuddZddGetPosVarIndex(
  DdManager * dd,
  int index)
{
    (void) dd; /* avoid warning */
    int	pv = index & ~0x1;
    return(pv);
} /* end of cuddZddGetPosVarIndex */


/**
  @brief Returns the index of negative %ZDD variable.
*/
int
cuddZddGetNegVarIndex(
  DdManager * dd,
  int index)
{
    (void) dd; /* avoid warning */
    int	nv = index | 0x1;
    return(nv);
} /* end of cuddZddGetPosVarIndex */


/**
  @brief Returns the level of positive %ZDD variable.
*/
int
cuddZddGetPosVarLevel(
  DdManager * dd,
  int index)
{
    int	pv = cuddZddGetPosVarIndex(dd, index);
    return(dd->permZ[pv]);
} /* end of cuddZddGetPosVarLevel */


/**
  @brief Returns the level of negative %ZDD variable.
*/
int
cuddZddGetNegVarLevel(
  DdManager * dd,
  int index)
{
    int	nv = cuddZddGetNegVarIndex(dd, index);
    return(dd->permZ[nv]);
} /* end of cuddZddGetNegVarLevel */

cuddZddGroup.c
35725
/**
  @file

  @ingroup cudd

  @brief Functions for %ZDD group sifting.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int zddTreeSiftingAux (DdManager *table, MtrNode *treenode, Cudd_ReorderingType method);
#ifdef DD_STATS
static int zddCountInternalMtrNodes (DdManager *table, MtrNode *treenode);
#endif
static int zddReorderChildren (DdManager *table, MtrNode *treenode, Cudd_ReorderingType method);
static void zddFindNodeHiLo (DdManager *table, MtrNode *treenode, int *lower, int *upper);
static int zddUniqueCompareGroup (void const *ptrX, void const *ptrY);
static int zddGroupSifting (DdManager *table, int lower, int upper);
static int zddGroupSiftingAux (DdManager *table, int x, int xLow, int xHigh);
static int zddGroupSiftingUp (DdManager *table, int y, int xLow, Move **moves);
static int zddGroupSiftingDown (DdManager *table, int x, int xHigh, Move **moves);
static int zddGroupMove (DdManager *table, int x, int y, Move **moves);
static int zddGroupMoveBackward (DdManager *table, int x, int y);
static int zddGroupSiftingBackward (DdManager *table, Move *moves, int size);
static void zddMergeGroups (DdManager *table, MtrNode *treenode, int low, int high);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Creates a new %ZDD variable group.

  @details The group starts at variable and contains size
  variables. The parameter low is the index of the first variable. If
  the variable already exists, its current position in the order is
  known to the manager. If the variable does not exist yet, the
  position is assumed to be the same as the index.  The group tree is
  created if it does not exist yet.

  @return a pointer to the group if successful; NULL otherwise.

  @sideeffect The %ZDD variable tree is changed.

  @see Cudd_MakeTreeNode

*/
MtrNode *
Cudd_MakeZddTreeNode(
  DdManager * dd /**< manager */,
  unsigned int  low /**< index of the first group variable */,
  unsigned int  size /**< number of variables in the group */,
  unsigned int  type /**< MTR_DEFAULT or MTR_FIXED */)
{
    MtrNode *group;
    MtrNode *tree;
    unsigned int level;

    /* If the variable does not exist yet, the position is assumed to be
    ** the same as the index. Therefore, applications that rely on
    ** Cudd_bddNewVarAtLevel or Cudd_addNewVarAtLevel to create new
    ** variables have to create the variables before they group them.
    */
    level = (low < (unsigned int) dd->sizeZ) ? (unsigned int) dd->permZ[low] : low;

    if (level + size - 1> (int) MTR_MAXHIGH)
	return(NULL);

    /* If the tree does not exist yet, create it. */
    tree = dd->treeZ;
    if (tree == NULL) {
	dd->treeZ = tree = Mtr_InitGroupTree(0, dd->sizeZ);
	if (tree == NULL)
	    return(NULL);
	tree->index = dd->invpermZ[0];
    }

    /* Extend the upper bound of the tree if necessary. This allows the
    ** application to create groups even before the variables are created.
    */
    tree->size = ddMax(tree->size, level + size);

    /* Create the group. */
    group = Mtr_MakeGroup(tree, level, size, type);
    if (group == NULL)
	return(NULL);

    /* Initialize the index field to the index of the variable currently
    ** in position low. This field will be updated by the reordering
    ** procedure to provide a handle to the group once it has been moved.
    */
    group->index = (MtrHalfWord) low;

    return(group);

} /* end of Cudd_MakeZddTreeNode */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Tree sifting algorithm for %ZDDs.

  @details Assumes that a tree representing a group hierarchy is
  passed as a parameter. It then reorders each group in postorder
  fashion by calling zddTreeSiftingAux.  Assumes that no dead nodes
  are present.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddZddTreeSifting(
  DdManager * table /**< %DD table */,
  Cudd_ReorderingType method /**< reordering method for the groups of leaves */)
{
    int i;
    int nvars;
    int result;
    int tempTree;

    /* If no tree is provided we create a temporary one in which all
    ** variables are in a single group. After reordering this tree is
    ** destroyed.
    */
    tempTree = table->treeZ == NULL;
    if (tempTree) {
	table->treeZ = Mtr_InitGroupTree(0,table->sizeZ);
	table->treeZ->index = table->invpermZ[0];
    }
    nvars = table->sizeZ;

#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0 && !tempTree)
	(void) fprintf(table->out,"cuddZddTreeSifting:");
    Mtr_PrintGroups(table->treeZ,table->enableExtraDebug <= 0);
#endif
#if 0
    /* Debugging code. */
    if (table->tree && table->treeZ) {
	(void) fprintf(table->out,"\n");
	Mtr_PrintGroups(table->tree, 0);
	cuddPrintVarGroups(table,table->tree,0,0);
	for (i = 0; i < table->size; i++) {
	    (void) fprintf(table->out,"%s%d",
			   (i == 0) ? "" : ",", table->invperm[i]);
	}
	(void) fprintf(table->out,"\n");
	for (i = 0; i < table->size; i++) {
	    (void) fprintf(table->out,"%s%d",
			   (i == 0) ? "" : ",", table->perm[i]);
	}
	(void) fprintf(table->out,"\n\n");
	Mtr_PrintGroups(table->treeZ,0);
	cuddPrintVarGroups(table,table->treeZ,1,0);
	for (i = 0; i < table->sizeZ; i++) {
	    (void) fprintf(table->out,"%s%d",
			   (i == 0) ? "" : ",", table->invpermZ[i]);
	}
	(void) fprintf(table->out,"\n");
	for (i = 0; i < table->sizeZ; i++) {
	    (void) fprintf(table->out,"%s%d",
			   (i == 0) ? "" : ",", table->permZ[i]);
	}
	(void) fprintf(table->out,"\n");
    }
    /* End of debugging code. */
#endif
#ifdef DD_STATS
    table->extsymmcalls = 0;
    table->extsymm = 0;
    table->secdiffcalls = 0;
    table->secdiff = 0;
    table->secdiffmisfire = 0;

    (void) fprintf(table->out,"\n");
    if (!tempTree)
	(void) fprintf(table->out,"#:IM_NODES  %8d: group tree nodes\n",
		       zddCountInternalMtrNodes(table,table->treeZ));
#endif

    /* Initialize the group of each subtable to itself. Initially
    ** there are no groups. Groups are created according to the tree
    ** structure in postorder fashion.
    */
    for (i = 0; i < nvars; i++)
	table->subtableZ[i].next = i;

    /* Reorder. */
    result = zddTreeSiftingAux(table, table->treeZ, method);

#ifdef DD_STATS		/* print stats */
    if (!tempTree && method == CUDD_REORDER_GROUP_SIFT &&
	(table->groupcheck == CUDD_GROUP_CHECK7 ||
	 table->groupcheck == CUDD_GROUP_CHECK5)) {
	(void) fprintf(table->out,"\nextsymmcalls = %d\n",table->extsymmcalls);
	(void) fprintf(table->out,"extsymm = %d",table->extsymm);
    }
    if (!tempTree && method == CUDD_REORDER_GROUP_SIFT &&
	table->groupcheck == CUDD_GROUP_CHECK7) {
	(void) fprintf(table->out,"\nsecdiffcalls = %d\n",table->secdiffcalls);
	(void) fprintf(table->out,"secdiff = %d\n",table->secdiff);
	(void) fprintf(table->out,"secdiffmisfire = %d",table->secdiffmisfire);
    }
#endif

    if (tempTree)
	Cudd_FreeZddTree(table);
    return(result);

} /* end of cuddZddTreeSifting */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Visits the group tree and reorders each group.

  @details Recursively visits the group tree and reorders each group
  in postorder fashion.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
zddTreeSiftingAux(
  DdManager * table,
  MtrNode * treenode,
  Cudd_ReorderingType method)
{
    MtrNode  *auxnode;
    int res;

#ifdef DD_DEBUG
    Mtr_PrintGroups(treenode,1);
#endif

    auxnode = treenode;
    while (auxnode != NULL) {
	if (auxnode->child != NULL) {
	    if (!zddTreeSiftingAux(table, auxnode->child, method))
		return(0);
	    res = zddReorderChildren(table, auxnode, CUDD_REORDER_GROUP_SIFT);
	    if (res == 0)
		return(0);
	} else if (auxnode->size > 1) {
	    if (!zddReorderChildren(table, auxnode, method))
		return(0);
	}
	auxnode = auxnode->younger;
    }

    return(1);

} /* end of zddTreeSiftingAux */


#ifdef DD_STATS
/**
  @brief Counts the number of internal nodes of the group tree.

  @return the count.

  @sideeffect None

*/
static int
zddCountInternalMtrNodes(
  DdManager * table,
  MtrNode * treenode)
{
    MtrNode *auxnode;
    int     count,nodeCount;


    nodeCount = 0;
    auxnode = treenode;
    while (auxnode != NULL) {
	if (!(MTR_TEST(auxnode,MTR_TERMINAL))) {
	    nodeCount++;
	    count = zddCountInternalMtrNodes(table,auxnode->child);
	    nodeCount += count;
	}
	auxnode = auxnode->younger;
    }

    return(nodeCount);

} /* end of zddCountInternalMtrNodes */
#endif


/**
  @brief Reorders the children of a group tree node according to
  the options.

  @details After reordering puts all the variables in the group and/or
  its descendents in a single group. This allows hierarchical
  reordering.  If the variables in the group do not exist yet, simply
  does nothing.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
zddReorderChildren(
  DdManager * table,
  MtrNode * treenode,
  Cudd_ReorderingType method)
{
    int lower;
    int upper = 0;
    int result;
    unsigned int initialSize;

    zddFindNodeHiLo(table,treenode,&lower,&upper);
    /* If upper == -1 these variables do not exist yet. */
    if (upper == -1)
	return(1);

    if (treenode->flags == MTR_FIXED) {
	result = 1;
    } else {
#ifdef DD_STATS
	(void) fprintf(table->out," ");
#endif
	switch (method) {
	case CUDD_REORDER_RANDOM:
	case CUDD_REORDER_RANDOM_PIVOT:
	    result = cuddZddSwapping(table,lower,upper,method);
	    break;
	case CUDD_REORDER_SIFT:
	    result = cuddZddSifting(table,lower,upper);
	    break;
	case CUDD_REORDER_SIFT_CONVERGE:
	    do {
		initialSize = table->keysZ;
		result = cuddZddSifting(table,lower,upper);
		if (initialSize <= table->keysZ)
		    break;
#ifdef DD_STATS
		else
		    (void) fprintf(table->out,"\n");
#endif
	    } while (result != 0);
	    break;
	case CUDD_REORDER_SYMM_SIFT:
	    result = cuddZddSymmSifting(table,lower,upper);
	    break;
	case CUDD_REORDER_SYMM_SIFT_CONV:
	    result = cuddZddSymmSiftingConv(table,lower,upper);
	    break;
	case CUDD_REORDER_GROUP_SIFT:
	    result = zddGroupSifting(table,lower,upper);
	    break;
        case CUDD_REORDER_GROUP_SIFT_CONV:
            do {
                initialSize = table->keysZ;
                result = zddGroupSifting(table,lower,upper);
                if (initialSize <= table->keysZ)
                    break;
            } while (result != 0);
            break;
	case CUDD_REORDER_LINEAR:
	    result = cuddZddLinearSifting(table,lower,upper);
	    break;
	case CUDD_REORDER_LINEAR_CONVERGE:
	    do {
		initialSize = table->keysZ;
		result = cuddZddLinearSifting(table,lower,upper);
		if (initialSize <= table->keysZ)
		    break;
#ifdef DD_STATS
		else
		    (void) fprintf(table->out,"\n");
#endif
	    } while (result != 0);
	    break;
	default:
	    return(0);
	}
    }

    /* Create a single group for all the variables that were sifted,
    ** so that they will be treated as a single block by successive
    ** invocations of zddGroupSifting.
    */
    zddMergeGroups(table,treenode,lower,upper);

#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,"zddReorderChildren:");
#endif

    return(result);

} /* end of zddReorderChildren */


/**
  @brief Finds the lower and upper bounds of the group represented
  by treenode.

  @details The high and low fields of treenode are indices.  From
  those we need to derive the current positions, and find maximum and
  minimum.

  @sideeffect The bounds are returned as side effects.

*/
static void
zddFindNodeHiLo(
  DdManager * table,
  MtrNode * treenode,
  int * lower,
  int * upper)
{
    int low;
    int high;

    /* Check whether no variables in this group already exist.
    ** If so, return immediately. The calling procedure will know from
    ** the values of upper that no reordering is needed.
    */
    if ((int) treenode->low >= table->sizeZ) {
	*lower = table->sizeZ;
	*upper = -1;
	return;
    }

    *lower = low = (unsigned int) table->permZ[treenode->index];
    high = (int) (low + treenode->size - 1);

    if (high >= table->sizeZ) {
	/* This is the case of a partially existing group. The aim is to
	** reorder as many variables as safely possible.  If the tree
	** node is terminal, we just reorder the subset of the group
	** that is currently in existence.  If the group has
	** subgroups, then we only reorder those subgroups that are
	** fully instantiated.  This way we avoid breaking up a group.
	*/
	MtrNode *auxnode = treenode->child;
	if (auxnode == NULL) {
	    *upper = (unsigned int) table->sizeZ - 1;
	} else {
	    /* Search the subgroup that strands the table->sizeZ line.
	    ** If the first group starts at 0 and goes past table->sizeZ
	    ** upper will get -1, thus correctly signaling that no reordering
	    ** should take place.
	    */
	    while (auxnode != NULL) {
		int thisLower = table->permZ[auxnode->low];
		int thisUpper = thisLower + auxnode->size - 1;
		if (thisUpper >= table->sizeZ && thisLower < table->sizeZ)
		    *upper = (unsigned int) thisLower - 1;
		auxnode = auxnode->younger;
	    }
	}
    } else {
	/* Normal case: All the variables of the group exist. */
	*upper = (unsigned int) high;
    }

#ifdef DD_DEBUG
    /* Make sure that all variables in group are contiguous. */
    assert(treenode->size >= (MtrHalfWord) (*upper - *lower + 1));
#endif

    return;

} /* end of zddFindNodeHiLo */


/**
  @brief Comparison function used by qsort.

  @details Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.

  @return the difference in number of keys between the two variables
  being compared.

  @sideeffect None

*/
static int
zddUniqueCompareGroup(
  void const * ptrX,
  void const * ptrY)
{
    IndexKey const * pX = (IndexKey const *) ptrX;
    IndexKey const * pY = (IndexKey const *) ptrY;
#if 0
    if (pY->keys == pX->keys) {
	return(pX->index - pY->index);
    }
#endif
    return(pY->keys - pX->keys);

} /* end of zddUniqueCompareGroup */


/**
  @brief Sifts from treenode->low to treenode->high.

  @details If croupcheck == CUDD_GROUP_CHECK7, it checks for group
  creation at the end of the initial sifting. If a group is created,
  it is then sifted again. After sifting one variable, the group that
  contains it is dissolved.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zddGroupSifting(
  DdManager * table,
  int  lower,
  int  upper)
{
    IndexKey	*var;
    int		i,j,x,xInit;
    int		nvars;
    int		classes;
    int		result;
    int		*sifted;
#ifdef DD_STATS
    unsigned	previousSize;
#endif
    int		xindex;

    nvars = table->sizeZ;

    /* Order variables to sift. */
    sifted = NULL;
    var = ALLOC(IndexKey,nvars);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto zddGroupSiftingOutOfMem;
    }
    sifted = ALLOC(int,nvars);
    if (sifted == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto zddGroupSiftingOutOfMem;
    }

    /* Here we consider only one representative for each group. */
    for (i = 0, classes = 0; i < nvars; i++) {
	sifted[i] = 0;
	x = table->permZ[i];
	if ((unsigned) x >= table->subtableZ[x].next) {
	    var[classes].index = i;
	    var[classes].keys = table->subtableZ[x].keys;
	    classes++;
	}
    }

    util_qsort(var,classes,sizeof(IndexKey),zddUniqueCompareGroup);

    /* Now sift. */
    for (i = 0; i < ddMin(table->siftMaxVar,classes); i++) {
	if (table->zddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime > table->timeLimit) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
	xindex = var[i].index;
	if (sifted[xindex] == 1) /* variable already sifted as part of group */
	    continue;
	x = table->permZ[xindex]; /* find current level of this variable */
	if (x < lower || x > upper)
	    continue;
#ifdef DD_STATS
	previousSize = table->keysZ;
#endif
#ifdef DD_DEBUG
	/* x is bottom of group */
	assert((unsigned) x >= table->subtableZ[x].next);
#endif
	result = zddGroupSiftingAux(table,x,lower,upper);
	if (!result) goto zddGroupSiftingOutOfMem;

#ifdef DD_STATS
	if (table->keysZ < previousSize) {
	    (void) fprintf(table->out,"-");
	} else if (table->keysZ > previousSize) {
	    (void) fprintf(table->out,"+");
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif

	/* Mark variables in the group just sifted. */
	x = table->permZ[xindex];
	if ((unsigned) x != table->subtableZ[x].next) {
	    xInit = x;
	    do {
		j = table->invpermZ[x];
		sifted[j] = 1;
		x = table->subtableZ[x].next;
	    } while (x != xInit);
	}

#ifdef DD_DEBUG
	if (table->enableExtraDebug > 0)
            (void) fprintf(table->out,"zddGroupSifting:");
#endif
    } /* for */

    FREE(sifted);
    FREE(var);

    return(1);

zddGroupSiftingOutOfMem:
    if (var != NULL)	FREE(var);
    if (sifted != NULL)	FREE(sifted);

    return(0);

} /* end of zddGroupSifting */


/**
  @brief Sifts one variable up and down until it has taken all
  positions. Checks for aggregation.

  @details There may be at most two sweeps, even if the group grows.
  Assumes that x is either an isolated variable, or it is the bottom
  of a group. All groups may not have been found. The variable being
  moved is returned to the best position seen during sifting.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zddGroupSiftingAux(
  DdManager * table,
  int  x,
  int  xLow,
  int  xHigh)
{
    Move *move;
    Move *moves;	/* list of moves */
    int  initialSize;
    int  result;


#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,
                       "zddGroupSiftingAux from %d to %d\n",xLow,xHigh);
    assert((unsigned) x >= table->subtableZ[x].next); /* x is bottom of group */
#endif

    initialSize = table->keysZ;
    moves = NULL;

    if (x == xLow) { /* Sift down */
#ifdef DD_DEBUG
	/* x must be a singleton */
	assert((unsigned) x == table->subtableZ[x].next);
#endif
	if (x == xHigh) return(1);	/* just one variable */

	if (!zddGroupSiftingDown(table,x,xHigh,&moves))
	    goto zddGroupSiftingAuxOutOfMem;
	/* at this point x == xHigh, unless early term */

	/* move backward and stop at best position */
	result = zddGroupSiftingBackward(table,moves,initialSize);
#ifdef DD_DEBUG
	assert(table->keysZ <= (unsigned) initialSize);
#endif
	if (!result) goto zddGroupSiftingAuxOutOfMem;

    } else if (cuddZddNextHigh(table,x) > xHigh) { /* Sift up */
#ifdef DD_DEBUG
	/* x is bottom of group */
	assert((unsigned) x >= table->subtableZ[x].next);
#endif
	/* Find top of x's group */
	x = table->subtableZ[x].next;

	if (!zddGroupSiftingUp(table,x,xLow,&moves))
	    goto zddGroupSiftingAuxOutOfMem;
	/* at this point x == xLow, unless early term */

	/* move backward and stop at best position */
	result = zddGroupSiftingBackward(table,moves,initialSize);
#ifdef DD_DEBUG
	assert(table->keysZ <= (unsigned) initialSize);
#endif
	if (!result) goto zddGroupSiftingAuxOutOfMem;

    } else if (x - xLow > xHigh - x) { /* must go down first: shorter */
	if (!zddGroupSiftingDown(table,x,xHigh,&moves))
	    goto zddGroupSiftingAuxOutOfMem;
	/* at this point x == xHigh, unless early term */

	/* Find top of group */
	if (moves) {
	    x = moves->y;
	}
	while ((unsigned) x < table->subtableZ[x].next)
	    x = table->subtableZ[x].next;
	x = table->subtableZ[x].next;
#ifdef DD_DEBUG
	/* x should be the top of a group */
	assert((unsigned) x <= table->subtableZ[x].next);
#endif

	if (!zddGroupSiftingUp(table,x,xLow,&moves))
	    goto zddGroupSiftingAuxOutOfMem;

	/* move backward and stop at best position */
	result = zddGroupSiftingBackward(table,moves,initialSize);
#ifdef DD_DEBUG
	assert(table->keysZ <= (unsigned) initialSize);
#endif
	if (!result) goto zddGroupSiftingAuxOutOfMem;

    } else { /* moving up first: shorter */
	/* Find top of x's group */
	x = table->subtableZ[x].next;

	if (!zddGroupSiftingUp(table,x,xLow,&moves))
	    goto zddGroupSiftingAuxOutOfMem;
	/* at this point x == xHigh, unless early term */

	if (moves) {
	    x = moves->x;
	}
	while ((unsigned) x < table->subtableZ[x].next)
	    x = table->subtableZ[x].next;
#ifdef DD_DEBUG
	/* x is bottom of a group */
	assert((unsigned) x >= table->subtableZ[x].next);
#endif

	if (!zddGroupSiftingDown(table,x,xHigh,&moves))
	    goto zddGroupSiftingAuxOutOfMem;

	/* move backward and stop at best position */
	result = zddGroupSiftingBackward(table,moves,initialSize);
#ifdef DD_DEBUG
	assert(table->keysZ <= (unsigned) initialSize);
#endif
	if (!result) goto zddGroupSiftingAuxOutOfMem;
    }

    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }

    return(1);

zddGroupSiftingAuxOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }

    return(0);

} /* end of zddGroupSiftingAux */


/**
  @brief Sifts up a variable until either it reaches position xLow
  or the size of the %DD heap increases too much.

  @details Assumes that y is the top of a group (or a singleton).
  Checks y for aggregation to the adjacent variables. Records all the
  moves that are appended to the list of moves received as input and
  returned as a side effect.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zddGroupSiftingUp(
  DdManager * table,
  int  y,
  int  xLow,
  Move ** moves)
{
    Move *move;
    int  x;
    int  size;
    int  gxtop;
    int  limitSize;

    limitSize = table->keysZ;

    x = cuddZddNextLow(table,y);
    while (x >= xLow) {
	gxtop = table->subtableZ[x].next;
	if (table->subtableZ[x].next == (unsigned) x &&
	    table->subtableZ[y].next == (unsigned) y) {
	    /* x and y are self groups */
	    size = cuddZddSwapInPlace(table,x,y);
#ifdef DD_DEBUG
	    assert(table->subtableZ[x].next == (unsigned) x);
	    assert(table->subtableZ[y].next == (unsigned) y);
#endif
	    if (size == 0) goto zddGroupSiftingUpOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL) goto zddGroupSiftingUpOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->flags = MTR_DEFAULT;
	    move->size = size;
	    move->next = *moves;
	    *moves = move;

#ifdef DD_DEBUG
	    if (table->enableExtraDebug > 0)
                (void) fprintf(table->out,
                               "zddGroupSiftingUp (2 single groups):\n");
#endif
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;
	} else { /* group move */
	    size = zddGroupMove(table,x,y,moves);
	    if (size == 0) goto zddGroupSiftingUpOutOfMem;
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;
	}
	y = gxtop;
	x = cuddZddNextLow(table,y);
    }

    return(1);

zddGroupSiftingUpOutOfMem:
    while (*moves != NULL) {
	move = (*moves)->next;
	cuddDeallocMove(table, *moves);
	*moves = move;
    }
    return(0);

} /* end of zddGroupSiftingUp */


/**
  @brief Sifts down a variable until it reaches position xHigh.

  @details Assumes that x is the bottom of a group (or a singleton).
  Records all the moves.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zddGroupSiftingDown(
  DdManager * table,
  int  x,
  int  xHigh,
  Move ** moves)
{
    Move *move;
    int  y;
    int  size;
    int  limitSize;
    int  gybot;


    /* Initialize R */
    limitSize = size = table->keysZ;
    y = cuddZddNextHigh(table,x);
    while (y <= xHigh) {
	/* Find bottom of y group. */
	gybot = table->subtableZ[y].next;
	while (table->subtableZ[gybot].next != (unsigned) y)
	    gybot = table->subtableZ[gybot].next;

	if (table->subtableZ[x].next == (unsigned) x &&
	    table->subtableZ[y].next == (unsigned) y) {
	    /* x and y are self groups */
	    size = cuddZddSwapInPlace(table,x,y);
#ifdef DD_DEBUG
	    assert(table->subtableZ[x].next == (unsigned) x);
	    assert(table->subtableZ[y].next == (unsigned) y);
#endif
	    if (size == 0) goto zddGroupSiftingDownOutOfMem;

	    /* Record move. */
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL) goto zddGroupSiftingDownOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->flags = MTR_DEFAULT;
	    move->size = size;
	    move->next = *moves;
	    *moves = move;

#ifdef DD_DEBUG
	    if (table->enableExtraDebug > 0)
                (void) fprintf(table->out,
                               "zddGroupSiftingDown (2 single groups):\n");
#endif
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;
	} else { /* Group move */
	    size = zddGroupMove(table,x,y,moves);
	    if (size == 0) goto zddGroupSiftingDownOutOfMem;
	    if ((double) size > (double) limitSize * table->maxGrowth)
		return(1);
	    if (size < limitSize) limitSize = size;
	}
	x = gybot;
	y = cuddZddNextHigh(table,x);
    }

    return(1);

zddGroupSiftingDownOutOfMem:
    while (*moves != NULL) {
	move = (*moves)->next;
	cuddDeallocMove(table, *moves);
	*moves = move;
    }

    return(0);

} /* end of zddGroupSiftingDown */


/**
  @brief Swaps two groups and records the move.

  @return the number of keys in the %DD table in case of success; 0
  otherwise.

  @sideeffect None

*/
static int
zddGroupMove(
  DdManager * table,
  int  x,
  int  y,
  Move ** moves)
{
    Move *move;
    int  size;
    int  i,j,xtop,xbot,xsize,ytop,ybot,ysize,newxtop;
    int  swapx = 0, swapy = 0;
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    int  initialSize,bestSize;
#endif

#ifdef DD_DEBUG
    /* We assume that x < y */
    assert(x < y);
#endif
    /* Find top, bottom, and size for the two groups. */
    xbot = x;
    xtop = table->subtableZ[x].next;
    xsize = xbot - xtop + 1;
    ybot = y;
    while ((unsigned) ybot < table->subtableZ[ybot].next)
	ybot = table->subtableZ[ybot].next;
    ytop = y;
    ysize = ybot - ytop + 1;

#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    initialSize = bestSize = table->keysZ;
#endif
    /* Sift the variables of the second group up through the first group */
    for (i = 1; i <= ysize; i++) {
	for (j = 1; j <= xsize; j++) {
	    size = cuddZddSwapInPlace(table,x,y);
	    if (size == 0) goto zddGroupMoveOutOfMem;
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
	    if (size < bestSize)
		bestSize = size;
#endif
	    swapx = x; swapy = y;
	    y = x;
	    x = cuddZddNextLow(table,y);
	}
	y = ytop + i;
	x = cuddZddNextLow(table,y);
    }
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    if ((bestSize < initialSize) && (bestSize < size))
	(void) fprintf(table->out,"Missed local minimum: initialSize:%d  bestSize:%d  finalSize:%d\n",initialSize,bestSize,size);
#endif

    /* fix groups */
    y = xtop; /* ytop is now where xtop used to be */
    for (i = 0; i < ysize - 1; i++) {
	table->subtableZ[y].next = cuddZddNextHigh(table,y);
	y = cuddZddNextHigh(table,y);
    }
    table->subtableZ[y].next = xtop; /* y is bottom of its group, join */
				    /* it to top of its group */
    x = cuddZddNextHigh(table,y);
    newxtop = x;
    for (i = 0; i < xsize - 1; i++) {
	table->subtableZ[x].next = cuddZddNextHigh(table,x);
	x = cuddZddNextHigh(table,x);
    }
    table->subtableZ[x].next = newxtop; /* x is bottom of its group, join */
				    /* it to top of its group */
#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,"zddGroupMove:\n");
#endif

    /* Store group move */
    move = (Move *) cuddDynamicAllocNode(table);
    if (move == NULL) goto zddGroupMoveOutOfMem;
    move->x = swapx;
    move->y = swapy;
    move->flags = MTR_DEFAULT;
    move->size = table->keysZ;
    move->next = *moves;
    *moves = move;

    return(table->keysZ);

zddGroupMoveOutOfMem:
    while (*moves != NULL) {
	move = (*moves)->next;
	cuddDeallocMove(table, *moves);
	*moves = move;
    }
    return(0);

} /* end of zddGroupMove */


/**
  @brief Undoes the swap two groups.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zddGroupMoveBackward(
  DdManager * table,
  int  x,
  int  y)
{
    int size;
    int i,j,xtop,xbot,xsize,ytop,ybot,ysize,newxtop;


#ifdef DD_DEBUG
    /* We assume that x < y */
    assert(x < y);
#endif

    /* Find top, bottom, and size for the two groups. */
    xbot = x;
    xtop = table->subtableZ[x].next;
    xsize = xbot - xtop + 1;
    ybot = y;
    while ((unsigned) ybot < table->subtableZ[ybot].next)
	ybot = table->subtableZ[ybot].next;
    ytop = y;
    ysize = ybot - ytop + 1;

    /* Sift the variables of the second group up through the first group */
    for (i = 1; i <= ysize; i++) {
	for (j = 1; j <= xsize; j++) {
	    size = cuddZddSwapInPlace(table,x,y);
	    if (size == 0)
		return(0);
	    y = x;
	    x = cuddZddNextLow(table,y);
	}
	y = ytop + i;
	x = cuddZddNextLow(table,y);
    }

    /* fix groups */
    y = xtop;
    for (i = 0; i < ysize - 1; i++) {
	table->subtableZ[y].next = cuddZddNextHigh(table,y);
	y = cuddZddNextHigh(table,y);
    }
    table->subtableZ[y].next = xtop; /* y is bottom of its group, join */
				    /* to its top */
    x = cuddZddNextHigh(table,y);
    newxtop = x;
    for (i = 0; i < xsize - 1; i++) {
	table->subtableZ[x].next = cuddZddNextHigh(table,x);
	x = cuddZddNextHigh(table,x);
    }
    table->subtableZ[x].next = newxtop; /* x is bottom of its group, join */
				    /* to its top */
#ifdef DD_DEBUG
    if (table->enableExtraDebug > 0)
        (void) fprintf(table->out,"zddGroupMoveBackward:\n");
#endif

    return(1);

} /* end of zddGroupMoveBackward */


/**
  @brief Determines the best position for a variables and returns
  it there.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zddGroupSiftingBackward(
  DdManager * table,
  Move * moves,
  int  size)
{
    Move *move;
    int  res;


    for (move = moves; move != NULL; move = move->next) {
	if (move->size < size) {
	    size = move->size;
	}
    }

    for (move = moves; move != NULL; move = move->next) {
	if (move->size == size) return(1);
	if ((table->subtableZ[move->x].next == move->x) &&
	(table->subtableZ[move->y].next == move->y)) {
	    res = cuddZddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!res) return(0);
#ifdef DD_DEBUG
	    if (table->enableExtraDebug > 0)
                (void) fprintf(table->out,"zddGroupSiftingBackward:\n");
	    assert(table->subtableZ[move->x].next == move->x);
	    assert(table->subtableZ[move->y].next == move->y);
#endif
	} else { /* Group move necessary */
	    res = zddGroupMoveBackward(table,(int)move->x,(int)move->y);
	    if (!res) return(0);
	}
    }

    return(1);

} /* end of zddGroupSiftingBackward */


/**
  @brief Merges groups in the %DD table.

  @details Creates a single group from low to high and adjusts the
  idex field of the tree node.

  @sideeffect None

*/
static void
zddMergeGroups(
  DdManager * table,
  MtrNode * treenode,
  int  low,
  int  high)
{
    int i;
    MtrNode *auxnode;
    int saveindex;
    int newindex;

    /* Merge all variables from low to high in one group, unless
    ** this is the topmost group. In such a case we do not merge lest
    ** we lose the symmetry information. */
    if (treenode != table->treeZ) {
	for (i = low; i < high; i++)
	    table->subtableZ[i].next = i+1;
	table->subtableZ[high].next = low;
    }

    /* Adjust the index fields of the tree nodes. If a node is the
    ** first child of its parent, then the parent may also need adjustment. */
    saveindex = treenode->index;
    newindex = table->invpermZ[low];
    auxnode = treenode;
    do {
	auxnode->index = newindex;
	if (auxnode->parent == NULL ||
		(int) auxnode->parent->index != saveindex)
	    break;
	auxnode = auxnode->parent;
    } while (1);
    return;

} /* end of zddMergeGroups */

cuddZddIsop.c
23996
/**
  @file

  @ingroup cudd

  @brief Functions to find irredundant SOP covers as ZDDs from BDDs.

  @author In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Computes an ISOP in %ZDD form from BDDs.

  @details Computes an irredundant sum of products (ISOP) in %ZDD
  form from BDDs. The two BDDs L and U represent the lower bound and
  the upper bound, respectively, of the function. The ISOP uses two
  %ZDD variables for each %BDD variable: One for the positive literal,
  and one for the negative literal. These two variables should be
  adjacent in the %ZDD order. The two %ZDD variables corresponding to
  %BDD variable <code>i</code> should have indices <code>2i</code> and
  <code>2i+1</code>.  The result of this procedure depends on the
  variable order. If successful, Cudd_zddIsop returns the %BDD for
  the function chosen from the interval. The %ZDD representing the
  irredundant cover is returned as a side effect in zdd_I. In case of
  failure, NULL is returned.

  @return the %BDD for the chosen function if successful; NULL otherwise.

  @sideeffect zdd_I holds the pointer to the %ZDD for the ISOP on
  successful return.

  @see Cudd_bddIsop Cudd_zddVarsFromBddVars

*/
DdNode	*
Cudd_zddIsop(
  DdManager * dd,
  DdNode * L,
  DdNode * U,
  DdNode ** zdd_I)
{
    DdNode	*res;
    int		autoDynZ;

    autoDynZ = dd->autoDynZ;
    dd->autoDynZ = 0;

    do {
	dd->reordered = 0;
	res = cuddZddIsop(dd, L, U, zdd_I);
    } while (dd->reordered == 1);
    dd->autoDynZ = autoDynZ;
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddIsop */


/**
  @brief Computes a %BDD in the interval between L and U with a
  simple sum-of-product cover.

  @details This procedure is similar to Cudd_zddIsop, but it does not
  return the %ZDD for the cover.

  @return a pointer to the %BDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddIsop

*/
DdNode	*
Cudd_bddIsop(
  DdManager * dd,
  DdNode * L,
  DdNode * U)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddBddIsop(dd, L, U);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_bddIsop */


/**
  @brief Converts a %ZDD cover to a %BDD.

  @details Converts a %ZDD cover to a %BDD for the function represented
  by the cover.

  @return a %BDD node if successful; otherwise it returns NULL.

  @see Cudd_zddIsop

*/
DdNode	*
Cudd_MakeBddFromZddCover(
  DdManager * dd,
  DdNode * node)
{
    DdNode	*res;

    do {
	dd->reordered = 0;
	res = cuddMakeBddFromZddCover(dd, node);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_MakeBddFromZddCover */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_zddIsop.

  @sideeffect None

  @see Cudd_zddIsop

*/
DdNode	*
cuddZddIsop(
  DdManager * dd,
  DdNode * L,
  DdNode * U,
  DdNode ** zdd_I)
{
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = Cudd_Not(one);
    DdNode	*zdd_one = DD_ONE(dd);
    DdNode	*zdd_zero = DD_ZERO(dd);
    int		v, top_l, top_u;
    DdNode	*Lsub0, *Usub0, *Lsub1, *Usub1, *Ld, *Ud;
    DdNode	*Lsuper0, *Usuper0, *Lsuper1, *Usuper1;
    DdNode	*Isub0, *Isub1, *Id;
    DdNode	*zdd_Isub0, *zdd_Isub1, *zdd_Id;
    DdNode	*x;
    DdNode	*term0, *term1, *sum;
    DdNode	*Lv, *Uv, *Lnv, *Unv;
    DdNode	*r, *y, *z;
    unsigned	index;
    DD_CTFP	cacheOp;

    statLine(dd);
    if (L == zero) {
	*zdd_I = zdd_zero;
	return(zero);
    }
    if (U == one) {
	*zdd_I = zdd_one;
	return(one);
    }

    if (U == zero || L == one) {
	printf("*** ERROR : illegal condition for ISOP (U < L).\n");
	exit(1);
    }

    /* Check the cache. We store two results for each recursive call.
    ** One is the BDD, and the other is the ZDD. Both are needed.
    ** Hence we need a double hit in the cache to terminate the
    ** recursion. Clearly, collisions may evict only one of the two
    ** results. */
    cacheOp = (DD_CTFP) cuddZddIsop;
    r = cuddCacheLookup2(dd, cuddBddIsop, L, U);
    if (r) {
	*zdd_I = cuddCacheLookup2Zdd(dd, cacheOp, L, U);
	if (*zdd_I)
	    return(r);
	else {
	    /* The BDD result may have been dead. In that case
	    ** cuddCacheLookup2 would have called cuddReclaim,
	    ** whose effects we now have to undo. */
	    cuddRef(r);
	    Cudd_RecursiveDeref(dd, r);
	}
    }

    top_l = dd->perm[Cudd_Regular(L)->index];
    top_u = dd->perm[Cudd_Regular(U)->index];
    v = ddMin(top_l, top_u);

    /* Compute cofactors. */
    if (top_l == v) {
	index = Cudd_Regular(L)->index;
	Lv = Cudd_T(L);
	Lnv = Cudd_E(L);
	if (Cudd_IsComplement(L)) {
	    Lv = Cudd_Not(Lv);
	    Lnv = Cudd_Not(Lnv);
	}
    }
    else {
	index = Cudd_Regular(U)->index;
	Lv = Lnv = L;
    }

    if (top_u == v) {
	Uv = Cudd_T(U);
	Unv = Cudd_E(U);
	if (Cudd_IsComplement(U)) {
	    Uv = Cudd_Not(Uv);
	    Unv = Cudd_Not(Unv);
	}
    }
    else {
	Uv = Unv = U;
    }

    Lsub0 = cuddBddAndRecur(dd, Lnv, Cudd_Not(Uv));
    if (Lsub0 == NULL)
	return(NULL);
    Cudd_Ref(Lsub0);
    Usub0 = Unv;
    Lsub1 = cuddBddAndRecur(dd, Lv, Cudd_Not(Unv));
    if (Lsub1 == NULL) {
	Cudd_RecursiveDeref(dd, Lsub0);
	return(NULL);
    }
    Cudd_Ref(Lsub1);
    Usub1 = Uv;

    Isub0 = cuddZddIsop(dd, Lsub0, Usub0, &zdd_Isub0);
    if (Isub0 == NULL) {
	Cudd_RecursiveDeref(dd, Lsub0);
	Cudd_RecursiveDeref(dd, Lsub1);
	return(NULL);
    }
    /*
    if ((!cuddIsConstant(Cudd_Regular(Isub0))) &&
	(Cudd_Regular(Isub0)->index != zdd_Isub0->index / 2 ||
	dd->permZ[index * 2] > dd->permZ[zdd_Isub0->index])) {
	printf("*** ERROR : illegal permutation in ZDD. ***\n");
    }
    */
    Cudd_Ref(Isub0);
    Cudd_Ref(zdd_Isub0);
    Isub1 = cuddZddIsop(dd, Lsub1, Usub1, &zdd_Isub1);
    if (Isub1 == NULL) {
	Cudd_RecursiveDeref(dd, Lsub0);
	Cudd_RecursiveDeref(dd, Lsub1);
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	return(NULL);
    }
    /*
    if ((!cuddIsConstant(Cudd_Regular(Isub1))) &&
	(Cudd_Regular(Isub1)->index != zdd_Isub1->index / 2 ||
	dd->permZ[index * 2] > dd->permZ[zdd_Isub1->index])) {
	printf("*** ERROR : illegal permutation in ZDD. ***\n");
    }
    */
    Cudd_Ref(Isub1);
    Cudd_Ref(zdd_Isub1);
    Cudd_RecursiveDeref(dd, Lsub0);
    Cudd_RecursiveDeref(dd, Lsub1);

    Lsuper0 = cuddBddAndRecur(dd, Lnv, Cudd_Not(Isub0));
    if (Lsuper0 == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	return(NULL);
    }
    Cudd_Ref(Lsuper0);
    Lsuper1 = cuddBddAndRecur(dd, Lv, Cudd_Not(Isub1));
    if (Lsuper1 == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Lsuper0);
	return(NULL);
    }
    Cudd_Ref(Lsuper1);
    Usuper0 = Unv;
    Usuper1 = Uv;

    /* Ld = Lsuper0 + Lsuper1 */
    Ld = cuddBddAndRecur(dd, Cudd_Not(Lsuper0), Cudd_Not(Lsuper1));
    if (Ld == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Lsuper0);
	Cudd_RecursiveDeref(dd, Lsuper1);
	return(NULL);
    }
    Ld = Cudd_Not(Ld);
    Cudd_Ref(Ld);
    /* Ud = Usuper0 * Usuper1 */
    Ud = cuddBddAndRecur(dd, Usuper0, Usuper1);
    if (Ud == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Lsuper0);
	Cudd_RecursiveDeref(dd, Lsuper1);
	Cudd_RecursiveDeref(dd, Ld);
	return(NULL);
    }
    Cudd_Ref(Ud);
    Cudd_RecursiveDeref(dd, Lsuper0);
    Cudd_RecursiveDeref(dd, Lsuper1);

    Id = cuddZddIsop(dd, Ld, Ud, &zdd_Id);
    if (Id == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Ld);
	Cudd_RecursiveDeref(dd, Ud);
	return(NULL);
    }
    /*
    if ((!cuddIsConstant(Cudd_Regular(Id))) &&
	(Cudd_Regular(Id)->index != zdd_Id->index / 2 ||
	dd->permZ[index * 2] > dd->permZ[zdd_Id->index])) {
	printf("*** ERROR : illegal permutation in ZDD. ***\n");
    }
    */
    Cudd_Ref(Id);
    Cudd_Ref(zdd_Id);
    Cudd_RecursiveDeref(dd, Ld);
    Cudd_RecursiveDeref(dd, Ud);

    x = cuddUniqueInter(dd, index, one, zero);
    if (x == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDerefZdd(dd, zdd_Id);
	return(NULL);
    }
    Cudd_Ref(x);
    /* term0 = x * Isub0 */
    term0 = cuddBddAndRecur(dd, Cudd_Not(x), Isub0);
    if (term0 == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDerefZdd(dd, zdd_Id);
	Cudd_RecursiveDeref(dd, x);
	return(NULL);
    }
    Cudd_Ref(term0);
    Cudd_RecursiveDeref(dd, Isub0);
    /* term1 = x * Isub1 */
    term1 = cuddBddAndRecur(dd, x, Isub1);
    if (term1 == NULL) {
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDerefZdd(dd, zdd_Id);
	Cudd_RecursiveDeref(dd, x);
	Cudd_RecursiveDeref(dd, term0);
	return(NULL);
    }
    Cudd_Ref(term1);
    Cudd_RecursiveDeref(dd, x);
    Cudd_RecursiveDeref(dd, Isub1);
    /* sum = term0 + term1 */
    sum = cuddBddAndRecur(dd, Cudd_Not(term0), Cudd_Not(term1));
    if (sum == NULL) {
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDerefZdd(dd, zdd_Id);
	Cudd_RecursiveDeref(dd, term0);
	Cudd_RecursiveDeref(dd, term1);
	return(NULL);
    }
    sum = Cudd_Not(sum);
    Cudd_Ref(sum);
    Cudd_RecursiveDeref(dd, term0);
    Cudd_RecursiveDeref(dd, term1);
    /* r = sum + Id */
    r = cuddBddAndRecur(dd, Cudd_Not(sum), Cudd_Not(Id));
    r = Cudd_NotCond(r, r != NULL);
    if (r == NULL) {
	Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDerefZdd(dd, zdd_Id);
	Cudd_RecursiveDeref(dd, sum);
	return(NULL);
    }
    Cudd_Ref(r);
    Cudd_RecursiveDeref(dd, sum);
    Cudd_RecursiveDeref(dd, Id);

    if (zdd_Isub0 != zdd_zero) {
	z = cuddZddGetNodeIVO(dd, index * 2 + 1, zdd_Isub0, zdd_Id);
	if (z == NULL) {
	    Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	    Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	    Cudd_RecursiveDerefZdd(dd, zdd_Id);
	    Cudd_RecursiveDeref(dd, r);
	    return(NULL);
	}
    }
    else {
	z = zdd_Id;
    }
    Cudd_Ref(z);
    if (zdd_Isub1 != zdd_zero) {
	y = cuddZddGetNodeIVO(dd, index * 2, zdd_Isub1, z);
	if (y == NULL) {
	    Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
	    Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
	    Cudd_RecursiveDerefZdd(dd, zdd_Id);
	    Cudd_RecursiveDeref(dd, r);
	    Cudd_RecursiveDerefZdd(dd, z);
	    return(NULL);
	}
    }
    else
	y = z;
    Cudd_Ref(y);

    Cudd_RecursiveDerefZdd(dd, zdd_Isub0);
    Cudd_RecursiveDerefZdd(dd, zdd_Isub1);
    Cudd_RecursiveDerefZdd(dd, zdd_Id);
    Cudd_RecursiveDerefZdd(dd, z);

    cuddCacheInsert2(dd, cuddBddIsop, L, U, r);
    cuddCacheInsert2(dd, cacheOp, L, U, y);

    Cudd_Deref(r);
    Cudd_Deref(y);
    *zdd_I = y;
    /*
    if (Cudd_Regular(r)->index != y->index / 2) {
	printf("*** ERROR : mismatch in indices between BDD and ZDD. ***\n");
    }
    */
    return(r);

} /* end of cuddZddIsop */


/**
  @brief Performs the recursive step of Cudd_bddIsop.

  @sideeffect None

  @see Cudd_bddIsop

*/
DdNode	*
cuddBddIsop(
  DdManager * dd,
  DdNode * L,
  DdNode * U)
{
    DdNode	*one = DD_ONE(dd);
    DdNode	*zero = Cudd_Not(one);
    int		v, top_l, top_u;
    DdNode	*Lsub0, *Usub0, *Lsub1, *Usub1, *Ld, *Ud;
    DdNode	*Lsuper0, *Usuper0, *Lsuper1, *Usuper1;
    DdNode	*Isub0, *Isub1, *Id;
    DdNode	*x;
    DdNode	*term0, *term1, *sum;
    DdNode	*Lv, *Uv, *Lnv, *Unv;
    DdNode	*r;
    unsigned	index;

    statLine(dd);
    if (L == zero)
	return(zero);
    if (U == one)
	return(one);

    /* Check cache */
    r = cuddCacheLookup2(dd, cuddBddIsop, L, U);
    if (r)
	return(r);

    top_l = dd->perm[Cudd_Regular(L)->index];
    top_u = dd->perm[Cudd_Regular(U)->index];
    v = ddMin(top_l, top_u);

    /* Compute cofactors */
    if (top_l == v) {
	index = Cudd_Regular(L)->index;
	Lv = Cudd_T(L);
	Lnv = Cudd_E(L);
	if (Cudd_IsComplement(L)) {
	    Lv = Cudd_Not(Lv);
	    Lnv = Cudd_Not(Lnv);
	}
    }
    else {
	index = Cudd_Regular(U)->index;
	Lv = Lnv = L;
    }

    if (top_u == v) {
	Uv = Cudd_T(U);
	Unv = Cudd_E(U);
	if (Cudd_IsComplement(U)) {
	    Uv = Cudd_Not(Uv);
	    Unv = Cudd_Not(Unv);
	}
    }
    else {
	Uv = Unv = U;
    }

    Lsub0 = cuddBddAndRecur(dd, Lnv, Cudd_Not(Uv));
    if (Lsub0 == NULL)
	return(NULL);
    Cudd_Ref(Lsub0);
    Usub0 = Unv;
    Lsub1 = cuddBddAndRecur(dd, Lv, Cudd_Not(Unv));
    if (Lsub1 == NULL) {
	Cudd_RecursiveDeref(dd, Lsub0);
	return(NULL);
    }
    Cudd_Ref(Lsub1);
    Usub1 = Uv;

    Isub0 = cuddBddIsop(dd, Lsub0, Usub0);
    if (Isub0 == NULL) {
	Cudd_RecursiveDeref(dd, Lsub0);
	Cudd_RecursiveDeref(dd, Lsub1);
	return(NULL);
    }
    Cudd_Ref(Isub0);
    Isub1 = cuddBddIsop(dd, Lsub1, Usub1);
    if (Isub1 == NULL) {
	Cudd_RecursiveDeref(dd, Lsub0);
	Cudd_RecursiveDeref(dd, Lsub1);
	Cudd_RecursiveDeref(dd, Isub0);
	return(NULL);
    }
    Cudd_Ref(Isub1);
    Cudd_RecursiveDeref(dd, Lsub0);
    Cudd_RecursiveDeref(dd, Lsub1);

    Lsuper0 = cuddBddAndRecur(dd, Lnv, Cudd_Not(Isub0));
    if (Lsuper0 == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	return(NULL);
    }
    Cudd_Ref(Lsuper0);
    Lsuper1 = cuddBddAndRecur(dd, Lv, Cudd_Not(Isub1));
    if (Lsuper1 == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDeref(dd, Lsuper0);
	return(NULL);
    }
    Cudd_Ref(Lsuper1);
    Usuper0 = Unv;
    Usuper1 = Uv;

    /* Ld = Lsuper0 + Lsuper1 */
    Ld = cuddBddAndRecur(dd, Cudd_Not(Lsuper0), Cudd_Not(Lsuper1));
    Ld = Cudd_NotCond(Ld, Ld != NULL);
    if (Ld == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDeref(dd, Lsuper0);
	Cudd_RecursiveDeref(dd, Lsuper1);
	return(NULL);
    }
    Cudd_Ref(Ld);
    Ud = cuddBddAndRecur(dd, Usuper0, Usuper1);
    if (Ud == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDeref(dd, Lsuper0);
	Cudd_RecursiveDeref(dd, Lsuper1);
	Cudd_RecursiveDeref(dd, Ld);
	return(NULL);
    }
    Cudd_Ref(Ud);
    Cudd_RecursiveDeref(dd, Lsuper0);
    Cudd_RecursiveDeref(dd, Lsuper1);

    Id = cuddBddIsop(dd, Ld, Ud);
    if (Id == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDeref(dd, Ld);
	Cudd_RecursiveDeref(dd, Ud);
	return(NULL);
    }
    Cudd_Ref(Id);
    Cudd_RecursiveDeref(dd, Ld);
    Cudd_RecursiveDeref(dd, Ud);

    x = cuddUniqueInter(dd, index, one, zero);
    if (x == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDeref(dd, Id);
	return(NULL);
    }
    Cudd_Ref(x);
    term0 = cuddBddAndRecur(dd, Cudd_Not(x), Isub0);
    if (term0 == NULL) {
	Cudd_RecursiveDeref(dd, Isub0);
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDeref(dd, x);
	return(NULL);
    }
    Cudd_Ref(term0);
    Cudd_RecursiveDeref(dd, Isub0);
    term1 = cuddBddAndRecur(dd, x, Isub1);
    if (term1 == NULL) {
	Cudd_RecursiveDeref(dd, Isub1);
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDeref(dd, x);
	Cudd_RecursiveDeref(dd, term0);
	return(NULL);
    }
    Cudd_Ref(term1);
    Cudd_RecursiveDeref(dd, x);
    Cudd_RecursiveDeref(dd, Isub1);
    /* sum = term0 + term1 */
    sum = cuddBddAndRecur(dd, Cudd_Not(term0), Cudd_Not(term1));
    sum = Cudd_NotCond(sum, sum != NULL);
    if (sum == NULL) {
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDeref(dd, term0);
	Cudd_RecursiveDeref(dd, term1);
	return(NULL);
    }
    Cudd_Ref(sum);
    Cudd_RecursiveDeref(dd, term0);
    Cudd_RecursiveDeref(dd, term1);
    /* r = sum + Id */
    r = cuddBddAndRecur(dd, Cudd_Not(sum), Cudd_Not(Id));
    r = Cudd_NotCond(r, r != NULL);
    if (r == NULL) {
	Cudd_RecursiveDeref(dd, Id);
	Cudd_RecursiveDeref(dd, sum);
	return(NULL);
    }
    Cudd_Ref(r);
    Cudd_RecursiveDeref(dd, sum);
    Cudd_RecursiveDeref(dd, Id);

    cuddCacheInsert2(dd, cuddBddIsop, L, U, r);

    Cudd_Deref(r);
    return(r);

} /* end of cuddBddIsop */


/**
  @brief Converts a %ZDD cover to a %BDD.

  @details It is a recursive algorithm that works as follows. First it
  computes 3 cofactors of a %ZDD cover: f1, f0 and fd. Second, it
  compute BDDs (b1, b0 and bd) of f1, f0 and fd.  Third, it computes
  T=b1+bd and E=b0+bd. Fourth, it computes ITE(v,T,E) where v is the
  variable which has the index of the top node of the %ZDD cover.  In
  this case, since the index of v can be larger than either the one of
  T or the one of E, cuddUniqueInterIVO is called, where IVO stands
  for independent from variable ordering.

  @return a %BDD node if successful; otherwise it returns NULL.

  @see Cudd_MakeBddFromZddCover

*/
DdNode	*
cuddMakeBddFromZddCover(
  DdManager * dd,
  DdNode * node)
{
    DdNode	*neW;
    unsigned	v;
    DdNode	*f1, *f0, *fd;
    DdNode	*b1, *b0, *bd;
    DdNode	*T, *E;

    statLine(dd);
    if (node == dd->one)
	return(dd->one);
    if (node == dd->zero)
	return(Cudd_Not(dd->one));

    /* Check cache */
    neW = cuddCacheLookup1(dd, cuddMakeBddFromZddCover, node);
    if (neW)
	return(neW);

    v = Cudd_Regular(node)->index;	/* either yi or zi */
    if (cuddZddGetCofactors3(dd, node, v, &f1, &f0, &fd)) return(NULL);
    Cudd_Ref(f1);
    Cudd_Ref(f0);
    Cudd_Ref(fd);

    b1 = cuddMakeBddFromZddCover(dd, f1);
    if (!b1) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	return(NULL);
    }
    Cudd_Ref(b1);
    b0 = cuddMakeBddFromZddCover(dd, f0);
    if (!b0) {
	Cudd_RecursiveDerefZdd(dd, f1);
	Cudd_RecursiveDerefZdd(dd, f0);
	Cudd_RecursiveDerefZdd(dd, fd);
	Cudd_RecursiveDeref(dd, b1);
	return(NULL);
    }
    Cudd_Ref(b0);
    Cudd_RecursiveDerefZdd(dd, f1);
    Cudd_RecursiveDerefZdd(dd, f0);
    if (fd != dd->zero) {
	bd = cuddMakeBddFromZddCover(dd, fd);
	if (!bd) {
	    Cudd_RecursiveDerefZdd(dd, fd);
	    Cudd_RecursiveDeref(dd, b1);
	    Cudd_RecursiveDeref(dd, b0);
	    return(NULL);
	}
	Cudd_Ref(bd);
	Cudd_RecursiveDerefZdd(dd, fd);

	T = cuddBddAndRecur(dd, Cudd_Not(b1), Cudd_Not(bd));
	if (!T) {
	    Cudd_RecursiveDeref(dd, b1);
	    Cudd_RecursiveDeref(dd, b0);
	    Cudd_RecursiveDeref(dd, bd);
	    return(NULL);
	}
	T = Cudd_NotCond(T, T != NULL);
	Cudd_Ref(T);
	Cudd_RecursiveDeref(dd, b1);
	E = cuddBddAndRecur(dd, Cudd_Not(b0), Cudd_Not(bd));
	if (!E) {
	    Cudd_RecursiveDeref(dd, b0);
	    Cudd_RecursiveDeref(dd, bd);
	    Cudd_RecursiveDeref(dd, T);
	    return(NULL);
	}
	E = Cudd_NotCond(E, E != NULL);
	Cudd_Ref(E);
	Cudd_RecursiveDeref(dd, b0);
	Cudd_RecursiveDeref(dd, bd);
    }
    else {
	Cudd_RecursiveDerefZdd(dd, fd);
	T = b1;
	E = b0;
    }

    if (Cudd_IsComplement(T)) {
	neW = cuddUniqueInterIVO(dd, v / 2, Cudd_Not(T), Cudd_Not(E));
	if (!neW) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
	neW = Cudd_Not(neW);
    }
    else {
	neW = cuddUniqueInterIVO(dd, v / 2, T, E);
	if (!neW) {
	    Cudd_RecursiveDeref(dd, T);
	    Cudd_RecursiveDeref(dd, E);
	    return(NULL);
	}
    }
    Cudd_Ref(neW);
    Cudd_RecursiveDeref(dd, T);
    Cudd_RecursiveDeref(dd, E);

    cuddCacheInsert1(dd, cuddMakeBddFromZddCover, node, neW);
    Cudd_Deref(neW);
    return(neW);

} /* end of cuddMakeBddFromZddCover */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

cuddZddLin.c
25595
/**
  @file

  @ingroup cudd

  @brief Procedures for dynamic variable ordering of ZDDs.

  @see cuddLinear.c cuddZddReord.c

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define CUDD_SWAP_MOVE 0
#define CUDD_LINEAR_TRANSFORM_MOVE 1
#define CUDD_INVERSE_TRANSFORM_MOVE 2

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int cuddZddLinearInPlace (DdManager * table, int x, int y);
static int cuddZddLinearAux (DdManager *table, int x, int xLow, int xHigh);
static Move * cuddZddLinearUp (DdManager *table, int y, int xLow, Move *prevMoves);
static Move * cuddZddLinearDown (DdManager *table, int x, int xHigh, Move *prevMoves);
static int cuddZddLinearBackward (DdManager *table, int size, Move *moves);
static Move* cuddZddUndoMoves (DdManager *table, Move *moves);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/




/**
  @brief Implementation of the linear sifting algorithm for ZDDs.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down and applies the XOR transformation,
    remembering each time the total size of the %DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddZddLinearSifting(
  DdManager * table,
  int  lower,
  int  upper)
{
    int	i;
    IndexKey *var;
    int	size;
    int	x;
    int	result;
#ifdef DD_STATS
    int	previousSize;
#endif

    size = table->sizeZ;

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey, size);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto cuddZddSiftingOutOfMem;
    }

    for (i = 0; i < size; i++) {
	x = table->permZ[i];
	var[i].index = i;
	var[i].keys = table->subtableZ[x].keys;
    }

    util_qsort(var, size, sizeof(IndexKey), cuddZddUniqueCompare);

    /* Now sift. */
    for (i = 0; i < ddMin(table->siftMaxVar, size); i++) {
	if (table->zddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime > table->timeLimit) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
	x = table->permZ[var[i].index];
	if (x < lower || x > upper) continue;
#ifdef DD_STATS
	previousSize = table->keysZ;
#endif
	result = cuddZddLinearAux(table, x, lower, upper);
	if (!result)
	    goto cuddZddSiftingOutOfMem;
#ifdef DD_STATS
	if (table->keysZ < (unsigned) previousSize) {
	    (void) fprintf(table->out,"-");
	} else if (table->keysZ > (unsigned) previousSize) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	    (void) fprintf(table->out,"\nSize increased from %d to %d while sifting variable %d\n", previousSize, table->keysZ , var[i].index);
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
    }

    FREE(var);

    return(1);

cuddZddSiftingOutOfMem:

    if (var != NULL) FREE(var);

    return(0);

} /* end of cuddZddLinearSifting */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Linearly combines two adjacent variables.

  @details It assumes that no dead nodes are present on entry to this
  procedure.  The procedure then guarantees that no dead nodes will be
  present when it terminates.  cuddZddLinearInPlace assumes that x
  &lt; y.

  @return the number of keys in the table if successful; 0 otherwise.

  @sideeffect None

  @see cuddZddSwapInPlace cuddLinearInPlace

*/
static int
cuddZddLinearInPlace(
  DdManager * table,
  int  x,
  int  y)
{
    DdNodePtr *xlist, *ylist;
    int		xindex, yindex;
    int		xslots, yslots;
    int		xshift, yshift;
    int         oldxkeys, oldykeys;
    int         newxkeys, newykeys;
    int		i;
    int		posn;
    DdNode	*f, *f1, *f0, *f11, *f10, *f01, *f00;
    DdNode	*newf1, *newf0, *g, *next, *previous;
    DdNode	*special;
    DdNode	*empty = table->zero;

#ifdef DD_DEBUG
    assert(x < y);
    assert(cuddZddNextHigh(table,x) == y);
    assert(table->subtableZ[x].keys != 0);
    assert(table->subtableZ[y].keys != 0);
    assert(table->subtableZ[x].dead == 0);
    assert(table->subtableZ[y].dead == 0);
#endif

    /* Get parameters of x subtable. */
    xindex   = table->invpermZ[x];
    xlist    = table->subtableZ[x].nodelist;
    oldxkeys = table->subtableZ[x].keys;
    xslots   = table->subtableZ[x].slots;
    xshift   = table->subtableZ[x].shift;
    newxkeys = 0;

    /* Get parameters of y subtable. */
    yindex   = table->invpermZ[y];
    ylist    = table->subtableZ[y].nodelist;
    oldykeys = table->subtableZ[y].keys;
    yslots   = table->subtableZ[y].slots;
    yshift   = table->subtableZ[y].shift;
    newykeys = oldykeys;

    /* The nodes in the x layer are put in two chains.  The chain
    ** pointed by g holds the normal nodes. When re-expressed they stay
    ** in the x list. The chain pointed by special holds the elements
    ** that will move to the y list.
    */
    g = special = NULL;
    for (i = 0; i < xslots; i++) {
	f = xlist[i];
	if (f == NULL) continue;
	xlist[i] = NULL;
	while (f != NULL) {
	    next = f->next;
	    f1 = cuddT(f);
	    /* if (f1->index == yindex) */ cuddSatDec(f1->ref);
	    f0 = cuddE(f);
	    /* if (f0->index == yindex) */ cuddSatDec(f0->ref);
	    if ((int) f1->index == yindex && cuddE(f1) == empty &&
		(int) f0->index != yindex) {
		f->next = special;
		special = f;
	    } else {
		f->next = g;
		g = f;
	    }
	    f = next;
	} /* while there are elements in the collision chain */
    } /* for each slot of the x subtable */

    /* Mark y nodes with pointers from above x. We mark them by
    **  changing their index to x.
    */
    for (i = 0; i < yslots; i++) {
	f = ylist[i];
	while (f != NULL) {
	    if (f->ref != 0) {
		f->index = xindex;
	    }
	    f = f->next;
	} /* while there are elements in the collision chain */
    } /* for each slot of the y subtable */

    /* Move special nodes to the y list. */
    f = special;
    while (f != NULL) {
	next = f->next;
	f1 = cuddT(f);
	f11 = cuddT(f1);
	cuddT(f) = f11;
	cuddSatInc(f11->ref);
	f0 = cuddE(f);
	cuddSatInc(f0->ref);
	f->index = yindex;
	/* Insert at the beginning of the list so that it will be
	** found first if there is a duplicate. The duplicate will
	** eventually be moved or garbage collected. No node
	** re-expression will add a pointer to it.
	*/
	posn = ddHash(f11, f0, yshift);
	f->next = ylist[posn];
	ylist[posn] = f;
	newykeys++;
	f = next;
    }

    /* Take care of the remaining x nodes that must be re-expressed.
    ** They form a linked list pointed by g.
    */
    f = g;
    while (f != NULL) {
#ifdef DD_COUNT
	table->swapSteps++;
#endif
	next = f->next;
	/* Find f1, f0, f11, f10, f01, f00. */
	f1 = cuddT(f);
	if ((int) f1->index == yindex || (int) f1->index == xindex) {
	    f11 = cuddT(f1); f10 = cuddE(f1);
	} else {
	    f11 = empty; f10 = f1;
	}
	f0 = cuddE(f);
	if ((int) f0->index == yindex || (int) f0->index == xindex) {
	    f01 = cuddT(f0); f00 = cuddE(f0);
	} else {
	    f01 = empty; f00 = f0;
	}
	/* Create the new T child. */
	if (f01 == empty) {
	    newf1 = f10;
	    cuddSatInc(newf1->ref);
	} else {
	    /* Check ylist for triple (yindex, f01, f10). */
	    posn = ddHash(f01, f10, yshift);
	    /* For each element newf1 in collision list ylist[posn]. */
	    newf1 = ylist[posn];
	    /* Search the collision chain skipping the marked nodes. */
	    while (newf1 != NULL) {
		if (cuddT(newf1) == f01 && cuddE(newf1) == f10 &&
		    (int) newf1->index == yindex) {
		    cuddSatInc(newf1->ref);
		    break; /* match */
		}
		newf1 = newf1->next;
	    } /* while newf1 */
	    if (newf1 == NULL) {	/* no match */
		newf1 = cuddDynamicAllocNode(table);
		if (newf1 == NULL)
		    goto zddSwapOutOfMem;
		newf1->index = yindex; newf1->ref = 1;
		cuddT(newf1) = f01;
		cuddE(newf1) = f10;
		/* Insert newf1 in the collision list ylist[pos];
		** increase the ref counts of f01 and f10
		*/
		newykeys++;
		newf1->next = ylist[posn];
		ylist[posn] = newf1;
		cuddSatInc(f01->ref);
		cuddSatInc(f10->ref);
	    }
	}
	cuddT(f) = newf1;

	/* Do the same for f0. */
	/* Create the new E child. */
	if (f11 == empty) {
	    newf0 = f00;
	    cuddSatInc(newf0->ref);
	} else {
	    /* Check ylist for triple (yindex, f11, f00). */
	    posn = ddHash(f11, f00, yshift);
	    /* For each element newf0 in collision list ylist[posn]. */
	    newf0 = ylist[posn];
	    while (newf0 != NULL) {
		if (cuddT(newf0) == f11 && cuddE(newf0) == f00 &&
		    (int) newf0->index == yindex) {
		    cuddSatInc(newf0->ref);
		    break; /* match */
		}
		newf0 = newf0->next;
	    } /* while newf0 */
	    if (newf0 == NULL) {	/* no match */
		newf0 = cuddDynamicAllocNode(table);
		if (newf0 == NULL)
		    goto zddSwapOutOfMem;
		newf0->index = yindex; newf0->ref = 1;
		cuddT(newf0) = f11; cuddE(newf0) = f00;
		/* Insert newf0 in the collision list ylist[posn];
		** increase the ref counts of f11 and f00.
		*/
		newykeys++;
		newf0->next = ylist[posn];
		ylist[posn] = newf0;
		cuddSatInc(f11->ref);
		cuddSatInc(f00->ref);
	    }
	}
	cuddE(f) = newf0;

	/* Re-insert the modified f in xlist.
	** The modified f does not already exists in xlist.
	** (Because of the uniqueness of the cofactors.)
	*/
	posn = ddHash(newf1, newf0, xshift);
	newxkeys++;
	f->next = xlist[posn];
	xlist[posn] = f;
	f = next;
    } /* while f != NULL */

    /* GC the y layer and move the marked nodes to the x list. */

    /* For each node f in ylist. */
    for (i = 0; i < yslots; i++) {
	previous = NULL;
	f = ylist[i];
	while (f != NULL) {
	    next = f->next;
	    if (f->ref == 0) {
		cuddSatDec(cuddT(f)->ref);
		cuddSatDec(cuddE(f)->ref);
		cuddDeallocNode(table, f);
		newykeys--;
		if (previous == NULL)
		    ylist[i] = next;
		else
		    previous->next = next;
	    } else if ((int) f->index == xindex) { /* move marked node */
		if (previous == NULL)
		    ylist[i] = next;
		else
		    previous->next = next;
		f1 = cuddT(f);
		cuddSatDec(f1->ref);
		/* Check ylist for triple (yindex, f1, empty). */
		posn = ddHash(f1, empty, yshift);
		/* For each element newf1 in collision list ylist[posn]. */
		newf1 = ylist[posn];
		while (newf1 != NULL) {
		    if (cuddT(newf1) == f1 && cuddE(newf1) == empty &&
			(int) newf1->index == yindex) {
			cuddSatInc(newf1->ref);
			break; /* match */
		    }
		    newf1 = newf1->next;
		} /* while newf1 */
		if (newf1 == NULL) {	/* no match */
		    newf1 = cuddDynamicAllocNode(table);
		    if (newf1 == NULL)
			goto zddSwapOutOfMem;
		    newf1->index = yindex; newf1->ref = 1;
		    cuddT(newf1) = f1; cuddE(newf1) = empty;
		    /* Insert newf1 in the collision list ylist[posn];
		    ** increase the ref counts of f1 and empty.
		    */
		    newykeys++;
		    newf1->next = ylist[posn];
		    ylist[posn] = newf1;
		    if (posn == i && previous == NULL)
			previous = newf1;
		    cuddSatInc(f1->ref);
		    cuddSatInc(empty->ref);
		}
		cuddT(f) = newf1;
		f0 = cuddE(f);
		/* Insert f in x list. */
		posn = ddHash(newf1, f0, xshift);
		newxkeys++;
		newykeys--;
		f->next = xlist[posn];
		xlist[posn] = f;
	    } else {
		previous = f;
	    }
	    f = next;
	} /* while f */
    } /* for i */

    /* Set the appropriate fields in table. */
    table->subtableZ[x].keys     = newxkeys;
    table->subtableZ[y].keys     = newykeys;

    table->keysZ += newxkeys + newykeys - oldxkeys - oldykeys;

    /* Update univ section; univ[x] remains the same. */
    table->univ[y] = cuddT(table->univ[x]);

#if 0
    (void) fprintf(table->out,"x = %d  y = %d\n", x, y);
    (void) Cudd_DebugCheck(table);
    (void) Cudd_CheckKeys(table);
#endif

    return (table->keysZ);

zddSwapOutOfMem:
    (void) fprintf(table->err, "Error: cuddZddSwapInPlace out of memory\n");

    return (0);

} /* end of cuddZddLinearInPlace */


/**
  @brief Given xLow <= x <= xHigh moves x up and down between the
  boundaries.

  @details Finds the best position and does the required changes.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
cuddZddLinearAux(
  DdManager * table,
  int  x,
  int  xLow,
  int  xHigh)
{
    Move	*move;
    Move	*moveUp;	/* list of up move */
    Move	*moveDown;	/* list of down move */

    int		initial_size;
    int		result;

    initial_size = table->keysZ;

#ifdef DD_DEBUG
    assert(table->subtableZ[x].keys > 0);
#endif

    moveDown = NULL;
    moveUp = NULL;

    if (x == xLow) {
	moveDown = cuddZddLinearDown(table, x, xHigh, NULL);
	/* At this point x --> xHigh. */
	if (moveDown == (Move *) CUDD_OUT_OF_MEM)
	    goto cuddZddLinearAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = cuddZddLinearBackward(table, initial_size, moveDown);
	if (!result)
	    goto cuddZddLinearAuxOutOfMem;

    } else if (x == xHigh) {
	moveUp = cuddZddLinearUp(table, x, xLow, NULL);
	/* At this point x --> xLow. */
	if (moveUp == (Move *) CUDD_OUT_OF_MEM)
	    goto cuddZddLinearAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = cuddZddLinearBackward(table, initial_size, moveUp);
	if (!result)
	    goto cuddZddLinearAuxOutOfMem;

    } else if ((x - xLow) > (xHigh - x)) { /* must go down first: shorter */
	moveDown = cuddZddLinearDown(table, x, xHigh, NULL);
	/* At this point x --> xHigh. */
	if (moveDown == (Move *) CUDD_OUT_OF_MEM)
	    goto cuddZddLinearAuxOutOfMem;
	moveUp = cuddZddUndoMoves(table,moveDown);
#ifdef DD_DEBUG
	assert(moveUp == NULL || moveUp->x == (DdHalfWord) x);
#endif
	moveUp = cuddZddLinearUp(table, x, xLow, moveUp);
	if (moveUp == (Move *) CUDD_OUT_OF_MEM)
	    goto cuddZddLinearAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = cuddZddLinearBackward(table, initial_size, moveUp);
	if (!result)
	    goto cuddZddLinearAuxOutOfMem;

    } else {
	moveUp = cuddZddLinearUp(table, x, xLow, NULL);
	/* At this point x --> xHigh. */
	if (moveUp == (Move *) CUDD_OUT_OF_MEM)
	    goto cuddZddLinearAuxOutOfMem;
	/* Then move up. */
	moveDown = cuddZddUndoMoves(table,moveUp);
#ifdef DD_DEBUG
	assert(moveDown == NULL || moveDown->y == (DdHalfWord) x);
#endif
	moveDown = cuddZddLinearDown(table, x, xHigh, moveDown);
	if (moveDown == (Move *) CUDD_OUT_OF_MEM)
	    goto cuddZddLinearAuxOutOfMem;
	/* Move backward and stop at best position. */
	result = cuddZddLinearBackward(table, initial_size, moveDown);
	if (!result)
	    goto cuddZddLinearAuxOutOfMem;
    }

    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(1);

cuddZddLinearAuxOutOfMem:
    if (moveDown != (Move *) CUDD_OUT_OF_MEM) {
	while (moveDown != NULL) {
	    move = moveDown->next;
	    cuddDeallocMove(table, moveDown);
	    moveDown = move;
	}
    }
    if (moveUp != (Move *) CUDD_OUT_OF_MEM) {
	while (moveUp != NULL) {
	    move = moveUp->next;
	    cuddDeallocMove(table, moveUp);
	    moveUp = move;
	}
    }

    return(0);

} /* end of cuddZddLinearAux */


/**
  @brief Sifts a variable up applying the XOR transformation.

  @details Moves y up until either it reaches the bound (xLow) or the
  size of the %ZDD heap increases too much.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
cuddZddLinearUp(
  DdManager * table,
  int  y,
  int  xLow,
  Move * prevMoves)
{
    Move	*moves;
    Move	*move;
    int		x;
    int		size, newsize;
    int		limitSize;

    moves = prevMoves;
    limitSize = table->keysZ;

    x = cuddZddNextLow(table, y);
    while (x >= xLow) {
	size = cuddZddSwapInPlace(table, x, y);
	if (size == 0)
	    goto cuddZddLinearUpOutOfMem;
	newsize = cuddZddLinearInPlace(table, x, y);
	if (newsize == 0)
	    goto cuddZddLinearUpOutOfMem;
	move = (Move *) cuddDynamicAllocNode(table);
	if (move == NULL)
	    goto cuddZddLinearUpOutOfMem;
	move->x = x;
	move->y = y;
	move->next = moves;
	moves = move;
	move->flags = CUDD_SWAP_MOVE;
	if (newsize > size) {
	    /* Undo transformation. The transformation we apply is
	    ** its own inverse. Hence, we just apply the transformation
	    ** again.
	    */
	    newsize = cuddZddLinearInPlace(table,x,y);
	    if (newsize == 0) goto cuddZddLinearUpOutOfMem;
#ifdef DD_DEBUG
	    if (newsize != size) {
		(void) fprintf(table->err,"Change in size after identity transformation! From %d to %d\n",size,newsize);
	    }
#endif
	} else {
	    size = newsize;
	    move->flags = CUDD_LINEAR_TRANSFORM_MOVE;
	}
	move->size = size;

	if ((double)size > (double)limitSize * table->maxGrowth)
	    break;
        if (size < limitSize)
	    limitSize = size;

	y = x;
	x = cuddZddNextLow(table, y);
    }
    return(moves);

cuddZddLinearUpOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of cuddZddLinearUp */


/**
  @brief Sifts a variable down and applies the XOR transformation.

  @details Sifts a variable down. Moves x down until either it
  reaches the bound (xHigh) or the size of the %ZDD heap increases too
  much.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
cuddZddLinearDown(
  DdManager * table,
  int  x,
  int  xHigh,
  Move * prevMoves)
{
    Move	*moves;
    Move	*move;
    int		y;
    int		size, newsize;
    int		limitSize;

    moves = prevMoves;
    limitSize = table->keysZ;

    y = cuddZddNextHigh(table, x);
    while (y <= xHigh) {
	size = cuddZddSwapInPlace(table, x, y);
	if (size == 0)
	    goto cuddZddLinearDownOutOfMem;
	newsize = cuddZddLinearInPlace(table, x, y);
	if (newsize == 0)
	    goto cuddZddLinearDownOutOfMem;
	move = (Move *) cuddDynamicAllocNode(table);
	if (move == NULL)
	    goto cuddZddLinearDownOutOfMem;
	move->x = x;
	move->y = y;
	move->next = moves;
	moves = move;
	move->flags = CUDD_SWAP_MOVE;
	if (newsize > size) {
	    /* Undo transformation. The transformation we apply is
	    ** its own inverse. Hence, we just apply the transformation
	    ** again.
	    */
	    newsize = cuddZddLinearInPlace(table,x,y);
	    if (newsize == 0) goto cuddZddLinearDownOutOfMem;
	    if (newsize != size) {
		(void) fprintf(table->err,"Change in size after identity transformation! From %d to %d\n",size,newsize);
	    }
	} else {
	    size = newsize;
	    move->flags = CUDD_LINEAR_TRANSFORM_MOVE;
	}
	move->size = size;

	if ((double)size > (double)limitSize * table->maxGrowth)
	    break;
        if (size < limitSize)
	    limitSize = size;

	x = y;
	y = cuddZddNextHigh(table, x);
    }
    return(moves);

cuddZddLinearDownOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of cuddZddLinearDown */


/**
  @brief Given a set of moves, returns the %ZDD heap to the position
  giving the minimum size.

  @details In case of ties, returns to the closest position giving the
  minimum size.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
cuddZddLinearBackward(
  DdManager * table,
  int  size,
  Move * moves)
{
    Move	*move;
    int		res;

    /* Find the minimum size among moves. */
    for (move = moves; move != NULL; move = move->next) {
	if (move->size < size) {
	    size = move->size;
	}
    }

    for (move = moves; move != NULL; move = move->next) {
	if (move->size == size) return(1);
	if (move->flags == CUDD_LINEAR_TRANSFORM_MOVE) {
	    res = cuddZddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!res) return(0);
	}
	res = cuddZddSwapInPlace(table, move->x, move->y);
	if (!res)
	    return(0);
	if (move->flags == CUDD_INVERSE_TRANSFORM_MOVE) {
	    res = cuddZddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!res) return(0);
	}
    }

    return(1);

} /* end of cuddZddLinearBackward */


/**
  @brief Given a set of moves, returns the %ZDD heap to the order
  in effect before the moves.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static Move*
cuddZddUndoMoves(
  DdManager * table,
  Move * moves)
{
    Move *invmoves = NULL;
    Move *move;
    Move *invmove;
    int	size;

    for (move = moves; move != NULL; move = move->next) {
	invmove = (Move *) cuddDynamicAllocNode(table);
	if (invmove == NULL) goto cuddZddUndoMovesOutOfMem;
	invmove->x = move->x;
	invmove->y = move->y;
	invmove->next = invmoves;
	invmoves = invmove;
	if (move->flags == CUDD_SWAP_MOVE) {
	    invmove->flags = CUDD_SWAP_MOVE;
	    size = cuddZddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto cuddZddUndoMovesOutOfMem;
	} else if (move->flags == CUDD_LINEAR_TRANSFORM_MOVE) {
	    invmove->flags = CUDD_INVERSE_TRANSFORM_MOVE;
	    size = cuddZddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto cuddZddUndoMovesOutOfMem;
	    size = cuddZddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto cuddZddUndoMovesOutOfMem;
	} else { /* must be CUDD_INVERSE_TRANSFORM_MOVE */
#ifdef DD_DEBUG
	    (void) fprintf(table->err,"Unforseen event in ddUndoMoves!\n");
#endif
	    invmove->flags = CUDD_LINEAR_TRANSFORM_MOVE;
	    size = cuddZddSwapInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto cuddZddUndoMovesOutOfMem;
	    size = cuddZddLinearInPlace(table,(int)move->x,(int)move->y);
	    if (!size) goto cuddZddUndoMovesOutOfMem;
	}
	invmove->size = size;
    }

    return(invmoves);

cuddZddUndoMovesOutOfMem:
    while (invmoves != NULL) {
	move = invmoves->next;
	cuddDeallocMove(table, invmoves);
	invmoves = move;
    }
    return((Move *) CUDD_OUT_OF_MEM);

} /* end of cuddZddUndoMoves */


cuddZddMisc.c
6648
/**
  @file

  @ingroup cudd

  @brief Miscellaneous utility functions for ZDDs.

  @author Hyong-Kyoon Shin, In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include <math.h>
#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int cuddZddDagInt (DdNode *n, st_table *tab);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Counts the number of nodes in a %ZDD.

  @deprecated This function duplicates Cudd_DagSize and is only
  retained for compatibility.

  @sideeffect None

  @see Cudd_DagSize

*/
int
Cudd_zddDagSize(
  DdNode * p_node)
{

    int		i;
    st_table	*table;

    table = st_init_table(st_ptrcmp, st_ptrhash);
    i = cuddZddDagInt(p_node, table);
    st_free_table(table);
    return(i);

} /* end of Cudd_zddDagSize */


/**
  @brief Counts the number of minterms of a %ZDD.

  @details Counts the number of minterms of the %ZDD rooted at
  <code>node</code>.  This procedure takes a parameter
  <code>path</code> that specifies how many variables are in the
  support of the function.

  @return the count.  If the procedure runs out of memory, it returns
  (double) CUDD_OUT_OF_MEM.

  @sideeffect None

  @see Cudd_zddCountDouble

*/
double
Cudd_zddCountMinterm(
  DdManager * zdd,
  DdNode * node,
  int  path)
{
    double	dc_var, minterms;

    dc_var = (double)((double)(zdd->sizeZ) - (double)path);
    minterms = Cudd_zddCountDouble(zdd, node) / pow(2.0, dc_var);
    return(minterms);

} /* end of Cudd_zddCountMinterm */


/**
  @brief Prints the %ZDD table for debugging purposes.

  @sideeffect None

*/
void
Cudd_zddPrintSubtable(
  DdManager * table)
{
    int		i, j;
    DdNode	*z1, *z1_next, *base;
    DdSubtable	*ZSubTable;

    base = table->one;
    for (i = table->sizeZ - 1; i >= 0; i--) {
	ZSubTable = &(table->subtableZ[i]);
	printf("subtable[%d]:\n", i);
	for (j = ZSubTable->slots - 1; j >= 0; j--) {
	    z1 = ZSubTable->nodelist[j];
	    while (z1 != NIL(DdNode)) {
		(void) fprintf(table->out,
		    "ID = 0x%" PRIxPTR "\tindex = %u\tr = %u\t",
		    (ptruint) z1 / (ptruint) sizeof(DdNode),
		    z1->index, z1->ref);
		z1_next = cuddT(z1);
		if (Cudd_IsConstantInt(z1_next)) {
		    (void) fprintf(table->out, "T = %d\t\t",
			(z1_next == base));
		}
		else {
		    (void) fprintf(table->out, "T = 0x%" PRIxPTR "\t",
			(ptruint) z1_next / (ptruint) sizeof(DdNode));
		}
		z1_next = cuddE(z1);
		if (Cudd_IsConstantInt(z1_next)) {
		    (void) fprintf(table->out, "E = %d\n",
			(z1_next == base));
		}
		else {
		    (void) fprintf(table->out, "E = 0x%" PRIxPTR "\n",
			(ptruint) z1_next / (ptruint) sizeof(DdNode));
		}

		z1_next = z1->next;
		z1 = z1_next;
	    }
	}
    }
    putchar('\n');

} /* Cudd_zddPrintSubtable */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_zddDagSize.

  @details Does not check for out-of-memory conditions.

  @sideeffect None

*/
static int
cuddZddDagInt(
  DdNode * n,
  st_table * tab)
{
    if (n == NIL(DdNode))
	return(0);

    if (st_is_member(tab, n) == 1)
	return(0);

    if (Cudd_IsConstantInt(n))
	return(0);

    (void)st_insert(tab, n, NIL(void));
    return(1 + cuddZddDagInt(cuddT(n), tab) +
	cuddZddDagInt(cuddE(n), tab));

} /* cuddZddDagInt */

cuddZddPort.c
9605
/**
  @file

  @ingroup cudd

  @brief Functions that translate BDDs to ZDDs.

  @author Hyong-kyoon Shin, In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * zddPortFromBddStep (DdManager *dd, DdNode *B, int expected);
static DdNode * zddPortToBddStep (DdManager *dd, DdNode *f, int depth);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Converts a %BDD into a %ZDD.

  @details This function assumes that there is a one-to-one
  correspondence between the %BDD variables and the %ZDD variables, and
  that the variable order is the same for both types of
  variables. These conditions are established if the %ZDD variables are
  created by one call to Cudd_zddVarsFromBddVars with multiplicity = 1.

  @return a pointer to the resulting %ZDD if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddVarsFromBddVars

*/
DdNode *
Cudd_zddPortFromBdd(
  DdManager * dd,
  DdNode * B)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = zddPortFromBddStep(dd,B,0);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_zddPortFromBdd */


/**
  @brief Converts a %ZDD into a %BDD.

  @return a pointer to the resulting %ZDD if successful; NULL
  otherwise.

  @sideeffect None

  @see Cudd_zddPortFromBdd

*/
DdNode *
Cudd_zddPortToBdd(
  DdManager * dd,
  DdNode * f)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = zddPortToBddStep(dd,f,0);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(res);

} /* end of Cudd_zddPortToBdd */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_zddPortFromBdd.

  @sideeffect None

*/
static DdNode *
zddPortFromBddStep(
  DdManager * dd,
  DdNode * B,
  int  expected)
{
    DdNode	*res, *prevZdd, *t, *e;
    DdNode	*Breg, *Bt, *Be;
    int		id;
    int		level;

    statLine(dd);
    /* Terminal cases. */
    if (B == Cudd_Not(DD_ONE(dd)))
	return(DD_ZERO(dd));
    if (B == DD_ONE(dd)) {
	if (expected >= dd->sizeZ) {
	    return(DD_ONE(dd));
	} else {
	    return(dd->univ[expected]);
	}
    }

    Breg = Cudd_Regular(B);

    /* Computed table look-up. */
    res = cuddCacheLookup1Zdd(dd,Cudd_zddPortFromBdd,B);
    if (res != NULL) {
	level = cuddI(dd,Breg->index);
	/* Adding DC vars. */
	if (expected < level) {
	    /* Add suppressed variables. */
	    cuddRef(res);
	    for (level--; level >= expected; level--) {
		prevZdd = res;
		id = dd->invperm[level];
		res = cuddZddGetNode(dd, id, prevZdd, prevZdd);
		if (res == NULL) {
		    Cudd_RecursiveDerefZdd(dd, prevZdd);
		    return(NULL);
		}
		cuddRef(res);
		Cudd_RecursiveDerefZdd(dd, prevZdd);
	    }
	    cuddDeref(res);
	}
	return(res);
    }	/* end of cache look-up */

    if (Cudd_IsComplement(B)) {
	Bt = Cudd_Not(cuddT(Breg));
	Be = Cudd_Not(cuddE(Breg));
    } else {
	Bt = cuddT(Breg);
	Be = cuddE(Breg);
    }

    id = (int) Breg->index;
    level = cuddI(dd,id);
    t = zddPortFromBddStep(dd, Bt, level+1);
    if (t == NULL) return(NULL);
    cuddRef(t);
    e = zddPortFromBddStep(dd, Be, level+1);
    if (e == NULL) {
	Cudd_RecursiveDerefZdd(dd, t);
	return(NULL);
    }
    cuddRef(e);
    res = cuddZddGetNode(dd, id, t, e);
    if (res == NULL) {
	Cudd_RecursiveDerefZdd(dd, t);
	Cudd_RecursiveDerefZdd(dd, e);
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDerefZdd(dd, t);
    Cudd_RecursiveDerefZdd(dd, e);

    cuddCacheInsert1(dd,Cudd_zddPortFromBdd,B,res);

    for (level--; level >= expected; level--) {
	prevZdd = res;
	id = dd->invperm[level];
	res = cuddZddGetNode(dd, id, prevZdd, prevZdd);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(dd, prevZdd);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDerefZdd(dd, prevZdd);
    }

    cuddDeref(res);
    return(res);

} /* end of zddPortFromBddStep */


/**
  @brief Performs the recursive step of Cudd_zddPortToBdd.

  @sideeffect None

*/
static DdNode *
zddPortToBddStep(
  DdManager * dd /* manager */,
  DdNode * f /* %ZDD to be converted */,
  int  depth /* recursion depth */)
{
    DdNode *one, *zero, *T, *E, *res, *var;
    int index;
    int level;

    statLine(dd);
    one = DD_ONE(dd);
    zero = DD_ZERO(dd);
    if (f == zero) return(Cudd_Not(one));

    if (depth == dd->sizeZ) return(one);

    index = dd->invpermZ[depth];
    level = cuddIZ(dd,f->index);
    var = cuddUniqueInter(dd,index,one,Cudd_Not(one));
    if (var == NULL) return(NULL);
    cuddRef(var);

    if (level > depth) {
	E = zddPortToBddStep(dd,f,depth+1);
	if (E == NULL) {
	    Cudd_RecursiveDeref(dd,var);
	    return(NULL);
	}
	cuddRef(E);
	res = cuddBddIteRecur(dd,var,Cudd_Not(one),E);
	if (res == NULL) {
	    Cudd_RecursiveDeref(dd,var);
	    Cudd_RecursiveDeref(dd,E);
	    return(NULL);
	}
	cuddRef(res);
	Cudd_RecursiveDeref(dd,var);
	Cudd_RecursiveDeref(dd,E);
	cuddDeref(res);
	return(res);
    }

    res = cuddCacheLookup1(dd,Cudd_zddPortToBdd,f);
    if (res != NULL) {
	Cudd_RecursiveDeref(dd,var);
	return(res);
    }

    T = zddPortToBddStep(dd,cuddT(f),depth+1);
    if (T == NULL) {
	Cudd_RecursiveDeref(dd,var);
	return(NULL);
    }
    cuddRef(T);
    E = zddPortToBddStep(dd,cuddE(f),depth+1);
    if (E == NULL) {
	Cudd_RecursiveDeref(dd,var);
	Cudd_RecursiveDeref(dd,T);
	return(NULL);
    }
    cuddRef(E);

    res = cuddBddIteRecur(dd,var,T,E);
    if (res == NULL) {
	Cudd_RecursiveDeref(dd,var);
	Cudd_RecursiveDeref(dd,T);
	Cudd_RecursiveDeref(dd,E);
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDeref(dd,var);
    Cudd_RecursiveDeref(dd,T);
    Cudd_RecursiveDeref(dd,E);
    cuddDeref(res);

    cuddCacheInsert1(dd,Cudd_zddPortToBdd,f,res);

    return(res);

} /* end of zddPortToBddStep */


cuddZddReord.c
40115
/**
  @file

  @ingroup cudd

  @brief Procedures for dynamic variable ordering of ZDDs.

  @author Hyong-Kyoon Shin, In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define DD_MAX_SUBTABLE_SPARSITY 8

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static Move * zddSwapAny (DdManager *table, int x, int y);
static int cuddZddSiftingAux (DdManager *table, int x, int x_low, int x_high);
static Move * cuddZddSiftingUp (DdManager *table, int x, int x_low, int initial_size);
static Move * cuddZddSiftingDown (DdManager *table, int x, int x_high, int initial_size);
static int cuddZddSiftingBackward (DdManager *table, Move *moves, int size);
static void zddReorderPreprocess (DdManager *table);
static int zddReorderPostprocess (DdManager *table);
static int zddShuffle (DdManager *table, int *permutation);
static int zddSiftUp (DdManager *table, int x, int xLow);
static void zddFixTree (DdManager *table, MtrNode *treenode);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Main dynamic reordering routine for ZDDs.

  @details@parblock
  Calls one of the possible reordering procedures:
  <ul>
  <li>Swapping
  <li>Sifting
  <li>Symmetric Sifting
  </ul>

  For sifting and symmetric sifting it is possible to request reordering
  to convergence.

  The core of all methods is the reordering procedure
  cuddZddSwapInPlace() which swaps two adjacent variables.
  @endparblock

  @return 1 in case of success; 0 otherwise. In the case of symmetric
  sifting (with and without convergence) returns 1 plus the number of
  symmetric variables, in case of success.

  @sideeffect Changes the variable order for all ZDDs and clears
  the cache.

*/
int
Cudd_zddReduceHeap(
  DdManager * table /**< DD manager */,
  Cudd_ReorderingType heuristic /**< method used for reordering */,
  int minsize /**< bound below which no reordering occurs */)
{
    DdHook	 *hook;
    int		 result;
    unsigned int nextDyn;
#ifdef DD_STATS
    unsigned int initialSize;
    unsigned int finalSize;
#endif
    unsigned long localTime;

    /* Don't reorder if there are too many dead nodes. */
    if (table->keysZ - table->deadZ < (unsigned) minsize)
	return(1);

    if (heuristic == CUDD_REORDER_SAME) {
	heuristic = table->autoMethodZ;
    }
    if (heuristic == CUDD_REORDER_NONE) {
	return(1);
    }

    /* This call to Cudd_zddReduceHeap does initiate reordering. Therefore
    ** we count it.
    */
    table->reorderings++;

    localTime = util_cpu_time();

    /* Run the hook functions. */
    hook = table->preReorderingHook;
    while (hook != NULL) {
	int res = (hook->f)(table, "ZDD", (void *)heuristic);
	if (res == 0) return(0);
	hook = hook->next;
    }

    /* Clear the cache and collect garbage. */
    zddReorderPreprocess(table);
    table->zddTotalNumberSwapping = 0;

#ifdef DD_STATS
    initialSize = table->keysZ;

    switch(heuristic) {
    case CUDD_REORDER_RANDOM:
    case CUDD_REORDER_RANDOM_PIVOT:
	(void) fprintf(table->out,"#:I_RANDOM  ");
	break;
    case CUDD_REORDER_SIFT:
    case CUDD_REORDER_SIFT_CONVERGE:
    case CUDD_REORDER_SYMM_SIFT:
    case CUDD_REORDER_SYMM_SIFT_CONV:
	(void) fprintf(table->out,"#:I_SIFTING ");
	break;
    case CUDD_REORDER_LINEAR:
    case CUDD_REORDER_LINEAR_CONVERGE:
	(void) fprintf(table->out,"#:I_LINSIFT ");
	break;
    default:
	(void) fprintf(table->err,"Unsupported ZDD reordering method\n");
	return(0);
    }
    (void) fprintf(table->out,"%8d: initial size",initialSize); 
#endif

    result = cuddZddTreeSifting(table,heuristic);

#ifdef DD_STATS
    (void) fprintf(table->out,"\n");
    finalSize = table->keysZ;
    (void) fprintf(table->out,"#:F_REORDER %8d: final size\n",finalSize); 
    (void) fprintf(table->out,"#:T_REORDER %8g: total time (sec)\n",
		   ((double)(util_cpu_time() - localTime)/1000.0)); 
    (void) fprintf(table->out,"#:N_REORDER %8d: total swaps\n",
		   table->zddTotalNumberSwapping);
#endif

    if (result == 0)
	return(0);

    if (!zddReorderPostprocess(table))
	return(0);

    if (table->realignZ) {
	if (!cuddBddAlignToZdd(table))
	    return(0);
    }

    nextDyn = table->keysZ * DD_DYN_RATIO;
    if (table->reorderings < 20 || nextDyn > table->nextDyn)
	table->nextDyn = nextDyn;
    else
	table->nextDyn += 20;

    table->reordered = 1;

    /* Run hook functions. */
    hook = table->postReorderingHook;
    while (hook != NULL) {
      int res = (hook->f)(table, "ZDD", (void *)(ptruint)localTime);
	if (res == 0) return(0);
	hook = hook->next;
    }
    /* Update cumulative reordering time. */
    table->reordTime += util_cpu_time() - localTime;

    return(result);

} /* end of Cudd_zddReduceHeap */


/**
  @brief Reorders %ZDD variables according to given permutation.

  @details The i-th entry of the permutation array contains the index
  of the variable that should be brought to the i-th level.  The size
  of the array should be equal or greater to the number of variables
  currently in use.

  @return 1 in case of success; 0 otherwise.

  @sideeffect Changes the %ZDD variable order for all diagrams and clears
  the cache.

  @see Cudd_zddReduceHeap

*/
int
Cudd_zddShuffleHeap(
  DdManager * table /**< DD manager */,
  int * permutation /**< required variable permutation */)
{

    int	result;

    zddReorderPreprocess(table);

    result = zddShuffle(table,permutation);

    if (!zddReorderPostprocess(table)) return(0);

    return(result);

} /* end of Cudd_zddShuffleHeap */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Reorders %ZDD variables according to the order of the %BDD
  variables.

  @details This function can be called at the end of %BDD reordering to
  insure that the order of the %ZDD variables is consistent with the
  order of the %BDD variables. The number of %ZDD variables must be a
  multiple of the number of %BDD variables. Let <code>M</code> be the
  ratio of the two numbers. cuddZddAlignToBdd then considers the %ZDD
  variables from <code>M*i</code> to <code>(M+1)*i-1</code> as
  corresponding to %BDD variable <code>i</code>.  This function should
  be normally called from Cudd_ReduceHeap, which clears the cache.

  @return 1 in case of success; 0 otherwise.

  @sideeffect Changes the %ZDD variable order for all diagrams and performs
  garbage collection of the %ZDD unique table.

  @see Cudd_zddShuffleHeap Cudd_ReduceHeap

*/
int
cuddZddAlignToBdd(
  DdManager * table /**< %DD manager */)
{
    int *invpermZ;		/* permutation array */
    int M;			/* ratio of ZDD variables to BDD variables */
    int i,j;			/* loop indices */
    int result;			/* return value */

    /* We assume that a ratio of 0 is OK. */
    if (table->sizeZ == 0)
	return(1);

    M = table->sizeZ / table->size;
    /* Check whether the number of ZDD variables is a multiple of the
    ** number of BDD variables.
    */
    if (M * table->size != table->sizeZ)
	return(0);
    /* Create and initialize the inverse permutation array. */
    invpermZ = ALLOC(int,table->sizeZ);
    if (invpermZ == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (i = 0; i < table->size; i++) {
	int index = table->invperm[i];
	int indexZ = index * M;
	int levelZ = table->permZ[indexZ];
	levelZ = (levelZ / M) * M;
	for (j = 0; j < M; j++) {
	    invpermZ[M * i + j] = table->invpermZ[levelZ + j];
	}
    }
    /* Eliminate dead nodes. Do not scan the cache again, because we
    ** assume that Cudd_ReduceHeap has already cleared it.
    */
    cuddGarbageCollect(table,0);

    result = zddShuffle(table, invpermZ);
    FREE(invpermZ);
    /* Fix the ZDD variable group tree. */
    zddFixTree(table,table->treeZ);
    return(result);
    
} /* end of cuddZddAlignToBdd */


/**
  @brief Finds the next subtable with a larger index.

  @return the index.

  @sideeffect None

*/
int
cuddZddNextHigh(
  DdManager * table,
  int  x)
{
    (void) table; /* avoid warning */
    return(x + 1);

} /* end of cuddZddNextHigh */


/**
  @brief Finds the next subtable with a smaller index.

  @return the index.

  @sideeffect None

*/
int
cuddZddNextLow(
  DdManager * table,
  int  x)
{
    (void) table; /* avoid warning */
    return(x - 1);

} /* end of cuddZddNextLow */


/**
  @brief Comparison function used by qsort.

  @details Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.

  @return the difference in number of keys between the two variables
  being compared.

  @sideeffect None

*/
int
cuddZddUniqueCompare(
  void const * ptr_x,
  void const * ptr_y)
{
    IndexKey const * pX = (IndexKey const *) ptr_x;
    IndexKey const * pY = (IndexKey const *) ptr_y;
    return(pY->keys - pX->keys);

} /* end of cuddZddUniqueCompare */


/**
  @brief Swaps two adjacent variables.

  @details It assumes that no dead nodes are present on entry to this
  procedure.  The procedure then guarantees that no dead nodes will be
  present when it terminates.  cuddZddSwapInPlace assumes that x &lt; y.

  @return the number of keys in the table if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddZddSwapInPlace(
  DdManager * table,
  int  x,
  int  y)
{
    DdNodePtr	*xlist, *ylist;
    int		xindex, yindex;
    int		xslots, yslots;
    int		xshift, yshift;
    int         oldxkeys, oldykeys;
    int         newxkeys, newykeys;
    int		i;
    int		posn;
    DdNode	*f, *f1, *f0, *f11, *f10, *f01, *f00;
    DdNode	*newf1 = NULL, *newf0 = NULL, *next;
    DdNodePtr	g, *lastP, *previousP;
    DdNode	*empty = table->zero;

#ifdef DD_DEBUG
    assert(x < y);
    assert(cuddZddNextHigh(table,x) == y);
    assert(table->subtableZ[x].keys != 0);
    assert(table->subtableZ[y].keys != 0);
    assert(table->subtableZ[x].dead == 0);
    assert(table->subtableZ[y].dead == 0);
#endif

    table->zddTotalNumberSwapping++;

    /* Get parameters of x subtable. */
    xindex   = table->invpermZ[x];
    xlist    = table->subtableZ[x].nodelist;
    oldxkeys = table->subtableZ[x].keys;
    xslots   = table->subtableZ[x].slots;
    xshift   = table->subtableZ[x].shift;
    newxkeys = 0;

    yindex   = table->invpermZ[y];
    ylist    = table->subtableZ[y].nodelist;
    oldykeys = table->subtableZ[y].keys;
    yslots   = table->subtableZ[y].slots;
    yshift   = table->subtableZ[y].shift;
    newykeys = oldykeys;

    /* The nodes in the x layer that don't depend on y directly
    ** will stay there; the others are put in a chain.
    ** The chain is handled as a FIFO; g points to the beginning and
    ** last points to the end.
    */

    g = NULL;
    lastP = &g;
    for (i = 0; i < xslots; i++) {
	previousP = &(xlist[i]);
	f = *previousP;
	while (f != NULL) {
	    next = f->next;
	    f1 = cuddT(f); f0 = cuddE(f);
	    if ((f1->index != (DdHalfWord) yindex) &&
		(f0->index != (DdHalfWord) yindex)) { /* stays */
	        newxkeys++;
		*previousP = f;
		previousP = &(f->next);
	    } else {
		f->index = yindex;
		*lastP = f;
		lastP = &(f->next);
	    }
	    f = next;
	} /* while there are elements in the collision chain */
	*previousP = NULL;
    } /* for each slot of the x subtable */
    *lastP = NULL;


#ifdef DD_COUNT
    table->swapSteps += oldxkeys - newxkeys;
#endif
    /* Take care of the x nodes that must be re-expressed.
    ** They form a linked list pointed by g. Their index has been
    ** changed to yindex already.
    */
    f = g;
    while (f != NULL) {
	next = f->next;
	/* Find f1, f0, f11, f10, f01, f00. */
	f1 = cuddT(f);
	if ((int) f1->index == yindex) {
	    f11 = cuddT(f1); f10 = cuddE(f1);
	} else {
	    f11 = empty; f10 = f1;
	}
	f0 = cuddE(f);
	if ((int) f0->index == yindex) {
	    f01 = cuddT(f0); f00 = cuddE(f0);
	} else {
	    f01 = empty; f00 = f0;
	}

	/* Decrease ref count of f1. */
	cuddSatDec(f1->ref);
	/* Create the new T child. */
	if (f11 == empty) {
	    if (f01 != empty) {
		newf1 = f01;
		cuddSatInc(newf1->ref);
	    }
	    /* else case was already handled when finding nodes
	    ** with both children below level y
	    */
	} else {
	    /* Check xlist for triple (xindex, f11, f01). */
	    posn = ddHash(f11, f01, xshift);
	    /* For each element newf1 in collision list xlist[posn]. */
	    newf1 = xlist[posn];
	    while (newf1 != NULL) {
		if (cuddT(newf1) == f11 && cuddE(newf1) == f01) {
		    cuddSatInc(newf1->ref);
		    break; /* match */
		}
		newf1 = newf1->next;
	    } /* while newf1 */
	    if (newf1 == NULL) {	/* no match */
		newf1 = cuddDynamicAllocNode(table);
		if (newf1 == NULL)
		    goto zddSwapOutOfMem;
		newf1->index = xindex; newf1->ref = 1;
		cuddT(newf1) = f11;
		cuddE(newf1) = f01;
		/* Insert newf1 in the collision list xlist[pos];
		** increase the ref counts of f11 and f01
		*/
		newxkeys++;
		newf1->next = xlist[posn];
		xlist[posn] = newf1;
		cuddSatInc(f11->ref);
		cuddSatInc(f01->ref);
	    }
	}
	cuddT(f) = newf1;

	/* Do the same for f0. */
	/* Decrease ref count of f0. */
	cuddSatDec(f0->ref);
	/* Create the new E child. */
	if (f10 == empty) {
	    newf0 = f00;
	    cuddSatInc(newf0->ref);
	} else {
	    /* Check xlist for triple (xindex, f10, f00). */
	    posn = ddHash(f10, f00, xshift);
	    /* For each element newf0 in collision list xlist[posn]. */
	    newf0 = xlist[posn];
	    while (newf0 != NULL) {
		if (cuddT(newf0) == f10 && cuddE(newf0) == f00) {
		    cuddSatInc(newf0->ref);
		    break; /* match */
		}
		newf0 = newf0->next;
	    } /* while newf0 */
	    if (newf0 == NULL) {	/* no match */
		newf0 = cuddDynamicAllocNode(table);
		if (newf0 == NULL)
		    goto zddSwapOutOfMem;
		newf0->index = xindex; newf0->ref = 1;
		cuddT(newf0) = f10; cuddE(newf0) = f00;
		/* Insert newf0 in the collision list xlist[posn];
		** increase the ref counts of f10 and f00.
		*/
		newxkeys++;
		newf0->next = xlist[posn];
		xlist[posn] = newf0;
		cuddSatInc(f10->ref);
		cuddSatInc(f00->ref);
	    }
	}
	cuddE(f) = newf0;

	/* Insert the modified f in ylist.
	** The modified f does not already exists in ylist.
	** (Because of the uniqueness of the cofactors.)
	*/
	posn = ddHash(newf1, newf0, yshift);
	newykeys++;
	f->next = ylist[posn];
	ylist[posn] = f;
	f = next;
    } /* while f != NULL */

    /* GC the y layer. */

    /* For each node f in ylist. */
    for (i = 0; i < yslots; i++) {
	previousP = &(ylist[i]);
	f = *previousP;
	while (f != NULL) {
	    next = f->next;
	    if (f->ref == 0) {
		cuddSatDec(cuddT(f)->ref);
		cuddSatDec(cuddE(f)->ref);
		cuddDeallocNode(table, f);
		newykeys--;
	    } else {
		*previousP = f;
		previousP = &(f->next);
	    }
	    f = next;
	} /* while f */
	*previousP = NULL;
    } /* for i */

    /* Set the appropriate fields in table. */
    table->subtableZ[x].nodelist = ylist;
    table->subtableZ[x].slots    = yslots;
    table->subtableZ[x].shift    = yshift;
    table->subtableZ[x].keys     = newykeys;
    table->subtableZ[x].maxKeys  = yslots * DD_MAX_SUBTABLE_DENSITY;

    table->subtableZ[y].nodelist = xlist;
    table->subtableZ[y].slots    = xslots;
    table->subtableZ[y].shift    = xshift;
    table->subtableZ[y].keys     = newxkeys;
    table->subtableZ[y].maxKeys  = xslots * DD_MAX_SUBTABLE_DENSITY;

    table->permZ[xindex] = y; table->permZ[yindex] = x;
    table->invpermZ[x] = yindex; table->invpermZ[y] = xindex;

    table->keysZ += newxkeys + newykeys - oldxkeys - oldykeys;

    /* Update univ section; univ[x] remains the same. */
    table->univ[y] = cuddT(table->univ[x]);

    return (table->keysZ);

zddSwapOutOfMem:
    (void) fprintf(table->err, "Error: cuddZddSwapInPlace out of memory\n");

    return (0);

} /* end of cuddZddSwapInPlace */


/**
  @brief Reorders variables by a sequence of (non-adjacent) swaps.

  @details Implementation of Plessier's algorithm that reorders
  variables by a sequence of (non-adjacent) swaps.
    <ol>
    <li> Select two variables (RANDOM or HEURISTIC).
    <li> Permute these variables.
    <li> If the nodes have decreased accept the permutation.
    <li> Otherwise reconstruct the original heap.
    <li> Loop.
    </ol>

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
cuddZddSwapping(
  DdManager * table,
  int lower,
  int upper,
  Cudd_ReorderingType heuristic)
{
    int	i, j;
    int max, keys;
    int nvars;
    int	x, y;
    int iterate;
    int previousSize;
    Move *moves, *move;
    int	pivot = 0;
    int modulo;
    int result;

#ifdef DD_DEBUG
    /* Sanity check */
    assert(lower >= 0 && upper < table->sizeZ && lower <= upper);
#endif

    nvars = upper - lower + 1;
    iterate = nvars;

    for (i = 0; i < iterate; i++) {
	if (heuristic == CUDD_REORDER_RANDOM_PIVOT) {
	    /* Find pivot <= id with maximum keys. */
	    for (max = -1, j = lower; j <= upper; j++) {
		if ((keys = table->subtableZ[j].keys) > max) {
		    max = keys;
		    pivot = j;
		}
	    }

	    modulo = upper - pivot;
	    if (modulo == 0) {
		y = pivot;	/* y = nvars-1 */
	    } else {
		/* y = random # from {pivot+1 .. nvars-1} */
		y = pivot + 1 + (int) (Cudd_Random(table) % modulo);
	    }

	    modulo = pivot - lower - 1;
	    if (modulo < 1) {	/* if pivot = 1 or 0 */
		x = lower;
	    } else {
		do { /* x = random # from {0 .. pivot-2} */
		    x = (int) Cudd_Random(table) % modulo;
		} while (x == y);
		  /* Is this condition really needed, since x and y
		     are in regions separated by pivot? */
	    }
	} else {
	    x = (int) (Cudd_Random(table) % nvars) + lower;
	    do {
		y = (int) (Cudd_Random(table) % nvars) + lower;
	    } while (x == y);
	}

	previousSize = table->keysZ;
	moves = zddSwapAny(table, x, y);
	if (moves == NULL)
	    goto cuddZddSwappingOutOfMem;

	result = cuddZddSiftingBackward(table, moves, previousSize);
	if (!result)
	    goto cuddZddSwappingOutOfMem;

	while (moves != NULL) {
	    move = moves->next;
	    cuddDeallocMove(table, moves);
	    moves = move;
	}
#ifdef DD_STATS
	if (table->keysZ < (unsigned) previousSize) {
	    (void) fprintf(table->out,"-");
	} else if (table->keysZ > (unsigned) previousSize) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
    }

    return(1);

cuddZddSwappingOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(0);

} /* end of cuddZddSwapping */


/**
  @brief Implementation of Rudell's sifting algorithm.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the %DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
cuddZddSifting(
  DdManager * table,
  int  lower,
  int  upper)
{
    int	i;
    IndexKey *var;
    int	size;
    int	x;
    int	result;
#ifdef DD_STATS
    int	previousSize;
#endif

    size = table->sizeZ;

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey, size);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto cuddZddSiftingOutOfMem;
    }

    for (i = 0; i < size; i++) {
	x = table->permZ[i];
	var[i].index = i;
	var[i].keys = table->subtableZ[x].keys;
    }

    util_qsort(var, size, sizeof(IndexKey), cuddZddUniqueCompare);

    /* Now sift. */
    for (i = 0; i < ddMin(table->siftMaxVar, size); i++) {
	if (table->zddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime > table->timeLimit) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
	x = table->permZ[var[i].index];
	if (x < lower || x > upper) continue;
#ifdef DD_STATS
	previousSize = table->keysZ;
#endif
	result = cuddZddSiftingAux(table, x, lower, upper);
	if (!result)
	    goto cuddZddSiftingOutOfMem;
#ifdef DD_STATS
	if (table->keysZ < (unsigned) previousSize) {
	    (void) fprintf(table->out,"-");
	} else if (table->keysZ > (unsigned) previousSize) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	    (void) fprintf(table->out,"\nSize increased from %d to %d while sifting variable %d\n", previousSize, table->keysZ , var[i].index);
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
    }

    FREE(var);

    return(1);

cuddZddSiftingOutOfMem:

    if (var != NULL) FREE(var);

    return(0);

} /* end of cuddZddSifting */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Swaps any two variables.

  @return the set of moves.

  @sideeffect None

*/
static Move *
zddSwapAny(
  DdManager * table,
  int  x,
  int  y)
{
    Move	*move, *moves;
    int		tmp, size;
    int		x_ref, y_ref;
    int		x_next, y_next;
    int		limit_size;

    if (x > y) {	/* make x precede y */
	tmp = x; x = y;	y = tmp;
    }

    x_ref = x; y_ref = y;

    x_next = cuddZddNextHigh(table, x);
    y_next = cuddZddNextLow(table, y);
    moves = NULL;
    limit_size = table->keysZ;

    for (;;) {
	if (x_next == y_next) {	/* x < x_next = y_next < y */
	    size = cuddZddSwapInPlace(table, x, x_next);
	    if (size == 0)
		goto zddSwapAnyOutOfMem;
	    move = (Move *) cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto zddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    size = cuddZddSwapInPlace(table, y_next, y);
	    if (size == 0)
		goto zddSwapAnyOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto zddSwapAnyOutOfMem;
	    move->x = y_next;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    size = cuddZddSwapInPlace(table, x, x_next);
	    if (size == 0)
		goto zddSwapAnyOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto zddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    tmp = x; x = y; y = tmp;

	} else if (x == y_next) { /* x = y_next < y = x_next */
	    size = cuddZddSwapInPlace(table, x, x_next);
	    if (size == 0)
		goto zddSwapAnyOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto zddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    tmp = x; x = y;  y = tmp;
	} else {
	    size = cuddZddSwapInPlace(table, x, x_next);
	    if (size == 0)
		goto zddSwapAnyOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto zddSwapAnyOutOfMem;
	    move->x = x;
	    move->y = x_next;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    size = cuddZddSwapInPlace(table, y_next, y);
	    if (size == 0)
		goto zddSwapAnyOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto zddSwapAnyOutOfMem;
	    move->x = y_next;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;

	    x = x_next; y = y_next;
	}

	x_next = cuddZddNextHigh(table, x);
	y_next = cuddZddNextLow(table, y);
	if (x_next > y_ref)
	    break;	/* if x == y_ref */

	if ((double) size > table->maxGrowth * (double) limit_size)
	    break;
	if (size < limit_size)
	    limit_size = size;
    }
    if (y_next >= x_ref) {
	size = cuddZddSwapInPlace(table, y_next, y);
	if (size == 0)
	    goto zddSwapAnyOutOfMem;
	move = (Move *)cuddDynamicAllocNode(table);
	if (move == NULL)
	    goto zddSwapAnyOutOfMem;
	move->x = y_next;
	move->y = y;
	move->size = size;
	move->next = moves;
	moves = move;
    }

    return(moves);

zddSwapAnyOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(NULL);

} /* end of zddSwapAny */


/**
  @brief Given xLow <= x <= xHigh moves x up and down between the
  boundaries.

  @details Finds the best position and does the required changes.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
cuddZddSiftingAux(
  DdManager * table,
  int  x,
  int  x_low,
  int  x_high)
{
    Move	*move;
    Move	*moveUp;	/* list of up move */
    Move	*moveDown;	/* list of down move */

    int		initial_size;
    int		result;

    initial_size = table->keysZ;

#ifdef DD_DEBUG
    assert(table->subtableZ[x].keys > 0);
#endif

    moveDown = NULL;
    moveUp = NULL;

    if (x == x_low) {
	moveDown = cuddZddSiftingDown(table, x, x_high, initial_size);
	/* after that point x --> x_high */
	if (moveDown == NULL)
	    goto cuddZddSiftingAuxOutOfMem;
	result = cuddZddSiftingBackward(table, moveDown,
	    initial_size);
	/* move backward and stop at best position */
	if (!result)
	    goto cuddZddSiftingAuxOutOfMem;

    }
    else if (x == x_high) {
	moveUp = cuddZddSiftingUp(table, x, x_low, initial_size);
	/* after that point x --> x_low */
	if (moveUp == NULL)
	    goto cuddZddSiftingAuxOutOfMem;
	result = cuddZddSiftingBackward(table, moveUp, initial_size);
	/* move backward and stop at best position */
	if (!result)
	    goto cuddZddSiftingAuxOutOfMem;
    }
    else if ((x - x_low) > (x_high - x)) {
	/* must go down first:shorter */
	moveDown = cuddZddSiftingDown(table, x, x_high, initial_size);
	/* after that point x --> x_high */
	if (moveDown == NULL)
	    goto cuddZddSiftingAuxOutOfMem;
	moveUp = cuddZddSiftingUp(table, moveDown->y, x_low,
	    initial_size);
	if (moveUp == NULL)
	    goto cuddZddSiftingAuxOutOfMem;
	result = cuddZddSiftingBackward(table, moveUp, initial_size);
	/* move backward and stop at best position */
	if (!result)
	    goto cuddZddSiftingAuxOutOfMem;
    }
    else {
	moveUp = cuddZddSiftingUp(table, x, x_low, initial_size);
	/* after that point x --> x_high */
	if (moveUp == NULL)
	    goto cuddZddSiftingAuxOutOfMem;
	moveDown = cuddZddSiftingDown(table, moveUp->x, x_high,
	    initial_size);
	/* then move up */
	if (moveDown == NULL)
	    goto cuddZddSiftingAuxOutOfMem;
	result = cuddZddSiftingBackward(table, moveDown,
	    initial_size);
	/* move backward and stop at best position */
	if (!result)
	    goto cuddZddSiftingAuxOutOfMem;
    }

    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(1);

cuddZddSiftingAuxOutOfMem:
    while (moveDown != NULL) {
	move = moveDown->next;
	cuddDeallocMove(table, moveDown);
	moveDown = move;
    }
    while (moveUp != NULL) {
	move = moveUp->next;
	cuddDeallocMove(table, moveUp);
	moveUp = move;
    }

    return(0);

} /* end of cuddZddSiftingAux */


/**
  @brief Sifts a variable up.

  @details Moves y up until either it reaches the bound (x_low) or the
  size of the %ZDD heap increases too much.

  @return the set of moves in case of success; NULL if memory is full.

  @sideeffect None

*/
static Move *
cuddZddSiftingUp(
  DdManager * table,
  int  x,
  int  x_low,
  int  initial_size)
{
    Move	*moves;
    Move	*move;
    int		y;
    int		size;
    int		limit_size = initial_size;

    moves = NULL;
    y = cuddZddNextLow(table, x);
    while (y >= x_low) {
	size = cuddZddSwapInPlace(table, y, x);
	if (size == 0)
	    goto cuddZddSiftingUpOutOfMem;
	move = (Move *)cuddDynamicAllocNode(table);
	if (move == NULL)
	    goto cuddZddSiftingUpOutOfMem;
	move->x = y;
	move->y = x;
	move->size = size;
	move->next = moves;
	moves = move;

	if ((double)size > (double)limit_size * table->maxGrowth)
	    break;
        if (size < limit_size)
	    limit_size = size;

	x = y;
	y = cuddZddNextLow(table, x);
    }
    return(moves);

cuddZddSiftingUpOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(NULL);

} /* end of cuddZddSiftingUp */


/**
  @brief Sifts a variable down.

  @details Moves x down until either it reaches the bound (x_high) or
  the size of the %ZDD heap increases too much.

  @return the set of moves in case of success; NULL if memory is
  full.

  @sideeffect None

*/
static Move *
cuddZddSiftingDown(
  DdManager * table,
  int  x,
  int  x_high,
  int  initial_size)
{
    Move	*moves;
    Move	*move;
    int		y;
    int		size;
    int		limit_size = initial_size;

    moves = NULL;
    y = cuddZddNextHigh(table, x);
    while (y <= x_high) {
	size = cuddZddSwapInPlace(table, x, y);
	if (size == 0)
	    goto cuddZddSiftingDownOutOfMem;
	move = (Move *)cuddDynamicAllocNode(table);
	if (move == NULL)
	    goto cuddZddSiftingDownOutOfMem;
	move->x = x;
	move->y = y;
	move->size = size;
	move->next = moves;
	moves = move;

	if ((double)size > (double)limit_size * table->maxGrowth)
	    break;
        if (size < limit_size)
	    limit_size = size;

	x = y;
	y = cuddZddNextHigh(table, x);
    }
    return(moves);

cuddZddSiftingDownOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(NULL);

} /* end of cuddZddSiftingDown */


/**
  @brief Given a set of moves, returns the %ZDD heap to the position
  giving the minimum size.

  @details In case of ties, returns to the closest position giving the
  minimum size.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
cuddZddSiftingBackward(
  DdManager * table,
  Move * moves,
  int  size)
{
    int	    	i;
    int		i_best;
    Move	*move;
    int		res;

    /* Find the minimum size among moves. */
    i_best = -1;
    for (move = moves, i = 0; move != NULL; move = move->next, i++) {
	if (move->size < size) {
	    i_best = i;
	    size = move->size;
	}
    }

    for (move = moves, i = 0; move != NULL; move = move->next, i++) {
	if (i == i_best)
	    break;
	res = cuddZddSwapInPlace(table, move->x, move->y);
	if (!res)
	    return(0);
	if (i_best == -1 && res == size)
	    break;
    }

    return(1);

} /* end of cuddZddSiftingBackward */


/**
  @brief Prepares the %ZDD heap for dynamic reordering.

  @details Does garbage collection, to guarantee that there are no
  dead nodes; and clears the cache, which is invalidated by dynamic
  reordering.

  @sideeffect None

*/
static void
zddReorderPreprocess(
  DdManager * table)
{

    /* Clear the cache. */
    cuddCacheFlush(table);

    /* Eliminate dead nodes. Do not scan the cache again. */
    cuddGarbageCollect(table,0);

    return;

} /* end of ddReorderPreprocess */


/**
  @brief Shrinks almost empty %ZDD subtables at the end of reordering
  to guarantee that they have a reasonable load factor.

  @details However, if there many nodes are being reclaimed, then no
  resizing occurs.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zddReorderPostprocess(
  DdManager * table)
{
    int i, j, posn;
    DdNodePtr *nodelist, *oldnodelist;
    DdNode *node, *next;
    unsigned int slots, oldslots;
    extern DD_OOMFP MMoutOfMemory;
    DD_OOMFP saveHandler;

#ifdef DD_VERBOSE
    (void) fflush(table->out);
#endif

    /* If we have very many reclaimed nodes, we do not want to shrink
    ** the subtables, because this will lead to more garbage
    ** collections. More garbage collections mean shorter mean life for
    ** nodes with zero reference count; hence lower probability of finding
    ** a result in the cache.
    */
    if (table->reclaimed > table->allocated * 0.5) return(1);

    /* Resize subtables. */
    for (i = 0; i < table->sizeZ; i++) {
	int shift;
	oldslots = table->subtableZ[i].slots;
	if (oldslots < table->subtableZ[i].keys * DD_MAX_SUBTABLE_SPARSITY ||
	    oldslots <= table->initSlots) continue;
	oldnodelist = table->subtableZ[i].nodelist;
	slots = oldslots >> 1;
	saveHandler = MMoutOfMemory;
	MMoutOfMemory = table->outOfMemCallback;
	nodelist = ALLOC(DdNodePtr, slots);
	MMoutOfMemory = saveHandler;
	if (nodelist == NULL) {
	    return(1);
	}
	table->subtableZ[i].nodelist = nodelist;
	table->subtableZ[i].slots = slots;
	table->subtableZ[i].shift++;
	table->subtableZ[i].maxKeys = slots * DD_MAX_SUBTABLE_DENSITY;
#ifdef DD_VERBOSE
	(void) fprintf(table->err,
		       "shrunk layer %d (%d keys) from %d to %d slots\n",
		       i, table->subtableZ[i].keys, oldslots, slots);
#endif

	for (j = 0; (unsigned) j < slots; j++) {
	    nodelist[j] = NULL;
	}
	shift = table->subtableZ[i].shift;
	for (j = 0; (unsigned) j < oldslots; j++) {
	    node = oldnodelist[j];
	    while (node != NULL) {
		next = node->next;
		posn = ddHash(cuddT(node), cuddE(node), shift);
		node->next = nodelist[posn];
		nodelist[posn] = node;
		node = next;
	    }
	}
	FREE(oldnodelist);

	table->memused += (slots - oldslots) * sizeof(DdNode *);
	table->slots += slots - oldslots;
	table->minDead = (unsigned) (table->gcFrac * (double) table->slots);
	table->cacheSlack = (int) ddMin(table->maxCacheHard,
	    DD_MAX_CACHE_TO_SLOTS_RATIO*table->slots) -
	    2 * (int) table->cacheSlots;
    }
    /* We don't look at the constant subtable, because it is not
    ** affected by reordering.
    */

    return(1);

} /* end of zddReorderPostprocess */


/**
  @brief Reorders %ZDD variables according to a given permutation.

  @details The i-th permutation array contains the index of the
  variable that should be brought to the i-th level. zddShuffle
  assumes that no dead nodes are present.  The reordering is achieved
  by a series of upward sifts.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
zddShuffle(
  DdManager * table,
  int * permutation)
{
    int		index;
    int		level;
    int		position;
    int		numvars;
    int		result;
#ifdef DD_STATS
    unsigned long localTime;
    int		initialSize;
    int		finalSize;
    int		previousSize;
#endif

    table->zddTotalNumberSwapping = 0;
#ifdef DD_STATS
    localTime = util_cpu_time();
    initialSize = table->keysZ;
    (void) fprintf(table->out,"#:I_SHUFFLE %8d: initial size\n",
		   initialSize); 
#endif

    numvars = table->sizeZ;

    for (level = 0; level < numvars; level++) {
	index = permutation[level];
	position = table->permZ[index];
#ifdef DD_STATS
	previousSize = table->keysZ;
#endif
	result = zddSiftUp(table,position,level);
	if (!result) return(0);
#ifdef DD_STATS
	if (table->keysZ < (unsigned) previousSize) {
	    (void) fprintf(table->out,"-");
	} else if (table->keysZ > (unsigned) previousSize) {
	    (void) fprintf(table->out,"+");	/* should never happen */
	} else {
	    (void) fprintf(table->out,"=");
	}
	fflush(table->out);
#endif
    }

#ifdef DD_STATS
    (void) fprintf(table->out,"\n");
    finalSize = table->keysZ;
    (void) fprintf(table->out,"#:F_SHUFFLE %8d: final size\n",finalSize); 
    (void) fprintf(table->out,"#:T_SHUFFLE %8g: total time (sec)\n",
	((double)(util_cpu_time() - localTime)/1000.0)); 
    (void) fprintf(table->out,"#:N_SHUFFLE %8d: total swaps\n",
		   table->zddTotalNumberSwapping);
#endif

    return(1);

} /* end of zddShuffle */


/**
  @brief Moves one %ZDD variable up.

  @details Takes a %ZDD variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.

  @return 1 if successful; 0 otherwise

  @sideeffect None

*/
static int
zddSiftUp(
  DdManager * table,
  int  x,
  int  xLow)
{
    int        y;
    int        size;

    y = cuddZddNextLow(table,x);
    while (y >= xLow) {
	size = cuddZddSwapInPlace(table,y,x);
	if (size == 0) {
	    return(0);
	}
	x = y;
	y = cuddZddNextLow(table,x);
    }
    return(1);

} /* end of zddSiftUp */


/**
  @brief Fixes the %ZDD variable group tree after a shuffle.

  @details Assumes that the order of the variables in a terminal node
  has not been changed.

  @sideeffect Changes the %ZDD variable group tree.

*/
static void
zddFixTree(
  DdManager * table,
  MtrNode * treenode)
{
    if (treenode == NULL) return;
    treenode->low = ((int) treenode->index < table->sizeZ) ?
	(MtrHalfWord) table->permZ[treenode->index] : treenode->index;
    if (treenode->child != NULL) {
	zddFixTree(table, treenode->child);
    }
    if (treenode->younger != NULL)
	zddFixTree(table, treenode->younger);
    if (treenode->parent != NULL && treenode->low < treenode->parent->low) {
	treenode->parent->low = treenode->low;
	treenode->parent->index = treenode->index;
    }
    return;

} /* end of zddFixTree */


cuddZddSetop.c
23818
/**
  @file

  @ingroup cudd

  @brief Set operations on ZDDs.

  @author Hyong-Kyoon Shin, In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static DdNode * zdd_subset1_aux (DdManager *zdd, DdNode *P, DdNode *zvar);
static DdNode * zdd_subset0_aux (DdManager *zdd, DdNode *P, DdNode *zvar);
static void zddVarToConst (DdNode *f, DdNode **gp, DdNode **hp, DdNode *base, DdNode *empty);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Computes the ITE of three ZDDs.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_zddIte(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddZddIte(dd, f, g, h);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddIte */


/**
  @brief Computes the union of two ZDDs.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_zddUnion(
  DdManager * dd,
  DdNode * P,
  DdNode * Q)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddZddUnion(dd, P, Q);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddUnion */


/**
  @brief Computes the intersection of two ZDDs.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_zddIntersect(
  DdManager * dd,
  DdNode * P,
  DdNode * Q)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddZddIntersect(dd, P, Q);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddIntersect */


/**
  @brief Computes the difference of two ZDDs.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_zddDiff(
  DdManager * dd,
  DdNode * P,
  DdNode * Q)
{
    DdNode *res;

    do {
	dd->reordered = 0;
	res = cuddZddDiff(dd, P, Q);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddDiff */


/**
  @brief Performs the inclusion test for ZDDs (P implies Q).

  @details No new nodes are generated by this procedure.

  @return empty if true; a valid pointer different from empty or
  DD_NON_CONSTANT otherwise.

  @sideeffect None

  @see Cudd_zddDiff

*/
DdNode *
Cudd_zddDiffConst(
  DdManager * zdd,
  DdNode * P,
  DdNode * Q)
{
    int		p_top, q_top;
    DdNode	*empty = DD_ZERO(zdd), *t, *res;
    DdManager	*table = zdd;

    statLine(zdd);
    if (P == empty)
	return(empty);
    if (Q == empty)
	return(P);
    if (P == Q)
	return(empty);

    /* Check cache.  The cache is shared by cuddZddDiff(). */
    res = cuddCacheLookup2Zdd(table, cuddZddDiff, P, Q);
    if (res != NULL)
	return(res);

    if (cuddIsConstant(P))
	p_top = P->index;
    else
	p_top = zdd->permZ[P->index];
    if (cuddIsConstant(Q))
	q_top = Q->index;
    else
	q_top = zdd->permZ[Q->index];
    if (p_top < q_top) {
	res = DD_NON_CONSTANT;
    } else if (p_top > q_top) {
	res = Cudd_zddDiffConst(zdd, P, cuddE(Q));
    } else {
	t = Cudd_zddDiffConst(zdd, cuddT(P), cuddT(Q));
	if (t != empty)
	    res = DD_NON_CONSTANT;
	else
	    res = Cudd_zddDiffConst(zdd, cuddE(P), cuddE(Q));
    }

    cuddCacheInsert2(table, cuddZddDiff, P, Q, res);

    return(res);

} /* end of Cudd_zddDiffConst */


/**
  @brief Computes the positive cofactor of a %ZDD w.r.t. a variable.

  @details In terms of combinations, the result is the set of all
  combinations in which the variable is asserted.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddSubset0

*/
DdNode *
Cudd_zddSubset1(
  DdManager * dd,
  DdNode * P,
  int  var)
{
    DdNode	*r;

    do {
	dd->reordered = 0;
	r = cuddZddSubset1(dd, P, var);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(r);

} /* end of Cudd_zddSubset1 */


/**
  @brief Computes the negative cofactor of a %ZDD w.r.t. a variable.

  @details In terms of combinations, the result is the set of all
  combinations in which the variable is negated.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddSubset1

*/
DdNode *
Cudd_zddSubset0(
  DdManager * dd,
  DdNode * P,
  int  var)
{
    DdNode	*r;

    do {
	dd->reordered = 0;
	r = cuddZddSubset0(dd, P, var);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }

    return(r);

} /* end of Cudd_zddSubset0 */


/**
  @brief Substitutes a variable with its complement in a %ZDD.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

*/
DdNode *
Cudd_zddChange(
  DdManager * dd,
  DdNode * P,
  int  var)
{
    DdNode	*res;

    if ((unsigned int) var >= CUDD_MAXINDEX - 1) return(NULL);
    
    do {
	dd->reordered = 0;
	res = cuddZddChange(dd, P, var);
    } while (dd->reordered == 1);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddChange */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_zddIte.

  @sideeffect None

*/
DdNode *
cuddZddIte(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  DdNode * h)
{
    DdNode *tautology, *empty;
    DdNode *r,*Gv,*Gvn,*Hv,*Hvn,*t,*e;
    int topf,topg,toph,v,top;
    unsigned int index;

    statLine(dd);
    /* Trivial cases. */
    /* One variable cases. */
    if (f == (empty = DD_ZERO(dd))) {	/* ITE(0,G,H) = H */
	return(h);
    }
    topf = cuddIZ(dd,f->index);
    topg = cuddIZ(dd,g->index);
    toph = cuddIZ(dd,h->index);
    v = ddMin(topg,toph);
    top  = ddMin(topf,v);

    tautology = (top == CUDD_MAXINDEX) ? DD_ONE(dd) : dd->univ[top];
    if (f == tautology) {			/* ITE(1,G,H) = G */
    	return(g);
    }

    /* From now on, f is known to not be a constant. */
    zddVarToConst(f,&g,&h,tautology,empty);

    /* Check remaining one variable cases. */
    if (g == h) {			/* ITE(F,G,G) = G */
	return(g);
    }

    if (g == tautology) {			/* ITE(F,1,0) = F */
	if (h == empty) return(f);
    }

    /* Check cache. */
    r = cuddCacheLookupZdd(dd,DD_ZDD_ITE_TAG,f,g,h);
    if (r != NULL) {
	return(r);
    }

    /* Recompute these because they may have changed in zddVarToConst. */
    topg = cuddIZ(dd,g->index);
    toph = cuddIZ(dd,h->index);
    v = ddMin(topg,toph);

    if (topf < v) {
	r = cuddZddIte(dd,cuddE(f),g,h);
	if (r == NULL) return(NULL);
    } else if (topf > v) {
	if (topg > v) {
	    Gvn = g;
	    index = h->index;
	} else {
	    Gvn = cuddE(g);
	    index = g->index;
	}
	if (toph > v) {
	    Hv = empty; Hvn = h;
	} else {
	    Hv = cuddT(h); Hvn = cuddE(h);
	}
	e = cuddZddIte(dd,f,Gvn,Hvn);
	if (e == NULL) return(NULL);
	cuddRef(e);
	r = cuddZddGetNode(dd,index,Hv,e);
	if (r == NULL) {
	    Cudd_RecursiveDerefZdd(dd,e);
	    return(NULL);
	}
	cuddDeref(e);
    } else {
	index = f->index;
	if (topg > v) {
	    Gv = empty; Gvn = g;
	} else {
	    Gv = cuddT(g); Gvn = cuddE(g);
	}
	if (toph > v) {
	    Hv = empty; Hvn = h;
	} else {
	    Hv = cuddT(h); Hvn = cuddE(h);
	}
	e = cuddZddIte(dd,cuddE(f),Gvn,Hvn);
	if (e == NULL) return(NULL);
	cuddRef(e);
	t = cuddZddIte(dd,cuddT(f),Gv,Hv);
	if (t == NULL) {
	    Cudd_RecursiveDerefZdd(dd,e);
	    return(NULL);
	}
	cuddRef(t);
	r = cuddZddGetNode(dd,index,t,e);
	if (r == NULL) {
	    Cudd_RecursiveDerefZdd(dd,e);
	    Cudd_RecursiveDerefZdd(dd,t);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert(dd,DD_ZDD_ITE_TAG,f,g,h,r);

    return(r);

} /* end of cuddZddIte */


/**
  @brief Performs the recursive step of Cudd_zddUnion.

  @sideeffect None

*/
DdNode *
cuddZddUnion(
  DdManager * zdd,
  DdNode * P,
  DdNode * Q)
{
    int		p_top, q_top;
    DdNode	*empty = DD_ZERO(zdd), *t, *e, *res;
    DdManager	*table = zdd;

    statLine(zdd);
    if (P == empty)
	return(Q);
    if (Q == empty)
	return(P);
    if (P == Q)
	return(P);

    /* Check cache */
    res = cuddCacheLookup2Zdd(table, cuddZddUnion, P, Q);
    if (res != NULL)
	return(res);

    if (cuddIsConstant(P))
	p_top = P->index;
    else
	p_top = zdd->permZ[P->index];
    if (cuddIsConstant(Q))
	q_top = Q->index;
    else
	q_top = zdd->permZ[Q->index];
    if (p_top < q_top) {
	e = cuddZddUnion(zdd, cuddE(P), Q);
	if (e == NULL) return (NULL);
	cuddRef(e);
	res = cuddZddGetNode(zdd, P->index, cuddT(P), e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(table, e);
	    return(NULL);
	}
	cuddDeref(e);
    } else if (p_top > q_top) {
	e = cuddZddUnion(zdd, P, cuddE(Q));
	if (e == NULL) return(NULL);
	cuddRef(e);
	res = cuddZddGetNode(zdd, Q->index, cuddT(Q), e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(table, e);
	    return(NULL);
	}
	cuddDeref(e);
    } else {
	t = cuddZddUnion(zdd, cuddT(P), cuddT(Q));
	if (t == NULL) return(NULL);
	cuddRef(t);
	e = cuddZddUnion(zdd, cuddE(P), cuddE(Q));
	if (e == NULL) {
	    Cudd_RecursiveDerefZdd(table, t);
	    return(NULL);
	}
	cuddRef(e);
	res = cuddZddGetNode(zdd, P->index, t, e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(table, t);
	    Cudd_RecursiveDerefZdd(table, e);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert2(table, cuddZddUnion, P, Q, res);

    return(res);

} /* end of cuddZddUnion */


/**
  @brief Performs the recursive step of Cudd_zddIntersect.

  @sideeffect None

*/
DdNode *
cuddZddIntersect(
  DdManager * zdd,
  DdNode * P,
  DdNode * Q)
{
    int		p_top, q_top;
    DdNode	*empty = DD_ZERO(zdd), *t, *e, *res;
    DdManager	*table = zdd;

    statLine(zdd);
    if (P == empty)
	return(empty);
    if (Q == empty)
	return(empty);
    if (P == Q)
	return(P);

    /* Check cache. */
    res = cuddCacheLookup2Zdd(table, cuddZddIntersect, P, Q);
    if (res != NULL)
	return(res);

    if (cuddIsConstant(P))
	p_top = P->index;
    else
	p_top = zdd->permZ[P->index];
    if (cuddIsConstant(Q))
	q_top = Q->index;
    else
	q_top = zdd->permZ[Q->index];
    if (p_top < q_top) {
	res = cuddZddIntersect(zdd, cuddE(P), Q);
	if (res == NULL) return(NULL);
    } else if (p_top > q_top) {
	res = cuddZddIntersect(zdd, P, cuddE(Q));
	if (res == NULL) return(NULL);
    } else {
	t = cuddZddIntersect(zdd, cuddT(P), cuddT(Q));
	if (t == NULL) return(NULL);
	cuddRef(t);
	e = cuddZddIntersect(zdd, cuddE(P), cuddE(Q));
	if (e == NULL) {
	    Cudd_RecursiveDerefZdd(table, t);
	    return(NULL);
	}
	cuddRef(e);
	res = cuddZddGetNode(zdd, P->index, t, e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(table, t);
	    Cudd_RecursiveDerefZdd(table, e);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert2(table, cuddZddIntersect, P, Q, res);

    return(res);

} /* end of cuddZddIntersect */


/**
  @brief Performs the recursive step of Cudd_zddDiff.

  @sideeffect None

*/
DdNode *
cuddZddDiff(
  DdManager * zdd,
  DdNode * P,
  DdNode * Q)
{
    int		p_top, q_top;
    DdNode	*empty = DD_ZERO(zdd), *t, *e, *res;
    DdManager	*table = zdd;

    statLine(zdd);
    if (P == empty)
	return(empty);
    if (Q == empty)
	return(P);
    if (P == Q)
	return(empty);

    /* Check cache.  The cache is shared by Cudd_zddDiffConst(). */
    res = cuddCacheLookup2Zdd(table, cuddZddDiff, P, Q);
    if (res != NULL && res != DD_NON_CONSTANT)
	return(res);

    if (cuddIsConstant(P))
	p_top = P->index;
    else
	p_top = zdd->permZ[P->index];
    if (cuddIsConstant(Q))
	q_top = Q->index;
    else
	q_top = zdd->permZ[Q->index];
    if (p_top < q_top) {
	e = cuddZddDiff(zdd, cuddE(P), Q);
	if (e == NULL) return(NULL);
	cuddRef(e);
	res = cuddZddGetNode(zdd, P->index, cuddT(P), e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(table, e);
	    return(NULL);
	}
	cuddDeref(e);
    } else if (p_top > q_top) {
	res = cuddZddDiff(zdd, P, cuddE(Q));
	if (res == NULL) return(NULL);
    } else {
	t = cuddZddDiff(zdd, cuddT(P), cuddT(Q));
	if (t == NULL) return(NULL);
	cuddRef(t);
	e = cuddZddDiff(zdd, cuddE(P), cuddE(Q));
	if (e == NULL) {
	    Cudd_RecursiveDerefZdd(table, t);
	    return(NULL);
	}
	cuddRef(e);
	res = cuddZddGetNode(zdd, P->index, t, e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(table, t);
	    Cudd_RecursiveDerefZdd(table, e);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert2(table, cuddZddDiff, P, Q, res);

    return(res);

} /* end of cuddZddDiff */


/**
  @brief Performs the recursive step of Cudd_zddChange.

  @sideeffect None

*/
DdNode *
cuddZddChangeAux(
  DdManager * zdd,
  DdNode * P,
  DdNode * zvar)
{
    int		top_var, level;
    DdNode	*res, *t, *e;
    DdNode	*base = DD_ONE(zdd);
    DdNode	*empty = DD_ZERO(zdd);

    statLine(zdd);
    if (P == empty)
	return(empty);
    if (P == base)
	return(zvar);

    /* Check cache. */
    res = cuddCacheLookup2Zdd(zdd, cuddZddChangeAux, P, zvar);
    if (res != NULL)
	return(res);

    top_var = zdd->permZ[P->index];
    level = zdd->permZ[zvar->index];

    if (top_var > level) {
	res = cuddZddGetNode(zdd, zvar->index, P, DD_ZERO(zdd));
	if (res == NULL) return(NULL);
    } else if (top_var == level) {
	res = cuddZddGetNode(zdd, zvar->index, cuddE(P), cuddT(P));
	if (res == NULL) return(NULL);
    } else {
	t = cuddZddChangeAux(zdd, cuddT(P), zvar);
	if (t == NULL) return(NULL);
	cuddRef(t);
	e = cuddZddChangeAux(zdd, cuddE(P), zvar);
	if (e == NULL) {
	    Cudd_RecursiveDerefZdd(zdd, t);
	    return(NULL);
	}
	cuddRef(e);
	res = cuddZddGetNode(zdd, P->index, t, e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(zdd, t);
	    Cudd_RecursiveDerefZdd(zdd, e);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert2(zdd, cuddZddChangeAux, P, zvar, res);

    return(res);

} /* end of cuddZddChangeAux */


/**
  @brief Computes the positive cofactor of a %ZDD w.r.t. a variable.

  @details In terms of combinations, the result is the set of all
  combinations in which the variable is asserted.  cuddZddSubset1
  performs the same function as Cudd_zddSubset1, but does not restart
  if reordering has taken place. Therefore it can be called from
  within a recursive procedure.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see cuddZddSubset0 Cudd_zddSubset1

*/
DdNode *
cuddZddSubset1(
  DdManager * dd,
  DdNode * P,
  int  var)
{
    DdNode	*zvar, *r;
    DdNode	*base, *empty;

    base = DD_ONE(dd);
    empty = DD_ZERO(dd);

    zvar = cuddUniqueInterZdd(dd, var, base, empty);
    if (zvar == NULL) {
	return(NULL);
    } else {
	cuddRef(zvar);
	r = zdd_subset1_aux(dd, P, zvar);
	if (r == NULL) {
	    Cudd_RecursiveDerefZdd(dd, zvar);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_RecursiveDerefZdd(dd, zvar);
    }

    cuddDeref(r);
    return(r);

} /* end of cuddZddSubset1 */


/**
  @brief Computes the negative cofactor of a %ZDD w.r.t. a variable.

  @details In terms of combinations, the result is the set of all
  combinations in which the variable is negated.  cuddZddSubset0
  performs the same function as Cudd_zddSubset0, but does not restart
  if reordering has taken place. Therefore it can be called from
  within a recursive procedure.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see cuddZddSubset1 Cudd_zddSubset0

*/
DdNode *
cuddZddSubset0(
  DdManager * dd,
  DdNode * P,
  int  var)
{
    DdNode	*zvar, *r;
    DdNode	*base, *empty;

    base = DD_ONE(dd);
    empty = DD_ZERO(dd);

    zvar = cuddUniqueInterZdd(dd, var, base, empty);
    if (zvar == NULL) {
	return(NULL);
    } else {
	cuddRef(zvar);
	r = zdd_subset0_aux(dd, P, zvar);
	if (r == NULL) {
	    Cudd_RecursiveDerefZdd(dd, zvar);
	    return(NULL);
	}
	cuddRef(r);
	Cudd_RecursiveDerefZdd(dd, zvar);
    }

    cuddDeref(r);
    return(r);

} /* end of cuddZddSubset0 */


/**
  @brief Substitutes a variable with its complement in a %ZDD.

  @details cuddZddChange performs the same function as Cudd_zddChange,
  but does not restart if reordering has taken place. Therefore it can
  be called from within a recursive procedure.

  @return a pointer to the result if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddChange

*/
DdNode *
cuddZddChange(
  DdManager * dd,
  DdNode * P,
  int  var)
{
    DdNode	*zvar, *res;

    zvar = cuddUniqueInterZdd(dd, var, DD_ONE(dd), DD_ZERO(dd));
    if (zvar == NULL) return(NULL);
    cuddRef(zvar);

    res = cuddZddChangeAux(dd, P, zvar);
    if (res == NULL) {
	Cudd_RecursiveDerefZdd(dd,zvar);
	return(NULL);
    }
    cuddRef(res);
    Cudd_RecursiveDerefZdd(dd,zvar);
    cuddDeref(res);
    return(res);

} /* end of cuddZddChange */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of Cudd_zddSubset1.

  @sideeffect None

*/
static DdNode *
zdd_subset1_aux(
  DdManager * zdd,
  DdNode * P,
  DdNode * zvar)
{
    int		top_var, level;
    DdNode	*res, *t, *e;
    DdNode	*empty;

    statLine(zdd);
    empty = DD_ZERO(zdd);

    /* Check cache. */
    res = cuddCacheLookup2Zdd(zdd, zdd_subset1_aux, P, zvar);
    if (res != NULL)
	return(res);

    if (cuddIsConstant(P)) {
	res = empty;
	cuddCacheInsert2(zdd, zdd_subset1_aux, P, zvar, res);
	return(res);
    }

    top_var = zdd->permZ[P->index];
    level = zdd->permZ[zvar->index];

    if (top_var > level) {
        res = empty;
    } else if (top_var == level) {
	res = cuddT(P);
    } else {
        t = zdd_subset1_aux(zdd, cuddT(P), zvar);
	if (t == NULL) return(NULL);
	cuddRef(t);
        e = zdd_subset1_aux(zdd, cuddE(P), zvar);
	if (e == NULL) {
	    Cudd_RecursiveDerefZdd(zdd, t);
	    return(NULL);
	}
	cuddRef(e);
        res = cuddZddGetNode(zdd, P->index, t, e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(zdd, t);
	    Cudd_RecursiveDerefZdd(zdd, e);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert2(zdd, zdd_subset1_aux, P, zvar, res);

    return(res);

} /* end of zdd_subset1_aux */


/**
  @brief Performs the recursive step of Cudd_zddSubset0.

  @sideeffect None

*/
static DdNode *
zdd_subset0_aux(
  DdManager * zdd,
  DdNode * P,
  DdNode * zvar)
{
    int		top_var, level;
    DdNode	*res, *t, *e;

    statLine(zdd);

    /* Check cache. */
    res = cuddCacheLookup2Zdd(zdd, zdd_subset0_aux, P, zvar);
    if (res != NULL)
	return(res);

    if (cuddIsConstant(P)) {
	res = P;
	cuddCacheInsert2(zdd, zdd_subset0_aux, P, zvar, res);
	return(res);
    }

    top_var = zdd->permZ[P->index];
    level = zdd->permZ[zvar->index];

    if (top_var > level) {
        res = P;
    }
    else if (top_var == level) {
        res = cuddE(P);
    }
    else {
        t = zdd_subset0_aux(zdd, cuddT(P), zvar);
	if (t == NULL) return(NULL);
	cuddRef(t);
        e = zdd_subset0_aux(zdd, cuddE(P), zvar);
	if (e == NULL) {
	    Cudd_RecursiveDerefZdd(zdd, t);
	    return(NULL);
	}
	cuddRef(e);
        res = cuddZddGetNode(zdd, P->index, t, e);
	if (res == NULL) {
	    Cudd_RecursiveDerefZdd(zdd, t);
	    Cudd_RecursiveDerefZdd(zdd, e);
	    return(NULL);
	}
	cuddDeref(t);
	cuddDeref(e);
    }

    cuddCacheInsert2(zdd, zdd_subset0_aux, P, zvar, res);

    return(res);

} /* end of zdd_subset0_aux */


/**
  @brief Replaces variables with constants if possible (part of
  canonical form).

  @sideeffect None

*/
static void
zddVarToConst(
  DdNode * f,
  DdNode ** gp,
  DdNode ** hp,
  DdNode * base,
  DdNode * empty)
{
    DdNode *g = *gp;
    DdNode *h = *hp;

    if (f == g) { /* ITE(F,F,H) = ITE(F,1,H) = F + H */
	*gp = base;
    }

    if (f == h) { /* ITE(F,G,F) = ITE(F,G,0) = F * G */
	*hp = empty;
    }

} /* end of zddVarToConst */


cuddZddSymm.c
43419
/**
  @file

  @ingroup cudd

  @brief Functions for symmetry-based %ZDD variable reordering.

  @see cuddSymmetry.c

  @author Hyong-Kyoon Shin, In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define ZDD_MV_OOM (Move *)1

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int cuddZddSymmSiftingAux (DdManager *table, int x, int x_low, int x_high);
static int cuddZddSymmSiftingConvAux (DdManager *table, int x, int x_low, int x_high);
static Move * cuddZddSymmSifting_up (DdManager *table, int x, int x_low, int initial_size);
static Move * cuddZddSymmSifting_down (DdManager *table, int x, int x_high, int initial_size);
static int cuddZddSymmSiftingBackward (DdManager *table, Move *moves, int size);
static int zdd_group_move (DdManager *table, int x, int y, Move **moves);
static int zdd_group_move_backward (DdManager *table, int x, int y);
static void cuddZddSymmSummary (DdManager *table, int lower, int upper, int *symvars, int *symgroups);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints statistics on symmetric %ZDD variables.

  @sideeffect None

*/
void
Cudd_zddSymmProfile(
  DdManager * table,
  int  lower,
  int  upper)
{
    int		i, x, gbot;
    int		TotalSymm = 0;
    int 	TotalSymmGroups = 0;

    for (i = lower; i < upper; i++) {
	if (table->subtableZ[i].next != (unsigned) i) {
	    x = i;
	    (void) fprintf(table->out,"Group:");
	    do {
		(void) fprintf(table->out,"  %d", table->invpermZ[x]);
		TotalSymm++;
		gbot = x;
		x = table->subtableZ[x].next;
	    } while (x != i);
	    TotalSymmGroups++;
#ifdef DD_DEBUG
	    assert(table->subtableZ[gbot].next == (unsigned) i);
#endif
	    i = gbot;
	    (void) fprintf(table->out,"\n");
	}
    }
    (void) fprintf(table->out,"Total Symmetric = %d\n", TotalSymm);
    (void) fprintf(table->out,"Total Groups = %d\n", TotalSymmGroups);

} /* end of Cudd_zddSymmProfile */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Checks for symmetry of x and y.

  @details Ignores projection functions, unless they are isolated.

  @return 1 in case of symmetry; 0 otherwise.

  @sideeffect None

*/
int
cuddZddSymmCheck(
  DdManager * table,
  int  x,
  int  y)
{
    int		i;
    DdNode	*f, *f0, *f1, *f01, *f00, *f11, *f10;
    int		yindex;
    int 	xsymmy = 1;
    int		xsymmyp = 1;
    int 	arccount = 0;
    int 	TotalRefCount = 0;
    int 	symm_found;
    DdNode	*empty = table->zero;

    yindex = table->invpermZ[y];
    for (i = table->subtableZ[x].slots - 1; i >= 0; i--) {
	f = table->subtableZ[x].nodelist[i];
	while (f != NULL) {
	    /* Find f1, f0, f11, f10, f01, f00 */
	    f1 = cuddT(f);
	    f0 = cuddE(f);
	    if ((int) f1->index == yindex) {
		f11 = cuddT(f1);
		f10 = cuddE(f1);
		if (f10 != empty)
		    arccount++;
	    } else {
		if ((int) f0->index != yindex) {
		    return(0); /* f bypasses layer y */
		}
		f11 = empty;
		f10 = f1;
	    }
	    if ((int) f0->index == yindex) {
		f01 = cuddT(f0);
		f00 = cuddE(f0);
		if (f00 != empty)
		    arccount++;
	    } else {
		f01 = empty;
		f00 = f0;
	    }
	    if (f01 != f10)
		xsymmy = 0;
	    if (f11 != f00)
		xsymmyp = 0;
	    if ((xsymmy == 0) && (xsymmyp == 0))
		return(0);

	    f = f->next;
	} /* for each element of the collision list */
    } /* for each slot of the subtable */

    /* Calculate the total reference counts of y
    ** whose else arc is not empty.
    */
    for (i = table->subtableZ[y].slots - 1; i >= 0; i--) {
	f = table->subtableZ[y].nodelist[i];
	while (f != NIL(DdNode)) {
	    if (cuddE(f) != empty)
		TotalRefCount += f->ref;
	    f = f->next;
	}
    }

    symm_found = (arccount == TotalRefCount);
#if defined(DD_DEBUG) && defined(DD_VERBOSE)
    if (symm_found) {
	int xindex = table->invpermZ[x];
	(void) fprintf(table->out,
		       "Found symmetry! x =%d\ty = %d\tPos(%d,%d)\n",
		       xindex,yindex,x,y);
    }
#endif

    return(symm_found);

} /* end cuddZddSymmCheck */


/**
  @brief Symmetric sifting algorithm for ZDDs.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the %ZDD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>

  @return 1 plus the number of symmetric variables if successful; 0
  otherwise.

  @sideeffect None

  @see cuddZddSymmSiftingConv

*/
int
cuddZddSymmSifting(
  DdManager * table,
  int  lower,
  int  upper)
{
    int		i;
    IndexKey	*var;
    int		nvars;
    int		x;
    int		result;
    int		symvars;
    int		symgroups;
    int		iteration;
#ifdef DD_STATS
    int		previousSize;
#endif

    nvars = table->sizeZ;

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey, nvars);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto cuddZddSymmSiftingOutOfMem;
    }

    for (i = 0; i < nvars; i++) {
	x = table->permZ[i];
	var[i].index = i;
	var[i].keys = table->subtableZ[x].keys;
    }

    util_qsort(var, nvars, sizeof(IndexKey), cuddZddUniqueCompare);

    /* Initialize the symmetry of each subtable to itself. */
    for (i = lower; i <= upper; i++)
	table->subtableZ[i].next = i;

    iteration = ddMin(table->siftMaxVar, nvars);
    for (i = 0; i < iteration; i++) {
	if (table->zddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime > table->timeLimit) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
	x = table->permZ[var[i].index];
#ifdef DD_STATS
	previousSize = table->keysZ;
#endif
	if (x < lower || x > upper) continue;
	if (table->subtableZ[x].next == (unsigned) x) {
	    result = cuddZddSymmSiftingAux(table, x, lower, upper);
	    if (!result)
		goto cuddZddSymmSiftingOutOfMem;
#ifdef DD_STATS
	    if (table->keysZ < (unsigned) previousSize) {
		(void) fprintf(table->out,"-");
	    } else if (table->keysZ > (unsigned) previousSize) {
		(void) fprintf(table->out,"+");
#ifdef DD_VERBOSE
		(void) fprintf(table->out,"\nSize increased from %d to %d while sifting variable %d\n", previousSize, table->keysZ, var[i].index);
#endif
	    } else {
		(void) fprintf(table->out,"=");
	    }
	    fflush(table->out);
#endif
	}
    }

    FREE(var);

    cuddZddSymmSummary(table, lower, upper, &symvars, &symgroups);

#ifdef DD_STATS
    (void) fprintf(table->out,"\n#:S_SIFTING %8d: symmetric variables\n",symvars);
    (void) fprintf(table->out,"#:G_SIFTING %8d: symmetric groups\n",symgroups);
#endif

    return(1+symvars);

cuddZddSymmSiftingOutOfMem:

    if (var != NULL)
	FREE(var);

    return(0);

} /* end of cuddZddSymmSifting */


/**
  @brief Symmetric sifting to convergence algorithm for ZDDs.

  @details Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the %ZDD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    <li> Repeat 1-4 until no further improvement.
    </ol>

  @return 1 plus the number of symmetric variables if successful; 0
  otherwise.

  @sideeffect None

  @see cuddZddSymmSifting

*/
int
cuddZddSymmSiftingConv(
  DdManager * table,
  int  lower,
  int  upper)
{
    int		i;
    IndexKey	*var;
    int		nvars;
    int		initialSize;
    int		x;
    int		result;
    int		symvars;
    int		symgroups;
    int		classes;
    int		iteration;
#ifdef DD_STATS
    int         previousSize;
#endif

    initialSize = table->keysZ;

    nvars = table->sizeZ;

    /* Find order in which to sift variables. */
    var = ALLOC(IndexKey, nvars);
    if (var == NULL) {
	table->errorCode = CUDD_MEMORY_OUT;
	goto cuddZddSymmSiftingConvOutOfMem;
    }

    for (i = 0; i < nvars; i++) {
	x = table->permZ[i];
	var[i].index = i;
	var[i].keys = table->subtableZ[x].keys;
    }

    util_qsort(var, nvars, sizeof(IndexKey), cuddZddUniqueCompare);

    /* Initialize the symmetry of each subtable to itself
    ** for first pass of converging symmetric sifting.
    */
    for (i = lower; i <= upper; i++)
	table->subtableZ[i].next = i;

    iteration = ddMin(table->siftMaxVar, table->sizeZ);
    for (i = 0; i < iteration; i++) {
	if (table->zddTotalNumberSwapping >= table->siftMaxSwap)
	    break;
        if (util_cpu_time() - table->startTime > table->timeLimit) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
        if (table->terminationCallback != NULL &&
            table->terminationCallback(table->tcbArg)) {
            table->autoDynZ = 0; /* prevent further reordering */
            break;
        }
	x = table->permZ[var[i].index];
	if (x < lower || x > upper) continue;
	/* Only sift if not in symmetry group already. */
	if (table->subtableZ[x].next == (unsigned) x) {
#ifdef DD_STATS
	    previousSize = table->keysZ;
#endif
	    result = cuddZddSymmSiftingAux(table, x, lower, upper);
	    if (!result)
		goto cuddZddSymmSiftingConvOutOfMem;
#ifdef DD_STATS
	    if (table->keysZ < (unsigned) previousSize) {
		(void) fprintf(table->out,"-");
	    } else if (table->keysZ > (unsigned) previousSize) {
		(void) fprintf(table->out,"+");
#ifdef DD_VERBOSE
		(void) fprintf(table->out,"\nSize increased from %d to %d while sifting variable %d\n", previousSize, table->keysZ, var[i].index);
#endif
	    } else {
		(void) fprintf(table->out,"=");
	    }
	    fflush(table->out);
#endif
	}
    }

    /* Sifting now until convergence. */
    while ((unsigned) initialSize > table->keysZ) {
	initialSize = table->keysZ;
#ifdef DD_STATS
	(void) fprintf(table->out,"\n");
#endif
	/* Here we consider only one representative for each symmetry class. */
	for (x = lower, classes = 0; x <= upper; x++, classes++) {
	    while ((unsigned) x < table->subtableZ[x].next)
		x = table->subtableZ[x].next;
	    /* Here x is the largest index in a group.
	    ** Groups consists of adjacent variables.
	    ** Hence, the next increment of x will move it to a new group.
	    */
	    i = table->invpermZ[x];
	    var[classes].index = i;
	    var[classes].keys = table->subtableZ[x].keys;
	}

	util_qsort(var,classes,sizeof(IndexKey),cuddZddUniqueCompare);

	/* Now sift. */
	iteration = ddMin(table->siftMaxVar, nvars);
	for (i = 0; i < iteration; i++) {
	    if (table->zddTotalNumberSwapping >= table->siftMaxSwap)
		break;
            if (util_cpu_time() - table->startTime > table->timeLimit) {
              table->autoDynZ = 0; /* prevent further reordering */
              break;
            }
            if (table->terminationCallback != NULL &&
                table->terminationCallback(table->tcbArg)) {
                table->autoDynZ = 0; /* prevent further reordering */
                break;
            }
	    x = table->permZ[var[i].index];
	    if ((unsigned) x >= table->subtableZ[x].next) {
#ifdef DD_STATS
		previousSize = table->keysZ;
#endif
		result = cuddZddSymmSiftingConvAux(table, x, lower, upper);
		if (!result)
		    goto cuddZddSymmSiftingConvOutOfMem;
#ifdef DD_STATS
		if (table->keysZ < (unsigned) previousSize) {
		    (void) fprintf(table->out,"-");
		} else if (table->keysZ > (unsigned) previousSize) {
		    (void) fprintf(table->out,"+");
#ifdef DD_VERBOSE
		(void) fprintf(table->out,"\nSize increased from %d to %d while sifting variable %d\n", previousSize, table->keysZ, var[i].index);
#endif
		} else {
		    (void) fprintf(table->out,"=");
		}
		fflush(table->out);
#endif
	    }
	} /* for */
    }

    cuddZddSymmSummary(table, lower, upper, &symvars, &symgroups);

#ifdef DD_STATS
    (void) fprintf(table->out,"\n#:S_SIFTING %8d: symmetric variables\n",
		   symvars);
    (void) fprintf(table->out,"#:G_SIFTING %8d: symmetric groups\n",
		   symgroups);
#endif

    FREE(var);

    return(1+symvars);

cuddZddSymmSiftingConvOutOfMem:

    if (var != NULL)
	FREE(var);

    return(0);

} /* end of cuddZddSymmSiftingConv */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Given x_low <= x <= x_high moves x up and down between the
  boundaries.

  @details Finds the best position and does the required changes.
  Assumes that x is not part of a symmetry group.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
cuddZddSymmSiftingAux(
  DdManager * table,
  int  x,
  int  x_low,
  int  x_high)
{
    Move *move;
    Move *move_up;	/* list of up move */
    Move *move_down;	/* list of down move */
    int	 initial_size;
    int	 result;
    int	 i;
    int  topbot;	/* index to either top or bottom of symmetry group */
    int	 init_group_size, final_group_size;

    initial_size = table->keysZ;

    move_down = NULL;
    move_up = NULL;

    /* Look for consecutive symmetries above x. */
    for (i = x; i > x_low; i--) {
	if (!cuddZddSymmCheck(table, i - 1, i))
            break;
	/* find top of i-1's symmetry */
	topbot = table->subtableZ[i - 1].next;
	table->subtableZ[i - 1].next = i;
	table->subtableZ[x].next = topbot;
	/* x is bottom of group so its symmetry is top of i-1's
	   group */
	i = topbot + 1; /* add 1 for i--, new i is top of symm group */
    }
    /* Look for consecutive symmetries below x. */
    for (i = x; i < x_high; i++) {
	if (!cuddZddSymmCheck(table, i, i + 1))
            break;
	/* find bottom of i+1's symm group */
	topbot = i + 1;
	while ((unsigned) topbot < table->subtableZ[topbot].next)
	    topbot = table->subtableZ[topbot].next;

	table->subtableZ[topbot].next = table->subtableZ[i].next;
	table->subtableZ[i].next = i + 1;
	i = topbot - 1; /* add 1 for i++,
			   new i is bottom of symm group */
    }

    /* Now x maybe in the middle of a symmetry group. */
    if (x == x_low) { /* Sift down */
	/* Find bottom of x's symm group */
	while ((unsigned) x < table->subtableZ[x].next)
	    x = table->subtableZ[x].next;

	i = table->subtableZ[x].next;
	init_group_size = x - i + 1;

	move_down = cuddZddSymmSifting_down(table, x, x_high,
	    initial_size);
	/* after that point x --> x_high, unless early term */
	if (move_down == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingAuxOutOfMem;

	if (move_down == NULL ||
	    table->subtableZ[move_down->y].next != move_down->y) {
	    /* symmetry detected may have to make another complete
	       pass */
            if (move_down != NULL)
		x = move_down->y;
	    else
		x = table->subtableZ[x].next;
	    i = x;
	    while ((unsigned) i < table->subtableZ[i].next) {
		i = table->subtableZ[i].next;
	    }
	    final_group_size = i - x + 1;

	    if (init_group_size == final_group_size) {
		/* No new symmetry groups detected,
		   return to best position */
		result = cuddZddSymmSiftingBackward(table,
		    move_down, initial_size);
	    }
	    else {
		initial_size = table->keysZ;
		move_up = cuddZddSymmSifting_up(table, x, x_low,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_down,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingAuxOutOfMem;
    }
    else if (x == x_high) { /* Sift up */
	/* Find top of x's symm group */
	while ((unsigned) x < table->subtableZ[x].next)
	    x = table->subtableZ[x].next;
	x = table->subtableZ[x].next;

	i = x;
	while ((unsigned) i < table->subtableZ[i].next) {
	    i = table->subtableZ[i].next;
	}
	init_group_size = i - x + 1;

	move_up = cuddZddSymmSifting_up(table, x, x_low, initial_size);
	/* after that point x --> x_low, unless early term */
	if (move_up == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingAuxOutOfMem;

	if (move_up == NULL ||
	    table->subtableZ[move_up->x].next != move_up->x) {
	    /* symmetry detected may have to make another complete
		pass */
            if (move_up != NULL)
		x = move_up->x;
	    else {
		while ((unsigned) x < table->subtableZ[x].next)
		    x = table->subtableZ[x].next;
	    }
	    i = table->subtableZ[x].next;
	    final_group_size = x - i + 1;

	    if (init_group_size == final_group_size) {
		/* No new symmetry groups detected,
		   return to best position */
		result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
	    }
	    else {
		initial_size = table->keysZ;
		move_down = cuddZddSymmSifting_down(table, x, x_high,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_down,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_up,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingAuxOutOfMem;
    }
    else if ((x - x_low) > (x_high - x)) { /* must go down first:
						shorter */
	/* Find bottom of x's symm group */
	while ((unsigned) x < table->subtableZ[x].next)
	    x = table->subtableZ[x].next;

	move_down = cuddZddSymmSifting_down(table, x, x_high,
	    initial_size);
	/* after that point x --> x_high, unless early term */
	if (move_down == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingAuxOutOfMem;

	if (move_down != NULL) {
	    x = move_down->y;
	}
	else {
	    x = table->subtableZ[x].next;
	}
	i = x;
	while ((unsigned) i < table->subtableZ[i].next) {
	    i = table->subtableZ[i].next;
	}
	init_group_size = i - x + 1;

	move_up = cuddZddSymmSifting_up(table, x, x_low, initial_size);
	if (move_up == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingAuxOutOfMem;

	if (move_up == NULL ||
	    table->subtableZ[move_up->x].next != move_up->x) {
	    /* symmetry detected may have to make another complete
	       pass */
	    if (move_up != NULL) {
		x = move_up->x;
	    }
	    else {
		while ((unsigned) x < table->subtableZ[x].next)
		    x = table->subtableZ[x].next;
	    }
	    i = table->subtableZ[x].next;
	    final_group_size = x - i + 1;

	    if (init_group_size == final_group_size) {
		/* No new symmetry groups detected,
		   return to best position */
		result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
	    }
	    else {
		while (move_down != NULL) {
		    move = move_down->next;
		    cuddDeallocMove(table, move_down);
		    move_down = move;
		}
		initial_size = table->keysZ;
		move_down = cuddZddSymmSifting_down(table, x, x_high,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_down,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_up,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingAuxOutOfMem;
    }
    else { /* moving up first:shorter */
        /* Find top of x's symmetry group */
	while ((unsigned) x < table->subtableZ[x].next)
	    x = table->subtableZ[x].next;
	x = table->subtableZ[x].next;

	move_up = cuddZddSymmSifting_up(table, x, x_low, initial_size);
	/* after that point x --> x_high, unless early term */
	if (move_up == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingAuxOutOfMem;

	if (move_up != NULL) {
	    x = move_up->x;
	}
	else {
	    while ((unsigned) x < table->subtableZ[x].next)
		x = table->subtableZ[x].next;
	}
	i = table->subtableZ[x].next;
	init_group_size = x - i + 1;

	move_down = cuddZddSymmSifting_down(table, x, x_high,
	    initial_size);
	if (move_down == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingAuxOutOfMem;

	if (move_down == NULL ||
	    table->subtableZ[move_down->y].next != move_down->y) {
	    /* symmetry detected may have to make another complete
	       pass */
            if (move_down != NULL) {
		x = move_down->y;
	    }
	    else {
		x = table->subtableZ[x].next;
	    }
	    i = x;
	    while ((unsigned) i < table->subtableZ[i].next) {
		i = table->subtableZ[i].next;
	    }
	    final_group_size = i - x + 1;

	    if (init_group_size == final_group_size) {
		/* No new symmetries detected,
		   go back to best position */
		result = cuddZddSymmSiftingBackward(table, move_down,
		    initial_size);
	    }
	    else {
		while (move_up != NULL) {
		    move = move_up->next;
		    cuddDeallocMove(table, move_up);
		    move_up = move;
		}
		initial_size = table->keysZ;
		move_up = cuddZddSymmSifting_up(table, x, x_low,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_down,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingAuxOutOfMem;
    }

    while (move_down != NULL) {
	move = move_down->next;
	cuddDeallocMove(table, move_down);
	move_down = move;
    }
    while (move_up != NULL) {
	move = move_up->next;
	cuddDeallocMove(table, move_up);
	move_up = move;
    }

    return(1);

cuddZddSymmSiftingAuxOutOfMem:
    if (move_down != ZDD_MV_OOM) {
	while (move_down != NULL) {
	    move = move_down->next;
	    cuddDeallocMove(table, move_down);
	    move_down = move;
	}
    }
    if (move_up != ZDD_MV_OOM) {
	while (move_up != NULL) {
	    move = move_up->next;
	    cuddDeallocMove(table, move_up);
	    move_up = move;
	}
    }

    return(0);

} /* end of cuddZddSymmSiftingAux */


/**
  @brief Given x_low <= x <= x_high moves x up and down between the
  boundaries.

  @details Finds the best position and does the required changes.
  Assumes that x is either an isolated variable, or it is the bottom of
  a symmetry group. All symmetries may not have been found, because of
  exceeded growth limit.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
cuddZddSymmSiftingConvAux(
  DdManager * table,
  int  x,
  int  x_low,
  int  x_high)
{
    Move	*move;
    Move	*move_up;	/* list of up move */
    Move	*move_down;	/* list of down move */
    int		initial_size;
    int		result;
    int		i;
    int		init_group_size, final_group_size;

    initial_size = table->keysZ;

    move_down = NULL;
    move_up = NULL;

    if (x == x_low) { /* Sift down */
        i = table->subtableZ[x].next;
	init_group_size = x - i + 1;

	move_down = cuddZddSymmSifting_down(table, x, x_high,
	    initial_size);
	/* after that point x --> x_high, unless early term */
	if (move_down == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;

	if (move_down == NULL ||
	    table->subtableZ[move_down->y].next != move_down->y) {
	    /* symmetry detected may have to make another complete
		pass */
            if (move_down != NULL)
		x = move_down->y;
	    else {
		while ((unsigned) x < table->subtableZ[x].next)
		    x = table->subtableZ[x].next;
		x = table->subtableZ[x].next;
	    }
	    i = x;
	    while ((unsigned) i < table->subtableZ[i].next) {
		i = table->subtableZ[i].next;
	    }
	    final_group_size = i - x + 1;

	    if (init_group_size == final_group_size) {
		/* No new symmetries detected,
		   go back to best position */
		result = cuddZddSymmSiftingBackward(table, move_down,
		    initial_size);
	    }
	    else {
		initial_size = table->keysZ;
		move_up = cuddZddSymmSifting_up(table, x, x_low,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_down,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;
    }
    else if (x == x_high) { /* Sift up */
	/* Find top of x's symm group */
	while ((unsigned) x < table->subtableZ[x].next)
	    x = table->subtableZ[x].next;
	x = table->subtableZ[x].next;

	i = x;
	while ((unsigned) i < table->subtableZ[i].next) {
	    i = table->subtableZ[i].next;
	}
	init_group_size = i - x + 1;

	move_up = cuddZddSymmSifting_up(table, x, x_low, initial_size);
	/* after that point x --> x_low, unless early term */
	if (move_up == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;

	if (move_up == NULL ||
	    table->subtableZ[move_up->x].next != move_up->x) {
	    /* symmetry detected may have to make another complete
	       pass */
            if (move_up != NULL)
		x = move_up->x;
	    else {
		while ((unsigned) x < table->subtableZ[x].next)
		    x = table->subtableZ[x].next;
	    }
	    i = table->subtableZ[x].next;
	    final_group_size = x - i + 1;

	    if (init_group_size == final_group_size) {
		/* No new symmetry groups detected,
		   return to best position */
		result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
	    }
	    else {
		initial_size = table->keysZ;
		move_down = cuddZddSymmSifting_down(table, x, x_high,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_down,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_up,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;
    }
    else if ((x - x_low) > (x_high - x)) { /* must go down first:
						shorter */
	move_down = cuddZddSymmSifting_down(table, x, x_high,
	    initial_size);
	/* after that point x --> x_high */
	if (move_down == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;

	if (move_down != NULL) {
	    x = move_down->y;
	}
	else {
	    while ((unsigned) x < table->subtableZ[x].next)
		x = table->subtableZ[x].next;
	    x = table->subtableZ[x].next;
	}
	i = x;
	while ((unsigned) i < table->subtableZ[i].next) {
	    i = table->subtableZ[i].next;
	}
	init_group_size = i - x + 1;

	move_up = cuddZddSymmSifting_up(table, x, x_low, initial_size);
	if (move_up == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;

	if (move_up == NULL ||
	    table->subtableZ[move_up->x].next != move_up->x) {
	    /* symmetry detected may have to make another complete
	       pass */
	    if (move_up != NULL) {
		x = move_up->x;
	    }
	    else {
		while ((unsigned) x < table->subtableZ[x].next)
		    x = table->subtableZ[x].next;
	    }
            i = table->subtableZ[x].next;
            final_group_size = x - i + 1;

            if (init_group_size == final_group_size) {
		/* No new symmetry groups detected,
		   return to best position */
                result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
            }
	    else {
		while (move_down != NULL) {
		    move = move_down->next;
		    cuddDeallocMove(table, move_down);
		    move_down = move;
		}
		initial_size = table->keysZ;
		move_down = cuddZddSymmSifting_down(table, x, x_high,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_down,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_up,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;
    }
    else { /* moving up first:shorter */
	/* Find top of x's symmetry group */
	x = table->subtableZ[x].next;

	move_up = cuddZddSymmSifting_up(table, x, x_low, initial_size);
	/* after that point x --> x_high, unless early term */
	if (move_up == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;

	if (move_up != NULL) {
	    x = move_up->x;
	}
	else {
	    while ((unsigned) x < table->subtableZ[x].next)
		x = table->subtableZ[x].next;
	}
        i = table->subtableZ[x].next;
        init_group_size = x - i + 1;

	move_down = cuddZddSymmSifting_down(table, x, x_high,
	    initial_size);
	if (move_down == ZDD_MV_OOM)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;

	if (move_down == NULL ||
	    table->subtableZ[move_down->y].next != move_down->y) {
	    /* symmetry detected may have to make another complete
	       pass */
            if (move_down != NULL) {
		x = move_down->y;
	    }
	    else {
		while ((unsigned) x < table->subtableZ[x].next)
		    x = table->subtableZ[x].next;
		x = table->subtableZ[x].next;
	    }
            i = x;
            while ((unsigned) i < table->subtableZ[i].next) {
                i = table->subtableZ[i].next;
            }
	    final_group_size = i - x + 1;

            if (init_group_size == final_group_size) {
		/* No new symmetries detected,
		   go back to best position */
                result = cuddZddSymmSiftingBackward(table, move_down,
		    initial_size);
            }
	    else {
		while (move_up != NULL) {
		    move = move_up->next;
		    cuddDeallocMove(table, move_up);
		    move_up = move;
		}
		initial_size = table->keysZ;
		move_up = cuddZddSymmSifting_up(table, x, x_low,
		    initial_size);
		result = cuddZddSymmSiftingBackward(table, move_up,
		    initial_size);
	    }
	}
	else {
	    result = cuddZddSymmSiftingBackward(table, move_down,
		initial_size);
	    /* move backward and stop at best position */
	}
	if (!result)
	    goto cuddZddSymmSiftingConvAuxOutOfMem;
    }

    while (move_down != NULL) {
	move = move_down->next;
	cuddDeallocMove(table, move_down);
	move_down = move;
    }
    while (move_up != NULL) {
	move = move_up->next;
	cuddDeallocMove(table, move_up);
	move_up = move;
    }

    return(1);

cuddZddSymmSiftingConvAuxOutOfMem:
    if (move_down != ZDD_MV_OOM) {
	while (move_down != NULL) {
	    move = move_down->next;
	    cuddDeallocMove(table, move_down);
	    move_down = move;
	}
    }
    if (move_up != ZDD_MV_OOM) {
	while (move_up != NULL) {
	    move = move_up->next;
	    cuddDeallocMove(table, move_up);
	    move_up = move;
	}
    }

    return(0);

} /* end of cuddZddSymmSiftingConvAux */


/**
  @brief Moves x up until either it reaches the bound (x_low) or
  the size of the %ZDD heap increases too much.

  @details Assumes that x is the top of a symmetry group.  Checks x
  for symmetry to the adjacent variables. If symmetry is found, the
  symmetry group of x is merged with the symmetry group of the other
  variable.

  @return the set of moves in case of success; ZDD_MV_OOM if memory is
  full.

  @sideeffect None

*/
static Move *
cuddZddSymmSifting_up(
  DdManager * table,
  int  x,
  int  x_low,
  int  initial_size)
{
    Move	*moves;
    Move	*move;
    int		y;
    int		size;
    int		limit_size = initial_size;
    int		i, gytop;

    moves = NULL;
    y = cuddZddNextLow(table, x);
    while (y >= x_low) {
	gytop = table->subtableZ[y].next;
	if (cuddZddSymmCheck(table, y, x)) {
	    /* Symmetry found, attach symm groups */
	    table->subtableZ[y].next = x;
	    i = table->subtableZ[x].next;
	    while (table->subtableZ[i].next != (unsigned) x)
		i = table->subtableZ[i].next;
	    table->subtableZ[i].next = gytop;
	}
	else if ((table->subtableZ[x].next == (unsigned) x) &&
	    (table->subtableZ[y].next == (unsigned) y)) {
	    /* x and y have self symmetry */
	    size = cuddZddSwapInPlace(table, y, x);
	    if (size == 0)
		goto cuddZddSymmSifting_upOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto cuddZddSymmSifting_upOutOfMem;
	    move->x = y;
	    move->y = x;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    if ((double)size >
		(double)limit_size * table->maxGrowth)
		return(moves);
	    if (size < limit_size)
		limit_size = size;
	}
	else { /* Group move */
	    size = zdd_group_move(table, y, x, &moves);
	    if ((double)size >
		(double)limit_size * table->maxGrowth)
		return(moves);
	    if (size < limit_size)
		limit_size = size;
	}
	x = gytop;
	y = cuddZddNextLow(table, x);
    }

    return(moves);

cuddZddSymmSifting_upOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(ZDD_MV_OOM);

} /* end of cuddZddSymmSifting_up */


/**
  @brief Moves x down until either it reaches the bound (x_high) or
  the size of the %ZDD heap increases too much.

  @details Assumes that x is the bottom of a symmetry group. Checks x
  for symmetry to the adjacent variables. If symmetry is found, the
  symmetry group of x is merged with the symmetry group of the other
  variable.

  @return the set of moves in case of success; ZDD_MV_OOM if memory is
  full.

  @sideeffect None

*/
static Move *
cuddZddSymmSifting_down(
  DdManager * table,
  int  x,
  int  x_high,
  int  initial_size)
{
    Move	*moves;
    Move	*move;
    int		y;
    int		size;
    int		limit_size = initial_size;
    int		i, gxtop, gybot;

    moves = NULL;
    y = cuddZddNextHigh(table, x);
    while (y <= x_high) {
	gybot = table->subtableZ[y].next;
	while (table->subtableZ[gybot].next != (unsigned) y)
	    gybot = table->subtableZ[gybot].next;
	if (cuddZddSymmCheck(table, x, y)) {
	    /* Symmetry found, attach symm groups */
	    gxtop = table->subtableZ[x].next;
	    table->subtableZ[x].next = y;
	    i = table->subtableZ[y].next;
	    while (table->subtableZ[i].next != (unsigned) y)
		i = table->subtableZ[i].next;
	    table->subtableZ[i].next = gxtop;
	}
	else if ((table->subtableZ[x].next == (unsigned) x) &&
	    (table->subtableZ[y].next == (unsigned) y)) {
	    /* x and y have self symmetry */
	    size = cuddZddSwapInPlace(table, x, y);
	    if (size == 0)
		goto cuddZddSymmSifting_downOutOfMem;
	    move = (Move *)cuddDynamicAllocNode(table);
	    if (move == NULL)
		goto cuddZddSymmSifting_downOutOfMem;
	    move->x = x;
	    move->y = y;
	    move->size = size;
	    move->next = moves;
	    moves = move;
	    if ((double)size >
		(double)limit_size * table->maxGrowth)
		return(moves);
	    if (size < limit_size)
		limit_size = size;
	}
	else { /* Group move */
	    size = zdd_group_move(table, x, y, &moves);
	    if ((double)size >
		(double)limit_size * table->maxGrowth)
		return(moves);
	    if (size < limit_size)
		limit_size = size;
	}
	x = gybot;
	y = cuddZddNextHigh(table, x);
    }

    return(moves);

cuddZddSymmSifting_downOutOfMem:
    while (moves != NULL) {
	move = moves->next;
	cuddDeallocMove(table, moves);
	moves = move;
    }
    return(ZDD_MV_OOM);

} /* end of cuddZddSymmSifting_down */


/**
  @brief Given a set of moves, returns the %ZDD heap to the position
  giving the minimum size.

  @details In case of ties, returns to the closest position giving the
  minimum size.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
cuddZddSymmSiftingBackward(
  DdManager * table,
  Move * moves,
  int  size)
{
    int		i;
    int		i_best;
    Move	*move;
    int		res;

    i_best = -1;
    for (move = moves, i = 0; move != NULL; move = move->next, i++) {
	if (move->size < size) {
	    i_best = i;
	    size = move->size;
	}
    }

    for (move = moves, i = 0; move != NULL; move = move->next, i++) {
	if (i == i_best) break;
	if ((table->subtableZ[move->x].next == move->x) &&
	    (table->subtableZ[move->y].next == move->y)) {
	    res = cuddZddSwapInPlace(table, move->x, move->y);
	    if (!res) return(0);
	}
	else { /* Group move necessary */
	    res = zdd_group_move_backward(table, move->x, move->y);
	}
	if (i_best == -1 && res == size)
	    break;
    }

    return(1);

} /* end of cuddZddSymmSiftingBackward */


/**
  @brief Swaps two groups.

  @details x is assumed to be the bottom variable of the first
  group. y is assumed to be the top variable of the second group.
  Updates the list of moves.

  @return the number of keys in the table if successful; 0 otherwise.

  @sideeffect None

*/
static int
zdd_group_move(
  DdManager * table,
  int  x,
  int  y,
  Move ** moves)
{
    Move	*move;
    int		size;
    int		i, temp, gxtop, gxbot, gybot, yprev;
    int		swapx = 0, swapy = 0;

#ifdef DD_DEBUG
    assert(x < y);	/* we assume that x < y */
#endif
    /* Find top and bottom for the two groups. */
    gxtop = table->subtableZ[x].next;
    gxbot = x;
    gybot = table->subtableZ[y].next;
    while (table->subtableZ[gybot].next != (unsigned) y)
	gybot = table->subtableZ[gybot].next;
    yprev = gybot;

    while (x <= y) {
	while (y > gxtop) {
	    /* Set correct symmetries. */
	    temp = table->subtableZ[x].next;
	    if (temp == x)
		temp = y;
	    i = gxtop;
	    for (;;) {
		if (table->subtableZ[i].next == (unsigned) x) {
		    table->subtableZ[i].next = y;
		    break;
		} else {
		    i = table->subtableZ[i].next;
		}
	    }
	    if (table->subtableZ[y].next != (unsigned) y) {
		table->subtableZ[x].next = table->subtableZ[y].next;
	    } else {
		table->subtableZ[x].next = x;
	    }

	    if (yprev != y) {
		table->subtableZ[yprev].next = x;
	    } else {
		yprev = x;
	    }
	    table->subtableZ[y].next = temp;

	    size = cuddZddSwapInPlace(table, x, y);
	    if (size == 0)
		goto zdd_group_moveOutOfMem;
            swapx = x;
	    swapy = y;
	    y = x;
	    x--;
	} /* while y > gxtop */

	/* Trying to find the next y. */
	if (table->subtableZ[y].next > (unsigned) y) {
	    y = table->subtableZ[y].next;
	}

	yprev = gxtop;
	gxtop++;
	gxbot++;
	x = gxbot;
    } /* while x <= y, end of group movement */
    move = (Move *)cuddDynamicAllocNode(table);
    if (move == NULL)
	goto zdd_group_moveOutOfMem;
    move->x = swapx;
    move->y = swapy;
    move->size = table->keysZ;
    move->next = *moves;
    *moves = move;

    return(table->keysZ);

zdd_group_moveOutOfMem:
    while (*moves != NULL) {
	move = (*moves)->next;
	cuddDeallocMove(table, *moves);
	*moves = move;
    }
    return(0);

} /* end of zdd_group_move */


/**
  @brief Undoes the swap of two groups.

  @details x is assumed to be the bottom variable of the first
  group. y is assumed to be the top variable of the second group.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
static int
zdd_group_move_backward(
  DdManager * table,
  int  x,
  int  y)
{
    int	       size = table->keysZ;
    int        i, temp, gxtop, gxbot, gybot, yprev;

#ifdef DD_DEBUG
    assert(x < y);	/* we assume that x < y */
#endif
    /* Find top and bottom of the two groups. */
    gxtop = table->subtableZ[x].next;
    gxbot = x;
    gybot = table->subtableZ[y].next;
    while (table->subtableZ[gybot].next != (unsigned) y)
	gybot = table->subtableZ[gybot].next;
    yprev = gybot;

    while (x <= y) {
	while (y > gxtop) {
	    /* Set correct symmetries. */
	    temp = table->subtableZ[x].next;
	    if (temp == x)
		temp = y;
	    i = gxtop;
	    for (;;) {
		if (table->subtableZ[i].next == (unsigned) x) {
		    table->subtableZ[i].next = y;
		    break;
		} else {
		    i = table->subtableZ[i].next;
		}
	    }
	    if (table->subtableZ[y].next != (unsigned) y) {
		table->subtableZ[x].next = table->subtableZ[y].next;
	    } else {
		table->subtableZ[x].next = x;
	    }

	    if (yprev != y) {
		table->subtableZ[yprev].next = x;
	    } else {
		yprev = x;
	    }
	    table->subtableZ[y].next = temp;

	    size = cuddZddSwapInPlace(table, x, y);
	    if (size == 0)
		return(0);
	    y = x;
	    x--;
	} /* while y > gxtop */

	/* Trying to find the next y. */
	if (table->subtableZ[y].next > (unsigned) y) {
	    y = table->subtableZ[y].next;
	}

	yprev = gxtop;
	gxtop++;
	gxbot++;
	x = gxbot;
    } /* while x <= y, end of group movement backward */

    return(size);

} /* end of zdd_group_move_backward */


/**
  @brief Counts numbers of symmetric variables and symmetry groups.

  @sideeffect None

*/
static void
cuddZddSymmSummary(
  DdManager * table,
  int  lower,
  int  upper,
  int * symvars,
  int * symgroups)
{
    int i,x,gbot;
    int TotalSymm = 0;
    int TotalSymmGroups = 0;

    for (i = lower; i <= upper; i++) {
	if (table->subtableZ[i].next != (unsigned) i) {
	    TotalSymmGroups++;
	    x = i;
	    do {
		TotalSymm++;
		gbot = x;
		x = table->subtableZ[x].next;
	    } while (x != i);
#ifdef DD_DEBUG
	    assert(table->subtableZ[gbot].next == (unsigned) i);
#endif
	    i = gbot;
	}
    }
    *symvars = TotalSymm;
    *symgroups = TotalSymmGroups;

    return;

} /* end of cuddZddSymmSummary */


cuddZddUtil.c
30406
/**
  @file

  @ingroup cudd

  @brief Utility functions for ZDDs.

  @author Hyong-Kyoon Shin, In-Ho Moon, Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "cuddInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int zp2 (DdManager *zdd, DdNode *f, st_table *t);
static void zdd_print_minterm_aux (DdManager *zdd, DdNode *node, int level, int *list);
static void zddPrintCoverAux (DdManager *zdd, DdNode *node, int level, int *list);
static void zddSupportStep(DdNode * f, int * support);
static void zddClearFlag(DdNode * f);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints a disjoint sum of product form for a %ZDD.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_zddPrintDebug Cudd_zddPrintCover

*/
int
Cudd_zddPrintMinterm(
  DdManager * zdd,
  DdNode * node)
{
    int		i, size;
    int		*list;

    size = (int)zdd->sizeZ;
    list = ALLOC(int, size);
    if (list == NULL) {
	zdd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (i = 0; i < size; i++) list[i] = 3; /* bogus value should disappear */
    zdd_print_minterm_aux(zdd, node, 0, list);
    FREE(list);
    return(1);

} /* end of Cudd_zddPrintMinterm */


/**
  @brief Prints a sum of products from a %ZDD representing a cover.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_zddPrintMinterm

*/
int
Cudd_zddPrintCover(
  DdManager * zdd,
  DdNode * node)
{
    int		i, size;
    int		*list;

    size = (int)zdd->sizeZ;
    if (size % 2 != 0) return(0); /* number of variables should be even */
    list = ALLOC(int, size);
    if (list == NULL) {
	zdd->errorCode = CUDD_MEMORY_OUT;
	return(0);
    }
    for (i = 0; i < size; i++) list[i] = 3; /* bogus value should disappear */
    zddPrintCoverAux(zdd, node, 0, list);
    FREE(list);
    return(1);

} /* end of Cudd_zddPrintCover */


/**
  @brief Prints to the standard output a %ZDD and its statistics.

  @details The statistics include the number of nodes and the number of
  minterms.  (The number of minterms is also the number of combinations
  in the set.)  The statistics are printed if pr &gt; 0.  Specifically:
  <ul>
  <li> pr = 0 : prints nothing
  <li> pr = 1 : prints counts of nodes and minterms
  <li> pr = 2 : prints counts + disjoint sum of products
  <li> pr = 3 : prints counts + list of nodes
  <li> pr &gt; 3 : prints counts + disjoint sum of products + list of nodes
  </ul>

  @return 1 if successful; 0 otherwise.

  @sideeffect None

*/
int
Cudd_zddPrintDebug(
  DdManager * zdd,
  DdNode * f,
  int  n,
  int  pr)
{
    DdNode	*empty = DD_ZERO(zdd);
    int		nodes;
    double	minterms;
    int		retval = 1;

    if (f == empty && pr > 0) {
	(void) fprintf(zdd->out,": is the empty ZDD\n");
	(void) fflush(zdd->out);
	return(1);
    }

    if (pr > 0) {
	nodes = Cudd_zddDagSize(f);
	if (nodes == CUDD_OUT_OF_MEM) retval = 0;
	minterms = Cudd_zddCountMinterm(zdd, f, n);
	if (minterms == (double)CUDD_OUT_OF_MEM) retval = 0;
	(void) fprintf(zdd->out,": %d nodes %g minterms\n",
		       nodes, minterms);
	if (pr > 2)
	    if (!cuddZddP(zdd, f)) retval = 0;
	if (pr == 2 || pr > 3) {
	    if (!Cudd_zddPrintMinterm(zdd, f)) retval = 0;
	    (void) fprintf(zdd->out,"\n");
	}
	(void) fflush(zdd->out);
    }
    return(retval);

} /* end of Cudd_zddPrintDebug */



/**
  @brief Finds the first path of a %ZDD.

  @details Defines an iterator on the paths of a %ZDD and finds its first
  path.<p>
  A path is represented as an array of literals, which are integers in
  {0, 1, 2}; 0 represents an else arc out of a node, 1 represents a then arc
  out of a node, and 2 stands for the absence of a node.
  The size of the array equals the number of variables in the manager at
  the time Cudd_zddFirstCube is called.<p>
  The paths that end in the empty terminal are not enumerated.

  @return a generator that contains the information necessary to
  continue the enumeration if successful; NULL otherwise.

  @sideeffect The first path is returned as a side effect.

  @see Cudd_zddForeachPath Cudd_zddNextPath Cudd_GenFree
  Cudd_IsGenEmpty

*/
DdGen *
Cudd_zddFirstPath(
  DdManager * zdd,
  DdNode * f,
  int ** path)
{
    DdGen *gen;
    DdNode *top, *next, *prev;
    int i;
    int nvars;

    /* Sanity Check. */
    if (zdd == NULL || f == NULL) return(NULL);

    /* Allocate generator an initialize it. */
    gen = ALLOC(DdGen,1);
    if (gen == NULL) {
	zdd->errorCode = CUDD_MEMORY_OUT;
	return(NULL);
    }

    gen->manager = zdd;
    gen->type = CUDD_GEN_ZDD_PATHS;
    gen->status = CUDD_GEN_EMPTY;
    gen->gen.cubes.cube = NULL;
    gen->gen.cubes.value = DD_ZERO_VAL;
    gen->stack.sp = 0;
    gen->stack.stack = NULL;
    gen->node = NULL;

    nvars = zdd->sizeZ;
    gen->gen.cubes.cube = ALLOC(int,nvars);
    if (gen->gen.cubes.cube == NULL) {
	zdd->errorCode = CUDD_MEMORY_OUT;
	FREE(gen);
	return(NULL);
    }
    for (i = 0; i < nvars; i++) gen->gen.cubes.cube[i] = 2;

    /* The maximum stack depth is one plus the number of variables.
    ** because a path may have nodes at all levels, including the
    ** constant level.
    */
    gen->stack.stack = ALLOC(DdNodePtr, nvars+1);
    if (gen->stack.stack == NULL) {
	zdd->errorCode = CUDD_MEMORY_OUT;
	FREE(gen->gen.cubes.cube);
	FREE(gen);
	return(NULL);
    }
    for (i = 0; i <= nvars; i++) gen->stack.stack[i] = NULL;

    /* Find the first path of the ZDD. */
    gen->stack.stack[gen->stack.sp] = f; gen->stack.sp++;

    while (1) {
	top = gen->stack.stack[gen->stack.sp-1];
	if (!cuddIsConstant(Cudd_Regular(top))) {
	    /* Take the else branch first. */
	    gen->gen.cubes.cube[Cudd_Regular(top)->index] = 0;
	    next = cuddE(Cudd_Regular(top));
	    gen->stack.stack[gen->stack.sp] = Cudd_Not(next); gen->stack.sp++;
	} else if (Cudd_Regular(top) == DD_ZERO(zdd)) {
	    /* Backtrack. */
	    while (1) {
		if (gen->stack.sp == 1) {
		    /* The current node has no predecessor. */
		    gen->status = CUDD_GEN_EMPTY;
		    gen->stack.sp--;
		    goto done;
		}
		prev = Cudd_Regular(gen->stack.stack[gen->stack.sp-2]);
		next = cuddT(prev);
		if (next != top) { /* follow the then branch next */
		    gen->gen.cubes.cube[prev->index] = 1;
		    gen->stack.stack[gen->stack.sp-1] = next;
		    break;
		}
		/* Pop the stack and try again. */
		gen->gen.cubes.cube[prev->index] = 2;
		gen->stack.sp--;
		top = gen->stack.stack[gen->stack.sp-1];
	    }
	} else {
	    gen->status = CUDD_GEN_NONEMPTY;
	    gen->gen.cubes.value = cuddV(Cudd_Regular(top));
	    goto done;
	}
    }

done:
    *path = gen->gen.cubes.cube;
    return(gen);

} /* end of Cudd_zddFirstPath */


/**
  @brief Generates the next path of a %ZDD.

  @details Generates the next path of a %ZDD onset, using generator
  gen.

  @return 0 if the enumeration is completed; 1 otherwise.

  @sideeffect The path is returned as a side effect. The generator is
  modified.

  @see Cudd_zddForeachPath Cudd_zddFirstPath Cudd_GenFree
  Cudd_IsGenEmpty

*/
int
Cudd_zddNextPath(
  DdGen * gen,
  int ** path)
{
    DdNode *top, *next, *prev;
    DdManager *zdd = gen->manager;

    /* Backtrack from previously reached terminal node. */
    while (1) {
	if (gen->stack.sp == 1) {
	    /* The current node has no predecessor. */
	    gen->status = CUDD_GEN_EMPTY;
	    gen->stack.sp--;
	    goto done;
	}
	top = gen->stack.stack[gen->stack.sp-1];
	prev = Cudd_Regular(gen->stack.stack[gen->stack.sp-2]);
	next = cuddT(prev);
	if (next != top) { /* follow the then branch next */
	    gen->gen.cubes.cube[prev->index] = 1;
	    gen->stack.stack[gen->stack.sp-1] = next;
	    break;
	}
	/* Pop the stack and try again. */
	gen->gen.cubes.cube[prev->index] = 2;
	gen->stack.sp--;
    }

    while (1) {
	top = gen->stack.stack[gen->stack.sp-1];
	if (!cuddIsConstant(Cudd_Regular(top))) {
	    /* Take the else branch first. */
	    gen->gen.cubes.cube[Cudd_Regular(top)->index] = 0;
	    next = cuddE(Cudd_Regular(top));
	    gen->stack.stack[gen->stack.sp] = Cudd_Not(next); gen->stack.sp++;
	} else if (Cudd_Regular(top) == DD_ZERO(zdd)) {
	    /* Backtrack. */
	    while (1) {
		if (gen->stack.sp == 1) {
		    /* The current node has no predecessor. */
		    gen->status = CUDD_GEN_EMPTY;
		    gen->stack.sp--;
		    goto done;
		}
		prev = Cudd_Regular(gen->stack.stack[gen->stack.sp-2]);
		next = cuddT(prev);
		if (next != top) { /* follow the then branch next */
		    gen->gen.cubes.cube[prev->index] = 1;
		    gen->stack.stack[gen->stack.sp-1] = next;
		    break;
		}
		/* Pop the stack and try again. */
		gen->gen.cubes.cube[prev->index] = 2;
		gen->stack.sp--;
		top = gen->stack.stack[gen->stack.sp-1];
	    }
	} else {
	    gen->status = CUDD_GEN_NONEMPTY;
	    gen->gen.cubes.value = cuddV(Cudd_Regular(top));
	    goto done;
	}
    }

done:
    if (gen->status == CUDD_GEN_EMPTY) return(0);
    *path = gen->gen.cubes.cube;
    return(1);

} /* end of Cudd_zddNextPath */


/**
  @brief Converts a path of a %ZDD representing a cover to a string.

  @details The string represents an implicant of the cover.  The path
  is typically produced by Cudd_zddForeachPath.  If the str input is
  NULL, it allocates a new string.  The string passed to this function
  must have enough room for all variables and for the terminator.

  @return a pointer to the string if successful; NULL otherwise.

  @sideeffect None

  @see Cudd_zddForeachPath

*/
char *
Cudd_zddCoverPathToString(
  DdManager *zdd		/**< %DD manager */,
  int *path			/**< path of %ZDD representing a cover */,
  char *str			/**< pointer to string to use if != NULL */
  )
{
    int nvars = zdd->sizeZ;
    int i;
    char *res;

    if (nvars & 1) return(NULL);
    nvars >>= 1;
    if (str == NULL) {
	res = ALLOC(char, nvars+1);
	if (res == NULL) return(NULL);
    } else {
	res = str;
    }
    for (i = 0; i < nvars; i++) {
	int v = (path[2*i] << 2) | path[2*i+1];
	switch (v) {
	case 0:
	case 2:
	case 8:
	case 10:
	    res[i] = '-';
	    break;
	case 1:
	case 9:
	    res[i] = '0';
	    break;
	case 4:
	case 6:
	    res[i] = '1';
	    break;
	default:
	    res[i] = '?';
	}
    }
    res[nvars] = 0;

    return(res);

} /* end of Cudd_zddCoverPathToString */


/**
  @brief Finds the variables on which a %ZDD depends.

  @return a %BDD consisting of the product of the variables if
  successful; NULL otherwise.

  @sideeffect None

  @see Cudd_Support

*/
DdNode *
Cudd_zddSupport(
  DdManager * dd /**< manager */,
  DdNode * f /**< %ZDD whose support is sought */)
{
    int *support;
    DdNode *res, *tmp, *var;
    int i,j;
    int size;

    /* Allocate and initialize support array for ddSupportStep. */
    size = ddMax(dd->size, dd->sizeZ);
    support = ALLOC(int,size);
    if (support == NULL) {
        dd->errorCode = CUDD_MEMORY_OUT;
        return(NULL);
    }
    for (i = 0; i < size; i++) {
        support[i] = 0;
    }

    /* Compute support and clean up markers. */
    zddSupportStep(Cudd_Regular(f),support);
    zddClearFlag(Cudd_Regular(f));

    /* Transform support from array to cube. */
    do {
        dd->reordered = 0;
        res = DD_ONE(dd);
        cuddRef(res);
        for (j = size - 1; j >= 0; j--) { /* for each level bottom-up */
            i = (j >= dd->size) ? j : dd->invperm[j];
            if (support[i] == 1) {
                /* The following call to cuddUniqueInter is guaranteed
                ** not to trigger reordering because the node we look up
                ** already exists. */
                var = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
                cuddRef(var);
                tmp = cuddBddAndRecur(dd,res,var);
                if (tmp == NULL) {
                    Cudd_RecursiveDeref(dd,res);
                    Cudd_RecursiveDeref(dd,var);
                    res = NULL;
                    break;
                }
                cuddRef(tmp);
                Cudd_RecursiveDeref(dd,res);
                Cudd_RecursiveDeref(dd,var);
                res = tmp;
            }
        }
    } while (dd->reordered == 1);

    FREE(support);
    if (res != NULL) cuddDeref(res);
    if (dd->errorCode == CUDD_TIMEOUT_EXPIRED && dd->timeoutHandler) {
        dd->timeoutHandler(dd, dd->tohArg);
    }
    return(res);

} /* end of Cudd_zddSupport */


/**
  @brief Writes a dot file representing the argument ZDDs.

  @details Writes a file representing the argument ZDDs in a format
  suitable for the graph drawing program dot.
  Cudd_zddDumpDot does not close the file: This is the caller
  responsibility. Cudd_zddDumpDot uses a minimal unique subset of the
  hexadecimal address of a node as name for it.
  If the argument inames is non-null, it is assumed to hold the pointers
  to the names of the inputs. Similarly for onames.
  Cudd_zddDumpDot uses the following convention to draw arcs:
    <ul>
    <li> solid line: THEN arcs;
    <li> dashed line: ELSE arcs.
    </ul>
  The dot options are chosen so that the drawing fits on a letter-size
  sheet.
  
  @return 1 in case of success; 0 otherwise (e.g., out-of-memory, file
  system full).

  @sideeffect None

  @see Cudd_DumpDot Cudd_zddPrintDebug

*/
int
Cudd_zddDumpDot(
  DdManager * dd /**< manager */,
  int  n /**< number of output nodes to be dumped */,
  DdNode ** f /**< array of output nodes to be dumped */,
  char const * const * inames /**< array of input names (or NULL) */,
  char const * const * onames /**< array of output names (or NULL) */,
  FILE * fp /**< pointer to the dump file */)
{
    DdNode	*support = NULL;
    DdNode	*scan;
    int		*sorted = NULL;
    int		nvars = dd->sizeZ;
    st_table	*visited = NULL;
    st_generator *gen;
    int		retval;
    int		i, j;
    int		slots;
    DdNodePtr	*nodelist;
    ptruint	refAddr, diff, mask = 0;

    /* Build a bit array with the support of f. */
    sorted = ALLOC(int,nvars);
    if (sorted == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	goto failure;
    }
    for (i = 0; i < nvars; i++) sorted[i] = 0;

    /* Take the union of the supports of each output function. */
    for (i = 0; i < n; i++) {
	support = Cudd_zddSupport(dd,f[i]);
	if (support == NULL) goto failure;
	cuddRef(support);
	scan = support;
	while (!cuddIsConstant(scan)) {
	    sorted[scan->index] = 1;
	    scan = cuddT(scan);
	}
	Cudd_RecursiveDeref(dd,support);
    }
    support = NULL; /* so that we do not try to free it in case of failure */

    /* Initialize symbol table for visited nodes. */
    visited = st_init_table(st_ptrcmp, st_ptrhash);
    if (visited == NULL) goto failure;

    /* Collect all the nodes of this DD in the symbol table. */
    for (i = 0; i < n; i++) {
	retval = cuddCollectNodes(f[i],visited);
	if (retval == 0) goto failure;
    }

    /* Find how many most significant hex digits are identical
    ** in the addresses of all the nodes. Build a mask based
    ** on this knowledge, so that digits that carry no information
    ** will not be printed. This is done in two steps.
    **  1. We scan the symbol table to find the bits that differ
    **     in at least 2 addresses.
    **  2. We choose one of the possible masks. There are 8 possible
    **     masks for 32-bit integer, and 16 possible masks for 64-bit
    **     integers.
    */

    /* Find the bits that are different. */
    refAddr = (ptruint) f[0];
    diff = 0;
    gen = st_init_gen(visited);
    while (st_gen(gen, (void **) &scan, NULL)) {
	diff |= refAddr ^ (ptruint) scan;
    }
    st_free_gen(gen);

    /* Choose the mask. */
    for (i = 0; (unsigned) i < 8 * sizeof(ptruint); i += 4) {
        mask = ((ptruint) 1 << i) - 1;
	if (diff <= mask) break;
    }

    /* Write the header and the global attributes. */
    retval = fprintf(fp,"digraph \"ZDD\" {\n");
    if (retval == EOF) return(0);
    retval = fprintf(fp,
	"size = \"7.5,10\"\ncenter = true;\nedge [dir = none];\n");
    if (retval == EOF) return(0);

    /* Write the input name subgraph by scanning the support array. */
    retval = fprintf(fp,"{ node [shape = plaintext];\n");
    if (retval == EOF) goto failure;
    retval = fprintf(fp,"  edge [style = invis];\n");
    if (retval == EOF) goto failure;
    /* We use a name ("CONST NODES") with an embedded blank, because
    ** it is unlikely to appear as an input name.
    */
    retval = fprintf(fp,"  \"CONST NODES\" [style = invis];\n");
    if (retval == EOF) goto failure;
    for (i = 0; i < nvars; i++) {
	if (sorted[dd->invpermZ[i]]) {
	    if (inames == NULL) {
		retval = fprintf(fp,"\" %d \" -> ", dd->invpermZ[i]);
	    } else {
		retval = fprintf(fp,"\" %s \" -> ", inames[dd->invpermZ[i]]);
	    }
	    if (retval == EOF) goto failure;
	}
    }
    retval = fprintf(fp,"\"CONST NODES\"; \n}\n");
    if (retval == EOF) goto failure;

    /* Write the output node subgraph. */
    retval = fprintf(fp,"{ rank = same; node [shape = box]; edge [style = invis];\n");
    if (retval == EOF) goto failure;
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp,"\"F%d\"", i);
	} else {
	    retval = fprintf(fp,"\"  %s  \"", onames[i]);
	}
	if (retval == EOF) goto failure;
	if (i == n - 1) {
	    retval = fprintf(fp,"; }\n");
	} else {
	    retval = fprintf(fp," -> ");
	}
	if (retval == EOF) goto failure;
    }

    /* Write rank info: All nodes with the same index have the same rank. */
    for (i = 0; i < nvars; i++) {
	if (sorted[dd->invpermZ[i]]) {
	    retval = fprintf(fp,"{ rank = same; ");
	    if (retval == EOF) goto failure;
	    if (inames == NULL) {
		retval = fprintf(fp,"\" %d \";\n", dd->invpermZ[i]);
	    } else {
		retval = fprintf(fp,"\" %s \";\n", inames[dd->invpermZ[i]]);
	    }
	    if (retval == EOF) goto failure;
	    nodelist = dd->subtableZ[i].nodelist;
	    slots = dd->subtableZ[i].slots;
	    for (j = 0; j < slots; j++) {
		scan = nodelist[j];
		while (scan != NULL) {
		    if (st_is_member(visited,scan)) {
			retval = fprintf(fp,"\"%#" PRIxPTR "\";\n",
					 ((mask & (ptruint) scan) /
					  sizeof(DdNode)));
			if (retval == EOF) goto failure;
		    }
		    scan = scan->next;
		}
	    }
	    retval = fprintf(fp,"}\n");
	    if (retval == EOF) goto failure;
	}
    }

    /* All constants have the same rank. */
    retval = fprintf(fp,
	"{ rank = same; \"CONST NODES\";\n{ node [shape = box]; ");
    if (retval == EOF) goto failure;
    nodelist = dd->constants.nodelist;
    slots = dd->constants.slots;
    for (j = 0; j < slots; j++) {
	scan = nodelist[j];
	while (scan != NULL) {
	    if (st_is_member(visited,scan)) {
		retval = fprintf(fp,"\"%#" PRIxPTR "\";\n",
				 ((mask & (ptruint) scan) / sizeof(DdNode)));
		if (retval == EOF) goto failure;
	    }
	    scan = scan->next;
	}
    }
    retval = fprintf(fp,"}\n}\n");
    if (retval == EOF) goto failure;

    /* Write edge info. */
    /* Edges from the output nodes. */
    for (i = 0; i < n; i++) {
	if (onames == NULL) {
	    retval = fprintf(fp,"\"F%d\"", i);
	} else {
	    retval = fprintf(fp,"\"  %s  \"", onames[i]);
	}
	if (retval == EOF) goto failure;
	retval = fprintf(fp," -> \"%#" PRIxPTR "\" [style = solid];\n",
			 ((mask & (ptruint) f[i]) / sizeof(DdNode)));
	if (retval == EOF) goto failure;
    }

    /* Edges from internal nodes. */
    for (i = 0; i < nvars; i++) {
	if (sorted[dd->invpermZ[i]]) {
	    nodelist = dd->subtableZ[i].nodelist;
	    slots = dd->subtableZ[i].slots;
	    for (j = 0; j < slots; j++) {
		scan = nodelist[j];
		while (scan != NULL) {
		    if (st_is_member(visited,scan)) {
			retval = fprintf(fp,
			    "\"%#" PRIxPTR "\" -> \"%#" PRIxPTR "\";\n",
			    ((mask & (ptruint) scan) / sizeof(DdNode)),
			    ((mask & (ptruint) cuddT(scan)) / sizeof(DdNode)));
			if (retval == EOF) goto failure;
			retval = fprintf(fp,
					 "\"%#" PRIxPTR "\" -> \"%#" PRIxPTR
                                         "\" [style = dashed];\n",
					 ((mask & (ptruint) scan) /
                                          sizeof(DdNode)),
					 ((mask & (ptruint) cuddE(scan)) /
                                          sizeof(DdNode)));
			if (retval == EOF) goto failure;
		    }
		    scan = scan->next;
		}
	    }
	}
    }

    /* Write constant labels. */
    nodelist = dd->constants.nodelist;
    slots = dd->constants.slots;
    for (j = 0; j < slots; j++) {
	scan = nodelist[j];
	while (scan != NULL) {
	    if (st_is_member(visited,scan)) {
		retval = fprintf(fp,"\"%#" PRIxPTR "\" [label = \"%g\"];\n",
				 ((mask & (ptruint) scan) / sizeof(DdNode)),
				 cuddV(scan));
		if (retval == EOF) goto failure;
	    }
	    scan = scan->next;
	}
    }

    /* Write trailer and return. */
    retval = fprintf(fp,"}\n");
    if (retval == EOF) goto failure;

    st_free_table(visited);
    FREE(sorted);
    return(1);

failure:
    if (sorted != NULL) FREE(sorted);
    if (visited != NULL) st_free_table(visited);
    return(0);

} /* end of Cudd_zddDumpBlif */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Prints a %ZDD to the standard output. One line per node is
  printed.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Cudd_zddPrintDebug

*/
int
cuddZddP(
  DdManager * zdd,
  DdNode * f)
{
    int retval;
    st_table *table = st_init_table(st_ptrcmp, st_ptrhash);

    if (table == NULL) return(0);

    retval = zp2(zdd, f, table);
    st_free_table(table);
    (void) fputc('\n', zdd->out);
    return(retval);

} /* end of cuddZddP */


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Performs the recursive step of cuddZddP.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
zp2(
  DdManager * zdd,
  DdNode * f,
  st_table * t)
{
    DdNode	*n;
    int		T, E;
    DdNode	*base = DD_ONE(zdd);

    if (f == NULL)
	return(0);

    if (Cudd_IsConstantInt(f)) {
	(void)fprintf(zdd->out, "ID = %d\n", (f == base));
	return(1);
    }
    if (st_is_member(t, f) == 1)
	return(1);

    if (st_insert(t, f, NULL) == ST_OUT_OF_MEM)
	return(0);

    (void) fprintf(zdd->out, "ID = 0x%" PRIxPTR "\tindex = %u\tr = %u\t",
	(ptruint)f / (ptruint) sizeof(DdNode), f->index, f->ref);

    n = cuddT(f);
    if (Cudd_IsConstantInt(n)) {
	(void) fprintf(zdd->out, "T = %d\t\t", (n == base));
	T = 1;
    } else {
	(void) fprintf(zdd->out, "T = 0x%" PRIxPTR "\t", (ptruint) n /
		       (ptruint) sizeof(DdNode));
	T = 0;
    }

    n = cuddE(f);
    if (Cudd_IsConstantInt(n)) {
	(void) fprintf(zdd->out, "E = %d\n", (n == base));
	E = 1;
    } else {
	(void) fprintf(zdd->out, "E = 0x%" PRIxPTR "\n", (ptruint) n /
		      (ptruint) sizeof(DdNode));
	E = 0;
    }

    if (E == 0)
	if (zp2(zdd, cuddE(f), t) == 0) return(0);
    if (T == 0)
	if (zp2(zdd, cuddT(f), t) == 0) return(0);
    return(1);

} /* end of zp2 */


/**
  @brief Performs the recursive step of Cudd_zddPrintMinterm.

  @sideeffect None

*/
static void
zdd_print_minterm_aux(
  DdManager * zdd /* manager */,
  DdNode * node /* current node */,
  int  level /* depth in the recursion */,
  int * list /* current recursion path */)
{
    DdNode	*Nv, *Nnv;
    int		i, v;
    DdNode	*base = DD_ONE(zdd);

    if (Cudd_IsConstantInt(node)) {
	if (node == base) {
	    /* Check for missing variable. */
	    if (level != zdd->sizeZ) {
		list[zdd->invpermZ[level]] = 0;
		zdd_print_minterm_aux(zdd, node, level + 1, list);
		return;
	    }
	    /* Terminal case: Print one cube based on the current recursion
	    ** path.
	    */
	    for (i = 0; i < zdd->sizeZ; i++) {
		v = list[i];
		if (v == 0)
		    (void) fprintf(zdd->out,"0");
		else if (v == 1)
		    (void) fprintf(zdd->out,"1");
		else if (v == 3)
		    (void) fprintf(zdd->out,"@");	/* should never happen */
		else
		    (void) fprintf(zdd->out,"-");
	    }
	    (void) fprintf(zdd->out," 1\n");
	}
    } else {
	/* Check for missing variable. */
	if (level != cuddIZ(zdd,node->index)) {
	    list[zdd->invpermZ[level]] = 0;
	    zdd_print_minterm_aux(zdd, node, level + 1, list);
	    return;
	}

	Nnv = cuddE(node);
	Nv = cuddT(node);
	if (Nv == Nnv) {
	    list[node->index] = 2;
	    zdd_print_minterm_aux(zdd, Nnv, level + 1, list);
	    return;
	}

	list[node->index] = 1;
	zdd_print_minterm_aux(zdd, Nv, level + 1, list);
	list[node->index] = 0;
	zdd_print_minterm_aux(zdd, Nnv, level + 1, list);
    }
    return;

} /* end of zdd_print_minterm_aux */


/**
  @brief Performs the recursive step of Cudd_zddPrintCover.

  @sideeffect None

*/
static void
zddPrintCoverAux(
  DdManager * zdd /* manager */,
  DdNode * node /* current node */,
  int  level /* depth in the recursion */,
  int * list /* current recursion path */)
{
    DdNode	*Nv, *Nnv;
    int		i, v;
    DdNode	*base = DD_ONE(zdd);

    if (Cudd_IsConstantInt(node)) {
	if (node == base) {
	    /* Check for missing variable. */
	    if (level != zdd->sizeZ) {
		list[zdd->invpermZ[level]] = 0;
		zddPrintCoverAux(zdd, node, level + 1, list);
		return;
	    }
	    /* Terminal case: Print one cube based on the current recursion
	    ** path.
	    */
	    for (i = 0; i < zdd->sizeZ; i += 2) {
		v = list[i] * 4 + list[i+1];
		if (v == 0)
		    (void) putc('-',zdd->out);
		else if (v == 4)
		    (void) putc('1',zdd->out);
		else if (v == 1)
		    (void) putc('0',zdd->out);
		else
		    (void) putc('@',zdd->out); /* should never happen */
	    }
	    (void) fprintf(zdd->out," 1\n");
	}
    } else {
	/* Check for missing variable. */
	if (level != cuddIZ(zdd,node->index)) {
	    list[zdd->invpermZ[level]] = 0;
	    zddPrintCoverAux(zdd, node, level + 1, list);
	    return;
	}

	Nnv = cuddE(node);
	Nv = cuddT(node);
	if (Nv == Nnv) {
	    list[node->index] = 2;
	    zddPrintCoverAux(zdd, Nnv, level + 1, list);
	    return;
	}

	list[node->index] = 1;
	zddPrintCoverAux(zdd, Nv, level + 1, list);
	list[node->index] = 0;
	zddPrintCoverAux(zdd, Nnv, level + 1, list);
    }
    return;

} /* end of zddPrintCoverAux */


/**
  @brief Performs the recursive step of Cudd_zddSupport.

  @details Performs a DFS from f. The support is accumulated in supp
  as a side effect. Uses the LSB of the then pointer as visited flag.

  @sideeffect None

  @see zddClearFlag

*/
static void
zddSupportStep(
  DdNode * f,
  int * support)
{
    if (cuddIsConstant(f) || Cudd_IsComplement(f->next)) {
        return;
    }

    support[f->index] = 1;
    zddSupportStep(cuddT(f),support);
    zddSupportStep(Cudd_Regular(cuddE(f)),support);
    /* Mark as visited. */
    f->next = Cudd_Not(f->next);
    return;

} /* end of zddSupportStep */


/**
  @brief Performs a DFS from f, clearing the LSB of the next
  pointers.

  @sideeffect None

  @see zddSupportStep

*/
static void
zddClearFlag(
  DdNode * f)
{
    if (!Cudd_IsComplement(f->next)) {
        return;
    }
    /* Clear visited flag. */
    f->next = Cudd_Regular(f->next);
    if (cuddIsConstant(f)) {
        return;
    }
    zddClearFlag(cuddT(f));
    zddClearFlag(Cudd_Regular(cuddE(f)));
    return;

} /* end of zddClearFlag */


datalimit.c
3092
/**
  @file

  @ingroup util

  @brief Access to datasize limit.

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "config.h"

#if HAVE_STDINT_H == 1
#include <stdint.h>
#endif
#if HAVE_STDDEF_H == 1
#include <stddef.h>
#endif

#if HAVE_SYS_RESOURCE_H == 1
#if HAVE_SYS_TIME_H == 1
#include <sys/time.h>
#endif
#include <sys/resource.h>
#endif

#ifdef _WIN32
#include <windows.h>
#endif

/**
 * @brief Default value returned if getrlimit not available.
 */
#ifndef RLIMIT_DATA_DEFAULT
#define RLIMIT_DATA_DEFAULT 268435456	/* assume 256MB by default */
#endif

/**
 * @def EXTERN
 * @brief Allows C linkage when compiling as C++.
 */
#ifndef EXTERN
#   ifdef __cplusplus
#	define EXTERN extern "C"
#   else
#	define EXTERN extern
#   endif
#endif

EXTERN size_t getSoftDataLimit(void);

/**
 * @brief Gets the soft datasize limit.
 */
size_t
getSoftDataLimit(void)
{
#if HAVE_SYS_RESOURCE_H == 1 && HAVE_GETRLIMIT == 1 && defined(RLIMIT_DATA)
    struct rlimit rl;
    int result;

    result = getrlimit(RLIMIT_DATA, &rl);
    if (result != 0 || rl.rlim_cur == RLIM_INFINITY)
	return (size_t) RLIMIT_DATA_DEFAULT;
    else
	return (size_t) rl.rlim_cur;
#elif defined(_WIN32)
    /* Not quite the same, because this returns available physical memory. */
    MEMORYSTATUSEX statex;
    statex.dwLength = sizeof(statex);
    if (GlobalMemoryStatusEx(&statex))
	return (size_t) statex.ullTotalPhys;
    else
	return (size_t) RLIMIT_DATA_DEFAULT;
#else
    return (size_t) RLIMIT_DATA_DEFAULT;
#endif

} /* end of getSoftDataLimit */

epd.c
23011
/**
  @file

  @ingroup epd

  @brief Arithmetic functions with extended double precision.

  @author In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include <math.h>
#include "util.h"
#include "epdInt.h"


/**
  @brief Allocates an EpDouble struct.
*/
EpDouble *
EpdAlloc(void)
{
  EpDouble	*epd;

  epd = ALLOC(EpDouble, 1);
  return(epd);
}


/**
  @brief Compares two EpDouble struct.

  @return 0 if the two structures hold the same value; 1 otherwise.
*/
int
EpdCmp(const void *key1, const void *key2)
{
  EpDouble const *epd1 = (EpDouble const *) key1;
  EpDouble const *epd2 = (EpDouble const *) key2;
  if (epd1->type.value != epd2->type.value ||
      epd1->exponent != epd2->exponent) {
    return(1);
  }
  return(0);
}


/**
  @brief Frees an EpDouble struct.
*/
void
EpdFree(EpDouble *epd)
{
  FREE(epd);
}


/**
  @brief Converts an extended precision double value to a string.

  @sideeffect The string is written at the address passed in `str`.
*/
void
EpdGetString(EpDouble const *epd, char *str)
{
  double	value;
  int		exponent;
  char		*pos;

  if (!str) return;

  if (IsNanDouble(epd->type.value)) {
    sprintf(str, "NaN");
    return;
  } else if (IsInfDouble(epd->type.value)) {
    if (epd->type.bits.sign == 1)
      sprintf(str, "-inf");
    else
      sprintf(str, "inf");
    return;
  }

  assert(epd->type.bits.exponent == EPD_MAX_BIN ||
	 epd->type.bits.exponent == 0);

  EpdGetValueAndDecimalExponent(epd, &value, &exponent);
  sprintf(str, "%e", value);
  pos = strstr(str, "e");
  if (exponent >= 0) {
    if (exponent < 10)
      sprintf(pos + 1, "+0%d", exponent);
    else
      sprintf(pos + 1, "+%d", exponent);
  } else {
    exponent *= -1;
    if (exponent < 10)
      sprintf(pos + 1, "-0%d", exponent);
    else
      sprintf(pos + 1, "-%d", exponent);
  }
}


/**
  @brief Converts double to EpDouble struct.
*/
void
EpdConvert(double value, EpDouble *epd)
{
  epd->type.value = value;
  epd->exponent = 0;
  EpdNormalize(epd);
}


/**
  @brief Multiplies an extended precision double by a double.
*/
void
EpdMultiply(EpDouble *epd1, double value)
{
  EpDouble	epd2;
  double	tmp;
  int		exponent;

  if (EpdIsNan(epd1) || IsNanDouble(value)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || IsInfDouble(value)) {
    int	sign;

    EpdConvert(value, &epd2);
    sign = epd1->type.bits.sign ^ epd2.type.bits.sign;
    EpdMakeInf(epd1, sign);
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);

  EpdConvert(value, &epd2);
  tmp = epd1->type.value * epd2.type.value;
  exponent = epd1->exponent + epd2.exponent;
  epd1->type.value = tmp;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Multiplies an extended precision double by another.
*/
void
EpdMultiply2(EpDouble *epd1, EpDouble const *epd2)
{
  double	value;
  int		exponent;

  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
    EpdMakeInf(epd1, sign);
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  value = epd1->type.value * epd2->type.value;
  exponent = epd1->exponent + epd2->exponent;
  epd1->type.value = value;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Multiplies two extended precision double values.
*/
void
EpdMultiply2Decimal(EpDouble *epd1, EpDouble const *epd2)
{
  double	value;
  int		exponent;

  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
    EpdMakeInf(epd1, sign);
    return;
  }

  value = epd1->type.value * epd2->type.value;
  exponent = epd1->exponent + epd2->exponent;
  epd1->type.value = value;
  epd1->exponent = exponent;
  EpdNormalizeDecimal(epd1);
}


/**
  @brief Multiplies two extended precision double values.

  @details The result goes in the third operand.
*/
void
EpdMultiply3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3)
{
  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd3);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
    EpdMakeInf(epd3, sign);
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  epd3->type.value = epd1->type.value * epd2->type.value;
  epd3->exponent = epd1->exponent + epd2->exponent;
  EpdNormalize(epd3);
}


/**
  @brief Multiplies two extended precision double values.
*/
void
EpdMultiply3Decimal(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3)
{
  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd3);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
    EpdMakeInf(epd3, sign);
    return;
  }

  epd3->type.value = epd1->type.value * epd2->type.value;
  epd3->exponent = epd1->exponent + epd2->exponent;
  EpdNormalizeDecimal(epd3);
}


/**
  @brief Divides an extended precision double by a double.
*/
void
EpdDivide(EpDouble *epd1, double value)
{
  EpDouble	epd2;
  double	tmp;
  int		exponent;

  if (EpdIsNan(epd1) || IsNanDouble(value)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || IsInfDouble(value)) {
    int	sign;

    EpdConvert(value, &epd2);
    if (EpdIsInf(epd1) && IsInfDouble(value)) {
      EpdMakeNan(epd1);
    } else if (EpdIsInf(epd1)) {
      sign = epd1->type.bits.sign ^ epd2.type.bits.sign;
      EpdMakeInf(epd1, sign);
    } else {
      sign = epd1->type.bits.sign ^ epd2.type.bits.sign;
      EpdMakeZero(epd1, sign);
    }
    return;
  }

  if (value == 0.0) {
    EpdMakeNan(epd1);
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);

  EpdConvert(value, &epd2);
  tmp = epd1->type.value / epd2.type.value;
  exponent = epd1->exponent - epd2.exponent;
  epd1->type.value = tmp;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Divides an extended precision double by another.
*/
void
EpdDivide2(EpDouble *epd1, EpDouble const *epd2)
{
  double	value;
  int		exponent;

  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    if (EpdIsInf(epd1) && EpdIsInf(epd2)) {
      EpdMakeNan(epd1);
    } else if (EpdIsInf(epd1)) {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      EpdMakeInf(epd1, sign);
    } else {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      EpdMakeZero(epd1, sign);
    }
    return;
  }

  if (epd2->type.value == 0.0) {
    EpdMakeNan(epd1);
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  value = epd1->type.value / epd2->type.value;
  exponent = epd1->exponent - epd2->exponent;
  epd1->type.value = value;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Divides two extended precision double values.
*/
void
EpdDivide3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3)
{
  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd3);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    if (EpdIsInf(epd1) && EpdIsInf(epd2)) {
      EpdMakeNan(epd3);
    } else if (EpdIsInf(epd1)) {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      EpdMakeInf(epd3, sign);
    } else {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      EpdMakeZero(epd3, sign);
    }
    return;
  }

  if (epd2->type.value == 0.0) {
    EpdMakeNan(epd3);
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  epd3->type.value = epd1->type.value / epd2->type.value;
  epd3->exponent = epd1->exponent - epd2->exponent;
  EpdNormalize(epd3);
}


/**
  @brief Adds a double to an extended precision double.
*/
void
EpdAdd(EpDouble *epd1, double value)
{
  EpDouble	epd2;
  double	tmp;
  int		exponent, diff;

  if (EpdIsNan(epd1) || IsNanDouble(value)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || IsInfDouble(value)) {
    int	sign;

    EpdConvert(value, &epd2);
    if (EpdIsInf(epd1) && IsInfDouble(value)) {
      sign = epd1->type.bits.sign ^ epd2.type.bits.sign;
      if (sign == 1)
	EpdMakeNan(epd1);
    } else if (EpdIsInf(&epd2)) {
      EpdCopy(&epd2, epd1);
    }
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);

  EpdConvert(value, &epd2);
  if (epd1->exponent > epd2.exponent) {
    diff = epd1->exponent - epd2.exponent;
    if (diff <= EPD_MAX_BIN)
      tmp = epd1->type.value + epd2.type.value / pow((double)2.0, (double)diff);
    else
      tmp = epd1->type.value;
    exponent = epd1->exponent;
  } else if (epd1->exponent < epd2.exponent) {
    diff = epd2.exponent - epd1->exponent;
    if (diff <= EPD_MAX_BIN)
      tmp = epd1->type.value / pow((double)2.0, (double)diff) + epd2.type.value;
    else
      tmp = epd2.type.value;
    exponent = epd2.exponent;
  } else {
    tmp = epd1->type.value + epd2.type.value;
    exponent = epd1->exponent;
  }
  epd1->type.value = tmp;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Adds an extended precision double to another.

  @details The sum goes in the first argument.
*/
void
EpdAdd2(EpDouble *epd1, EpDouble const *epd2)
{
  double	value;
  int		exponent, diff;

  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    if (EpdIsInf(epd1) && EpdIsInf(epd2)) {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      if (sign == 1)
	EpdMakeNan(epd1);
    } else if (EpdIsInf(epd2)) {
      EpdCopy(epd2, epd1);
    }
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  if (epd1->exponent > epd2->exponent) {
    diff = epd1->exponent - epd2->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value +
		epd2->type.value / pow((double)2.0, (double)diff);
    } else
      value = epd1->type.value;
    exponent = epd1->exponent;
  } else if (epd1->exponent < epd2->exponent) {
    diff = epd2->exponent - epd1->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value / pow((double)2.0, (double)diff) +
		epd2->type.value;
    } else
      value = epd2->type.value;
    exponent = epd2->exponent;
  } else {
    value = epd1->type.value + epd2->type.value;
    exponent = epd1->exponent;
  }
  epd1->type.value = value;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Adds two extended precision double values.
*/
void
EpdAdd3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3)
{
  double	value;
  int		exponent, diff;

  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd3);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    if (EpdIsInf(epd1) && EpdIsInf(epd2)) {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      if (sign == 1)
	EpdMakeNan(epd3);
      else
	EpdCopy(epd1, epd3);
    } else if (EpdIsInf(epd1)) {
      EpdCopy(epd1, epd3);
    } else {
      EpdCopy(epd2, epd3);
    }
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  if (epd1->exponent > epd2->exponent) {
    diff = epd1->exponent - epd2->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value +
		epd2->type.value / pow((double)2.0, (double)diff);
    } else
      value = epd1->type.value;
    exponent = epd1->exponent;
  } else if (epd1->exponent < epd2->exponent) {
    diff = epd2->exponent - epd1->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value / pow((double)2.0, (double)diff) +
		epd2->type.value;
    } else
      value = epd2->type.value;
    exponent = epd2->exponent;
  } else {
    value = epd1->type.value + epd2->type.value;
    exponent = epd1->exponent;
  }
  epd3->type.value = value;
  epd3->exponent = exponent;
  EpdNormalize(epd3);
}


/**
  @brief Subtracts a double from an extended precision double.
*/
void
EpdSubtract(EpDouble *epd1, double value)
{
  EpDouble	epd2;
  double	tmp;
  int		exponent, diff;

  if (EpdIsNan(epd1) || IsNanDouble(value)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || IsInfDouble(value)) {
    int	sign;

    EpdConvert(value, &epd2);
    if (EpdIsInf(epd1) && IsInfDouble(value)) {
      sign = epd1->type.bits.sign ^ epd2.type.bits.sign;
      if (sign == 0)
	EpdMakeNan(epd1);
    } else if (EpdIsInf(&epd2)) {
      EpdCopy(&epd2, epd1);
    }
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);

  EpdConvert(value, &epd2);
  if (epd1->exponent > epd2.exponent) {
    diff = epd1->exponent - epd2.exponent;
    if (diff <= EPD_MAX_BIN)
      tmp = epd1->type.value - epd2.type.value / pow((double)2.0, (double)diff);
    else
      tmp = epd1->type.value;
    exponent = epd1->exponent;
  } else if (epd1->exponent < epd2.exponent) {
    diff = epd2.exponent - epd1->exponent;
    if (diff <= EPD_MAX_BIN)
      tmp = epd1->type.value / pow((double)2.0, (double)diff) - epd2.type.value;
    else
      tmp = epd2.type.value * (double)(-1.0);
    exponent = epd2.exponent;
  } else {
    tmp = epd1->type.value - epd2.type.value;
    exponent = epd1->exponent;
  }
  epd1->type.value = tmp;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Subtracts an extended precision double from another.
*/
void
EpdSubtract2(EpDouble *epd1, EpDouble const *epd2)
{
  double	value;
  int		exponent, diff;

  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd1);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    if (EpdIsInf(epd1) && EpdIsInf(epd2)) {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      if (sign == 0)
	EpdMakeNan(epd1);
    } else if (EpdIsInf(epd2)) {
      EpdCopy(epd2, epd1);
    }
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  if (epd1->exponent > epd2->exponent) {
    diff = epd1->exponent - epd2->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value -
		epd2->type.value / pow((double)2.0, (double)diff);
    } else
      value = epd1->type.value;
    exponent = epd1->exponent;
  } else if (epd1->exponent < epd2->exponent) {
    diff = epd2->exponent - epd1->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value / pow((double)2.0, (double)diff) -
		epd2->type.value;
    } else
      value = epd2->type.value * (double)(-1.0);
    exponent = epd2->exponent;
  } else {
    value = epd1->type.value - epd2->type.value;
    exponent = epd1->exponent;
  }
  epd1->type.value = value;
  epd1->exponent = exponent;
  EpdNormalize(epd1);
}


/**
  @brief Subtracts two extended precision double values.
*/
void
EpdSubtract3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3)
{
  double	value;
  int		exponent, diff;

  if (EpdIsNan(epd1) || EpdIsNan(epd2)) {
    EpdMakeNan(epd3);
    return;
  } else if (EpdIsInf(epd1) || EpdIsInf(epd2)) {
    int	sign;

    if (EpdIsInf(epd1) && EpdIsInf(epd2)) {
      sign = epd1->type.bits.sign ^ epd2->type.bits.sign;
      if (sign == 0)
	EpdCopy(epd1, epd3);
      else
	EpdMakeNan(epd3);
    } else if (EpdIsInf(epd1)) {
      EpdCopy(epd1, epd3);
    } else {
      sign = epd2->type.bits.sign ^ 0x1;
      EpdMakeInf(epd3, sign);
    }
    return;
  }

  assert(epd1->type.bits.exponent == EPD_MAX_BIN);
  assert(epd2->type.bits.exponent == EPD_MAX_BIN);

  if (epd1->exponent > epd2->exponent) {
    diff = epd1->exponent - epd2->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value -
		epd2->type.value / pow((double)2.0, (double)diff);
    } else
      value = epd1->type.value;
    exponent = epd1->exponent;
  } else if (epd1->exponent < epd2->exponent) {
    diff = epd2->exponent - epd1->exponent;
    if (diff <= EPD_MAX_BIN) {
      value = epd1->type.value / pow((double)2.0, (double)diff) -
		epd2->type.value;
    } else
      value = epd2->type.value * (double)(-1.0);
    exponent = epd2->exponent;
  } else {
    value = epd1->type.value - epd2->type.value;
    exponent = epd1->exponent;
  }
  epd3->type.value = value;
  epd3->exponent = exponent;
  EpdNormalize(epd3);
}


/**
  @brief Computes extended precision pow of base 2.
*/
void
EpdPow2(int n, EpDouble *epd)
{
  if (n <= EPD_MAX_BIN) {
    EpdConvert(pow((double)2.0, (double)n), epd);
  } else {
    EpDouble	epd1, epd2;
    int		n1, n2;

    n1 = n / 2;
    n2 = n - n1;
    EpdPow2(n1, &epd1);
    EpdPow2(n2, &epd2);
    EpdMultiply3(&epd1, &epd2, epd);
  }
}


/**
  @brief Computes extended precision pow of base 2.
*/
void
EpdPow2Decimal(int n, EpDouble *epd)
{
  if (n <= EPD_MAX_BIN) {
    epd->type.value = pow((double)2.0, (double)n);
    epd->exponent = 0;
    EpdNormalizeDecimal(epd);
  } else {
    EpDouble	epd1, epd2;
    int		n1, n2;

    n1 = n / 2;
    n2 = n - n1;
    EpdPow2Decimal(n1, &epd1);
    EpdPow2Decimal(n2, &epd2);
    EpdMultiply3Decimal(&epd1, &epd2, epd);
  }
}


/**
  @brief Normalize an extended precision double value.
*/
void
EpdNormalize(EpDouble *epd)
{
  int		exponent;

  if (IsNanOrInfDouble(epd->type.value)) {
    epd->exponent = 0;
    return;
  }

  exponent = EpdGetExponent(epd->type.value);
  if (exponent == EPD_MAX_BIN)
    return;
  exponent -= EPD_MAX_BIN;
  epd->type.bits.exponent = EPD_MAX_BIN;
  epd->exponent += exponent;
}


/**
  @brief Normalize an extended precision double value.
*/
void
EpdNormalizeDecimal(EpDouble *epd)
{
  int		exponent;

  if (IsNanOrInfDouble(epd->type.value)) {
    epd->exponent = 0;
    return;
  }

  exponent = EpdGetExponentDecimal(epd->type.value);
  epd->type.value /= pow((double)10.0, (double)exponent);
  epd->exponent += exponent;
}


/**
  @brief Returns value and decimal exponent of EpDouble.
*/
void
EpdGetValueAndDecimalExponent(EpDouble const *epd, double *value, int *exponent)
{
  EpDouble	epd1, epd2;

  if (EpdIsNanOrInf(epd)) {
    *exponent = EPD_EXP_INF;
    *value = 0.0;
    return;
  }

  if (EpdIsZero(epd)) {
    *value = 0.0;
    *exponent = 0;
    return;
  }

  epd1.type.value = epd->type.value;
  epd1.exponent = 0;
  EpdPow2Decimal(epd->exponent, &epd2);
  EpdMultiply2Decimal(&epd1, &epd2);

  *value = epd1.type.value;
  *exponent = epd1.exponent;
}

/**
  @brief Returns the exponent value of a double.
*/
int
EpdGetExponent(double value)
{
  int		exponent;
  EpDouble	epd;

  epd.type.value = value;
  exponent = epd.type.bits.exponent;
  return(exponent);
}


/**
  @brief Returns the decimal exponent value of a double.
*/
int
EpdGetExponentDecimal(double value)
{
  char	*pos, str[24];
  int	exponent;

  sprintf(str, "%E", value);
  pos = strstr(str, "E");
  sscanf(pos, "E%d", &exponent);
  return(exponent);
}


/**
  @brief Makes EpDouble Inf.
*/
void
EpdMakeInf(EpDouble *epd, int sign)
{
  epd->type.bits.mantissa1 = 0;
  epd->type.bits.mantissa0 = 0;
  epd->type.bits.exponent = EPD_EXP_INF;
  epd->type.bits.sign = sign;
  epd->exponent = 0;
}


/**
  @brief Makes EpDouble Zero.
*/
void
EpdMakeZero(EpDouble *epd, int sign)
{
  epd->type.bits.mantissa1 = 0;
  epd->type.bits.mantissa0 = 0;
  epd->type.bits.exponent = 0;
  epd->type.bits.sign = sign;
  epd->exponent = 0;
}


/**
  @brief Makes EpDouble NaN.
*/
void
EpdMakeNan(EpDouble *epd)
{
  epd->type.nan.mantissa1 = 0;
  epd->type.nan.mantissa0 = 0;
  epd->type.nan.quiet_bit = 1;
  epd->type.nan.exponent = EPD_EXP_INF;
  epd->type.nan.sign = 1;
  epd->exponent = 0;
}


/**
  @brief Copies an EpDouble struct.
*/
void
EpdCopy(EpDouble const *from, EpDouble *to)
{
  to->type.value = from->type.value;
  to->exponent = from->exponent;
}


/**
  @brief Checks whether the value is Inf.
*/
int
EpdIsInf(EpDouble const *epd)
{
  return(IsInfDouble(epd->type.value));
}


/**
  @brief Checks whether the value is Zero.
*/
int
EpdIsZero(EpDouble const *epd)
{
  if (epd->type.value == 0.0)
    return(1);
  else
    return(0);
}


/**
  @brief Checks whether the value is NaN.
*/
int
EpdIsNan(EpDouble const *epd)
{
  return(IsNanDouble(epd->type.value));
}


/**
  @brief Checks whether the value is NaN or Inf.
*/
int
EpdIsNanOrInf(EpDouble const *epd)
{
  return(IsNanOrInfDouble(epd->type.value));
}


/**
  @brief Checks whether the value is Inf.
*/
int
IsInfDouble(double value)
{
  EpType val;

  val.value = value;
  if (val.bits.exponent == EPD_EXP_INF &&
      val.bits.mantissa0 == 0 &&
      val.bits.mantissa1 == 0) {
    if (val.bits.sign == 0)
      return(1);
    else
      return(-1);
  }
  return(0);
}


/**
  @brief Checks whether the value is NaN.
*/
int
IsNanDouble(double value)
{
  EpType	val;
  
  val.value = value;
  if (val.nan.exponent == EPD_EXP_INF &&
      val.nan.sign == 1 &&
      val.nan.quiet_bit == 1 &&
      val.nan.mantissa0 == 0 &&
      val.nan.mantissa1 == 0) {
    return(1);
  }
  return(0);
}


/**
  @brief Checks whether the value is NaN or Inf.
*/
int
IsNanOrInfDouble(double value)
{
  EpType	val;

  val.value = value;
  if (val.nan.exponent == EPD_EXP_INF &&
      val.nan.mantissa0 == 0 &&
      val.nan.mantissa1 == 0 &&
      (val.nan.sign == 1 || val.nan.quiet_bit == 0)) {
    return(1);
  }
  return(0);
}

epd.h
4712
/**
  @file 

  @ingroup epd

  @brief The University of Colorado extended double precision package.

  @details Arithmetic functions with extended double precision.  The floating
  point numbers manipulated by this package use an int to hold the exponent.
  The significand has the same precision as a standard double.

  @author In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef EPD_H_
#define EPD_H_

#ifdef __cplusplus
extern "C" {
#endif

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
   @brief The type of extended precision floating-point numbers.
*/
typedef struct EpDoubleStruct EpDouble;

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

extern EpDouble *EpdAlloc(void);
extern int EpdCmp(const void *key1, const void *key2);
extern void EpdFree(EpDouble *epd);
extern void EpdGetString(EpDouble const *epd, char *str);
extern void EpdConvert(double value, EpDouble *epd);
extern void EpdMultiply(EpDouble *epd1, double value);
extern void EpdMultiply2(EpDouble *epd1, EpDouble const *epd2);
extern void EpdMultiply2Decimal(EpDouble *epd1, EpDouble const *epd2);
extern void EpdMultiply3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3);
extern void EpdMultiply3Decimal(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3);
extern void EpdDivide(EpDouble *epd1, double value);
extern void EpdDivide2(EpDouble *epd1, EpDouble const *epd2);
extern void EpdDivide3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3);
extern void EpdAdd(EpDouble *epd1, double value);
extern void EpdAdd2(EpDouble *epd1, EpDouble const *epd2);
extern void EpdAdd3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3);
extern void EpdSubtract(EpDouble *epd1, double value);
extern void EpdSubtract2(EpDouble *epd1, EpDouble const *epd2);
extern void EpdSubtract3(EpDouble const *epd1, EpDouble const *epd2, EpDouble *epd3);
extern void EpdPow2(int n, EpDouble *epd);
extern void EpdPow2Decimal(int n, EpDouble *epd);
extern void EpdNormalize(EpDouble *epd);
extern void EpdNormalizeDecimal(EpDouble *epd);
extern void EpdGetValueAndDecimalExponent(EpDouble const *epd, double *value, int *exponent);
extern int EpdGetExponent(double value);
extern int EpdGetExponentDecimal(double value);
extern void EpdMakeInf(EpDouble *epd, int sign);
extern void EpdMakeZero(EpDouble *epd, int sign);
extern void EpdMakeNan(EpDouble *epd);
extern void EpdCopy(EpDouble const *from, EpDouble *to);
extern int EpdIsInf(EpDouble const *epd);
extern int EpdIsZero(EpDouble const *epd);
extern int EpdIsNan(EpDouble const *epd);
extern int EpdIsNanOrInf(EpDouble const *epd);
extern int IsInfDouble(double value);
extern int IsNanDouble(double value);
extern int IsNanOrInfDouble(double value);

#ifdef __cplusplus
}
#endif

#endif /* EPD_H_ */

epdInt.h
4259
/**
  @file 

  @ingroup epd

  @brief Internal header for the University of Colorado extended
  double precision package.

  @author In-Ho Moon

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef EPD_INT_H_
#define EPD_INT_H_

#include "config.h"
#include "epd.h"

#if WORDS_BIGENDIAN == 1
#define EPD_BIG_ENDIAN
#endif

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#define	EPD_MAX_BIN	1023
#define	EPD_MAX_DEC	308
#define	EPD_EXP_INF	0x7ff

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

typedef struct IeeeDoubleStruct IeeeDouble;
typedef struct IeeeNanStruct IeeeNan;
typedef union EpTypeUnion EpType;

/*---------------------------------------------------------------------------*/
/* Structure declarations                                                    */
/*---------------------------------------------------------------------------*/

/**
  @brief IEEE double struct.
*/
#ifdef	EPD_BIG_ENDIAN
struct IeeeDoubleStruct {	/* BIG_ENDIAN */
  unsigned int sign: 1;
  unsigned int exponent: 11;
  unsigned int mantissa0: 20;
  unsigned int mantissa1: 32;
};
#else
struct IeeeDoubleStruct {	/* LITTLE_ENDIAN */
  unsigned int mantissa1: 32;
  unsigned int mantissa0: 20;
  unsigned int exponent: 11;
  unsigned int sign: 1;
};
#endif

/**
  @brief IEEE double NaN struct.
*/
#ifdef	EPD_BIG_ENDIAN
struct IeeeNanStruct {	/* BIG_ENDIAN */
  unsigned int sign: 1;
  unsigned int exponent: 11;
  unsigned int quiet_bit: 1;
  unsigned int mantissa0: 19;
  unsigned int mantissa1: 32;
};
#else
struct IeeeNanStruct {	/* LITTLE_ENDIAN */
  unsigned int mantissa1: 32;
  unsigned int mantissa0: 19;
  unsigned int quiet_bit: 1;
  unsigned int exponent: 11;
  unsigned int sign: 1;
};
#endif

/**
  @brief Different views of a double.
*/
union EpTypeUnion {
  double			value;
  struct IeeeDoubleStruct	bits;
  struct IeeeNanStruct		nan;
};

/**
  @brief Extended precision double to keep very large value.
*/
struct EpDoubleStruct {
  union EpTypeUnion		type;
  int				exponent;
};

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#endif /* EPD_H_ */

mtr.h
5409
/**
  @file 

  @ingroup mtr

  @brief Multiway-branch tree manipulation

  @details This package provides two layers of functions. Functions
  of the lower level manipulate multiway-branch trees, implemented
  according to the classical scheme whereby each node points to its
  first child and its previous and next siblings. These functions are
  collected in mtrBasic.c.<p>
  Functions of the upper layer deal with group trees, that is the trees
  used by group sifting to represent the grouping of variables. These
  functions are collected in mtrGroup.c.

  @see The CUDD package documentation; specifically on group
  sifting.

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef MTR_H_
#define MTR_H_

/*---------------------------------------------------------------------------*/
/* Nested includes                                                           */
/*---------------------------------------------------------------------------*/

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/* Flag definitions */
#define MTR_DEFAULT	0x00000000
#define MTR_TERMINAL	0x00000001
#define MTR_SOFT	0x00000002
#define MTR_FIXED	0x00000004
#define MTR_NEWNODE	0x00000008

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
 * @brief multi-way tree node.
 */
typedef struct MtrNode_ MtrNode;

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

MtrNode * Mtr_AllocNode(void);
void Mtr_DeallocNode(MtrNode *node);
MtrNode * Mtr_InitTree(void);
void Mtr_FreeTree(MtrNode *node);
MtrNode * Mtr_CopyTree(MtrNode const *node, int expansion);
void Mtr_MakeFirstChild(MtrNode *parent, MtrNode *child);
void Mtr_MakeLastChild(MtrNode *parent, MtrNode *child);
MtrNode * Mtr_CreateFirstChild(MtrNode *parent);
MtrNode * Mtr_CreateLastChild(MtrNode *parent);
void Mtr_MakeNextSibling(MtrNode *first, MtrNode *second);
void Mtr_PrintTree(MtrNode const *node);
MtrNode * Mtr_InitGroupTree(int lower, int size);
MtrNode * Mtr_MakeGroup(MtrNode *root, unsigned int low, unsigned int high, unsigned int flags);
MtrNode * Mtr_DissolveGroup(MtrNode *group);
MtrNode * Mtr_FindGroup(MtrNode *root, unsigned int low, unsigned int high);
int Mtr_SwapGroups(MtrNode *first, MtrNode *second);
void Mtr_ReorderGroups(MtrNode *treenode, int *permutation);
void Mtr_PrintGroups(MtrNode const *root, int silent);
int Mtr_PrintGroupedOrder(MtrNode const * root, int const *invperm, FILE *fp);
MtrNode * Mtr_ReadGroups(FILE *fp, int nleaves);

#ifdef __cplusplus
}
#endif

#endif /* MTR_H_ */

mtrBasic.c
9536
/**
  @file

  @ingroup mtr

  @brief Basic manipulation of multiway branching trees.

  @see cudd package

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"


/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Allocates new tree node.

  @return pointer to node.

  @sideeffect None

  @see Mtr_DeallocNode

*/
MtrNode *
Mtr_AllocNode(void)
{
    MtrNode *node;

    node = ALLOC(MtrNode,1);
    node->flags = node->low = node->size = node->index = 0;
    return node;

} /* Mtr_AllocNode */


/**
  @brief Deallocates tree node.

  @sideeffect None

  @see Mtr_AllocNode

*/
void
Mtr_DeallocNode(
  MtrNode * node /**< node to be deallocated */)
{
    FREE(node);
    return;

} /* end of Mtr_DeallocNode */


/**
  @brief Initializes tree with one node.

  @return pointer to node.

  @sideeffect None

  @see Mtr_FreeTree Mtr_InitGroupTree

*/
MtrNode *
Mtr_InitTree(void)
{
    MtrNode *node;

    node = Mtr_AllocNode();
    if (node == NULL) return(NULL);

    node->parent = node->child = node->elder = node->younger = NULL;

    return(node);

} /* end of Mtr_InitTree */


/**
  @brief Disposes of tree rooted at node.

  @sideeffect None

  @see Mtr_InitTree

*/
void
Mtr_FreeTree(
  MtrNode * node)
{
    if (node == NULL) return;
    if (! MTR_TEST(node,MTR_TERMINAL)) Mtr_FreeTree(node->child);
    Mtr_FreeTree(node->younger);
    Mtr_DeallocNode(node);
    return;

} /* end of Mtr_FreeTree */


/**
  @brief Makes a copy of tree.

  @details If parameter expansion is greater than 1, it will expand
  the tree by that factor. It is an error for expansion to be less
  than 1.

  @return a pointer to the copy if successful; NULL otherwise.

  @sideeffect None

  @see Mtr_InitTree

*/
MtrNode *
Mtr_CopyTree(
  MtrNode const * node,
  int  expansion)
{
    MtrNode *copy;

    if (node == NULL) return(NULL);
    if (expansion < 1) return(NULL);
    copy = Mtr_AllocNode();
    if (copy == NULL) return(NULL);
    copy->parent = copy->elder = copy->child = copy->younger = NULL;
    if (node->child != NULL) {
	copy->child = Mtr_CopyTree(node->child, expansion);
	if (copy->child == NULL) {
	    Mtr_DeallocNode(copy);
	    return(NULL);
	}
    }
    if (node->younger != NULL) {
	copy->younger = Mtr_CopyTree(node->younger, expansion);
	if (copy->younger == NULL) {
	    Mtr_FreeTree(copy);
	    return(NULL);
	}
    }
    copy->flags = node->flags;
    copy->low = node->low * expansion;
    copy->size = node->size * expansion;
    copy->index = node->index * expansion;
    if (copy->younger) copy->younger->elder = copy;
    if (copy->child) {
	MtrNode *auxnode = copy->child;
	while (auxnode != NULL) {
	    auxnode->parent = copy;
	    auxnode = auxnode->younger;
	}
    }
    return(copy);

} /* end of Mtr_CopyTree */


/**
  @brief Makes child the first child of parent.

  @sideeffect None

  @see Mtr_MakeLastChild Mtr_CreateFirstChild

*/
void
Mtr_MakeFirstChild(
  MtrNode * parent,
  MtrNode * child)
{
    child->parent = parent;
    child->younger = parent->child;
    child->elder = NULL;
    if (parent->child != NULL) {
#ifdef MTR_DEBUG
	assert(parent->child->elder == NULL);
#endif
	parent->child->elder = child;
    }
    parent->child = child;
    return;

} /* end of Mtr_MakeFirstChild */


/**
  @brief Makes child the last child of parent.

  @sideeffect None

  @see Mtr_MakeFirstChild Mtr_CreateLastChild

*/
void
Mtr_MakeLastChild(
  MtrNode * parent,
  MtrNode * child)
{
    MtrNode *node;

    child->younger = NULL;

    if (parent->child == NULL) {
	parent->child = child;
	child->elder = NULL;
    } else {
	for (node = parent->child;
	     node->younger != NULL;
	     node = node->younger);
	node->younger = child;
	child->elder = node;
    }
    child->parent = parent;
    return;

} /* end of Mtr_MakeLastChild */


/**
  @brief Creates a new node and makes it the first child of parent.

  @return pointer to new child.

  @sideeffect None

  @see Mtr_MakeFirstChild Mtr_CreateLastChild

*/
MtrNode *
Mtr_CreateFirstChild(
  MtrNode * parent)
{
    MtrNode *child;

    child = Mtr_AllocNode();
    if (child == NULL) return(NULL);

    child->child = NULL;
    Mtr_MakeFirstChild(parent,child);
    return(child);

} /* end of Mtr_CreateFirstChild */


/**
  @brief Creates a new node and makes it the last child of parent.

  @return pointer to new child.

  @sideeffect None

  @see Mtr_MakeLastChild Mtr_CreateFirstChild

*/
MtrNode *
Mtr_CreateLastChild(
  MtrNode * parent)
{
    MtrNode *child;

    child = Mtr_AllocNode();
    if (child == NULL) return(NULL);

    child->child = NULL;
    Mtr_MakeLastChild(parent,child);
    return(child);

} /* end of Mtr_CreateLastChild */


/**
  @brief Makes second the next sibling of first.

  @details Second becomes a child of the parent of first.

  @sideeffect None

*/
void
Mtr_MakeNextSibling(
  MtrNode * first,
  MtrNode * second)
{
    second->parent = first->parent;
    second->elder = first;
    second->younger = first->younger;
    if (first->younger != NULL) {
	first->younger->elder = second;
    }
    first->younger = second;
    return;

} /* end of Mtr_MakeNextSibling */


/**
  @brief Prints a tree, one node per line.

  @sideeffect None

  @see Mtr_PrintGroups

*/
void
Mtr_PrintTree(
  MtrNode const * node)
{
    if (node == NULL) return;
    (void) fprintf(stdout,
        "N=0x%-8" PRIxPTR " C=0x%-8" PRIxPTR " Y=0x%-8" PRIxPTR
        " E=0x%-8" PRIxPTR " P=0x%-8" PRIxPTR " F=%x L=%u S=%u\n",
        (uintptr_t) node, (uintptr_t) node->child,
        (uintptr_t) node->younger, (uintptr_t) node->elder,
        (uintptr_t) node->parent, node->flags, node->low, node->size);
    if (!MTR_TEST(node,MTR_TERMINAL)) Mtr_PrintTree(node->child);
    Mtr_PrintTree(node->younger);
    return;

} /* end of Mtr_PrintTree */

/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

mtrGroup.c
24499
/**
  @file

  @ingroup mtr

  @brief Functions to support group specification for reordering.

  @see cudd package

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "mtrInt.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int mtrShiftHL (MtrNode *node, int shift);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/


/**
  @brief Allocate new tree.

  @details Allocate new tree with one node, whose low and size
  fields are specified by the lower and size parameters.

  @return pointer to tree root.

  @sideeffect None

  @see Mtr_InitTree Mtr_FreeTree

*/
MtrNode *
Mtr_InitGroupTree(
  int  lower,
  int  size)
{
    MtrNode *root;

    root = Mtr_InitTree();
    if (root == NULL) return(NULL);
    root->flags = MTR_DEFAULT;
    root->low = lower;
    root->size = size;
    return(root);

} /* end of Mtr_InitGroupTree */


/**
  @brief Makes a new group with size leaves starting at low.

  @details If the new group intersects an existing group, it must
  either contain it or be contained by it.  This procedure relies on
  the low and size fields of each node. It also assumes that the
  children of each node are sorted in order of increasing low.  In
  case of a valid request, the flags of the new group are set to the
  value passed in `flags.'

  @return the pointer to the root of the new group upon successful
  termination; NULL otherwise. If the group already exists, the
  pointer to its root is returned.

  @sideeffect None

  @see Mtr_DissolveGroup Mtr_ReadGroups Mtr_FindGroup

*/
MtrNode *
Mtr_MakeGroup(
  MtrNode * root /**< root of the group tree */,
  unsigned int  low /**< lower bound of the group */,
  unsigned int  size /**< size of the group */,
  unsigned int  flags /**< flags for the new group */)
{
    MtrNode *node,
	    *first,
	    *last,
	    *previous,
	    *newn;

    /* Sanity check. */
    if (size == 0)
	return(NULL);

    /* Check whether current group includes new group.  This check is
    ** necessary at the top-level call.  In the subsequent calls it is
    ** redundant. */
    if (low < (unsigned int) root->low ||
	low + size > (unsigned int) (root->low + root->size))
	return(NULL);

    /* At this point we know that the new group is contained
    ** in the group of root. We have two possible cases here:
    **  - root is a terminal node;
    **  - root has children.       */

    /* Root has no children: create a new group. */
    if (root->child == NULL) {
	newn = Mtr_AllocNode();
	if (newn == NULL) return(NULL);	/* out of memory */
	newn->low = low;
	newn->size = size;
	newn->flags = flags;
	newn->parent = root;
	newn->elder = newn->younger = newn->child = NULL;
	root->child = newn;
	return(newn);
    }

    /* Root has children: Find all children of root that are included
    ** in the new group.  If the group of any child entirely contains
    ** the new group, call Mtr_MakeGroup recursively. */
    previous = NULL;
    first = root->child; /* guaranteed to be non-NULL */
    while (first != NULL && low >= (unsigned int) (first->low + first->size)) {
	previous = first;
	first = first->younger;
    }
    if (first == NULL) {
	/* We have scanned the entire list and we need to append a new
	** child at the end of it.  Previous points to the last child
	** of root. */
	newn = Mtr_AllocNode();
	if (newn == NULL) return(NULL);	/* out of memory */
	newn->low = low;
	newn->size = size;
	newn->flags = flags;
	newn->parent = root;
	newn->elder = previous;
	previous->younger = newn;
	newn->younger = newn->child = NULL;
	return(newn);
    }
    /* Here first is non-NULL and low < first->low + first->size. */
    if (low >= (unsigned int) first->low &&
	low + size <= (unsigned int) (first->low + first->size)) {
	/* The new group is contained in the group of first. */
	newn = Mtr_MakeGroup(first, low, size, flags);
	return(newn);
    } else if (low + size <= first->low) {
	/* The new group is entirely contained in the gap between
	** previous and first. */
	newn = Mtr_AllocNode();
	if (newn == NULL) return(NULL);	/* out of memory */
	newn->low = low;
	newn->size = size;
	newn->flags = flags;
	newn->child = NULL;
	newn->parent = root;
	newn->elder = previous;
	newn->younger = first;
	first->elder = newn;
	if (previous != NULL) {
	    previous->younger = newn;
	} else {
	    root->child = newn;
	}
	return(newn);
    } else if (low < (unsigned int) first->low &&
	       low + size < (unsigned int) (first->low + first->size)) {
	/* Trying to cut an existing group: not allowed. */
	return(NULL);
    } else if (low > first->low) {
	/* The new group neither is contained in the group of first
	** (this was tested above) nor contains it. It is therefore
	** trying to cut an existing group: not allowed. */
	return(NULL);
    }

    /* First holds the pointer to the first child contained in the new
    ** group. Here low <= first->low and low + size >= first->low +
    ** first->size.  One of the two inequalities is strict. */
    last = first;
    while (last->younger != NULL &&
	   (unsigned int) (last->younger->low + last->younger->size) <= low + size) {
	last = last->younger;
    }
    if (last == NULL) {
	/* All the chilren of root from first onward become children
	** of the new group. */
	newn = Mtr_AllocNode();
	if (newn == NULL) return(NULL);	/* out of memory */
	newn->low = low;
	newn->size = size;
	newn->flags = flags;
	newn->child = first;
	newn->parent = root;
	newn->elder = previous;
	newn->younger = NULL;
	first->elder = NULL;
	if (previous != NULL) {
	    previous->younger = newn;
	} else {
	    root->child = newn;
	}
	last = first;
	while (last != NULL) {
	    last->parent = newn;
	    last = last->younger;
	}
	return(newn);
    }

    /* Here last != NULL and low + size <= last->low + last->size. */
    if (low + size - 1 >= (unsigned int) last->low &&
	low + size < (unsigned int) (last->low + last->size)) {
	/* Trying to cut an existing group: not allowed. */
	return(NULL);
    }

    /* First and last point to the first and last of the children of
    ** root that are included in the new group. Allocate a new node
    ** and make all children of root between first and last chidren of
    ** the new node.  Previous points to the child of root immediately
    ** preceeding first. If it is NULL, then first is the first child
    ** of root. */
    newn = Mtr_AllocNode();
    if (newn == NULL) return(NULL);	/* out of memory */
    newn->low = low;
    newn->size = size;
    newn->flags = flags;
    newn->child = first;
    newn->parent = root;
    if (previous == NULL) {
	root->child = newn;
    } else {
	previous->younger = newn;
    }
    newn->elder = previous;
    newn->younger = last->younger;
    if (last->younger != NULL) {
	last->younger->elder = newn;
    }
    last->younger = NULL;
    first->elder = NULL;
    for (node = first; node != NULL; node = node->younger) {
	node->parent = newn;
    }

    return(newn);

} /* end of Mtr_MakeGroup */


/**
  @brief Merges the children of `group' with the children of its
  parent.

  @details Disposes of the node pointed by group. If group is the root
  of the group tree, this procedure leaves the tree unchanged.

  @return the pointer to the parent of `group' upon successful
  termination; NULL otherwise.

  @sideeffect None

  @see Mtr_MakeGroup

*/
MtrNode *
Mtr_DissolveGroup(
  MtrNode * group /**< group to be dissolved */)
{
    MtrNode *parent;
    MtrNode *last;

    parent = group->parent;

    if (parent == NULL) return(NULL);
    if (MTR_TEST(group,MTR_TERMINAL) || group->child == NULL) return(NULL);

    /* Make all children of group children of its parent, and make
    ** last point to the last child of group. */
    for (last = group->child; last->younger != NULL; last = last->younger) {
	last->parent = parent;
    }
    last->parent = parent;

    last->younger = group->younger;
    if (group->younger != NULL) {
	group->younger->elder = last;
    }

    group->child->elder = group->elder;
    if (group == parent->child) {
	parent->child = group->child;
    } else {
	group->elder->younger = group->child;
    }

    Mtr_DeallocNode(group);
    return(parent);

} /* end of Mtr_DissolveGroup */


/**
  @brief Finds a group with size leaves starting at low, if it exists.

  @details This procedure relies on the low and size fields of each
  node. It also assumes that the children of each node are sorted in
  order of increasing low.

  @return the pointer to the root of the group upon successful
  termination; NULL otherwise.

  @sideeffect None

*/
MtrNode *
Mtr_FindGroup(
  MtrNode * root /**< root of the group tree */,
  unsigned int  low /**< lower bound of the group */,
  unsigned int  size /**< upper bound of the group */)
{
    MtrNode *node;

#ifdef MTR_DEBUG
    /* We cannot have a non-empty proper subgroup of a singleton set. */
    assert(!MTR_TEST(root,MTR_TERMINAL));
#endif

    /* Sanity check. */
    if (size < 1) return(NULL);

    /* Check whether current group includes the group sought.  This
    ** check is necessary at the top-level call.  In the subsequent
    ** calls it is redundant. */
    if (low < (unsigned int) root->low ||
	low + size > (unsigned int) (root->low + root->size))
	return(NULL);

    if (root->size == size && root->low == low)
	return(root);

    if (root->child == NULL)
	return(NULL);

    /* Find all chidren of root that are included in the new group. If
    ** the group of any child entirely contains the new group, call
    ** Mtr_MakeGroup recursively.  */
    node = root->child;
    while (low >= (unsigned int) (node->low + node->size)) {
	node = node->younger;
    }
    if (low + size <= (unsigned int) (node->low + node->size)) {
	/* The group is contained in the group of node. */
	node = Mtr_FindGroup(node, low, size);
	return(node);
    } else {
	return(NULL);
    }

} /* end of Mtr_FindGroup */


/**
  @brief Swaps two children of a tree node.

  @details Adjusts the high and low fields of the two nodes and their
  descendants.  The two children must be adjacent. However, first may
  be the younger sibling of second.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
int
Mtr_SwapGroups(
  MtrNode * first /**< first node to be swapped */,
  MtrNode * second /**< second node to be swapped */)
{
    MtrNode *node;
    MtrNode *parent;
    int sizeFirst;
    int sizeSecond;

    if (second->younger == first) { /* make first first */
	node = first;
	first = second;
	second = node;
    } else if (first->younger != second) { /* non-adjacent */
	return(0);
    }

    sizeFirst = first->size;
    sizeSecond = second->size;

    /* Swap the two nodes. */
    parent = first->parent;
    if (parent == NULL || second->parent != parent) return(0);
    if (parent->child == first) {
	parent->child = second;
    } else { /* first->elder != NULL */
	first->elder->younger = second;
    }
    if (second->younger != NULL) {
	second->younger->elder = first;
    }
    first->younger = second->younger;
    second->elder = first->elder;
    first->elder = second;
    second->younger = first;

    /* Adjust the high and low fields. */
    if (!mtrShiftHL(first,sizeSecond)) return(0);
    if (!mtrShiftHL(second,-sizeFirst)) return(0);

    return(1);

} /* end of Mtr_SwapGroups */


/**
  @brief Fix variable tree at the end of tree sifting.

  @details Fix the levels in the variable tree sorting siblings
  according to them.  It should be called on a non-NULL tree.  It then
  maintains this invariant.  It applies insertion sorting to the list of
  siblings  The order is determined by permutation, which is used to find
  the new level of the node index.  Index must refer to the first variable
  in the group.

  @sideeffect The tree is modified.

*/
void
Mtr_ReorderGroups(
  MtrNode *treenode,
  int *permutation)
{
    MtrNode *auxnode;
    /* Initialize sorted list to first element. */
    MtrNode *sorted = treenode;
    sorted->low = permutation[sorted->index];
    if (sorted->child != NULL)
      Mtr_ReorderGroups(sorted->child, permutation);

    auxnode = treenode->younger;
    while (auxnode != NULL) {
        MtrNode *rightplace;
        MtrNode *moving = auxnode;
	auxnode->low = permutation[auxnode->index];
	if (auxnode->child != NULL)
          Mtr_ReorderGroups(auxnode->child, permutation);
        rightplace = auxnode->elder;
        /* Find insertion point. */
        while (rightplace != NULL && auxnode->low < rightplace->low)
            rightplace = rightplace->elder;
        auxnode = auxnode->younger;
        if (auxnode != NULL) {
            auxnode->elder = moving->elder;
            auxnode->elder->younger = auxnode;
        } else {
            moving->elder->younger = NULL;
        }
        if (rightplace == NULL) { /* Move to head of sorted list. */
            sorted->elder = moving;
            moving->elder = NULL;
            moving->younger = sorted;
            sorted = moving;
        } else { /* Splice. */
            moving->elder = rightplace;
            moving->younger = rightplace->younger;
            if (rightplace->younger != NULL)
                rightplace->younger->elder = moving;
            rightplace->younger = moving;
        }
    }
    /* Fix parent. */
    if (sorted->parent != NULL)
        sorted->parent->child = sorted;

} /* end of Mtr_ReorderGroups */


/**
  @brief Prints the groups as a parenthesized list.

  @details After each group, the group's flag are printed, preceded by a `|'.
  For each flag (except MTR_TERMINAL) a character is printed.
  <ul>
  <li>F: MTR_FIXED
  <li>N: MTR_NEWNODE
  <li>S: MTR_SOFT
  </ul>
  The second argument, silent, if different from 0, causes
  Mtr_PrintGroups to only check the syntax of the group tree.

  @sideeffect None

  @see Mtr_PrintTree

*/
void
Mtr_PrintGroups(
  MtrNode const * root /**< root of the group tree */,
  int  silent /**< flag to check tree syntax only */)
{
    MtrNode *node;

    assert(root != NULL);
    assert(root->younger == NULL || root->younger->elder == root);
    assert(root->elder == NULL || root->elder->younger == root);
#if SIZEOF_VOID_P == 8
    if (!silent) (void) printf("(%u",root->low);
#else
    if (!silent) (void) printf("(%hu",root->low);
#endif
    if (MTR_TEST(root,MTR_TERMINAL) || root->child == NULL) {
	if (!silent) (void) printf(",");
    } else {
	node = root->child;
	while (node != NULL) {
	    assert(node->low >= root->low && (int) (node->low + node->size) <= (int) (root->low + root->size));
	    assert(node->parent == root);
	    Mtr_PrintGroups(node,silent);
	    node = node->younger;
	}
    }
    if (!silent) {
#if SIZEOF_VOID_P == 8
	(void) printf("%u", (MtrHalfWord) (root->low + root->size - 1));
#else
	(void) printf("%hu", (MtrHalfWord) (root->low + root->size - 1));
#endif
	if (root->flags != MTR_DEFAULT) {
	    (void) printf("|");
	    if (MTR_TEST(root,MTR_FIXED)) (void) printf("F");
	    if (MTR_TEST(root,MTR_NEWNODE)) (void) printf("N");
	    if (MTR_TEST(root,MTR_SOFT)) (void) printf("S");
	}
	(void) printf(")");
	if (root->parent == NULL) (void) printf("\n");
    }
    assert((root->flags &~(MTR_TERMINAL | MTR_SOFT | MTR_FIXED | MTR_NEWNODE)) == 0);
    return;

} /* end of Mtr_PrintGroups */


/**
  @brief Prints the variable order as a parenthesized list.

  @details After each group, the group's flag are printed, preceded by a `|'.
  For each flag (except MTR_TERMINAL) a character is printed.
  <ul>
  <li>F: MTR_FIXED
  <li>N: MTR_NEWNODE
  <li>S: MTR_SOFT
  </ul>
  The second argument, gives the map from levels to variable indices.

  @return 1 if successful; 0 otherwise.

  @sideeffect None

  @see Mtr_PrintGroups

*/
int
Mtr_PrintGroupedOrder(
  MtrNode const * root /**< root of the group tree */,
  int const *invperm /**< map from levels to indices */,
  FILE *fp /**< output file */)
{
    MtrNode *child;
    MtrHalfWord level;
    int retval;

    assert(root != NULL);
    assert(root->younger == NULL || root->younger->elder == root);
    assert(root->elder == NULL || root->elder->younger == root);
    retval = fprintf(fp,"(");
    if (retval == EOF) return(0);
    level = root->low;
    child = root->child;
    while (child != NULL) {
        assert(child->low >= root->low && (child->low + child->size) <= (root->low + root->size));
        assert(child->parent == root);
        while (level < child->low) {
            retval = fprintf(fp,"%d%s", invperm[level], (level < root->low + root->size - 1) ? "," : "");
            if (retval == EOF) return(0);
            level++;
        }
        retval = Mtr_PrintGroupedOrder(child,invperm,fp);
        if (retval == 0) return(0);
        level += child->size;
        if (level < root->low + root->size - 1) {
            retval = fprintf(fp,",");
            if (retval == EOF) return(0);
        }
        child = child->younger;
    }
    while (level < root->low + root->size) {
        retval = fprintf(fp,"%d%s", invperm[level], (level < root->low + root->size - 1) ? "," : "");
        if (retval == EOF) return(0);
        level++;
    }
    if (root->flags != MTR_DEFAULT) {
      retval = fprintf(fp,"|");
      if (retval == EOF) return(0);
      if (MTR_TEST(root,MTR_FIXED)) {
          retval = fprintf(fp,"F");
          if (retval == EOF) return(0);
      }
      if (MTR_TEST(root,MTR_NEWNODE)) {
          retval = fprintf(fp,"N");
          if (retval == EOF) return(0);
      }
      if (MTR_TEST(root,MTR_SOFT)) {
          retval = fprintf(fp,"S");
          if (retval == EOF) return(0);
      }
    }
    retval = fprintf(fp,")");
    if (retval == EOF) return(0);
    if (root->parent == NULL) {
        retval = fprintf(fp,"\n");
        if (retval == EOF) return(0);
    }
    assert((root->flags &~(MTR_SOFT | MTR_FIXED | MTR_NEWNODE)) == 0);
    return(1);

} /* end of Mtr_PrintGroupedOrder */


/**
  @brief Reads groups from a file and creates a group tree.

  @details Each group is specified by three fields:

       low size flags.

  Low and size are (short) integers. Flags is a string composed of the
  following characters (with associated translation):
  <ul>
  <li>D: MTR_DEFAULT
  <li>F: MTR_FIXED
  <li>N: MTR_NEWNODE
  <li>S: MTR_SOFT
  <li>T: MTR_TERMINAL
  </ul>
  Normally, the only flags that are needed are D and F.  Groups and
  fields are separated by white space (spaces, tabs, and newlines).

  @return a pointer to the group tree if successful; NULL otherwise.

  @sideeffect None

  @see Mtr_InitGroupTree Mtr_MakeGroup

*/
MtrNode *
Mtr_ReadGroups(
  FILE * fp /**< file pointer */,
  int  nleaves /**< number of leaves of the new tree */)
{
    int low;
    int size;
    int err;
    unsigned int flags;
    MtrNode *root;
    MtrNode *node;
    char attrib[8*sizeof(unsigned int)+1];
    char *c;

    root = Mtr_InitGroupTree(0,nleaves);
    if (root == NULL) return NULL;

    while (! feof(fp)) {
	/* Read a triple and check for consistency. */
	err = fscanf(fp, "%d %d %s", &low, &size, attrib);
	if (err == EOF) {
	    break;
	} else if (err != 3) {
	    Mtr_FreeTree(root);
	    return(NULL);
	} else if (low < 0 || low+size > nleaves || size < 1) {
	    Mtr_FreeTree(root);
	    return(NULL);
	} else if (strlen(attrib) > 8 * sizeof(MtrHalfWord)) {
	    /* Not enough bits in the flags word to store these many
	    ** attributes. */
	    Mtr_FreeTree(root);
	    return(NULL);
	}

	/* Parse the flag string. Currently all flags are permitted,
	** to make debugging easier. Normally, specifying NEWNODE
	** wouldn't be allowed. */
	flags = MTR_DEFAULT;
	for (c=attrib; *c != 0; c++) {
	    switch (*c) {
	    case 'D':
		break;
	    case 'F':
		flags |= MTR_FIXED;
		break;
	    case 'N':
		flags |= MTR_NEWNODE;
		break;
	    case 'S':
		flags |= MTR_SOFT;
		break;
	    case 'T':
		flags |= MTR_TERMINAL;
		break;
	    default:
		return NULL;
	    }
	}
	node = Mtr_MakeGroup(root, (MtrHalfWord) low, (MtrHalfWord) size,
			     flags);
	if (node == NULL) {
	    Mtr_FreeTree(root);
	    return(NULL);
	}
    }

    return(root);

} /* end of Mtr_ReadGroups */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/


/**
  @brief Adjusts the low fields of a node and its descendants.

  @details Adds shift to low of each node. Checks that no
  out-of-bounds values result.

  @return 1 in case of success; 0 otherwise.

  @sideeffect None

*/
static int
mtrShiftHL(
  MtrNode * node /**< group tree node */,
  int  shift /**< amount by which low should be changed */)
{
    MtrNode *auxnode;
    int low;

    low = (int) node->low;


    low += shift;

    if (low < 0 || low + (int) (node->size - 1) > (int) MTR_MAXHIGH) return(0);

    node->low = (MtrHalfWord) low;

    if (!MTR_TEST(node,MTR_TERMINAL) && node->child != NULL) {
	auxnode = node->child;
	do {
	    if (!mtrShiftHL(auxnode,shift)) return(0);
	    auxnode = auxnode->younger;
	} while (auxnode != NULL);
    }

    return(1);

} /* end of mtrShiftHL */

mtrInt.h
4753
/**
  @file 

  @ingroup mtr

  @brief Internal data structures of the mtr package

  @author Fabio Somenzi

  @copyright@parblock
  Copyright (c) 1995-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef MTRINT_H_
#define MTRINT_H_

/*---------------------------------------------------------------------------*/
/* Nested includes                                                           */
/*---------------------------------------------------------------------------*/

#include "config.h"
#include "mtr.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

#ifndef SIZEOF_VOID_P
#define SIZEOF_VOID_P 4
#endif
#ifndef SIZEOF_INT
#define SIZEOF_INT 4
#endif

#if defined(__GNUC__)
#define MTR_INLINE __inline__
# if (__GNUC__ >2 || __GNUC_MINOR__ >=7)
#   define MTR_UNUSED __attribute__ ((unused))
# else
#   define MTR_UNUSED
# endif
#else
#define MTR_INLINE
#define MTR_UNUSED
#endif

/* MTR_MAXHIGH is defined in such a way that on 32-bit and 64-bit
** machines one can cast a value to (int) without generating a negative
** number.
*/
#if SIZEOF_VOID_P == 8
#define MTR_MAXHIGH	(((MtrHalfWord) ~0) >> 1)
#else
#define MTR_MAXHIGH	((MtrHalfWord) ~0)
#endif

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
 * @brief unsigned integer half the size of a pointer.
 */
#if SIZEOF_VOID_P == 8
typedef uint32_t   MtrHalfWord;
#else
typedef uint16_t MtrHalfWord;
#endif

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief multi-way tree node.
 */
struct MtrNode_ {
    MtrHalfWord flags;
    MtrHalfWord low;
    MtrHalfWord size;
    MtrHalfWord index;
    struct MtrNode_ *parent;
    struct MtrNode_ *child;
    struct MtrNode_ *elder;
    struct MtrNode_ *younger;
};

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/* Flag manipulation macros */
#define MTR_SET(node, flag)	(node->flags |= (flag))
#define MTR_RESET(node, flag)	(node->flags &= ~ (flag))
#define MTR_TEST(node, flag)	(node->flags & (flag))


/** \cond */

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

/** \endcond */


#endif /* MTRINT_H_ */

pathsearch.c
4851
/**
  @file

  @ingroup util

  @brief Search in PATH.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"

/** \cond */

static int check_file (char const *, char const *);

/** \endcond */

/**
 * @brief Looks for a program in the directories specified by PATH.
 */
char *
util_path_search(char const *prog)
{
#ifdef UNIX
    return util_file_search(prog, getenv("PATH"), (char *) "x");
#else
    return util_file_search(prog, NIL(char), (char *) "x");
#endif
}


/**
 * @brief Searches for a file given a set of paths.
 */
char *
util_file_search(
  char const *file,		/**< file we're looking for */
  char *path,			/**< search path, colon separated */
  char const *mode		/**< "r", "w", or "x" */)
{
    int quit;
    char *buffer, *filename, *save_path, *cp;

    if (path == 0 || strcmp(path, "") == 0) {
	path = (char *) ".";	/* just look in the current directory */
    }

    save_path = path = util_strsav(path);
    quit = 0;
    do {
	cp = strchr(path, ':');
	if (cp != 0) {
	    *cp = '\0';
	} else {
	    quit = 1;
	}

	/* cons up the filename out of the path and file name */
	if (strcmp(path, ".") == 0) {
	    buffer = util_strsav(file);
	} else {
	    buffer = ALLOC(char, strlen(path) + strlen(file) + 4);
	    (void) sprintf(buffer, "%s/%s", path, file);
	}
	filename = util_tilde_expand(buffer);
	FREE(buffer);

	/* see if we can access it */
	if (check_file(filename, mode)) {
	    FREE(save_path);
	    return filename;
	}
	FREE(filename);
	path = ++cp;
    } while (! quit); 

    FREE(save_path);
    return 0;
}

/**
 * @brief Checks user permissions for a file.
 */
static int
check_file(char const *filename, char const *mode)
{
#ifdef UNIX
    int access_mode = /*F_OK*/ 0;

    if (strcmp(mode, "r") == 0) {
	access_mode = /*R_OK*/ 4;
    } else if (strcmp(mode, "w") == 0) {
	access_mode = /*W_OK*/ 2;
    } else if (strcmp(mode, "x") == 0) {
	access_mode = /*X_OK*/ 1;
    }
    return access(filename, access_mode) == 0;
#else
    FILE *fp;
    int got_file;

    if (strcmp(mode, "x") == 0) {
	mode = "r";
    }
    fp = fopen(filename, mode);
    got_file = (fp != 0);
    if (fp != 0) {
	(void) fclose(fp);
    }
    return got_file;
#endif
}

pipefork.c
5070
/**
  @file

  @ingroup util

  @brief Forks a command and sets up pipes to and from.

  @author Rick L Spickelmier
  @author Richard Rudell

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "config.h"
#if HAVE_UNISTD_H == 1
#define _POSIX_SOURCE
#include <unistd.h>
#endif
#include <stdio.h>
#if HAVE_SYS_WAIT_H == 1
#include <sys/wait.h>
#endif

/**
 * @def EXTERN
 * @brief Allows C linkage when compiling as C++.
 */
#ifndef EXTERN
#   ifdef __cplusplus
#	define EXTERN extern "C"
#   else
#	define EXTERN extern
#   endif
#endif


/**
 * @brief Forks a command and sets up pipes to and from.
 *
 * @return 1 for success, with toCommand and fromCommand pointing to
 *   the streams; 0 for failure
 */
int
util_pipefork(
  char * const *argv,	/**< normal argv argument list */
  FILE **toCommand,	/**< pointer to the sending stream */
  FILE **fromCommand,	/**< pointer to the reading stream */
  int *pid /**< process ID */)
{
#if HAVE_SYS_WAIT_H == 1
    int forkpid, waitPid;
    int topipe[2], frompipe[2];
    char buffer[1024];
    int status;

    /* create the PIPES...
     * fildes[0] for reading from command
     * fildes[1] for writing to command
     */
    if (pipe(topipe)) return(0);
    if (pipe(frompipe)) return(0);

    if ((forkpid = fork()) == 0) {
	/* child here, connect the pipes */
	(void) dup2(topipe[0], fileno(stdin));
	(void) dup2(frompipe[1], fileno(stdout));

	(void) close(topipe[0]);
	(void) close(topipe[1]);
	(void) close(frompipe[0]);
	(void) close(frompipe[1]);

	(void) execvp(argv[0], argv);
	(void) sprintf(buffer, "util_pipefork: can not exec %s", argv[0]);
	perror(buffer);
	(void) _exit(1);
    }

    if (pid) {
        *pid = forkpid;
    }

    waitPid = waitpid(-1, &status, WNOHANG);

    /* parent here, use fork() semantics to get return status */
    if (waitPid == forkpid && WIFEXITED(status)) {
	return 0;
    }
    if ((*toCommand = fdopen(topipe[1], "w")) == NULL) {
	return 0;
    }
    if ((*fromCommand = fdopen(frompipe[0], "r")) == NULL) {
	return 0;
    }
    (void) close(topipe[0]);
    (void) close(frompipe[1]);
    return 1;
#else
    (void) argv;        /* to avoid warning */
    (void) toCommand;   /* to avoid warning */
    (void) fromCommand; /* to avoid warning */
    (void) pid;         /* to avoid warning */
    (void) fprintf(stderr, 
	"util_pipefork: not implemented on your operating system\n");
    return 0;
#endif
}

prtime.c
3107
/**
  @file

  @ingroup util

  @brief Time printing utility.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"

/**
 *  @brief Massages a long that represents a time interval in
 *  milliseconds into a string suitable for output.
 *
 *  Hack for IBM/PC -- avoids using floating point.
 */
char *
util_print_time(unsigned long t)
{
    static char s[40];

    (void) sprintf(s, "%lu.%02lu sec", t/1000, (t%1000)/10);
    return s;
}

safe_mem.c
3904
/**
  @file

  @ingroup util

  @brief Interface routines to be placed between a program and the
  system memory allocator.  

  The function pointer MMoutOfMemory() contains a vector to handle a
  'out-of-memory' error (which, by default, points at a simple wrap-up 
  and exit routine).

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Global out-of-memory handler.
 */
void (*MMoutOfMemory)(size_t) = MMout_of_memory;

#ifdef __cplusplus
}
#endif


/**
 * @brief Out of memory for lazy people: flush and exit.
 */
void 
MMout_of_memory(size_t size)
{
    (void) fflush(stdout);
    (void) fprintf(stderr,
                   "\nCUDD: out of memory allocating %" PRIszt " bytes\n",
		   (size_t) size);
    exit(1);
}

/**
 * @brief malloc replacement.
 */
void *
MMalloc(size_t size)
{
    void *p;

    if ((p = malloc(size)) == NIL(void)) {
	if (MMoutOfMemory != 0 ) (*MMoutOfMemory)(size);
	return NIL(void);
    }
    return p;
}


/**
 * @brief realloc replacement.
 */
void *
MMrealloc(void *obj, size_t size)
{
    void *p;

    if ((p = realloc(obj, size)) == NIL(void)) {
	if (MMoutOfMemory != 0 ) (*MMoutOfMemory)(size);
	return NIL(void);
    }
    return p;
}

st.c
30078
/**
  @file

  @ingroup st

  @brief Symbol table package.

  @details The st library provides functions to create, maintain,
  and query symbol tables.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"
#include "st.h"

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
 * @brief Type of symbol table entries.
 */     
typedef struct st_table_entry st_table_entry;

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief Symbol table entry.
 */
struct st_table_entry {
    void *key;
    void *record;
    st_table_entry *next;
};

/**
 * @brief Symbol table header.
 */
struct st_table {
    st_compare_t compare;
    st_hash_t hash;
    st_compare_arg_t compare_arg;
    st_hash_arg_t hash_arg;
    void const * arg;
    int num_bins;
    int num_entries;
    int max_density;
    int reorder_flag;
    double grow_factor;
    st_table_entry **bins;
};

/**
 * @brief Symbol table generator.
 */
struct st_generator {
    st_table const *table;
    st_table_entry const *entry;
    int index;
};

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/**
 * @brief Compares two numbers or two pointers.
 *
 * @details Used by the default comparison functions.
 */
#define ST_NUMCMP(x,y) ((x) != (y))

/**
 * @brief Hash function for numbers.
 */
#define ST_NUMHASH(x,size) ((int)((uintptr_t)(x)%(uintptr_t)(size)))

/**
 * @brief Amount by which pointers should be shifted right when hashing.
 *
 * @details This is to discard bits that are (likely to be) 0 due to
 * alignment constraints.
 */
#if SIZEOF_VOID_P == 8
#define st_shift 3
#else
#define st_shift 2
#endif

/**
 * @brief Hash function for pointers.
 */
#define ST_PTRHASH(x,size) ((int)(((uintptr_t)(x)>>st_shift)%(uintptr_t)(size)))

/**
 * @brief Compares two entries.
 */
#define EQUAL(table, x, y) \
    ((((table)->compare == st_numcmp) || ((table)->compare == st_ptrcmp)) ?\
     (ST_NUMCMP((x),(y)) == 0) : ((table)->compare) ?\
     ((*(table)->compare)((x), (y)) == 0) :\
     ((*(table)->compare_arg)((x), (y), (table)->arg) == 0))

/**
 * @brief Computes the hash of one entry.
 */
#define do_hash(key, table)\
    (((table)->hash == st_ptrhash) ? ST_PTRHASH((key), (table)->num_bins) : \
     ((table)->hash == st_numhash) ? ST_NUMHASH((key), (table)->num_bins) : \
     ((table)->hash) ? (*(table)->hash)((key), (table)->num_bins) : \
     (*(table)->hash_arg)((key), (table)->num_bins, (table)->arg))

/**
 * @brief Compares the new key to one in a collision list.
 */
#define PTR_NOT_EQUAL(table, ptr, user_key)\
    ((ptr) != NIL(st_table_entry) && \
     !EQUAL((table), (user_key), (ptr)->key))

/**
 * @brief Looks up an entry in a collision list.
 *
 * @details If the entry is found and the reorder flag is set, the found
 * entry is brought to the fore of the collision list.
 */
#define FIND_ENTRY(table, hash_val, key, ptr, last) \
    (last) = &(table)->bins[hash_val];\
    (ptr) = *(last);\
    while (PTR_NOT_EQUAL((table), (ptr), (key))) {\
	(last) = &(ptr)->next; (ptr) = *(last);\
    }\
    if ((ptr) != NIL(st_table_entry) && (table)->reorder_flag) {\
	*(last) = (ptr)->next;\
	(ptr)->next = (table)->bins[hash_val];\
	(table)->bins[hash_val] = (ptr);\
    }

/**
 * @brief Adds an entry to a table.
 *
 * @deprecated This macro does not check if memory allocation fails.
 * Use at your own risk.
 */
#define ADD_DIRECT(table, key, value, hash_val, newt)\
{\
    if (table->num_entries/table->num_bins >= table->max_density) {\
	rehash(table);\
	hash_val = do_hash(key,table);\
    }\
    \
    newt = ALLOC(st_table_entry, 1);\
    \
    newt->key = key;\
    newt->record = value;\
    newt->next = table->bins[hash_val];\
    table->bins[hash_val] = newt;\
    table->num_entries++;\
}

/** \cond */

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

static int rehash (st_table *);

/** \endcond */


/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

/**
  @brief Creates and initializes a table.

  @details Creates and initializes a table with the comparison function
  compare_fn and hash function hash_fn. compare_fn is

      int compare_fn(const void *key1, const void *key2)

  It returns `<,=,> 0` depending on whether `key1 <,=,> key2` by some
  measure.<p>
  hash_fn is

      int hash_fn(void *key, int modulus)

  It returns an integer between `0` and `modulus-1` such that if
  `compare_fn(key1,key2) == 0` then `hash_fn(key1) == hash_fn(key2)`.<p>
  There are five predefined hash and comparison functions in st.
  For keys as numbers:

      st_numhash(key, modulus) { return (unsigned int) key % modulus; }
      st_numcmp(x,y) { return (int) x - (int) y; }

  For keys as pointers:

      st_ptrhash(key, modulus) { return ((unsigned int) key/4) % modulus }
      st_ptrcmp(x,y) { return (int) x - (int) y; }

  For keys as strings:

      st_strhash(x,y) - a reasonable hashing function for strings
      strcmp(x,y) - the standard library function

  It is recommended to use these particular functions if they fit your
  needs, since st will recognize certain of them and run more quickly
  because of it.

  @sideeffect None

  @see st_init_table_with_params st_free_table

*/
st_table *
st_init_table(st_compare_t compare, st_hash_t hash)
{
    return st_init_table_with_params(compare, hash, ST_DEFAULT_INIT_TABLE_SIZE,
				     ST_DEFAULT_MAX_DENSITY,
				     ST_DEFAULT_GROW_FACTOR,
				     ST_DEFAULT_REORDER_FLAG);

} /* st_init_table */


/**
  @brief Create a table with given parameters.

  @details The full blown table initializer.  compare and hash are
  the same as in st_init_table. density is the largest the average
  number of entries per hash bin there should be before the table is
  grown.  grow_factor is the factor the table is grown by when it
  becomes too full. size is the initial number of bins to be allocated
  for the hash table.  If reorder_flag is non-zero, then every time an
  entry is found, it is moved to the top of the chain.<p>
  st_init_table(compare, hash) is equivelent to

      st_init_table_with_params(compare, hash, ST_DEFAULT_INIT_TABLE_SIZE,
                                ST_DEFAULT_MAX_DENSITY, ST_DEFAULT_GROW_FACTOR,
                                ST_DEFAULT_REORDER_FLAG);

  @sideeffect None

  @see st_init_table st_free_table

*/
st_table *
st_init_table_with_params(
  st_compare_t compare,
  st_hash_t hash,
  int size,
  int density,
  double grow_factor,
  int reorder_flag)
{
    int i;
    st_table *newt;

    newt = ALLOC(st_table, 1);
    if (newt == NIL(st_table)) {
	return NIL(st_table);
    }
    newt->compare = compare;
    newt->hash = hash;
    newt->compare_arg = (st_compare_arg_t) 0;
    newt->hash_arg = (st_hash_arg_t) 0;
    newt->arg = NIL(void);
    newt->num_entries = 0;
    newt->max_density = density;
    newt->grow_factor = grow_factor;
    newt->reorder_flag = reorder_flag;
    if (size <= 0) {
	size = 1;
    }
    newt->num_bins = size;
    newt->bins = ALLOC(st_table_entry *, size);
    if (newt->bins == NIL(st_table_entry *)) {
	FREE(newt);
	return NIL(st_table);
    }
    for(i = 0; i < size; i++) {
	newt->bins[i] = 0;
    }
    return newt;

} /* st_init_table_with_params */


/**
   @brief Creates and initializes a table.

   @details Like st_init_table_with_params, but the comparison and
   hash functions are passed an extra parameter `arg` that is
   registered in the table at initialization.

   @see st_init_table_with_params
*/
st_table *
st_init_table_with_params_and_arg(
  st_compare_arg_t compare,
  st_hash_arg_t hash,
  void const * arg,
  int size,
  int density,
  double growth_factor,
  int reorder_flag)
{
    st_table *table;

    table = st_init_table_with_params((st_compare_t) 0, (st_hash_t) 0, size,
                                      density, growth_factor, reorder_flag);
    if (table == NIL(st_table))
        return NIL(st_table);
    table->compare_arg = compare;
    table->hash_arg = hash;
    table->arg = arg;

    return table;

} /* st_init_table_with_params_and_arg */


/**
   @brief Creates and initializes a table.

   @details Like st_init_table, but the comparison and hash functions are
   passed an extra parameter `arg` that is registered in the table at
   initialization.

   @see st_init_table st_init_table_with_params_and_arg
*/
st_table *
st_init_table_with_arg(
  st_compare_arg_t compare,
  st_hash_arg_t hash,
  void const * arg)
{
    return st_init_table_with_params_and_arg(compare, hash, arg,
                                             ST_DEFAULT_INIT_TABLE_SIZE,
                                             ST_DEFAULT_MAX_DENSITY,
                                             ST_DEFAULT_GROW_FACTOR,
                                             ST_DEFAULT_REORDER_FLAG);

} /* st_init_table_with_arg */


/**
  @brief Free a table.

  @details Any internal storage associated with table is freed.  It is
  the user's responsibility to free any storage associated with the
  pointers he placed in the table (by perhaps using st_foreach).

  @sideeffect None

  @see st_init_table st_init_table_with_params

*/
void
st_free_table(st_table *table)
{
    st_table_entry *ptr, *next;
    int i;

    for(i = 0; i < table->num_bins ; i++) {
	ptr = table->bins[i];
	while (ptr != NIL(st_table_entry)) {
	    next = ptr->next;
	    FREE(ptr);
	    ptr = next;
	}
    }
    FREE(table->bins);
    FREE(table);

} /* st_free_table */


/**
  @brief Lookup up `key` in `table`.

  @details If an entry is found, 1 is returned and if `value` is not
  nil, the variable it points to is set to the associated value.  If
  an entry is not found, 0 is returned and the variable pointed by
  value is unchanged.

  @sideeffect The location pointed by value is modified.

  @see st_lookup_int

*/
int
st_lookup(st_table *table, void const *key, void **value)
{
    int hash_val;
    st_table_entry *ptr, **last;

    hash_val = do_hash(key, table);

    FIND_ENTRY(table, hash_val, key, ptr, last);

    if (ptr == NIL(st_table_entry)) {
	return 0;
    } else {
	if (value != NIL(void *)) {
	    *value = ptr->record;
	}
	return 1;
    }

} /* st_lookup */


/**
  @brief Lookup up `key` in `table`.

  @details If an entry is found, 1 is returned and if `value` is not
  nil, the variable it points to is set to the associated integer
  value.  If an entry is not found, 0 is return and the variable
  pointed by `value` is unchanged.

  @sideeffect The location pointed by value is modified.

  @see st_lookup

*/
int
st_lookup_int(st_table *table, void const *key, int *value)
{
    int hash_val;
    st_table_entry *ptr, **last;

    hash_val = do_hash(key, table);

    FIND_ENTRY(table, hash_val, key, ptr, last);
    
    if (ptr == NIL(st_table_entry)) {
	return 0;
    } else {
	if (value != NIL(int)) {
	    *value = (int) (intptr_t) ptr->record;
	}
	return 1;
    }

} /* st_lookup_int */


/**
  @brief Insert value in `table` under the key `key`.

  @return 1 if there was an entry already under the key; 0 if there
  was no entry under the key and insertion was successful;
  ST_OUT_OF_MEM otherwise.  In either of the first two cases the new
  value is added.

  @sideeffect None

*/
int
st_insert(st_table *table, void *key, void *value)
{
    int hash_val;
    st_table_entry *newt;
    st_table_entry *ptr, **last;

    hash_val = do_hash(key, table);

    FIND_ENTRY(table, hash_val, key, ptr, last);

    if (ptr == NIL(st_table_entry)) {
	if (table->num_entries/table->num_bins >= table->max_density) {
	    if (rehash(table) == ST_OUT_OF_MEM) {
		return ST_OUT_OF_MEM;
	    }
	    hash_val = do_hash(key, table);
	}
	newt = ALLOC(st_table_entry, 1);
	if (newt == NIL(st_table_entry)) {
	    return ST_OUT_OF_MEM;
	}
	newt->key = key;
	newt->record = value;
	newt->next = table->bins[hash_val];
	table->bins[hash_val] = newt;
	table->num_entries++;
	return 0;
    } else {
	ptr->record = value;
	return 1;
    }

} /* st_insert */


/**
  @brief Place 'value' in 'table' under the key 'key'.

  @details This is done without checking if 'key' is in 'table'
  already.  This should only be used if you are sure there is not
  already an entry for 'key', since it is undefined which entry you
  would later get from st_lookup or st_find_or_add.

  @return 1 if successful; ST_OUT_OF_MEM otherwise.

  @sideeffect None

  @see st_lookup st_find_or_add

*/
int
st_add_direct(st_table *table, void *key, void *value)
{
    int hash_val;
    st_table_entry *newt;

    if (table->num_entries / table->num_bins >= table->max_density) {
	if (rehash(table) == ST_OUT_OF_MEM) {
	    return ST_OUT_OF_MEM;
	}
    }
    hash_val = do_hash(key, table);
    newt = ALLOC(st_table_entry, 1);
    if (newt == NIL(st_table_entry)) {
	return ST_OUT_OF_MEM;
    }
    newt->key = key;
    newt->record = value;
    newt->next = table->bins[hash_val];
    table->bins[hash_val] = newt;
    table->num_entries++;
    return 1;

} /* st_add_direct */


/**
  @brief Lookup `key` in `table`; if not found, create an entry.

  @details In either case set slot to point to the field in the entry
  where the value is stored.  The value associated with `key` may then
  be changed by accessing directly through slot.  As an example:

      void **slot;
      void *key;
      void *value = item_ptr // ptr to a malloc'd structure

      if (st_find_or_add(table, key, &slot) == 1) {
          FREE(*slot); // free the old value of the record
      }
      *slot = value;  // attach the new value to the record

  This replaces the equivelent code:

      if (st_lookup(table, key, &ovalue) == 1) {
          FREE(ovalue);
      }
      st_insert(table, key, value);

  @return 1 if an entry already existed, 0 if it did not exist and
  creation was successful; ST_OUT_OF_MEM otherwise.

  @sideeffect The location pointed by slot is modified.

  @see st_find

*/
int
st_find_or_add(st_table *table, void *key, void ***slot)
{
    int hash_val;
    st_table_entry *newt, *ptr, **last;

    hash_val = do_hash(key, table);

    FIND_ENTRY(table, hash_val, key, ptr, last);

    if (ptr == NIL(st_table_entry)) {
	if (table->num_entries / table->num_bins >= table->max_density) {
	    if (rehash(table) == ST_OUT_OF_MEM) {
		return ST_OUT_OF_MEM;
	    }
	    hash_val = do_hash(key, table);
	}
	newt = ALLOC(st_table_entry, 1);
	if (newt == NIL(st_table_entry)) {
	    return ST_OUT_OF_MEM;
	}
	newt->key = key;
	newt->record = NIL(void);
	newt->next = table->bins[hash_val];
	table->bins[hash_val] = newt;
	table->num_entries++;
	if (slot != NIL(void **)) *slot = &newt->record;
	return 0;
    } else {
	if (slot != NIL(void **)) *slot = &ptr->record;
	return 1;
    }

} /* st_find_or_add */


/**
  @brief Lookup `key` in `table`.

  @details Like st_find_or_add, but does not create an entry if one is
  not found.

  @sideeffect The location pointed by slot is modified.

  @see st_find_or_add

*/
int
st_find(st_table *table, void const *key, void ***slot)
{
    int hash_val;
    st_table_entry *ptr, **last;

    hash_val = do_hash(key, table);

    FIND_ENTRY(table, hash_val, key, ptr, last);

    if (ptr == NIL(st_table_entry)) {
	return 0;
    } else {
	if (slot != NIL(void **)) {
	    *slot = &ptr->record;
	}
	return 1;
    }

} /* st_find */


/**
  @brief Returns a copy of old_table and all its members.

  @details (st_table *) 0 is returned if there was insufficient memory
  to do the copy.

  @sideeffect None

*/
st_table *
st_copy
(st_table const *old_table)
{
    st_table *new_table;
    st_table_entry *ptr, *newptr, *next, *newt;
    int i, j, num_bins = old_table->num_bins;

    new_table = ALLOC(st_table, 1);
    if (new_table == NIL(st_table)) {
	return NIL(st_table);
    }

    *new_table = *old_table;
    new_table->bins = ALLOC(st_table_entry *, num_bins);
    if (new_table->bins == NIL(st_table_entry *)) {
	FREE(new_table);
	return NIL(st_table);
    }
    for(i = 0; i < num_bins ; i++) {
	new_table->bins[i] = NIL(st_table_entry);
	ptr = old_table->bins[i];
	while (ptr != NIL(st_table_entry)) {
	    newt = ALLOC(st_table_entry, 1);
	    if (newt == NIL(st_table_entry)) {
		for (j = 0; j <= i; j++) {
		    newptr = new_table->bins[j];
		    while (newptr != NIL(st_table_entry)) {
			next = newptr->next;
			FREE(newptr);
			newptr = next;
		    }
		}
		FREE(new_table->bins);
		FREE(new_table);
		return NIL(st_table);
	    }
	    *newt = *ptr;
	    newt->next = new_table->bins[i];
	    new_table->bins[i] = newt;
	    ptr = ptr->next;
	}
    }
    return new_table;

} /* st_copy */


/**
  @brief Deletes the entry with the key pointed to by `keyp`.

  @details If the entry is found, 1 is returned, the variable pointed
  by `keyp` is set to the actual key and the variable pointed by
  `value` is set to the corresponding entry.  (This allows the freeing
  of the associated storage.)  If the entry is not found, then 0 is
  returned and nothing is changed.

  @sideeffect The locations pointed by keyp and value are modified.

  @see st_delete_int

*/
int
st_delete(st_table *table, void **keyp, void **value)
{
    int hash_val;
    void *key = *keyp;
    st_table_entry *ptr, **last;

    hash_val = do_hash(key, table);

    FIND_ENTRY(table, hash_val, key, ptr ,last);

    if (ptr == NIL(st_table_entry)) {
	return 0;
    }

    *last = ptr->next;
    if (value != NIL(void *)) *value = ptr->record;
    *keyp = ptr->key;
    FREE(ptr);
    table->num_entries--;
    return 1;

} /* st_delete */


/**
  @brief Deletes the entry with the key pointed to by `keyp`.

  @details `value` must be a pointer to an integer.  If the entry is
  found, 1 is returned, the variable pointed by `keyp` is set to the
  actual key and the variable pointed by `value` is set to the
  corresponding entry.  (This allows the freeing of the associated
  storage.) If the entry is not found, then 0 is returned and nothing
  is changed.

  @sideeffect The locations pointed by keyp and value are modified.

  @see st_delete

*/
int
st_delete_int(st_table *table, void **keyp, int *value)
{
    int hash_val;
    void *key = *keyp;
    st_table_entry *ptr, **last;

    hash_val = do_hash(key, table);

    FIND_ENTRY(table, hash_val, key, ptr ,last);

    if (ptr == NIL(st_table_entry)) {
        return 0;
    }

    *last = ptr->next;
    if (value != NIL(int)) *value = (int) (intptr_t) ptr->record;
    *keyp = ptr->key;
    FREE(ptr);
    table->num_entries--;
    return 1;

} /* st_delete_int */


/**
  @brief Returns the number of entries in the table `table`.

  @sideeffect None

*/
int st_count(st_table const *table)
{
  return table->num_entries;
}


/**
  @brief Iterates over the elements of a table.

  @details
  For each (key, value) record in `table`, st_foreach
  calls func with the arguments

      (*func)(key, value, arg)

  If func returns ST_CONTINUE, st_foreach continues
  processing entries.  If func returns ST_STOP, st_foreach stops
  processing and returns immediately.  If func returns ST_DELETE, then
  the entry is deleted from the symbol table and st_foreach continues.
  In the case of ST_DELETE, it is func's responsibility to free the
  key and value, if necessary.  The order in which the records are
  visited will be seemingly random.

  @return 1 if all items in the table were generated and 0 if the
  generation sequence was aborted using ST_STOP.

  @sideeffect None

  @see st_foreach_item st_foreach_item_int

*/
int
st_foreach(st_table *table, st_foreach_t func, void *arg)
{
    st_table_entry *ptr, **last;
    enum st_retval retval;
    int i;

    for(i = 0; i < table->num_bins; i++) {
	last = &table->bins[i]; ptr = *last;
	while (ptr != NIL(st_table_entry)) {
	    retval = (*func)(ptr->key, ptr->record, arg);
	    switch (retval) {
	    case ST_CONTINUE:
		last = &ptr->next; ptr = *last;
		break;
	    case ST_STOP:
		return 0;
	    case ST_DELETE:
		*last = ptr->next;
		table->num_entries--;	/* cstevens@ic */
		FREE(ptr);
		ptr = *last;
	    }
	}
    }
    return 1;

} /* st_foreach */


/**
  @brief String hash function.

  @sideeffect None

  @see st_init_table

*/
int
st_strhash(void const *string, int modulus)
{
    int val = 0;
    int c;
    char const * s = (char const *) string;
    
    while ((c = *s++) != '\0') {
	val = val*997 + c;
    }

    return ((val < 0) ? -val : val)%modulus;

} /* st_strhash */


/**
  @brief Integral number hash function.

  @sideeffect None

  @see st_init_table st_numcmp

*/
int
st_numhash(void const *x, int size)
{
    return ST_NUMHASH(x, size);

} /* st_numhash */


/**
  @brief Pointer hash function.

  @sideeffect None

  @see st_init_table st_ptrcmp

*/
int
st_ptrhash(void const *x, int size)
{
    return ST_PTRHASH(x, size);

} /* st_ptrhash */


/**
  @brief Integral number comparison function.

  @sideeffect None

  @see st_init_table st_numhash

*/
int
st_numcmp(void const *x, void const *y)
{
    return ST_NUMCMP(x, y);

} /* st_numcmp */


/**
  @brief Pointer comparison function.

  @sideeffect None

  @see st_init_table st_ptrhash

*/
int
st_ptrcmp(void const *x, void const *y)
{
    return ST_NUMCMP(x, y);

} /* st_ptrcmp */


/**
  @brief Initializes a generator.

  @details Returns a generator handle which when used with
  st_gen() will progressively return each (key, value) record in
  `table`.

  @sideeffect None

  @see st_free_gen

*/
st_generator *
st_init_gen(st_table const *table)
{
    st_generator *gen;

    gen = ALLOC(st_generator, 1);
    if (gen == NIL(st_generator)) {
	return NIL(st_generator);
    }
    gen->table = table;
    gen->entry = NIL(st_table_entry);
    gen->index = 0;
    return gen;

} /* st_init_gen */


/**
  @brief Returns the next (key, value) pair in the generation sequence.

  @details@parblock
  Given a generator returned by st_init_gen(), this
  routine returns the next (key, value) pair in the generation
  sequence.  The pointer `value_p` can be zero which means no value
  will be returned.  When there are no more items in the generation
  sequence, the routine returns 0.

  While using a generation sequence, deleting any (key, value) pair
  other than the one just generated may cause a fatal error when
  st_gen() is called later in the sequence and is therefore not
  recommended.
  @endparblock

  @sideeffect The locations pointed by key_p and value_p are modified.

  @see st_gen_int

*/
int
st_gen(st_generator *gen, void **key_p, void **value_p)
{
    int i;

    if (gen->entry == NIL(st_table_entry)) {
	/* try to find next entry */
	for(i = gen->index; i < gen->table->num_bins; i++) {
	    if (gen->table->bins[i] != NIL(st_table_entry)) {
		gen->index = i+1;
		gen->entry = gen->table->bins[i];
		break;
	    }
	}
	if (gen->entry == NIL(st_table_entry)) {
	    return 0;		/* that's all folks ! */
	}
    }
    *key_p = gen->entry->key;
    if (value_p != NIL(void *)) {
	*value_p = gen->entry->record;
    }
    gen->entry = gen->entry->next;
    return 1;

} /* st_gen */


/**
  @brief Returns the next (key, value) pair in the generation
  sequence.

  @details Given a generator returned by st_init_gen(), this
  routine returns the next (key, value) pair in the generation
  sequence.  `value_p` must be a pointer to an integer.  The pointer
  `value_p` can be zero which means no value will be returned.  When
  there are no more items in the generation sequence, the routine
  returns 0.

  @sideeffect The locations pointed by key_p and value_p are modified.

  @see st_gen

*/
int 
st_gen_int(st_generator *gen, void **key_p, int *value_p)
{
    int i;

    if (gen->entry == NIL(st_table_entry)) {
	/* try to find next entry */
	for(i = gen->index; i < gen->table->num_bins; i++) {
	    if (gen->table->bins[i] != NIL(st_table_entry)) {
		gen->index = i+1;
		gen->entry = gen->table->bins[i];
		break;
	    }
	}
	if (gen->entry == NIL(st_table_entry)) {
	    return 0;		/* that's all folks ! */
	}
    }
    *key_p = gen->entry->key;
    if (value_p != NIL(int)) {
   	*value_p = (int) (intptr_t) gen->entry->record;
    }
    gen->entry = gen->entry->next;
    return 1;

} /* st_gen_int */


/**
  @brief Reclaims the resources associated with `gen`.

  @details After generating all items in a generation sequence,
  this routine must be called to reclaim the resources associated with
  `gen`.

  @sideeffect None

  @see st_init_gen

*/
void
st_free_gen(st_generator *gen)
{
    FREE(gen);

} /* st_free_gen */


/*---------------------------------------------------------------------------*/
/* Definition of internal functions                                          */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
  @brief Rehashes a symbol table.

  @sideeffect None

  @see st_insert

*/
static int
rehash(st_table *table)
{
    st_table_entry *ptr, *next, **old_bins;
    int             i, old_num_bins, hash_val, old_num_entries;

    /* save old values */
    old_bins = table->bins;
    old_num_bins = table->num_bins;
    old_num_entries = table->num_entries;

    /* rehash */
    table->num_bins = (int) (table->grow_factor * old_num_bins);
    if (table->num_bins % 2 == 0) {
	table->num_bins += 1;
    }
    table->num_entries = 0;
    table->bins = ALLOC(st_table_entry *, table->num_bins);
    if (table->bins == NIL(st_table_entry *)) {
	table->bins = old_bins;
	table->num_bins = old_num_bins;
	table->num_entries = old_num_entries;
	return ST_OUT_OF_MEM;
    }
    /* initialize */
    for (i = 0; i < table->num_bins; i++) {
	table->bins[i] = 0;
    }

    /* copy data over */
    for (i = 0; i < old_num_bins; i++) {
	ptr = old_bins[i];
	while (ptr != NIL(st_table_entry)) {
	    next = ptr->next;
	    hash_val = do_hash(ptr->key, table);
	    ptr->next = table->bins[hash_val];
	    table->bins[hash_val] = ptr;
	    table->num_entries++;
	    ptr = next;
	}
    }
    FREE(old_bins);

    return 1;

} /* rehash */

st.h
8912
/**
  @file 

  @ingroup st

  @brief Symbol table package.

  @details The st library provides functions to create, maintain,
  and query symbol tables.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#ifndef ST_H_
#define ST_H_

/*---------------------------------------------------------------------------*/
/* Nested includes                                                           */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/

/**
 * @brief Value returned if memory is exhausted.
 */
#define ST_OUT_OF_MEM -10000

/**
 * @brief Default value for the maximum table density.
 * @see st_init_table_with_params
 */
#define ST_DEFAULT_MAX_DENSITY 5

/**
 * @brief Default value for the initial table size.
 * @see st_init_table_with_params
 */
#define ST_DEFAULT_INIT_TABLE_SIZE 11

/**
 * @brief Default table growth factor.
 * @see st_init_table_with_params
 */
#define ST_DEFAULT_GROW_FACTOR 2.0

/**
 * @brief Default table reorder flag.
 * @see st_init_table_with_params
 */
#define ST_DEFAULT_REORDER_FLAG 0

/*---------------------------------------------------------------------------*/
/* Stucture declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/**
 * @brief Type of symbol tables.
 */
typedef struct st_table st_table;

/**
 * @brief Type of symbol table generators.
 */
typedef struct st_generator st_generator;

/**
 * @brief Type of return values for iterators.
 */
enum st_retval {ST_CONTINUE, ST_STOP, ST_DELETE};

/**
 *  @brief Type for function passed to @ref st_foreach.
 */
typedef enum st_retval (*st_foreach_t)(void *, void *, void *);

/**
 * @brief Type of comparison functions.
 */
typedef int (*st_compare_t)(void const *, void const *);

/**
 * @brief Type of hash functions.
 */
typedef int (*st_hash_t)(void const *, int);

/**
 * @brief Type of comparison functions with extra argument.
 */
typedef int (*st_compare_arg_t)(void const *, void const *, void const *);

/**
 * @brief Type of hash functions with extra argument.
 */
typedef int (*st_hash_arg_t)(void const *, int, void const *);

/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/

/**
  @brief Checks whethere `key` is in `table`.

  @details Returns 1 if there is an entry under `key` in `table`, 0
  otherwise.

  @sideeffect None

  @see st_lookup

*/
#define st_is_member(table,key) st_lookup(table,key,(void **) 0)


/**
  @brief Iteration macro.

  @details
  An iteration macro which loops over all the entries in
  `table`, setting `key` to point to the key and `value` to the
  associated value (if it is not nil). `gen` is a generator variable
  used internally. Sample usage:

      void *key, *value;
      st_generator *gen;

      st_foreach_item(table, gen, &key, &value) {
          process_item(value);
      }

  @sideeffect None

  @see st_foreach_item_int st_foreach

*/
#define st_foreach_item(table, gen, key, value) \
    for(gen=st_init_gen(table); st_gen(gen,key,value) || (st_free_gen(gen),0);)


/**
  @brief Iteration macro.

  @details
  An iteration macro which loops over all the entries in
  `table`, setting `key` to point to the key and `value` to the
  associated value (if it is not nil). `value` is assumed to be a
  pointer to an integer.  `gen` is a generator variable used
  internally. Sample usage:

      void *key;
      int value;
      st_generator *gen;

      st_foreach_item_int(table, gen, &key, &value) {
          process_item(value);
      }

  @sideeffect None

  @see st_foreach_item st_foreach

*/
#define st_foreach_item_int(table, gen, key, value) \
    for(gen=st_init_gen(table); st_gen_int(gen,key,value) || (st_free_gen(gen),0);)

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

st_table *st_init_table_with_params (st_compare_t, st_hash_t, int, int, double, int);
st_table *st_init_table (st_compare_t, st_hash_t);
st_table *st_init_table_with_params_and_arg (st_compare_arg_t, st_hash_arg_t, void const *, int, int, double, int);
    st_table *st_init_table_with_arg (st_compare_arg_t, st_hash_arg_t, void const *);
void st_free_table (st_table *);
int st_lookup (st_table *, void const *, void **);
int st_lookup_int (st_table *, void const *, int *);
int st_insert (st_table *, void *, void *);
int st_add_direct (st_table *, void *, void *);
int st_find_or_add (st_table *, void *, void ***);
int st_find (st_table *, void const *, void ***);
st_table *st_copy (st_table const *);
int st_delete (st_table *, void **, void **);
int st_delete_int (st_table *, void **, int *);
int st_count(st_table const *);
int st_foreach (st_table *, st_foreach_t, void *);
int st_strhash (void const *, int);
int st_numhash (void const *, int);
int st_ptrhash (void const *, int);
int st_numcmp (void const *, void const *);
int st_ptrcmp (void const *, void const *);
st_generator *st_init_gen (st_table const *);
int st_gen (st_generator *, void **, void **);
int st_gen_int (st_generator *, void **, int *);
void st_free_gen (st_generator *);

#ifdef __cplusplus
} /* end of extern "C" */
#endif

#endif /* ST_H_ */

strsav.c
2913
/**
  @file

  @ingroup util

  @brief String copying.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"

/**
 *  @brief Returns a copy of a string.
 */
char *
util_strsav(char const *s)
{
    return strcpy(ALLOC(char, strlen(s)+1), s);
}

texpand.c
3877
/**
  @file

  @ingroup util

  @brief Tilde expansion.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/

#include "util.h"

#ifdef BSD
#include <pwd.h>
#endif

/**
 * @brief Expands tilde in a file name
 */
char *
util_tilde_expand(char const *fname)
{
#ifdef BSD
    struct passwd *userRecord;
    char username[256], *filename;
    register int i, j;

    filename = ALLOC(char, strlen(fname) + 256);

    /* Clear the return string */
    i = 0;
    filename[0] = '\0';

    /* Tilde? */
    if (fname[0] == '~') {
	j = 0;
	i = 1;
	while ((fname[i] != '\0') && (fname[i] != '/')) {
	    username[j++] = fname[i++];
	}
	username[j] = '\0';

	if (username[0] == '\0') {
	    /* ~/ resolves to home directory of current user */
	    if ((userRecord = getpwuid(getuid())) != 0) {
		(void) strcat(filename, userRecord->pw_dir);
	    } else {
		i = 0;
	    }
	} else {
	    /* ~user/ resolves to home directory of 'user' */
	    if ((userRecord = getpwnam(username)) != 0) {
		(void) strcat(filename, userRecord->pw_dir);
	    } else {
		i = 0;
	    }
	}
    }

    /* Concantenate remaining portion of file name */
    (void) strcat(filename, fname + i);
    return filename;
#else
    return util_strsav(fname);
#endif
}

ucbqsort.c
10751
/**
  @file

  @ingroup util

  @brief Ancient implementation of qsort.

  @details This is shipped with CUDD so that results of reordering may
  be more reproducible across different platforms.

  qsort.c	4.2 (Berkeley) 3/9/83

  Our own version of the system qsort routine which is faster by an average
  of 25%, with lows and highs of 10% and 50%.
  The THRESHold below is the insertion sort threshold, and has been adjusted
  for records of size 48 bytes.
  The MTHREShold is where we stop finding a better median.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

 */

#include "util.h"

#ifndef USE_SYSTEM_QSORT
/**
   @brief Threshold for insertion.
*/
#define		THRESH		4
/**
   @brief Threshold for median.
*/
#define		MTHRESH		6

/**
   @brief Miscellaneous information.
*/
typedef struct {
    QSFP	qcmp;			/**< the comparison routine */
    int		qsz;			/**< size of each record */
    int		thresh;			/**< THRESHold in chars */
    int		mthresh;		/**< MTHRESHold in chars */
} info_t;

/*---------------------------------------------------------------------------*/
/* Static function prototypes                                                */
/*---------------------------------------------------------------------------*/

/** \cond */

static	void		qst (char *base, char *max, info_t const * info);

/** \endcond */

/*---------------------------------------------------------------------------*/
/* Definition of exported functions                                          */
/*---------------------------------------------------------------------------*/

#undef min
#undef max
#endif
/**
 * @brief Implements the quicksort algorithm.
 *
 * @details First, set up some global parameters for qst to share.
 * Then, quicksort with qst(), and then a cleanup insertion sort
 * ourselves.  Sound simple?  It's not...
 */
void
util_qsort(
  void *vbase /**< start address of array */,
  int n       /**< number of items */,
  int size    /**< size of each item */,
  QSFP compar /**< comparison function */)
{
#ifdef USE_SYSTEM_QSORT
    qsort(vbase, n, size, compar);
#else
    char *base = (char *) vbase;
    char c, *i, *j, *lo, *hi;
    char *min, *max;
    info_t info;

    if (n <= 1)
        return;
    info.qsz = size;
    info.qcmp = compar;
    info.thresh = size * THRESH;
    info.mthresh = size * MTHRESH;
    max = base + n * size;
    if (n >= THRESH) {
        qst(base, max, &info);
        hi = base + info.thresh;
    } else {
        hi = max;
    }
    /*
     * First put smallest element, which must be in the first THRESH, in
     * the first position as a sentinel.  This is done just by searching
     * the first THRESH elements (or the first n if n < THRESH), finding
     * the min, and swapping it into the first position.
     */
    for (j = lo = base; (lo += size) < hi; )
        if ((*compar)(j, lo) > 0)
            j = lo;
    if (j != base) {
        /* swap j into place */
        for (i = base, hi = base + size; i < hi; ) {
            c = *j;
            *j++ = *i;
            *i++ = c;
        }
    }
    /*
     * With our sentinel in place, we now run the following hyper-fast
     * insertion sort. For each remaining element, min, from [1] to [n-1],
     * set hi to the index of the element AFTER which this one goes.
     * Then, do the standard insertion sort shift on a character at a time
     * basis for each element in the frob.
     */
    for (min = base; (hi = min += size) < max; ) {
        while ((*compar)(hi -= size, min) > 0)
            /* void */;
        if ((hi += size) != min) {
            for (lo = min + size; --lo >= min; ) {
                c = *lo;
                for (i = j = lo; (j -= size) >= hi; i = j)
                    *i = *j;
                *i = c;
            }
        }
    }
#endif
}


/*---------------------------------------------------------------------------*/
/* Definition of static functions                                            */
/*---------------------------------------------------------------------------*/

/**
 * @brief Do a quicksort.
 *
 * @details First, find the median element, and put that one in the
 * first place as the discriminator.  (This "median" is just the
 * median of the first, last and middle elements).  (Using this median
 * instead of the first element is a big win).  Then, the usual
 * partitioning/swapping, followed by moving the discriminator into
 * the right place.  Then, figure out the sizes of the two partions,
 * do the smaller one recursively and the larger one via a repeat of
 * this code.  Stopping when there are less than THRESH elements in a
 * partition and cleaning up with an insertion sort (in our caller) is
 * a huge win.  All data swaps are done in-line, which is space-losing
 * but time-saving.  (And there are only three places where this is
 * done).
 */
#ifndef USE_SYSTEM_QSORT
static void
qst(char *base, char *max, info_t const * info)
{
    char c, *i, *j, *jj;
    int ii;
    char *mid, *tmp;
    intptr_t lo, hi;

    /*
     * At the top here, lo is the number of characters of elements in the
     * current partition.  (Which should be max - base).
     * Find the median of the first, last, and middle element and make
     * that the middle element.  Set j to largest of first and middle.
     * If max is larger than that guy, then it's that guy, else compare
     * max with loser of first and take larger.  Things are set up to
     * prefer the middle, then the first in case of ties.
     */
    lo = max - base;		/* number of elements as chars */
    do	{
        mid = i = base + info->qsz * ((lo / info->qsz) >> 1);
        if (lo >= info->mthresh) {
            j = ((*info->qcmp)((jj = base), i) > 0 ? jj : i);
            if ((*info->qcmp)(j, (tmp = max - info->qsz)) > 0) {
                /* switch to first loser */
                j = (j == jj ? i : jj);
                if ((*info->qcmp)(j, tmp) < 0)
                    j = tmp;
            }
            if (j != i) {
                ii = info->qsz;
                do	{
                    c = *i;
                    *i++ = *j;
                    *j++ = c;
                } while (--ii);
            }
        }
        /*
         * Semi-standard quicksort partitioning/swapping
         */
        for (i = base, j = max - info->qsz; ; ) {
            while (i < mid && (*info->qcmp)(i, mid) <= 0)
                i += info->qsz;
            while (j > mid) {
                if ((*info->qcmp)(mid, j) <= 0) {
                    j -= info->qsz;
                    continue;
                }
                tmp = i + info->qsz;	/* value of i after swap */
                if (i == mid) {
                    /* j <-> mid, new mid is j */
                    mid = jj = j;
                } else {
                    /* i <-> j */
                    jj = j;
                    j -= info->qsz;
                }
                goto swap;
            }
            if (i == mid) {
                break;
            } else {
                /* i <-> mid, new mid is i */
                jj = mid;
                tmp = mid = i;	/* value of i after swap */
                j -= info->qsz;
            }
        swap:
            ii = info->qsz;
            do	{
                c = *i;
                *i++ = *jj;
                *jj++ = c;
            } while (--ii);
            i = tmp;
        }
        /*
         * Look at sizes of the two partitions, do the smaller
         * one first by recursion, then do the larger one by
         * making sure lo is its size, base and max are update
         * correctly, and branching back.  But only repeat
         * (recursively or by branching) if the partition is
         * of at least size THRESH.
         */
        i = (j = mid) + info->qsz;
        if ((lo = j - base) <= (hi = max - i)) {
            if (lo >= info->thresh)
                qst(base, j, info);
            base = i;
            lo = hi;
        } else {
            if (hi >= info->thresh)
                qst(i, max, info);
            max = j;
        }
    } while (lo >= info->thresh);
}
#endif

util.h
6575
/**
  @file

  @ingroup util

  @brief Low-level utilities.

  @copyright@parblock
  Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  @endparblock

  @copyright@parblock
  Copyright (c) 1999-2015, Regents of the University of Colorado

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  Neither the name of the University of Colorado nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  @endparblock

*/
#ifndef UTIL_H_
#define UTIL_H_

#include "config.h"

#if HAVE_ASSERT_H == 1
#include <assert.h>
#else
#error assert.h is needed to build this package
#endif

#if HAVE_UNISTD_H == 1
#include <unistd.h>
#endif

#include <stdio.h>
#include <ctype.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#else
#error stdlib.h is needed to build this package
#endif

#if HAVE_STRING_H == 1
#include <string.h>
#else
#error string.h is needed to build this package
#endif

#if HAVE_INTTYPES_H == 1
#include <inttypes.h>
#else
#error inttypes.h is needed to build this package
#endif

/**
 * @def PRIszt
 * @brief Format string for a size_t value.
 */
#if defined(_WIN32) && !defined(__USE_MINGW_ANSI_STDIO)
#ifndef PRIuPTR
#define PRIuPTR "Iu"
#endif
#ifndef PRIxPTR
#define PRIxPTR "Ix"
#endif
#ifndef PRIiPTR
#define PRIiPTR "Id"
#endif
#define PRIszt "Iu"
#else
#define PRIszt "zu"
#endif

/**
 * @def UTIL_UNUSED
 * @brief Macro to tell gcc that a variable is intentionally unused.
 */
#if defined(__GNUC__)
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 7
#define UTIL_UNUSED __attribute__ ((unused))
#else
#define UTIL_UNUSED
#endif
#else
#define UTIL_UNUSED
#endif

/**
 * @brief Type-decorated NULL (for documentation).
 */
#define NIL(type)		((type *) 0)

/* #define USE_MM */		/* choose default memory allocator */

/**
 * @def ALLOC
 * @brief Wrapper for either malloc or MMalloc.
 * @details Which function is wrapped depends on whether USE_MM is defined.
 */

/**
 * @def REALLOC
 * @brief Wrapper for either realloc or MMrealloc.
 * @details Which function is wrapped depends on whether USE_MM is defined.
 */

/**
 * @def FREE
 * @brief Wrapper for free.
 * @details Sets its argument to 0 after freeing.
 */

#if defined(USE_MM)
/* Assumes the memory manager is default one. */
#define ALLOC(type, num)	\
    ((type *) malloc(sizeof(type) * (num)))
#define REALLOC(type, obj, num)	\
    ((type *) realloc(obj, sizeof(type) * (num)))
#else
/* Use replacements that call MMoutOfMemory if allocation fails. */
#define ALLOC(type, num)	\
    ((type *) MMalloc(sizeof(type) * (size_t) (num)))
#define REALLOC(type, obj, num)	\
    ((type *) MMrealloc((obj), sizeof(type) * (size_t) (num)))
#endif
/* In any case, set to zero the pointer to freed memory. */
#define FREE(obj) (free(obj), (obj) = 0)

/**
 * @brief Prints message and terminates execution.
 */
#define fail(why) {\
    (void) fprintf(stderr, "Fatal error: file %s, line %d\n%s\n",\
	__FILE__, __LINE__, why);\
    (void) fflush(stdout);\
    abort();\
}

/* These arguably do NOT belong in util.h */
/**
 * @brief Computes the absolute value of its argument.
 */
#define ABS(a)			((a) < 0 ? -(a) : (a))
/**
 * @brief Computes the maximum of its two arguments.
 */
#define MAX(a,b)		((a) > (b) ? (a) : (b))
/**
 * @brief Computes the minimum of its two arguments.
 */
#define MIN(a,b)		((a) < (b) ? (a) : (b))

/**
 * @brief Type of comparison functions for util_qsort.
 */
typedef int (*QSFP)(void const *, void const *);

#ifdef __cplusplus
extern "C" {
#endif

#ifndef USE_MM
extern void *MMalloc(size_t);
extern void *MMrealloc(void *, size_t);
#endif
extern void MMout_of_memory(size_t);
extern void (*MMoutOfMemory) (size_t);

extern long util_cpu_time(void);
extern long util_cpu_ctime(void);
extern char *util_path_search(char const *);
extern char *util_file_search(char const *, char *, char const *);
extern void util_print_cpu_stats(FILE *);
extern char *util_print_time(unsigned long);
extern char *util_strsav(char const *);
extern char *util_tilde_expand(char const *);
extern size_t getSoftDataLimit(void);
extern void util_qsort (void *vbase, int n, int size, QSFP compar);
extern int util_pipefork(char * const * argv, FILE ** toCommand,
                         FILE ** fromCommand, int * pid);
#ifdef __cplusplus
}
#endif

#endif /* UTIL_H_ */

0
table
4
README.md
16
# truth tables

gentt.cpp
157
// this program uses matrix (mx) format to generate TT
// the output is .ttb which is exhaustive binary output

// ! check that every input is present


in.mx
156
# this is a matrix producing truth table
# 0 - variable is not present
# 1 - variable is present
# 2 - variable is present negative

0012012
0201102

ttattb.cpp
105
// this program converts between .tta and .ttb formats 

// ! check that output file is not present


0
ext
1
dummy
0

0
src
1
dummy
0

0
tests
1
dummy
0

0
tools
1
dummy
0

0
xdoc
1
dummy
0

0
